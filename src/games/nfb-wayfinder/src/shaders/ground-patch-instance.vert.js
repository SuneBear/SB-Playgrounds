module.exports="#define GLSLIFY 1\nattribute vec2 offset;\nattribute float scale;\nattribute vec4 spriteCoords;\nattribute float spriteAspect;\n\nuniform bool useSpriteAtlas;\nuniform float spriteMapAspect;\n\nuniform sampler2D groundMap;\nuniform sampler2D worldDataMap;\nuniform sampler2D waterMap;\n// uniform sampler2D worldGrassMap;\n\nuniform bool worldDataMapEnabled;\nuniform float time;\nuniform float globalSpriteScale;\nuniform vec2 spriteTextureAtlasSize;\nuniform vec2 spriteTextureSize;\nuniform float spriteTextureAtlasColumns;\nuniform mat4 groundProjectionMatrix;\nuniform vec2 worldMapSize;\nuniform vec3 userTargetWorldPosition;\n\nuniform mat4 worldDataProjection;\nuniform mat4 worldDataView;\n\nvarying float vDataScale;\n\nvarying vec2 vDataUv;\nvarying vec3 vGroundColor;\n// varying float vSpriteIndex;\nvarying vec2 vUv;\nvarying vec2 vScreenUv;\nvarying vec2 vGroundUv;\nvarying vec2 vWorldUv;\nvarying vec2 vOriginalUv;\nvarying float vHighlight;\nvarying float gradientY;\nvarying vec3 vGrassColor;\n\n// #pragma glslify: noise = require('glsl-noise/simplex/3d')\n\n#define TRUE_FIXED_BLEND\n\n//returns -1.0 if x < 0, and 1.0 if x >= 0\nfloat sign01 (float x) {\n  return x < 0.0 ? -1.0 : 1.0;\n  // return step(0.0, x) * 2.0 - 1.0;\n}\n\nfloat hash(vec2 p)  // replace this by something better\n{\n  p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n  return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat fastnoise( in vec2 p )\n{\n  vec2 i = floor( p );\n  vec2 f = fract( p );\n  vec2 u = f*f*(3.0-2.0*f);\n  return mix( mix( hash( i + vec2(0.0,0.0) ), \n                   hash( i + vec2(1.0,0.0) ), u.x),\n              mix( hash( i + vec2(0.0,1.0) ), \n                   hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat smoothCurve(float x)\n{\n\treturn x * x * (3.0 - 2.0 * x);\n}\n\nfloat triangleWave(float x)\n{\n\treturn abs(fract(x + 0.5) * 2.0 - 1.0);\n}\n\nfloat smoothTriangleWave(float x)\n{\n  // return sin(x);\n\treturn smoothCurve(triangleWave(x)) * 2.0 - 1.0;\n}\n\nvec2 range(vec2 vmin, vec2 vmax, vec2 value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nfloat manhattanDistance(vec2 p1, vec2 p2) {\n  float d1 = abs(p1.x - p2.x);\n  float d2 = abs(p1.y - p2.y);\n  return d1 + d2;\n}\n\nfloat insideBox(vec2 v, vec2 bottomLeft, vec2 topRight) {\n  vec2 s = step(bottomLeft, v) - step(topRight, v);\n  return s.x * s.y;\n}\n\nvec3 opCheapBend( vec3 p, float angle )\n{\n    float c = cos(angle*p.y);\n    float s = sin(angle*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    c, 0.0, -s,\n    0.0, 1.0, 0.0,\n    s, 0.0, c\n  );\n}\n\nmat3 rotation3dX(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, c, s,\n\t\t0.0, -s, c\n\t);\n}\nmat3 rotation3dZ(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3(\n\t\tc, s, 0.0,\n\t\t-s, c, 0.0,\n\t\t0.0, 0.0, 1.0\n\t);\n}\n\nvoid main() {\n  float absScale = abs(scale);\n  vec3 offsetPos = vec3(offset.x, 0.0, offset.y);\n  vec2 spriteRepeat = useSpriteAtlas ? spriteCoords.xy : vec2(1.0);\n  vec2 spriteOffset = useSpriteAtlas ? spriteCoords.zw : vec2(0.0);\n  vec2 spriteCoord = uv;\n  if (scale < 0.0) spriteCoord.x = (1.0 - spriteCoord.x);\n  spriteCoord *= spriteRepeat;\n  spriteCoord += spriteOffset;\n  vOriginalUv = uv;\n  // if (scale < 0.0) spriteCoord.x = 1.0 - spriteCoord.x;\n  // spriteCoord.x += spriteIndex;\n  // spriteCoord.x *= 1.0 / spriteTextureAtlasColumns;\n  // if (spriteIndex < 1.5) gradientY += 0.15;\n\n  vec3 centerWorldPos = (modelMatrix * vec4(offsetPos, 1.0)).xyz;\n  vec3 camRightWorld = vec3(viewMatrix[0].x, viewMatrix[1].x, viewMatrix[2].x);\n  vec3 camUpWorld = vec3(viewMatrix[0].y, viewMatrix[1].y, viewMatrix[2].y);\n\n  vWorldUv = range(\n    -vec2(worldMapSize / 2.0),\n    vec2(worldMapSize / 2.0),\n    centerWorldPos.xz\n  );\n  vWorldUv.y = 1.0 - vWorldUv.y;\n\n  // float wdist = 0.1;\n  // float wd = distance(vWorldUv, vec2(0.5)) / wdist;\n  // float wt = 0.4;\n  // float wg = 0.1;\n  // wd = smoothstep(wt - wg, wt + wg, wd);\n  // float distFromCenter = clamp(wd, 0.0, 1.0);\n  // absScale *= distFromCenter;\n\n  float water = texture2D(waterMap, vWorldUv).r;\n  absScale *= 1.0 - water;\n\n  float wdist = 0.04;\n  float wd = distance(vWorldUv, vec2(0.5, 0.5)) / wdist;\n  float wt = 0.5;\n  float wg = 0.45;\n  wd = smoothstep(wt - wg, wt + wg, wd);\n  float distFromCenter = clamp(wd, 0.0, 1.0);\n  absScale *= distFromCenter;\n\n  // camRightWorld *= rotation3dZ(sin(time) * position.y);\n\n  \n  // vec2 centerWorldUv = range(\n  //   -vec2(worldMapSize / 2.0),\n  //   vec2(worldMapSize / 2.0),\n  //   centerWorldPos.xz\n  // );\n  // centerWorldUv.y = 1.0 - centerWorldUv.y;\n\n  // vec2 envPosInWorldPos = (centerWorldUv * 2.0 - 1.0) * worldMapSize / 2.0;\n  vec4 vDataUvPos4 = worldDataProjection * worldDataView * vec4(centerWorldPos.xz, 0.0, 1.0);\n  vec2 vDataScreen = vDataUvPos4.xy / vDataUvPos4.w;\n  vDataUv = vDataScreen.xy * 0.5 + 0.5;\n\n  // vec3 \n\n  // vec4 centerClipPos = projectionMatrix * viewMatrix * vec4(centerWorldPos, 1.0);\n  // vec2 center2D = centerClipPos.xy / centerClipPos.w;\n  // float distanceScale = manhattanDistance(center2D.xy, vec2(0.0));\n  // vec4 dataColor = texture2D(worldDataMap, centerWorldUv);\n  vec3 dCol = texture2D(worldDataMap, vDataUv).rgb;\n  // float dirAngle = (dCol.g * 2.0 - 1.0) * 3.14;\n  vec2 curDirection2D = vec2(dCol.gb) * 2.0 - 1.0;\n  vec3 curDirection = vec3(curDirection2D.x, 0.0, curDirection2D.y);\n  \n  float dScale = dCol.r;\n  // float dScale = 0.0;\n  float dataScale = 1.0 + dScale * 0.0;\n  vDataScale = dScale;\n  // float dataScale = 1.0; // green is leaf growth\n  float dataMove = 1.0;\n  \n  vec3 grassColor = vec3(1.0);\n  vGrassColor = grassColor;\n\n  // dataScale = smoothstep(1.75, 1.25, dataScale);\n  // float worldRadius = 30.0;\n  // float dataScale = 1.0 - clamp(distance(centerWorldPos, userTargetWorldPosition) / worldRadius, 0.0, 1.0);\n  // dataScale = smoothstep(0.0, 0.5, dataScale);\n  // vec3 modifiedCamUpWorld = normalize(camUpWorld + curDirection * 0.25);\n\n  // float aspect = 418.0/419.0;\n  // float aspect = spriteRepeat.x / spriteRepeat.y;\n  float aspect = useSpriteAtlas ? spriteAspect : spriteMapAspect;\n\n  float billboardSize01 = globalSpriteScale * absScale;\n  float billboardSize = dataScale * billboardSize01;\n  vec3 vertexStraightWorldPos = (centerWorldPos)\n    + camRightWorld * position.x * billboardSize * aspect\n    + camUpWorld * position.y * billboardSize;\n\n  float moveGradientY = clamp(vertexStraightWorldPos.y / 0.5, 0.0, 1.0);\n  gradientY = pow(clamp(vertexStraightWorldPos.y / 1.0, 0.0, 1.0), 1.25);\n\n  float scaleTime = time * 0.1;\n  // float noiseValue = (\n  //   smoothTriangleWave(scaleTime + centerWorldPos.x * 0.05 + centerWorldPos.z * -0.01) * 0.5 +\n  //   smoothTriangleWave(scaleTime + centerWorldPos.z * 0.05) * 0.25 + \n  //   sin(scaleTime + centerWorldPos.y * 0.1) * 0.25\n  // );\n\n  float noiseValue = 0.0;\n  noiseValue += cos(time * 2.0 + centerWorldPos.x * 0.5) * 0.33;\n  noiseValue += sin(time + centerWorldPos.z * 0.25) * 0.33;\n  noiseValue += sin(time + centerWorldPos.x * 0.25) * 0.33;\n  noiseValue = clamp(noiseValue, -1.0, 1.0);\n\n  float invDScale = 1.0;\n  camUpWorld *= rotation3dZ(noiseValue * 3.14 * 0.25 * moveGradientY * invDScale);\n\n  vec3 vertexWorldPos = (centerWorldPos)\n    + camRightWorld * position.x * billboardSize * aspect\n    + camUpWorld * position.y * billboardSize;\n  \n  // vec3 axisDirection = \n  \n  // noiseValue += sin(time * 0.75 + centerWorldPos.x * 0.2) * 0.25;\n  // noiseValue += sin(time * 0.75 + centerWorldPos.z * 0.2) * 0.25;\n  // noiseValue += sin(time * 0.85 + centerWorldPos.z * 0.2) * 0.25;\n  // noiseValue += cos(time * 0.25 + centerWorldPos.x * 0.1) * 0.25;\n  // noiseValue = smoothstep(0.2, 0.8, noiseValue * 0.5 + 0.5) * 2.0 - 1.0;\n\n  float skewValue = gradientY * noiseValue;\n  float skewScaled = skewValue * 0.25* invDScale;\n  \n  // vertexWorldPos *= rotationMatrix(vec3(0.0, 1.0, 0.0), sin(time) * 2.0);\n\n  vertexWorldPos += camRightWorld * skewScaled;\n  vertexWorldPos.xyz += curDirection * 0.1 * dScale;\n  vertexWorldPos.xyz += curDirection * gradientY * 0.66 * dScale;\n\n  // vertexWorldPos += dScale * moveGradientY * camRightWorld * curDirection.xyz * 1.0;\n  // vertexWorldPos += dScale * moveGradientY * camRightWorld * curDirection.xyz * 0.5;\n\n  vec3 vertexWorldBasePos = (centerWorldPos)\n    + camRightWorld * position.x * billboardSize * aspect\n    + camUpWorld * position.y * billboardSize;\n  \n  // vec3 vertexWorldBasePos = centerWorldPos;\n  \n\n  vec4 baseClipPos = groundProjectionMatrix * viewMatrix * vec4(vertexWorldBasePos, 1.0);\n  vec4 clipPos = projectionMatrix * viewMatrix * vec4(vertexWorldPos, 1.0);\n  vGroundUv = baseClipPos.xy / baseClipPos.w * 0.5 + 0.5;\n  // vGroundUv = clamp(vGroundUv, 0.0, 1.0);\n  vGroundColor = texture2D(groundMap, vGroundUv).rgb;\n  // vGroundUv = baseClipPos.xy / baseClipPos.w * 0.5 + 0.5;\n  // vGroundUv = floor(vGroundUv / 0.05) * 0.05;\n  \n  // if (absScale > 2.35) vGroundColor = vec3(1.0,0.0,0.0);\n  vUv = spriteCoord;\n  // if (scale < 0.0) vUv.x = 1.0 - vUv.x;\n\n  gl_Position = clipPos;\n  // vec4 mvPosition = modelViewMatrix * vec4(offsetPos, 1.0);\n  // vec2 mvScale;\n  // mvScale.x = length(modelMatrix[0].xyz);\n  // mvScale.y = length(modelMatrix[1].xyz);\n  // mvScale *= globalSpriteScale * absScale;\n  // vec2 mvOffset = mvScale * position.xy;\n\n  // vec3 worldPos = centerWorldPos;\n  // worldPos.xy += mvOffset;\n\n  // vec4 groundPoint = mvPosition;\n\n  // mvPosition.xy += mvOffset;\n  // mvPosition.x -= skewScaled * mvScale.x;\n\n  // #if defined(TRUE_BLEND)\n  // groundPoint.x += mvScale.x * position.x - skewScaled * mvScale.x;\n  // #elif defined(TRUE_FIXED_BLEND)\n  // groundPoint.x += mvScale.x * position.x;\n  // #endif\n\n  // vec4 screenPointSolid = groundProjectionMatrix * groundPoint;\n  // vGroundUv = screenPointSolid.xy / screenPointSolid.w * 0.5 + 0.5;\n  // gl_Position = projectionMatrix * mvPosition;\n\n  \n  // vec3 worldPos = \n  // const x = (u * environment.size) / 2;\n  // const z = (v * environment.size) / 2;\n  // vWorldUv = \n\n  // inverseLerp(-environment.size / 2, environment.size / 2, position.x) *\n  //         2 -\n  //       1;\n  \n  // vSpriteIndex = spriteIndex;\n  vHighlight = noiseValue * 0.5 + 0.5;\n  vScreenUv = gl_Position.xy / gl_Position.w * 0.5 + 0.5;\n}\n";