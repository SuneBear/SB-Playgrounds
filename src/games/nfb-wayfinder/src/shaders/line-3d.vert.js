module.exports="#define GLSLIFY 1\n// #define IS_CLOSED\nattribute float direction;\nattribute vec2 vertexDistance;\nattribute vec3 nextPosition;\nattribute vec3 previousPosition;\nattribute float vertexHasToken;\n\nuniform bool taper;\nuniform bool miter;\nuniform float time;\nuniform float totalDistance;\nuniform float miterLimit;\nuniform float thickness;\nuniform float draw;\nuniform bool drawing;\nuniform bool filling;\n\nuniform vec2 resolution;\n\nvarying float vToken;\nvarying vec2 vDist;\n\nvec4 screenSpaceLine (vec3 offset, float computedThickness) {\n  float aspect = resolution.x / resolution.y;\n  vec2 aspectVec = vec2(aspect, 1.0);\n  mat4 projViewModel = projectionMatrix * modelViewMatrix;\n  vec4 previousProjected = projViewModel * vec4(vec3(previousPosition.xyz) + offset, 1.0);\n  vec4 currentProjected = projViewModel * vec4(vec3(position.xyz) + offset, 1.0);\n  vec4 nextProjected = projViewModel * vec4(vec3(nextPosition.xyz) + offset, 1.0);\n\n  //get 2D screen space with W divide and aspect correction\n  vec2 currentScreen = currentProjected.xy / currentProjected.w * aspectVec;\n  vec2 previousScreen = previousProjected.xy / previousProjected.w * aspectVec;\n  vec2 nextScreen = nextProjected.xy / nextProjected.w * aspectVec;\n  \n  float len = computedThickness;\n  float orientation = direction;\n  vec2 dirA = normalize(currentScreen - previousScreen);\n\n  //starting point uses (next - current)\n  vec2 dir = vec2(0.0);\n  #ifndef IS_CLOSED\n  if (currentScreen == previousScreen) {\n    dir = normalize(nextScreen - currentScreen);\n  } \n  //ending point uses (current - previous)\n  else if (currentScreen == nextScreen) {\n    dir = normalize(currentScreen - previousScreen);\n  }\n  //somewhere in middle, needs a join\n  else {\n  #endif\n    //get directions from (C - B) and (B - A)\n    vec2 dirB = normalize(nextScreen - currentScreen);\n    if (miter) {\n      //now compute the miter join normal and length\n      vec2 tangent = normalize(dirA + dirB);\n      vec2 perp = vec2(-dirA.y, dirA.x);\n      vec2 miter = vec2(-tangent.y, tangent.x);\n      float miterDot = dot(miter, perp);\n      len = miterDot == 0.0 ? 0.0 : (computedThickness / miterDot);\n      len = clamp(len, 0.0, computedThickness * miterLimit);\n      dir = tangent;\n    } else {\n      dir = normalize(dirA + dirB);\n    }\n  #ifndef IS_CLOSED\n  }\n  #endif\n\n  vec2 normal = vec2(-dir.y, dir.x);\n\n  // convert pixel thickness to NDC space\n  vec2 normalLength = vec2(len / 2.0);\n  normalLength = normalLength * 2.0;\n\n  // scale normal to line thickness\n  normal *= normalLength;\n  normal.x /= aspect;\n\n  vec4 finalOffset = vec4(normal * orientation, 0.0, 0.0);\n  return currentProjected + finalOffset;\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n  x = abs(x - c);\n  if( x>w ) return 0.0;\n  x /= w;\n  return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat parabola( float x, float k )\n{\n    return pow( 4.0*x*(1.0-x), k );\n}\n\nvoid main () {\n  float computedThickness = thickness;\n  // computedThickness *= mix(0.5, 1.0, vertexHasToken);\n  if (taper) computedThickness *= sin(3.14 * vertexDistance.x);\n\n  if (drawing) {\n    computedThickness *= smoothstep(1.0, 1.0-0.05, vertexDistance.x);\n    computedThickness *= smoothstep(0.0, 0.05, vertexDistance.x);\n    // computedThickness *= smoothstep(draw - smoothness, draw + smoothness, vertexDistance.x);\n\n    float e = 0.25;\n    float t = draw;\n\n    // computedThickness *= parabola(vertexDistance.x, 1.0);\n    float m = mix(-e, 1.0 + e, t);\n    float d = 1.0 - min(1.0, abs(vertexDistance.x - m) / e);\n    // computedThickness *= step(t, vertexDistance.x);\n\n    // float d = smoothstep(m + e, m - e, vertexDistance.x);\n    computedThickness *= cubicPulse(m, e, vertexDistance.x);\n    // computedThickness *= smoothstep(totalDistance, totalDistance / 2.0, vertexDistance.y);\n  } else if (filling) {\n    computedThickness *= step(vertexDistance.x, draw);\n  }\n  // computedThickness *= abs(vertexDistance.y / )\n  float yoff = sin(time + vertexDistance.x * 4.0) * 0.1;\n  vec3 offset = vec3(0.0, 0.0, 0.0);\n  // offset.y += 2.0 + sin(position.y * 4.0) * 2.0;\n  gl_Position = screenSpaceLine(offset, computedThickness);\n  vDist = vertexDistance;\n  vToken = vertexHasToken;\n}";