module.exports="#define GLSLIFY 1\n#define PI 3.1415926538\n\nuniform float rotation;\nuniform vec2 repeat;\nuniform vec2 offset;\nuniform float flip;\nuniform float time;\n\nuniform sampler2D worldDataMap;\nuniform mat4 worldDataProjection;\nuniform mat4 worldDataView;\nuniform float spriteHeight;\nuniform bool silhouette;\n\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\n\nvoid main () {\n  vUv = uv;\n  vUv *= repeat;\n  vUv += offset;\n\n  vec3 centerWorldPos = (modelMatrix * vec4(vec3(0.0), 1.0)).xyz;\n  vec3 camRightWorld = vec3(viewMatrix[0].x, viewMatrix[1].x, viewMatrix[2].x);\n  vec3 camUpWorld = vec3(viewMatrix[0].y, viewMatrix[1].y, viewMatrix[2].y);\n  \n  vec2 scale;\n  scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n  scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n  scale.x *= flip;\n\n  vec4 vDataUvPos4 = worldDataProjection * worldDataView * vec4(centerWorldPos.xz, 0.0, 1.0);\n  vec2 vDataScreen = vDataUvPos4.xy / vDataUvPos4.w;\n  vec2 vDataUv = vDataScreen.xy * 0.5 + 0.5;\n  vec3 dCol = texture2D(worldDataMap, vDataUv).rgb;\n\n  vec3 offsetPos = position.xyz;\n  vec3 vertexWorldPos = centerWorldPos\n    + camRightWorld * offsetPos.x * scale.x\n    + camUpWorld * offsetPos.y * scale.y;\n\n  vec3 realVertexWorldPos = vertexWorldPos;\n\n  vec3 vertexWorldBasePos = centerWorldPos;\n  vec2 curDirection2D = vec2(dCol.gb) * 2.0 - 1.0;\n  vec3 curDirection = vec3(curDirection2D.x, 0.0, curDirection2D.y);\n  float gradientY = clamp(vertexWorldPos.y / 0.25, 0.0, 1.0);\n  // vertexWorldPos += 0.05 * scale.y * camRightWorld * sin(time*7.0) * pow(dCol.r, 2.0) * gradientY;\n  vertexWorldPos += 0.05 * position.y * spriteHeight * camRightWorld * sin(time*7.0) * curDirection * pow(dCol.r, 2.0) * gradientY;\n\n  if (silhouette) {\n    float xSkew = -60.0 * (PI/180.0);\n    float ySkew = 0.0;\n\n    // Create a transform that will skew our texture coords\n    // mat3 trans = mat3(\n    //   1.0       , tan(xSkew), 0.0,\n    //   tan(ySkew), 1.0,        0.0,\n    //   0.0       , 0.0,        1.0\n    // );\n    vertexWorldPos.y *= 0.25;\n    vertexWorldPos.xyz -= camRightWorld * realVertexWorldPos.y * 0.5;\n    vertexWorldPos.z += -0.15;\n    // vertexWorldPos.x += -0.05;\n    // vertexWorldPos.xyz += vYGradient * camRightWorld * -0.5;\n    // vertexWorldPos.y *= 1.0;\n    // vertexWorldPos.xyz -= centerWorldPos;\n    // // vertexWorldPos.xyz *= rotation3dX(PI / -4.0);\n    // vertexWorldPos *= rotationMatrix(camRightWorld, PI / 2.0);\n    // vertexWorldPos.xyz += centerWorldPos;\n    // vertexWorldPos += vYGradient * camRightWorld * -0.5;\n    // vertexWorldPos *= offsetPos.y * camRightWorld * -2.0;\n    // vertexWorldPos.z *= 0.5;\n  }\n\n  vWorldPosition = vertexWorldPos;\n  gl_Position = projectionMatrix * viewMatrix * vec4(vertexWorldPos, 1.0);\n}\n";