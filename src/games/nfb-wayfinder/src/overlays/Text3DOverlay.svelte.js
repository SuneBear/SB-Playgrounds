/* overlays/Text3DOverlay.svelte generated by Svelte v3.31.0 */
import {
	SvelteComponent,
	attr,
	binding_callbacks,
	detach,
	element,
	init,
	insert,
	noop,
	safe_not_equal
} from "svelte/internal";

import * as THREE from "three";
import * as Tags from "../tags";
import { onMount } from "svelte";
import ObjectPool from "../util/ObjectPool";
import cameraProject from "camera-project";
import { addPostRenderCallback } from "../util/addFrameTasks";
import * as MathUtil from "../util/math";
import eases from "eases";

function create_fragment(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "container svelte-1bz0ho2");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			/*div_binding*/ ctx[3](div);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
			/*div_binding*/ ctx[3](null);
		}
	};
}

function buildChildTexts(container, text) {
	text.split("").forEach(letter => {
		const span = document.createElement("span");
		span.textContent = letter;
		container.appendChild(span);
	});
}

function clearChildren(node) {
	while (node.lastElementChild) {
		node.removeChild(node.lastElementChild);
	}
}

function instance($$self, $$props, $$invalidate) {
	let { world } = $$props;
	let { state } = $$props;
	const viewport = [0, 0, 0, 0];
	const upVector = new THREE.Vector3(0, 1, 0);
	const vec3 = new THREE.Vector3();
	const arr4D = [0, 0, 0, 0];
	const inArr3 = [0, 0, 0];

	class TextNode {
		constructor() {
			this.inner = document.createElement("div");
			this.inner.className = "text-sprite-3d";
			this.element = document.createElement("div");
			this.element.appendChild(this.inner);
			this.element.className = "text-sprite-3d-container";
			this.reset();
		}

		reset() {
			this._splitText = false;
			this._visible = false;
			this._text = "";
			this._x = null;
			this._y = null;
			this._scale = null;
			this._opacity = null;
			this._fontSize = null;
			this._fontStyle = null;
			this.element.style.opacity = "1";
			this.element.style.display = "none";
			this.setTransform(0, 0, 1);
			this.setOpacity(1);
			this.setFont(16, "normal");
		} // clearChildren(this.inner);

		setFont(size, style) {
			let oldSize = this._fontSize;
			let oldStyle = this._fontStyle;
			this._fontSize = size;
			this._fontStyle = style;

			if (oldStyle !== this._fontStyle) {
				this.element.style.fontStyle = this._fontStyle;
			}

			if (oldSize !== this._fontSize) {
				this.element.style.fontSize = `${this._fontSize}px`;
				this.element.style.top = `${-this._fontSize}px`;
			}
		}

		appendTo(parent) {
			if (this.element) parent.appendChild(this.element);
		}

		detach() {
			if (this.element && this.element.parentElement) {
				this.element.parentElement.removeChild(this.element);
			}
		}

		dispose() {
			this.detach();
			this.element = null;
			this.container = null;
		}

		setOpacity(o) {
			const eps = 0.01;

			if (Math.abs(this._opacity - o) >= eps || o >= 1 || o <= 0) {
				this._opacity = o;
				if (this.element) this.element.style.opacity = o;

				if (this.inner) {
					const v = eases.quadInOut(o);
				} // this.inner.style.clipPath = `inset(-20px ${((1 - v) * 100).toFixed(
				//   5
			} // )}% -20px -20px)`;
		}

		setVisible(v) {
			if (this._visible !== v) {
				this._visible = v;
				if (this.element) this.element.style.display = this._visible ? "" : "none";
			}
		}

		setTransform(x, y, scale = 1) {
			const eps = 0.001;

			if (Math.abs(this._x - x) >= eps || Math.abs(this._y - y) >= eps || Math.abs(this._scale - scale) >= eps) {
				this._x = x;
				this._y = y;
				this._scale = scale;

				if (this.element) {
					// scale(${scale}, ${scale})
					this.element.style.transform = `translate(${x}px, ${y}px)`;
				}

				if (this.inner) {
					this.inner.style.transform = `scale(${scale}, ${scale})`;
				}
			}
		}

		setText(text) {
			if (this._text !== text) {
				this._text = text;

				if (this.inner) {
					this.inner.textContent = text;
				} // clearChildren(this.inner);
				// this._splitText = true;
			} // buildChildTexts(this.inner, text);
		}
	}

	const elementPool = new ObjectPool({
			create() {
				return new TextNode();
			},
			release(e) {
				e.reset();
			}
		});

	const projectionMatrix = new THREE.Matrix4();
	let container;
	let nodes = [];
	let wasVisible = null;
	let currentElements = [];

	addPostRenderCallback(() => {
		if (!nodes) return;
		const camera = world.findTag(Tags.MainCamera);
		const appState = world.findTag(Tags.AppState);
		viewport[2] = appState.width;
		viewport[3] = appState.height;
		projectionMatrix.copy(camera.projectionMatrix).multiply(camera.matrixWorldInverse);

		// nodes = v;
		updated(container, nodes);
	});

	state.subscribe(v => {
		nodes = v;
	});

	// $: updated(container, nodes);
	function updated(container, nodes) {
		if (!container) return;

		// first we adjust arrays to be aligned
		if (currentElements.length !== nodes.length) {
			// fill buffer to match
			for (let i = 0; i < nodes.length; i++) {
				if (!currentElements[i]) {
					// get from pool
					currentElements[i] = elementPool.next();

					// add to container
					currentElements[i].appendTo(container);
				}
			}

			// fix any overflow
			if (currentElements.length > nodes.length) {
				for (let j = nodes.length; j < currentElements.length; j++) {
					if (currentElements[j]) {
						const e = currentElements[j];
						e.detach();
						elementPool.release(e);
						currentElements[j] = null;
					}
				}
			}

			currentElements.length = nodes.length;
		}

		let hasVisible = false;

		for (let i = 0; i < currentElements.length; i++) {
			const el = currentElements[i];
			const entity = nodes[i];
			const sprite = entity.get(Tags.TextSprite3D);
			let visible = false;

			if (sprite && sprite.parent) {
				visible = true;
				sprite.parent.getWorldPosition(vec3);
				vec3.toArray(inArr3);
				cameraProject(arr4D, inArr3, viewport, projectionMatrix.elements);
				const x = arr4D[0];
				const y = viewport[3] - arr4D[1];
				const xpad = 80;
				const ypad = 20;
				const inside = x >= -xpad && y >= -ypad && x <= viewport[2] + xpad && y <= viewport[3] + ypad;

				if (inside || !sprite.culling) {
					const ySize = 1;
					vec3.addScaledVector(upVector, ySize);
					vec3.toArray(inArr3);
					cameraProject(arr4D, inArr3, viewport, projectionMatrix.elements);
					const y2 = viewport[3] - arr4D[1];

					// Here's how I got this:
					// First, set window to any size (e.g. 534px high)
					// Then check the view units coming from the difference (~23.31 px)
					// between the two projected vectors, and scale that by
					// the height factor so that we get the size at that 534px high view
					// and divide by the target size to get a scaling factor
					const heightFactor = viewport[3] / 534;

					const sizeAtHeight = 23.31024;
					let size = Math.abs(y2 - y) / heightFactor / sizeAtHeight;

					// size = MathUtil.clamp(size, 0.25, 2);
					size = viewport[3] / 500;

					el.setTransform(x, y, size);
					hasVisible = true;
				} else {
					visible = false;
				}

				if (visible) {
					el.setText(sprite.text);
					el.setOpacity(sprite.opacity);
					el.setFont(sprite.fontSize, sprite.fontStyle);
				}
			}

			el.setVisible(visible);
		}

		const oldVisible = wasVisible;
		wasVisible = hasVisible;

		if (oldVisible !== hasVisible) {
			container.style.display = hasVisible ? "" : "none";
		}
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			container = $$value;
			$$invalidate(0, container);
		});
	}

	$$self.$$set = $$props => {
		if ("world" in $$props) $$invalidate(1, world = $$props.world);
		if ("state" in $$props) $$invalidate(2, state = $$props.state);
	};

	return [container, world, state, div_binding];
}

class Text3DOverlay extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { world: 1, state: 2 });
	}
}

export default Text3DOverlay;