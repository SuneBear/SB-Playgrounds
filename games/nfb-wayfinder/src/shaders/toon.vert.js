module.exports="#define GLSLIFY 1\n#ifdef HAS_INTENSITY\nattribute float intensity;\nvarying float vIntensity;\n#endif\n\n#ifdef HAS_VERTEX_COLORS\nattribute vec3 vertexColor;\nvarying vec3 vVertexColor;\n#endif\n\nvarying vec2 vGroundUv;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\n\nvarying vec2 vBillboardUV;\nuniform vec3 minBounds;\nuniform mat4 groundProjectionMatrix;\nuniform vec3 maxBounds;\nuniform vec2 resolution;\n\nfloat range(float vmin, float vmax, float value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nvec2 range(vec2 vmin, vec2 vmax, vec2 value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nvec3 range(vec3 vmin, vec3 vmax, vec3 value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nvec4 range(vec4 vmin, vec4 vmax, vec4 value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\n// modified from http://graphics.cs.williams.edu/papers/HashedAlphaI3D17/\n// fixed4 tex2DConstScale(sampler2D tex, float texSize, float2 uv)\n// {\n//   // Find the discretized derivatives of our coordinates\n//   float maxDeriv = max( length(ddx(uv)), length(ddy(uv)) );\n//   float pixScale = 1.0 / (texSize * maxDeriv);\n//   // Find two nearest log-discretized noise scales\n//   float2 pixScales = float2(\n//       exp2(floor(log2(pixScale))),\n//       exp2( ceil(log2(pixScale)))\n//       );\n//   // Factor to interpolate lerp with\n//   float lerpFactor = frac( log2(pixScale) );\n\n//   return lerp(\n//       tex2D(tex, pixScales.x * uv),\n//       tex2D(tex, pixScales.y * uv),\n//       lerpFactor\n//       );\n// }\n\n// \n\nvec2 getScreenUV (vec2 clipPos, float uvScale) {\n  // vec3 boxCenter = (minBounds + maxBounds) * 0.5;\n  // vec4 SSobjectPosition = projectionMatrix * viewMatrix * vec4(boxCenter, 1.0);\n  vec4 SSobjectPosition = projectionMatrix * modelViewMatrix * vec4(vec3(0.0), 1.0);\n  vec2 screenUV = vec2(clipPos.xy);\n  float screenRatio = resolution.y/resolution.x;\n\n  screenUV.x -= SSobjectPosition.x/(SSobjectPosition.w);\n  screenUV.y -= SSobjectPosition.y/(SSobjectPosition.w);\n\n  screenUV.y *= screenRatio;\n\n  screenUV *= 1.0/uvScale;\n  screenUV *= SSobjectPosition.z; // or z\n  return screenUV; \n}\n\nvoid main () {\n  vUv = uv;\n  vec3 objectNormal = normal;\n  vec3 transformedNormal = objectNormal;\n  transformedNormal = normalMatrix * transformedNormal;\n  transformedNormal = normalize(transformedNormal);\n  vNormal = transformedNormal;\n  vec3 transformed = position.xyz;\n  // transformed += normal.xyz * 0.1;\n  vPosition = transformed.xyz;\n  vec4 worldPos = modelMatrix * vec4(transformed, 1.0);\n  vec4 mvPosition = viewMatrix * worldPos;\n  gl_Position = projectionMatrix * mvPosition;\n  \n  vViewPosition = -mvPosition.xyz;\n  vWorldPosition = worldPos.xyz;\n  #ifdef HAS_INTENSITY\n  vIntensity = intensity;\n  #endif\n  #ifdef HAS_VERTEX_COLORS\n  vVertexColor = vertexColor;\n  #endif\n\n  vec3 gPos = worldPos.xyz;\n  gPos.y *= 0.0;\n  vec4 baseClipPos = groundProjectionMatrix * viewMatrix * vec4(gPos, 1.0);\n  vGroundUv = baseClipPos.xy / baseClipPos.w * 0.5 + 0.5;\n\n  // vec3 bpoint = range()\n  // vec4 vpos = projectionMatrix * modelMatrix * vec4(transformed.xyz, 1.0);\n\n  // vec3 boxCenter = (minBounds + maxBounds) * 0.5;\n  // vec3 centerWorldPos = (modelMatrix * vec4(boxCenter, 1.0)).xyz;\n\n  // vec3 npos = transformed.xyz;\n  // vec4 clipCur = projectionMatrix * modelMatrix * vec4(npos, 1.0);\n  // vec4 clipCur = projectionMatrix * modelMatrix * vec4(position.xyz, 1.0);\n  // vec4 clipMin = projectionMatrix * modelViewMatrix * vec4(minBounds.xyz, 1.0);\n  // vec4 clipMax = projectionMatrix * modelViewMatrix * vec4(maxBounds.xyz, 1.0);\n  // vec4 clipCenter = (projectionMatrix * viewMatrix * vec4(centerWorldPos, 1.0));\n  // clipCur.xy -= clipCenter.xy / clipCenter.w;\n  // vec2 clipCur2D = clipCur.xy / clipCur.w * 0.5 + 0.5;\n  // clipCur2D.xy -= clipCenter.xy / clipCenter.w * 0.5 + 0.5;\n  // vec2 clipMin2D = clipMin.xy / clipMin.w;\n  // vec2 clipMax2D = clipMax.xy / clipMax.w;\n\n  // vBillboardUV = getScreenUV(gl_Position.xy / gl_Position.w, 40.0);\n  // vBillboardUV = mix(clipMin2D, clipMax2D, range(minBounds, maxBounds, position.xyz));\n\n  // vec3 bWorldPos = worldPos.xyz + boxCenter.xyz;\n  // vec4 bClipPos = projectionMatrix * viewMatrix * vec4(bWorldPos, 1.0);\n  // vBillboardUV = bClipPos.xy / bClipPos.w * 0.5 + 0.5;\n  \n  // vec3 camRightWorld = vec3(viewMatrix[0].x, viewMatrix[1].x, viewMatrix[2].x);\n  // vec3 camUpWorld = vec3(viewMatrix[0].y, viewMatrix[1].y, viewMatrix[2].y);\n\n  \n\n  // float billboardSize = 1.0 * globalSpriteScale * absScale;\n  // vec3 vertexWorldPos = boxCenter\n  //   + camRightWorld * position.x * billboardSize\n  //   + camUpWorld * position.y * billboardSize;\n\n}";