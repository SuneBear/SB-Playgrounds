module.exports="#define GLSLIFY 1\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendOverlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n\nvarying vec2 vUv;\nvarying vec2 vDataUv;\nvarying vec2 vShadowUv;\nvarying vec2 vTextureUv;\nvarying vec3 vShadowClipPos;\nuniform sampler2D dataMapBiome;\nuniform sampler2D dataMapColor;\nuniform sampler2D dataMapLake;\nuniform float overlayOpacity;\n\nuniform float time;\n\n#ifdef USE_MAP_OVERRIDE\nuniform sampler2D overrideMap;\n#endif\n\nuniform sampler2D shadowMap;\n\nuniform mat4 worldFogProjection;\nuniform sampler2D worldFogMap;\nuniform vec3 clearColor;\n\n#ifdef USE_MAP_OVERRIDE\nuniform bool useOverrideMap;\n#endif\n\nuniform bool useOverrideColor;\nuniform vec3 overrideColor;\nuniform float solved;\nuniform vec3 originColor;\nuniform sampler2D worldDataMap;\n\n// uniform sampler2D map0;\n// uniform sampler2D map1;\n// uniform sampler2D map2;\n// uniform sampler2D map3;\n// uniform sampler2D mapPath;\nuniform sampler2D mapGround;\nuniform sampler2D mapGroundPath;\nuniform sampler2D mapOverlay;\n\nuniform float tutorial;\n\n// vec3 blend(vec4 texture1, float a1, vec4 texture2, float a2) {\n//     float depth = 0.2;\n//     float ma = max(texture1.a + a1, texture2.a + a2) - depth;\n\n//     float b1 = max(texture1.a + a1 - ma, 0);\n//     float b2 = max(texture2.a + a2 - ma, 0);\n\n//     return (texture1.rgb * b1 + texture2.rgb * b2) / (b1 + b2);\n// }\n\nvec3 blend(vec4 texture1, float a1, vec4 texture2, float a2) {\n  return texture1.a > texture2.a ? texture1.rgb : texture2.rgb;\n}\n\nvec4 textureLuma(sampler2D tex, vec2 uv) {\n  vec3 rgb = texture2D(tex, uv).rgb;\n  float d = dot(rgb, vec3(0.299, 0.587, 0.114));\n  return vec4(rgb, d);\n}\n\n// vec3 splat (float m, float e, float p, vec2 uv) {\n//   vec3 tex0 = texture2D(map0, uv).rgb;\n//   vec3 tex1 = texture2D(map1, uv).rgb;\n//   vec3 tex2 = texture2D(map2, uv).rgb;\n//   vec3 tex3 = texture2D(map3, uv).rgb;\n//   vec3 texPath = texture2D(mapPath, uv).rgb;\n//   //   mix(tex0, tex1, m),\n//   //   mix(tex2, tex3, e),\n//   //   p);\n//   // return tex;\n\n//   // vec3 tex;\n//   // if (m < 0.5 && e >= 0.5) {\n//   //   // dry, high\n//   //   tex = tex0;\n//   // } else if (m < 0.5 && e < 0.5) {\n//   //   // dry, low\n//   //   tex = tex1;\n//   // } else if (m >= 0.5 && e >= 0.5) {\n//   //   // wet, high\n//   //   tex = tex2;\n//   // } else {\n//   //   // wet, low\n//   //   tex = tex3;\n//   // }\n//   // return mix(tex, texPath, step(0.4, p));\n\n//   float w0 = 0.0;\n//   float w1 = 0.0;\n//   float w2 = 0.0;\n//   float w3 = 0.0;\n//   float feather = 0.1;\n//   float t = 0.5;\n//   w0 = smoothstep(t + feather, t - feather, m) * smoothstep(t - feather, t + feather, e);\n//   w1 = smoothstep(t + feather, t - feather, m) * smoothstep(t + feather, t - feather, e);\n//   w2 = smoothstep(t - feather, t + feather, m) * smoothstep(t - feather, t + feather, e);\n//   w3 = smoothstep(t - feather, t + feather, m) * smoothstep(t + feather, t - feather, e);\n//   vec3 tex = vec3(0.0);\n//   // tex = tex0 * w0;\n//   tex += tex0 * w0 + tex1 * w1;\n//   tex += tex2 * w2 + tex3 * w3;\n//   float pt = 0.35;\n//   float pf = 0.5;\n//   return mix(tex * 0.5, tex, smoothstep(pt - pf, pt + pf, p));\n//   // return mix(mix(tex, texPath.r * tex, 0.15), tex, smoothstep(pt - pf, pt + pf, p));\n//   // return mix(tex, texPath.rgb, smoothstep(pt - pf, pt + pf, p));\n// }\n\n// void main () {\n//   vec3 dataColor = texture2D(worldDataMap, vDataUv).rgb;\n//   vec3 biome = texture2D(dataMapBiome, vUv).rgb;\n//   vec3 worldColor = texture2D(dataMapColor, vUv).rgb;\n//   if (useOverrideColor) {\n//     worldColor = overrideColor;\n//   }\n//   vec3 overlay = texture2D(mapOverlay, vTextureUv).rgb;\n//   vec3 groundTex = texture2D(mapGround, vTextureUv).rgb;\n//   vec3 pathTex = texture2D(mapGroundPath, vTextureUv * 2.0).rgb;\n//   gl_FragColor.rgb = vec3(worldColor);\n\n//   vec3 worldFogColor = texture2D(worldFogMap, vUv).rgb;\n//   gl_FragColor.rgb *= worldFogColor;\n//   gl_FragColor.a = 1.0;\n// }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid main2 () {\n  vec3 dataColor = texture2D(worldDataMap, vDataUv).rgb;\n  vec3 biome = texture2D(dataMapBiome, vUv).rgb;\n  vec3 worldColor = texture2D(dataMapColor, vUv).rgb;\n  gl_FragColor.rgb = worldColor;\n  gl_FragColor.a = 1.0;\n}\n\nvoid main () {\n  vec3 dataColor = texture2D(worldDataMap, vDataUv).rgb;\n  vec3 biome = texture2D(dataMapBiome, vUv).rgb;\n  vec3 worldColor = texture2D(dataMapColor, vUv).rgb;\n  vec3 oWorldColor = worldColor;\n  if (useOverrideColor) {\n    worldColor = overrideColor;\n  }\n\n  vec3 overlay = texture2D(mapOverlay, vTextureUv).rgb;\n  vec3 groundTex = texture2D(mapGround, vTextureUv).rgb;\n  vec3 pathTex = texture2D(mapGroundPath, vTextureUv * 2.0).rgb;\n\n  float wdist = 0.04;\n  float wd = distance(vUv, vec2(0.5, 0.5)) / wdist;\n  float wt = 0.5 + ((groundTex.x*2.0-1.0) * 0.5) + ((pathTex.x*2.0-1.0) * 0.5);\n  float wg = 0.45;\n  wd = smoothstep(wt - wg, wt + wg, wd);\n  float distFromCenter = 1.0 - clamp(wd, 0.0, 1.0);\n  // worldColor = mix(worldColor, vec3(0.45), distFromCenter);\n  worldColor = mix(mix(worldColor, vec3(originColor), tutorial), vec3(originColor), distFromCenter);\n\n  // worldColor = mix(worldColor, vec3(originColor), distFromCenter);\n  \n  // float boxLen = abs(vUv.x - 0.5) + abs(vUv.y - 0.5);\n  float edgeThreshold = 0.5;\n  float edgeGlow = 0.025;\n  // worldColor = vec3(boxLen);\n  // worldColor *= step(boxLen, 0.48);\n\n  float edge0 = smoothstep(edgeThreshold, edgeThreshold-edgeGlow, abs(vUv.x - 0.5));\n  float edge1 = smoothstep(edgeThreshold, edgeThreshold-edgeGlow, abs(vUv.y - 0.5));\n  // worldColor = originColor;\n  // worldColor = mix(originColor, worldColor, distFromCenter);\n\n  // vec3 worldFogColor = texture2D(worldFogMap, vUv).rgb;\n  // worldColor.rgb *= mix(1.0, 0.0, (1.0-distFromCenter) * (1.0-worldFogColor.r));\n\n  float lake = texture2D(dataMapLake, vUv).r;\n\n  float pathEdge = smoothstep(0.4, 0.75, biome.b + (biome.r * 2.0 - 1.0) * 0.1);\n  pathEdge = clamp(pathEdge, 0.0, 1.0);\n  vec3 tex = mix(groundTex, pathTex, pathEdge);\n\n  vec3 col = worldColor;\n\n  // #ifdef USE_MAP_OVERRIDE\n  // vec3 overrideRGB = texture2D(overrideMap, vTextureUv).rgb;\n  // if (useOverrideMap) {\n  //   col *= overrideRGB;\n  // } else {\n    float darken = 0.45; //0.66;\n    col = blendSoftLight(col, col + overlay, overlayOpacity * 0.3 * biome.b * (1.0 - darken * dataColor.r));\n    col = mix(col, col * (1.0 - overlay), 0.075 * (biome.b));\n    //blendSoftLight(col, col + overlay, overlayOpacity * biome.b * (1.0 - darken * dataColor.r));\n    col = blendSoftLight(col, tex, 1.0 - darken * dataColor.r);\n    // col = blendSoftLight(col, col + overlay, overlayOpacity * biome.b * 0.075);\n    // col = blendSoftLight(col, tex, 1.0);\n  // }\n\n  // col = vec3(gl_FragCoord.x / 800.0);\n  // vec2 shadowUv = (vShadowClipPos.xy / vShadowClipPos.z) * 0.5 + 0.5;\n  // col *= 1.0 - 0.25 * texture2D(shadowMap, shadowUv).r;\n  \n  // col = texture2D(mapGround, vShadowUv).rgb;\n  // float pt = 0.4;\n  // float pf = 0.4;\n  // float pathEdge = smoothstep(pt-pf, pt+pf, biome.b  );\n  // col = mix(col * 0.75, col * 1.0, pathEdge);\n  // col = vec3(pathEdge);\n  gl_FragColor = vec4(vec3(col), 1.0);\n  gl_FragColor = clamp(gl_FragColor, 0.0, 1.0);\n  gl_FragColor.rgb = mix(clearColor, gl_FragColor.rgb, edge0 * edge1);\n  // gl_FragColor.rgb = vec3(edge0);\n\n  // gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(1.0), lake);\n}";