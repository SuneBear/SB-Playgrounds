/* components/GameProgress.svelte generated by Svelte v3.31.0 */
import {
	SvelteComponent,
	add_render_callback,
	append,
	attr,
	check_outros,
	create_bidirectional_transition,
	create_component,
	create_in_transition,
	destroy_component,
	detach,
	element,
	group_outros,
	init,
	insert,
	mount_component,
	outro_and_destroy_block,
	safe_not_equal,
	space,
	toggle_class,
	transition_in,
	transition_out,
	update_keyed_each
} from "svelte/internal";

import { fadeTransition } from "../animations/transitions";
import getConfig from "../config";
import Random from "../util/Random";
import Image from "./Image.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	child_ctx[0] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	child_ctx[13] = i;
	return child_ctx;
}

// (89:14) {:else}
function create_else_block(ctx) {
	let div;
	let image;
	let div_intro;
	let current;

	image = new Image({
			props: {
				width: "100%",
				height: "100%",
				id: "image/ui/empty_box"
			}
		});

	return {
		c() {
			div = element("div");
			create_component(image.$$.fragment);
			attr(div, "class", "haiku-card-icon svelte-rdjqne");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(image, div, null);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i(local) {
			if (current) return;
			transition_in(image.$$.fragment, local);

			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fadeTransition, {
						delay: stagger(/*biomeIndex*/ ctx[0] * 4 + 1 + /*i*/ ctx[13])
					});

					div_intro.start();
				});
			}

			current = true;
		},
		o(local) {
			transition_out(image.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(image);
		}
	};
}

// (78:14) {#if card.collected}
function create_if_block(ctx) {
	let div;
	let image;
	let div_intro;
	let current;

	image = new Image({
			props: {
				width: "100%",
				height: "100%",
				id: "image/ui/filled_box"
			}
		});

	return {
		c() {
			div = element("div");
			create_component(image.$$.fragment);
			attr(div, "class", "haiku-card-icon svelte-rdjqne");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(image, div, null);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		i(local) {
			if (current) return;
			transition_in(image.$$.fragment, local);

			if (!div_intro) {
				add_render_callback(() => {
					div_intro = create_in_transition(div, fadeTransition, {
						delay: stagger(/*biomeIndex*/ ctx[0] * 4 + 1 + /*i*/ ctx[13])
					});

					div_intro.start();
				});
			}

			current = true;
		},
		o(local) {
			transition_out(image.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(image);
		}
	};
}

// (70:10) {#each el.cards as card, i (card)}
function create_each_block_1(key_1, ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let t;
	let div_style_value;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*card*/ ctx[11].collected) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		key: key_1,
		first: null,
		c() {
			div = element("div");
			if_block.c();
			t = space();
			attr(div, "class", "haiku-card svelte-rdjqne");
			attr(div, "style", div_style_value = /*card*/ ctx[11].style);
			toggle_class(div, "locked", /*el*/ ctx[9].locked);
			toggle_class(div, "active", /*el*/ ctx[9].active);
			toggle_class(div, "collected", /*card*/ ctx[11].collected);
			this.first = div;
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			append(div, t);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, t);
			}

			if (!current || dirty & /*elements*/ 2 && div_style_value !== (div_style_value = /*card*/ ctx[11].style)) {
				attr(div, "style", div_style_value);
			}

			if (dirty & /*elements*/ 2) {
				toggle_class(div, "locked", /*el*/ ctx[9].locked);
			}

			if (dirty & /*elements*/ 2) {
				toggle_class(div, "active", /*el*/ ctx[9].active);
			}

			if (dirty & /*elements*/ 2) {
				toggle_class(div, "collected", /*card*/ ctx[11].collected);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
		}
	};
}

// (56:2) {#each elements as el, biomeIndex (el)}
function create_each_block(key_1, ctx) {
	let div0;
	let image0;
	let div0_transition;
	let t0;
	let div5;
	let div2;
	let div1;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t1;
	let div4;
	let div3;
	let image1;
	let div3_intro;
	let current;

	image0 = new Image({
			props: {
				width: "100%",
				height: "100%",
				id: "image/ui/vertical-rule"
			}
		});

	let each_value_1 = /*el*/ ctx[9].cards;
	const get_key = ctx => /*card*/ ctx[11];

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
	}

	image1 = new Image({
			props: {
				width: "100%",
				height: "100%",
				id: /*getBiomeId*/ ctx[2](/*el*/ ctx[9].name, /*el*/ ctx[9].finished)
			}
		});

	return {
		key: key_1,
		first: null,
		c() {
			div0 = element("div");
			create_component(image0.$$.fragment);
			t0 = space();
			div5 = element("div");
			div2 = element("div");
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			div4 = element("div");
			div3 = element("div");
			create_component(image1.$$.fragment);
			attr(div0, "class", "vertical-rule svelte-rdjqne");
			attr(div1, "class", "haiku-card-container svelte-rdjqne");
			toggle_class(div1, "locked", /*el*/ ctx[9].locked);
			toggle_class(div1, "acitve", /*el*/ ctx[9].active);
			attr(div2, "class", "top-row svelte-rdjqne");
			attr(div3, "class", "biome-icon svelte-rdjqne");
			toggle_class(div3, "locked", /*el*/ ctx[9].locked);
			attr(div4, "class", "biome-icon-container svelte-rdjqne");
			attr(div5, "class", "biome-container svelte-rdjqne");
			this.first = div0;
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			mount_component(image0, div0, null);
			insert(target, t0, anchor);
			insert(target, div5, anchor);
			append(div5, div2);
			append(div2, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append(div5, t1);
			append(div5, div4);
			append(div4, div3);
			mount_component(image1, div3, null);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*elements*/ 2) {
				const each_value_1 = /*el*/ ctx[9].cards;
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div1, outro_and_destroy_block, create_each_block_1, null, get_each_context_1);
				check_outros();
			}

			if (dirty & /*elements*/ 2) {
				toggle_class(div1, "locked", /*el*/ ctx[9].locked);
			}

			if (dirty & /*elements*/ 2) {
				toggle_class(div1, "acitve", /*el*/ ctx[9].active);
			}

			const image1_changes = {};
			if (dirty & /*elements*/ 2) image1_changes.id = /*getBiomeId*/ ctx[2](/*el*/ ctx[9].name, /*el*/ ctx[9].finished);
			image1.$set(image1_changes);

			if (dirty & /*elements*/ 2) {
				toggle_class(div3, "locked", /*el*/ ctx[9].locked);
			}
		},
		i(local) {
			if (current) return;
			transition_in(image0.$$.fragment, local);

			add_render_callback(() => {
				if (!div0_transition) div0_transition = create_bidirectional_transition(
					div0,
					fadeTransition,
					{
						delay: stagger(/*biomeIndex*/ ctx[0] * 4)
					},
					true
				);

				div0_transition.run(1);
			});

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(image1.$$.fragment, local);

			if (!div3_intro) {
				add_render_callback(() => {
					div3_intro = create_in_transition(div3, fadeTransition, {
						delay: stagger(/*biomeIndex*/ ctx[0] * 4 + 1)
					});

					div3_intro.start();
				});
			}

			current = true;
		},
		o(local) {
			transition_out(image0.$$.fragment, local);

			if (!div0_transition) div0_transition = create_bidirectional_transition(
				div0,
				fadeTransition,
				{
					delay: stagger(/*biomeIndex*/ ctx[0] * 4)
				},
				false
			);

			div0_transition.run(0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(image1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			destroy_component(image0);
			if (detaching && div0_transition) div0_transition.end();
			if (detaching) detach(t0);
			if (detaching) detach(div5);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			destroy_component(image1);
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t;
	let div0;
	let image;
	let div0_intro;
	let current;
	let each_value = /*elements*/ ctx[1];
	const get_key = ctx => /*el*/ ctx[9];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	image = new Image({
			props: {
				width: "100%",
				height: "100%",
				id: "image/ui/vertical-rule"
			}
		});

	return {
		c() {
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			div0 = element("div");
			create_component(image.$$.fragment);
			attr(div0, "class", "vertical-rule svelte-rdjqne");
			attr(div1, "class", "progress-container svelte-rdjqne");
		},
		m(target, anchor) {
			insert(target, div1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append(div1, t);
			append(div1, div0);
			mount_component(image, div0, null);
			current = true;
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (dirty & /*elements, getBiomeId, stagger*/ 6) {
				const each_value = /*elements*/ ctx[1];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block, t, get_each_context);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(image.$$.fragment, local);

			if (!div0_intro) {
				add_render_callback(() => {
					div0_intro = create_in_transition(div0, fadeTransition, { delay: stagger(3 * 4) });
					div0_intro.start();
				});
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(image.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			destroy_component(image);
		}
	};
}

function stagger(i) {
	return 50 + i * 100;
}

function instance($$self, $$props, $$invalidate) {
	const random = Random();
	let { biome = "forest" } = $$props;
	let { biomeIndex = 0 } = $$props;
	let { haikusCollected = 0 } = $$props;
	const haikusPerBiome = getConfig().haikusPerBiome;
	const biomes = ["forest", "grasslands", "tundra"];

	const biomeIcons = {
		forest: "biomeforest",
		grasslands: "biomegrass",
		tundra: "biometundra"
	};

	let elements;

	function getBiomeId(name, finished) {
		return `image/ui/${biomeIcons[name]}${finished ? "-alt" : ""}`;
	}

	$$self.$$set = $$props => {
		if ("biome" in $$props) $$invalidate(3, biome = $$props.biome);
		if ("biomeIndex" in $$props) $$invalidate(0, biomeIndex = $$props.biomeIndex);
		if ("haikusCollected" in $$props) $$invalidate(4, haikusCollected = $$props.haikusCollected);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*biomeIndex, haikusCollected*/ 17) {
			$: $$invalidate(1, elements = biomes.map((name, index) => {
				let collected;
				if (index < biomeIndex) collected = haikusPerBiome; else if (index > biomeIndex) collected = 0; else collected = haikusCollected;

				return {
					name,
					finished: biomeIndex > index,
					active: biomeIndex === index,
					locked: index > biomeIndex,
					cards: new Array(haikusPerBiome).fill(null).map((_, i) => {
						const offset = random.range(-0.75, 0.75);
						const rotation = random.range(-4, 1.5);

						return {
							style: `transform: translate(0px, ${offset}px) rotateZ(${rotation}deg);`,
							collected: i < collected,
							mostRecent: false
						};
					}),
					index
				};
			}));
		}
	};

	return [biomeIndex, elements, getBiomeId, biome, haikusCollected];
}

class GameProgress extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			biome: 3,
			biomeIndex: 0,
			haikusCollected: 4
		});
	}
}

export default GameProgress;