/* components/TokenInventorySlot.svelte generated by Svelte v3.31.0 */
import {
	SvelteComponent,
	add_render_callback,
	append,
	attr,
	check_outros,
	create_bidirectional_transition,
	create_component,
	destroy_component,
	detach,
	element,
	group_outros,
	init,
	insert,
	mount_component,
	noop,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} from "svelte/internal";

import { CollectedTokenURLs } from "../util/tokens";
import { cubicInOut } from "svelte/easing";
import Image from "./Image.svelte";
import Assets from "../util/Assets";

function create_if_block_1(ctx) {
	let div;
	let image;
	let div_transition;
	let current;
	image = new Image({ props: { id: emptyToken } });

	return {
		c() {
			div = element("div");
			create_component(image.$$.fragment);
			attr(div, "class", "img-container svelte-1xnqt9x");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(image, div, null);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(image.$$.fragment, local);

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, /*transition*/ ctx[2], {}, true);
				div_transition.run(1);
			});

			current = true;
		},
		o(local) {
			transition_out(image.$$.fragment, local);
			if (!div_transition) div_transition = create_bidirectional_transition(div, /*transition*/ ctx[2], {}, false);
			div_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(image);
			if (detaching && div_transition) div_transition.end();
		}
	};
}

// (66:4) {#if collected}
function create_if_block(ctx) {
	let div;
	let img;
	let img_src_value;
	let div_transition;
	let current;

	return {
		c() {
			div = element("div");
			img = element("img");
			if (img.src !== (img_src_value = /*src*/ ctx[0])) attr(img, "src", img_src_value);
			attr(img, "alt", "");
			attr(img, "class", "svelte-1xnqt9x");
			attr(div, "class", "img-container svelte-1xnqt9x");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, img);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*src*/ 1 && img.src !== (img_src_value = /*src*/ ctx[0])) {
				attr(img, "src", img_src_value);
			}
		},
		i(local) {
			if (current) return;

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, /*transition*/ ctx[2], {}, true);
				div_transition.run(1);
			});

			current = true;
		},
		o(local) {
			if (!div_transition) div_transition = create_bidirectional_transition(div, /*transition*/ ctx[2], {}, false);
			div_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (detaching && div_transition) div_transition.end();
		}
	};
}

function create_fragment(ctx) {
	let div2;
	let div0;
	let t;
	let div1;
	let current;
	let if_block0 = !/*collected*/ ctx[1] && create_if_block_1(ctx);
	let if_block1 = /*collected*/ ctx[1] && create_if_block(ctx);

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			if (if_block0) if_block0.c();
			t = space();
			div1 = element("div");
			if (if_block1) if_block1.c();
			attr(div0, "class", "outline svelte-1xnqt9x");
			attr(div1, "class", "content svelte-1xnqt9x");
			attr(div2, "class", "container svelte-1xnqt9x");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			if (if_block0) if_block0.m(div0, null);
			append(div2, t);
			append(div2, div1);
			if (if_block1) if_block1.m(div1, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (!/*collected*/ ctx[1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*collected*/ 2) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div0, null);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*collected*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*collected*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

const emptyToken = "image/ui/ico_emptytoken";

function fadeScale(node, { delay = 0, duration = 200, easing = x => x, baseScale = 0 }) {
	const o = +getComputedStyle(node).opacity;
	const m = getComputedStyle(node).transform.match(/scale\(([0-9.]+)\)/);
	const s = m ? m[1] : 1;
	const is = 1 - baseScale;

	return {
		delay,
		duration,
		css: t => {
			const eased = easing(t);
			return `opacity: ${eased * o}; transform: scale(${eased * s * is + baseScale})`;
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	Assets.prepare(emptyToken);
	let { src = null } = $$props;
	let { collected = false } = $$props;
	let outlineIcon, tokenIcon;

	function setToken(icon) {
		$$invalidate(0, src = icon ? CollectedTokenURLs[icon] : null);
		$$invalidate(1, collected = Boolean(icon && src));
	}

	const transition = (node, opts) => {
		return fadeScale(node, {
			delay: 0,
			duration: 1000,
			easing: cubicInOut,
			baseScale: 0.5,
			...opts
		});
	};

	$$self.$$set = $$props => {
		if ("src" in $$props) $$invalidate(0, src = $$props.src);
		if ("collected" in $$props) $$invalidate(1, collected = $$props.collected);
	};

	return [src, collected, transition, setToken];
}

class TokenInventorySlot extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { src: 0, collected: 1, setToken: 3 });
	}

	get setToken() {
		return this.$$.ctx[3];
	}
}

export default TokenInventorySlot;