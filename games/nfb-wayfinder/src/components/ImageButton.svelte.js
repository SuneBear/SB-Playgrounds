/* components/ImageButton.svelte generated by Svelte v3.31.0 */
import {
	SvelteComponent,
	add_render_callback,
	append,
	attr,
	bubble,
	create_in_transition,
	create_out_transition,
	detach,
	element,
	init,
	insert,
	listen,
	run_all,
	safe_not_equal,
	set_data,
	space,
	text as text_1,
	toggle_class
} from "svelte/internal";

import AlertButtonHover from "../assets/image/ui/btn_restart.png";

// import AlertButtonIdle from "../assets/image/ui/btn_restart_top.png";
import DarkButtonIdle from "../assets/image/ui/btn_about.png";

import DarkButtonLongIdle from "../assets/image/ui/btn_about_long.png";

// import NormalButtonIdle from "../assets/image/ui/btn_start_top.png";
import NormalButtonHover from "../assets/image/ui/btn_start.png";

import { createEventDispatcher } from "svelte";
import { emptyTransition } from "../animations/transitions";

function create_if_block_1(ctx) {
	let img;
	let img_src_value;

	return {
		c() {
			img = element("img");
			attr(img, "class", "icon svelte-1j4vnox");
			if (img.src !== (img_src_value = /*icon*/ ctx[0])) attr(img, "src", img_src_value);
			attr(img, "alt", "");
		},
		m(target, anchor) {
			insert(target, img, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 1 && img.src !== (img_src_value = /*icon*/ ctx[0])) {
				attr(img, "src", img_src_value);
			}
		},
		d(detaching) {
			if (detaching) detach(img);
		}
	};
}

// (106:4) {#if text}
function create_if_block(ctx) {
	let div;
	let t;

	return {
		c() {
			div = element("div");
			t = text_1(/*text*/ ctx[2]);
			attr(div, "class", "text svelte-1j4vnox");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*text*/ 4) set_data(t, /*text*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

function create_fragment(ctx) {
	let div2;
	let div0;
	let img;
	let img_src_value;
	let img_alt_value;
	let t0;
	let div1;
	let t1;
	let div2_intro;
	let div2_outro;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*icon*/ ctx[0] && create_if_block_1(ctx);
	let if_block1 = /*text*/ ctx[2] && create_if_block(ctx);

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			img = element("img");
			t0 = space();
			div1 = element("div");
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			if (img.src !== (img_src_value = /*image*/ ctx[7])) attr(img, "src", img_src_value);
			attr(img, "alt", img_alt_value = /*alt*/ ctx[3] || /*text*/ ctx[2]);
			attr(img, "class", "svelte-1j4vnox");
			attr(div0, "class", "image-container svelte-1j4vnox");
			attr(div1, "class", "content-container svelte-1j4vnox");
			toggle_class(div1, "offset", /*offset*/ ctx[8]);
			attr(div2, "class", "container svelte-1j4vnox");
			toggle_class(div2, "invert", /*mode*/ ctx[1] === "dark" || /*mode*/ ctx[1] === "dark_long");
			toggle_class(div2, "smaller", /*smaller*/ ctx[9]);
			toggle_class(div2, "longer", /*longer*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			append(div0, img);
			append(div2, t0);
			append(div2, div1);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div2, "introend", /*introend_handler*/ ctx[12]),
					listen(div2, "introstart", /*introstart_handler*/ ctx[13]),
					listen(div2, "outroend", /*outroend_handler*/ ctx[14]),
					listen(div2, "outrostart", /*outrostart_handler*/ ctx[15]),
					listen(div2, "click", /*click_handler*/ ctx[16]),
					listen(div2, "mouseenter", /*mouseenter_handler*/ ctx[17]),
					listen(div2, "mouseleave", /*mouseleave_handler*/ ctx[18])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*image*/ 128 && img.src !== (img_src_value = /*image*/ ctx[7])) {
				attr(img, "src", img_src_value);
			}

			if (!current || dirty & /*alt, text*/ 12 && img_alt_value !== (img_alt_value = /*alt*/ ctx[3] || /*text*/ ctx[2])) {
				attr(img, "alt", img_alt_value);
			}

			if (/*icon*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*text*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*offset*/ 256) {
				toggle_class(div1, "offset", /*offset*/ ctx[8]);
			}

			if (dirty & /*mode*/ 2) {
				toggle_class(div2, "invert", /*mode*/ ctx[1] === "dark" || /*mode*/ ctx[1] === "dark_long");
			}

			if (dirty & /*smaller*/ 512) {
				toggle_class(div2, "smaller", /*smaller*/ ctx[9]);
			}

			if (dirty & /*longer*/ 1024) {
				toggle_class(div2, "longer", /*longer*/ ctx[10]);
			}
		},
		i(local) {
			if (current) return;

			add_render_callback(() => {
				if (div2_outro) div2_outro.end(1);
				if (!div2_intro) div2_intro = create_in_transition(div2, /*inTransition*/ ctx[4], {});
				div2_intro.start();
			});

			current = true;
		},
		o(local) {
			if (div2_intro) div2_intro.invalidate();
			div2_outro = create_out_transition(div2, /*outTransition*/ ctx[5], {});
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (detaching && div2_outro) div2_outro.end();
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	const dispatcher = createEventDispatcher();

	// We have a few different types of idle/hover images, depending on mode
	const modes = {
		normal: {
			idle: NormalButtonHover,
			hover: NormalButtonHover,
			offset: true
		},
		normal_small: {
			idle: NormalButtonHover,
			hover: NormalButtonHover,
			offset: true,
			smaller: true
		},
		alert: {
			idle: AlertButtonHover,
			hover: AlertButtonHover,
			offset: true
		},
		dark: {
			idle: DarkButtonIdle,
			hover: DarkButtonIdle,
			smaller: true
		},
		dark_long: {
			idle: DarkButtonLongIdle,
			hover: DarkButtonLongIdle,
			smaller: true,
			longer: true
		}
	};

	let { icon = "" } = $$props;
	let { mode = "normal" } = $$props;
	let { text = "" } = $$props;
	let { alt = "" } = $$props;
	let { inTransition = emptyTransition } = $$props;
	let { outTransition = emptyTransition } = $$props;

	// local props
	let state;

	let image;
	let offset = false;
	let hover = false;
	let smaller = false;
	let longer = false;

	function introend_handler(event) {
		bubble($$self, event);
	}

	function introstart_handler(event) {
		bubble($$self, event);
	}

	function outroend_handler(event) {
		bubble($$self, event);
	}

	function outrostart_handler(event) {
		bubble($$self, event);
	}

	function click_handler(event) {
		bubble($$self, event);
	}

	const mouseenter_handler = () => {
		$$invalidate(6, hover = true);
	}; // dispatcher("triggerHoverSound");

	const mouseleave_handler = () => {
		$$invalidate(6, hover = false);
	}; // dispatcher("unmountTriggerHoverSound");

	$$self.$$set = $$props => {
		if ("icon" in $$props) $$invalidate(0, icon = $$props.icon);
		if ("mode" in $$props) $$invalidate(1, mode = $$props.mode);
		if ("text" in $$props) $$invalidate(2, text = $$props.text);
		if ("alt" in $$props) $$invalidate(3, alt = $$props.alt);
		if ("inTransition" in $$props) $$invalidate(4, inTransition = $$props.inTransition);
		if ("outTransition" in $$props) $$invalidate(5, outTransition = $$props.outTransition);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*mode, state, hover*/ 2114) {
			// svelte reactive statement
			$: {
				// when mode changes, get a new state
				$$invalidate(11, state = modes[mode]);

				// whether to offset text a bit due to button shadow
				$$invalidate(8, offset = Boolean(state.offset));

				// whether to make button a bit smaller
				$$invalidate(9, smaller = Boolean(state.smaller));

				// Bit longer?
				$$invalidate(10, longer = Boolean(state.longer));

				// when hover changes, update image
				$$invalidate(7, image = hover ? state.hover : state.idle);
			}
		}
	};

	return [
		icon,
		mode,
		text,
		alt,
		inTransition,
		outTransition,
		hover,
		image,
		offset,
		smaller,
		longer,
		state,
		introend_handler,
		introstart_handler,
		outroend_handler,
		outrostart_handler,
		click_handler,
		mouseenter_handler,
		mouseleave_handler
	];
}

class ImageButton extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			icon: 0,
			mode: 1,
			text: 2,
			alt: 3,
			inTransition: 4,
			outTransition: 5
		});
	}
}

export default ImageButton;