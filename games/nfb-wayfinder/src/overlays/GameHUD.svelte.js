/* overlays/GameHUD.svelte generated by Svelte v3.31.0 */
import {
	SvelteComponent,
	binding_callbacks,
	bubble,
	check_outros,
	create_component,
	destroy_component,
	detach,
	empty,
	group_outros,
	init,
	insert,
	mount_component,
	noop,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} from "svelte/internal";

import HaikuInventory from "../components/HaikuInventory.svelte";
import TokenInventory from "../components/TokenInventory.svelte";
import { onDestroy, onMount } from "svelte";
import { createEventDispatcher } from "svelte";
import CornerMenuButton from "../components/CornerMenuButton.svelte";
import Assets from "../util/Assets";
import { context } from "../alec-svelte";
import * as Tags from "../tags";
import { sendAnalytics } from "../nfb";

function create_if_block_3(ctx) {
	let cornermenubutton;
	let current;

	cornermenubutton = new CornerMenuButton({
			props: {
				style: "top: 8px; left: 6px",
				image: /*pausePromise*/ ctx[5]
			}
		});

	cornermenubutton.$on("click", /*click_handler*/ ctx[14]);

	return {
		c() {
			create_component(cornermenubutton.$$.fragment);
		},
		m(target, anchor) {
			mount_component(cornermenubutton, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(cornermenubutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(cornermenubutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(cornermenubutton, detaching);
		}
	};
}

// (93:0) {#if canCollectTokens}
function create_if_block_2(ctx) {
	let tokeninventory;
	let t;
	let cornermenubutton;
	let current;
	tokeninventory = new TokenInventory({ props: { store: /*store*/ ctx[0] } });

	cornermenubutton = new CornerMenuButton({
			props: {
				size: "large",
				style: "top: 7px; right: 7px",
				image: /*compassPromise*/ ctx[7]
			}
		});

	cornermenubutton.$on("click", /*click_handler_1*/ ctx[15]);

	return {
		c() {
			create_component(tokeninventory.$$.fragment);
			t = space();
			create_component(cornermenubutton.$$.fragment);
		},
		m(target, anchor) {
			mount_component(tokeninventory, target, anchor);
			insert(target, t, anchor);
			mount_component(cornermenubutton, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const tokeninventory_changes = {};
			if (dirty & /*store*/ 1) tokeninventory_changes.store = /*store*/ ctx[0];
			tokeninventory.$set(tokeninventory_changes);
		},
		i(local) {
			if (current) return;
			transition_in(tokeninventory.$$.fragment, local);
			transition_in(cornermenubutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(tokeninventory.$$.fragment, local);
			transition_out(cornermenubutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(tokeninventory, detaching);
			if (detaching) detach(t);
			destroy_component(cornermenubutton, detaching);
		}
	};
}

// (105:0) {#if currentHaikuCount > 0 && !currentHaiku}
function create_if_block(ctx) {
	let t;
	let cornermenubutton;
	let current;
	let if_block = /*canCollectTokens*/ ctx[1] && create_if_block_1(ctx);

	let cornermenubutton_props = {
		image: /*journalPromise*/ ctx[6],
		style: "bottom: 12px; right: 10px",
		id: JOURNAL_ID
	};

	cornermenubutton = new CornerMenuButton({ props: cornermenubutton_props });
	/*cornermenubutton_binding*/ ctx[17](cornermenubutton);
	cornermenubutton.$on("click", /*click_handler_2*/ ctx[18]);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			create_component(cornermenubutton.$$.fragment);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			mount_component(cornermenubutton, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*canCollectTokens*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*canCollectTokens*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			const cornermenubutton_changes = {};
			cornermenubutton.$set(cornermenubutton_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(cornermenubutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(cornermenubutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			/*cornermenubutton_binding*/ ctx[17](null);
			destroy_component(cornermenubutton, detaching);
		}
	};
}

// (106:2) {#if canCollectTokens}
function create_if_block_1(ctx) {
	let haikuinventory;
	let current;
	haikuinventory = new HaikuInventory({ props: { store: /*store*/ ctx[0] } });
	haikuinventory.$on("journal", /*journal_handler*/ ctx[16]);

	return {
		c() {
			create_component(haikuinventory.$$.fragment);
		},
		m(target, anchor) {
			mount_component(haikuinventory, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const haikuinventory_changes = {};
			if (dirty & /*store*/ 1) haikuinventory_changes.store = /*store*/ ctx[0];
			haikuinventory.$set(haikuinventory_changes);
		},
		i(local) {
			if (current) return;
			transition_in(haikuinventory.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(haikuinventory.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(haikuinventory, detaching);
		}
	};
}

function create_fragment(ctx) {
	let t0;
	let t1;
	let if_block2_anchor;
	let current;
	let if_block0 = !/*currentHaiku*/ ctx[2] && create_if_block_3(ctx);
	let if_block1 = /*canCollectTokens*/ ctx[1] && create_if_block_2(ctx);
	let if_block2 = /*currentHaikuCount*/ ctx[3] > 0 && !/*currentHaiku*/ ctx[2] && create_if_block(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, t1, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert(target, if_block2_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (!/*currentHaiku*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*currentHaiku*/ 4) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*canCollectTokens*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*canCollectTokens*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t1.parentNode, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*currentHaikuCount*/ ctx[3] > 0 && !/*currentHaiku*/ ctx[2]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*currentHaikuCount, currentHaiku*/ 12) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(t1);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach(if_block2_anchor);
		}
	};
}

const PAUSE_ID = "image/ui/btn_pause";
const JOURNAL_ID = "image/ui/ico_journal";
const COMPASS_ID = "image/ui/compass3";

function instance($$self, $$props, $$invalidate) {
	Assets.prepare([PAUSE_ID, JOURNAL_ID, COMPASS_ID]);
	const pausePromise = Assets.load(PAUSE_ID);
	const journalPromise = Assets.load(JOURNAL_ID);
	const compassPromise = Assets.load(COMPASS_ID);
	const dispatch = createEventDispatcher();
	const { world } = context();
	const entity = world.entity();
	let { store } = $$props;
	let { moving = false } = $$props;
	let { canCollectTokens = false } = $$props;
	let { finishedHaikus = [] } = $$props;
	let { currentHaiku = false } = $$props;
	let currentHaikuCount = 0;
	let journalButton;

	const onNotifyHaiku = () => {
		if (journalButton) journalButton.notify();
	};

	store.update(d => ({ ...d, onNotifyHaiku }));

	onMount(() => {
		const unsub = store.subscribe(v => {
			$$invalidate(3, currentHaikuCount = v.finishedHaikus.length);
		});

		return () => {
			unsub();
		};
	});

	function handleCompass(ev) {
		ev.preventDefault();
		ev.stopPropagation();
		ev.stopImmediatePropagation();
		const pos = world.findTag(Tags.UserTarget).position;
		entity.tagOn(Tags.CompassVisible);

		// entity.tagOn(Tags.CameraZoomOut);
		const vis = entity.get(Tags.CompassVisible);

		vis.position.copy(pos);

		sendAnalytics({
			event: "compass_open",
			eventLabel: "compass_open"
		});
	}

	const click_handler = ev => {
		if (world.findTag(Tags.ShowBiomeResolution) || world.findTag(Tags.TransitionToNextBiome)) {
			return;
		}

		ev.preventDefault();
		ev.stopImmediatePropagation();
		entity.tagOff(Tags.ButtonClick);
		entity.tagOn(Tags.ButtonClick);
		dispatch("pause");

		sendAnalytics({
			event: "menu_open",
			eventLabel: "menu_open"
		});
	};

	const click_handler_1 = ev => {
		handleCompass(ev);
	};

	function journal_handler(event) {
		bubble($$self, event);
	}

	function cornermenubutton_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			journalButton = $$value;
			$$invalidate(4, journalButton);
		});
	}

	const click_handler_2 = ev => {
		if (world.findTag(Tags.ShowBiomeResolution) || world.findTag(Tags.TransitionToNextBiome)) {
			return;
		}

		dispatch("journal");

		sendAnalytics({
			event: "journal_open",
			eventLabel: "journal_open"
		});
	};

	$$self.$$set = $$props => {
		if ("store" in $$props) $$invalidate(0, store = $$props.store);
		if ("moving" in $$props) $$invalidate(12, moving = $$props.moving);
		if ("canCollectTokens" in $$props) $$invalidate(1, canCollectTokens = $$props.canCollectTokens);
		if ("finishedHaikus" in $$props) $$invalidate(13, finishedHaikus = $$props.finishedHaikus);
		if ("currentHaiku" in $$props) $$invalidate(2, currentHaiku = $$props.currentHaiku);
	};

	return [
		store,
		canCollectTokens,
		currentHaiku,
		currentHaikuCount,
		journalButton,
		pausePromise,
		journalPromise,
		compassPromise,
		dispatch,
		world,
		entity,
		handleCompass,
		moving,
		finishedHaikus,
		click_handler,
		click_handler_1,
		journal_handler,
		cornermenubutton_binding,
		click_handler_2
	];
}

class GameHUD extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			store: 0,
			moving: 12,
			canCollectTokens: 1,
			finishedHaikus: 13,
			currentHaiku: 2
		});
	}
}

export default GameHUD;