/* overlays/HaikuPopup.svelte generated by Svelte v3.31.0 */
import {
	SvelteComponent,
	add_render_callback,
	append,
	assign,
	attr,
	component_subscribe,
	create_component,
	create_in_transition,
	create_out_transition,
	destroy_component,
	detach,
	element,
	get_spread_object,
	get_spread_update,
	init,
	insert,
	mount_component,
	safe_not_equal,
	space,
	toggle_class,
	transition_in,
	transition_out
} from "svelte/internal";

import { InvertedTokenURLs } from "../util/tokens";
import ImageButton from "../components/ImageButton.svelte";
import AbsoluteOverlay from "../components/AbsoluteOverlay.svelte";
import HaikuInventory from "../components/HaikuInventory.svelte";
import * as Tags from "../tags";
import paperJournalOne from "../assets/image/ui/ico_paperJournal1-rotated.png";
import GameProgress from "../components/GameProgress.svelte";
import { language, localize } from "../util/locale";
import { createEventDispatcher, onMount } from "svelte";

import {
	fadeInTransition,
	fadeOpacityTransition,
	fadeTransition
} from "../animations/transitions";

import { context } from "../alec-svelte";
import HaikuCard from "../components/HaikuCard.svelte";
import getConfig from "../config";

function create_fragment(ctx) {
	let div2;
	let div0;
	let gameprogress;
	let t0;
	let haikucard;
	let t1;
	let div1;
	let imagebutton;
	let div1_intro;
	let div1_outro;
	let div2_intro;
	let div2_outro;
	let current;
	const gameprogress_spread_levels = [/*getProgressData*/ ctx[5]()];
	let gameprogress_props = {};

	for (let i = 0; i < gameprogress_spread_levels.length; i += 1) {
		gameprogress_props = assign(gameprogress_props, gameprogress_spread_levels[i]);
	}

	gameprogress = new GameProgress({ props: gameprogress_props });

	haikucard = new HaikuCard({
			props: {
				animatePoem: true,
				lines: /*lines*/ ctx[0],
				tokens: /*tokens*/ ctx[1]
			}
		});

	imagebutton = new ImageButton({
			props: {
				text: /*$localize*/ ctx[3].continueButton,
				mode: "normal_small"
			}
		});

	imagebutton.$on("click", /*closePopup*/ ctx[4]);

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			create_component(gameprogress.$$.fragment);
			t0 = space();
			create_component(haikucard.$$.fragment);
			t1 = space();
			div1 = element("div");
			create_component(imagebutton.$$.fragment);
			attr(div0, "class", "progress-wrapper svelte-1wd0urs");
			attr(div1, "class", "save-memory-container svelte-1wd0urs");
			attr(div2, "class", "page-container svelte-1wd0urs");
			toggle_class(div2, "ignorePointer", /*ignorePointer*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			mount_component(gameprogress, div0, null);
			append(div2, t0);
			mount_component(haikucard, div2, null);
			append(div2, t1);
			append(div2, div1);
			mount_component(imagebutton, div1, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const gameprogress_changes = (dirty & /*getProgressData*/ 32)
			? get_spread_update(gameprogress_spread_levels, [get_spread_object(/*getProgressData*/ ctx[5]())])
			: {};

			gameprogress.$set(gameprogress_changes);
			const haikucard_changes = {};
			if (dirty & /*lines*/ 1) haikucard_changes.lines = /*lines*/ ctx[0];
			if (dirty & /*tokens*/ 2) haikucard_changes.tokens = /*tokens*/ ctx[1];
			haikucard.$set(haikucard_changes);
			const imagebutton_changes = {};
			if (dirty & /*$localize*/ 8) imagebutton_changes.text = /*$localize*/ ctx[3].continueButton;
			imagebutton.$set(imagebutton_changes);

			if (dirty & /*ignorePointer*/ 4) {
				toggle_class(div2, "ignorePointer", /*ignorePointer*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(gameprogress.$$.fragment, local);
			transition_in(haikucard.$$.fragment, local);
			transition_in(imagebutton.$$.fragment, local);

			add_render_callback(() => {
				if (div1_outro) div1_outro.end(1);
				if (!div1_intro) div1_intro = create_in_transition(div1, fadeTransition, { delay: 500 + 250, duration: 500 });
				div1_intro.start();
			});

			add_render_callback(() => {
				if (div2_outro) div2_outro.end(1);
				if (!div2_intro) div2_intro = create_in_transition(div2, fadeOpacityTransition, { delay: 0, duration: 500 });
				div2_intro.start();
			});

			current = true;
		},
		o(local) {
			transition_out(gameprogress.$$.fragment, local);
			transition_out(haikucard.$$.fragment, local);
			transition_out(imagebutton.$$.fragment, local);
			if (div1_intro) div1_intro.invalidate();
			div1_outro = create_out_transition(div1, fadeTransition, { duration: 250 });
			if (div2_intro) div2_intro.invalidate();
			div2_outro = create_out_transition(div2, fadeOpacityTransition, { delay: 50, duration: 500 });
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div2);
			destroy_component(gameprogress);
			destroy_component(haikucard);
			destroy_component(imagebutton);
			if (detaching && div1_outro) div1_outro.end();
			if (detaching && div2_outro) div2_outro.end();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $localize;
	component_subscribe($$self, localize, $$value => $$invalidate(3, $localize = $$value));
	const dispatcher = createEventDispatcher();
	const { world } = context();
	const haikusPerBiome = getConfig().haikusPerBiome;
	let { lines } = $$props;
	let { tokens } = $$props;
	let { store } = $$props;
	let ignorePointer = false;
	let curLang = language.get();
	let storeData;

	const unsubscribe = store.subscribe(v => {
		storeData = v;
	});

	const biomes = ["forest", "grasslands", "tundra"];

	function closePopup() {
		$$invalidate(2, ignorePointer = true);
		dispatcher("close");
	}

	function getProgressData() {
		const q = world.query(Tags.HaikuInInventory);
		const active = world.findEntity(Tags.ActiveEnvironmentState);

		const name = active
		? active.get(Tags.EnvironmentState).name
		: "forest";

		const biomeIndex = biomes.includes(name) ? biomes.indexOf(name) : 0;

		return {
			biome: name,
			biomeIndex,
			haikusCollected: Math.min(haikusPerBiome, Math.max(0, q.entities.length))
		}; // haikusPerBiome: haikusPerBiome,
	}

	onMount(() => {
		store.update(d => ({ ...d, playing: false }));
		$$invalidate(2, ignorePointer = false);

		const detachLang = language.subscribe(s => {
			curLang = s;
		});

		return () => {
			unsubscribe();
			detachLang();
		};
	});

	$$self.$$set = $$props => {
		if ("lines" in $$props) $$invalidate(0, lines = $$props.lines);
		if ("tokens" in $$props) $$invalidate(1, tokens = $$props.tokens);
		if ("store" in $$props) $$invalidate(6, store = $$props.store);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*lines, tokens*/ 3) {
			$: (lines, tokens, $$invalidate(2, ignorePointer = false));
		}
	};

	return [lines, tokens, ignorePointer, $localize, closePopup, getProgressData, store];
}

class HaikuPopup extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { lines: 0, tokens: 1, store: 6 });
	}
}

export default HaikuPopup;