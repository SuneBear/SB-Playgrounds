// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/array-flat-polyfill/index.mjs":[function(require,module,exports) {
Array.prototype.flat || Object.defineProperty(Array.prototype, "flat", {
  configurable: !0,
  value: function r() {
    var t = isNaN(arguments[0]) ? 1 : Number(arguments[0]);
    return t ? Array.prototype.reduce.call(this, function (a, e) {
      return Array.isArray(e) ? a.push.apply(a, r.call(e, t - 1)) : a.push(e), a;
    }, []) : Array.prototype.slice.call(this);
  },
  writable: !0
}), Array.prototype.flatMap || Object.defineProperty(Array.prototype, "flatMap", {
  configurable: !0,
  value: function (r) {
    return Array.prototype.map.apply(this, arguments).flat();
  },
  writable: !0
});
},{}],"src/vendor/three.module.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AmbientLight = AmbientLight;
exports.AmbientLightProbe = AmbientLightProbe;
exports.AnimationClip = AnimationClip;
exports.AnimationLoader = AnimationLoader;
exports.AnimationMixer = AnimationMixer;
exports.AnimationObjectGroup = AnimationObjectGroup;
exports.ArcCurve = ArcCurve;
exports.ArrayCamera = ArrayCamera;
exports.ArrowHelper = ArrowHelper;
exports.Audio = Audio;
exports.AudioAnalyser = AudioAnalyser;
exports.AudioListener = AudioListener;
exports.AudioLoader = AudioLoader;
exports.AxesHelper = AxesHelper;
exports.AxisHelper = AxisHelper;
exports.BinaryTextureLoader = BinaryTextureLoader;
exports.Bone = Bone;
exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
exports.BoundingBoxHelper = BoundingBoxHelper;
exports.Box2 = Box2;
exports.Box3 = Box3;
exports.Box3Helper = Box3Helper;
exports.BoxHelper = BoxHelper;
exports.BufferAttribute = BufferAttribute;
exports.BufferGeometry = BufferGeometry;
exports.BufferGeometryLoader = BufferGeometryLoader;
exports.Camera = Camera;
exports.CameraHelper = CameraHelper;
exports.CanvasRenderer = CanvasRenderer;
exports.CanvasTexture = CanvasTexture;
exports.CatmullRomCurve3 = CatmullRomCurve3;
exports.CircleBufferGeometry = CircleBufferGeometry;
exports.CircleGeometry = CircleGeometry;
exports.Clock = Clock;
exports.ClosedSplineCurve3 = ClosedSplineCurve3;
exports.Color = Color;
exports.ColorKeyframeTrack = ColorKeyframeTrack;
exports.CompressedTexture = CompressedTexture;
exports.CompressedTextureLoader = CompressedTextureLoader;
exports.ConeBufferGeometry = ConeBufferGeometry;
exports.ConeGeometry = ConeGeometry;
exports.CubeCamera = CubeCamera;
exports.CubeTexture = CubeTexture;
exports.CubeTextureLoader = CubeTextureLoader;
exports.CubicBezierCurve = CubicBezierCurve;
exports.CubicBezierCurve3 = CubicBezierCurve3;
exports.CubicInterpolant = CubicInterpolant;
exports.Curve = Curve;
exports.CurvePath = CurvePath;
exports.CylinderBufferGeometry = CylinderBufferGeometry;
exports.CylinderGeometry = CylinderGeometry;
exports.Cylindrical = Cylindrical;
exports.DataTexture = DataTexture;
exports.DataTexture2DArray = DataTexture2DArray;
exports.DataTexture3D = DataTexture3D;
exports.DataTextureLoader = DataTextureLoader;
exports.DepthTexture = DepthTexture;
exports.DirectionalLight = DirectionalLight;
exports.DirectionalLightHelper = DirectionalLightHelper;
exports.DirectionalLightShadow = DirectionalLightShadow;
exports.DiscreteInterpolant = DiscreteInterpolant;
exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
exports.DodecahedronGeometry = DodecahedronGeometry;
exports.DynamicBufferAttribute = DynamicBufferAttribute;
exports.EdgesGeometry = EdgesGeometry;
exports.EdgesHelper = EdgesHelper;
exports.EllipseCurve = EllipseCurve;
exports.Euler = Euler;
exports.EventDispatcher = EventDispatcher;
exports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;
exports.ExtrudeGeometry = ExtrudeGeometry;
exports.Face3 = Face3;
exports.Face4 = Face4;
exports.FileLoader = FileLoader;
exports.Float32Attribute = Float32Attribute;
exports.Float32BufferAttribute = Float32BufferAttribute;
exports.Float64Attribute = Float64Attribute;
exports.Float64BufferAttribute = Float64BufferAttribute;
exports.Fog = Fog;
exports.FogExp2 = FogExp2;
exports.Font = Font;
exports.FontLoader = FontLoader;
exports.Frustum = Frustum;
exports.Geometry = Geometry;
exports.GridHelper = GridHelper;
exports.Group = Group;
exports.HemisphereLight = HemisphereLight;
exports.HemisphereLightHelper = HemisphereLightHelper;
exports.HemisphereLightProbe = HemisphereLightProbe;
exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
exports.IcosahedronGeometry = IcosahedronGeometry;
exports.ImageBitmapLoader = ImageBitmapLoader;
exports.ImageLoader = ImageLoader;
exports.ImmediateRenderObject = ImmediateRenderObject;
exports.InstancedBufferAttribute = InstancedBufferAttribute;
exports.InstancedBufferGeometry = InstancedBufferGeometry;
exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
exports.InstancedMesh = InstancedMesh;
exports.Int16Attribute = Int16Attribute;
exports.Int16BufferAttribute = Int16BufferAttribute;
exports.Int32Attribute = Int32Attribute;
exports.Int32BufferAttribute = Int32BufferAttribute;
exports.Int8Attribute = Int8Attribute;
exports.Int8BufferAttribute = Int8BufferAttribute;
exports.InterleavedBuffer = InterleavedBuffer;
exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
exports.Interpolant = Interpolant;
exports.JSONLoader = JSONLoader;
exports.KeyframeTrack = KeyframeTrack;
exports.LOD = LOD;
exports.LatheBufferGeometry = LatheBufferGeometry;
exports.LatheGeometry = LatheGeometry;
exports.Layers = Layers;
exports.LensFlare = LensFlare;
exports.Light = Light;
exports.LightProbe = LightProbe;
exports.LightShadow = LightShadow;
exports.Line = Line;
exports.Line3 = Line3;
exports.LineBasicMaterial = LineBasicMaterial;
exports.LineCurve = LineCurve;
exports.LineCurve3 = LineCurve3;
exports.LineDashedMaterial = LineDashedMaterial;
exports.LineLoop = LineLoop;
exports.LineSegments = LineSegments;
exports.LinearInterpolant = LinearInterpolant;
exports.Loader = Loader;
exports.LoadingManager = LoadingManager;
exports.Material = Material;
exports.MaterialLoader = MaterialLoader;
exports.Matrix3 = Matrix3;
exports.Matrix4 = Matrix4;
exports.Mesh = Mesh;
exports.MeshBasicMaterial = MeshBasicMaterial;
exports.MeshDepthMaterial = MeshDepthMaterial;
exports.MeshDistanceMaterial = MeshDistanceMaterial;
exports.MeshFaceMaterial = MeshFaceMaterial;
exports.MeshLambertMaterial = MeshLambertMaterial;
exports.MeshMatcapMaterial = MeshMatcapMaterial;
exports.MeshNormalMaterial = MeshNormalMaterial;
exports.MeshPhongMaterial = MeshPhongMaterial;
exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
exports.MeshStandardMaterial = MeshStandardMaterial;
exports.MeshToonMaterial = MeshToonMaterial;
exports.MultiMaterial = MultiMaterial;
exports.NumberKeyframeTrack = NumberKeyframeTrack;
exports.Object3D = Object3D;
exports.ObjectLoader = ObjectLoader;
exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
exports.OctahedronGeometry = OctahedronGeometry;
exports.OrthographicCamera = OrthographicCamera;
exports.PMREMGenerator = PMREMGenerator;
exports.ParametricBufferGeometry = ParametricBufferGeometry;
exports.ParametricGeometry = ParametricGeometry;
exports.Particle = Particle;
exports.ParticleBasicMaterial = ParticleBasicMaterial;
exports.ParticleSystem = ParticleSystem;
exports.ParticleSystemMaterial = ParticleSystemMaterial;
exports.Path = Path;
exports.PerspectiveCamera = PerspectiveCamera;
exports.Plane = Plane;
exports.PlaneBufferGeometry = PlaneBufferGeometry;
exports.PlaneGeometry = PlaneGeometry;
exports.PlaneHelper = PlaneHelper;
exports.PointCloud = PointCloud;
exports.PointCloudMaterial = PointCloudMaterial;
exports.PointLight = PointLight;
exports.PointLightHelper = PointLightHelper;
exports.Points = Points;
exports.PointsMaterial = PointsMaterial;
exports.PolarGridHelper = PolarGridHelper;
exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
exports.PolyhedronGeometry = PolyhedronGeometry;
exports.PositionalAudio = PositionalAudio;
exports.PropertyBinding = PropertyBinding;
exports.PropertyMixer = PropertyMixer;
exports.QuadraticBezierCurve = QuadraticBezierCurve;
exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
exports.Quaternion = Quaternion;
exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
exports.RawShaderMaterial = RawShaderMaterial;
exports.Ray = Ray;
exports.Raycaster = Raycaster;
exports.RectAreaLight = RectAreaLight;
exports.RingBufferGeometry = RingBufferGeometry;
exports.RingGeometry = RingGeometry;
exports.Scene = Scene;
exports.ShaderMaterial = ShaderMaterial;
exports.ShadowMaterial = ShadowMaterial;
exports.Shape = Shape;
exports.ShapeBufferGeometry = ShapeBufferGeometry;
exports.ShapeGeometry = ShapeGeometry;
exports.ShapePath = ShapePath;
exports.Skeleton = Skeleton;
exports.SkeletonHelper = SkeletonHelper;
exports.SkinnedMesh = SkinnedMesh;
exports.Sphere = Sphere;
exports.SphereBufferGeometry = SphereBufferGeometry;
exports.SphereGeometry = SphereGeometry;
exports.Spherical = Spherical;
exports.SphericalHarmonics3 = SphericalHarmonics3;
exports.Spline = Spline;
exports.SplineCurve = SplineCurve;
exports.SplineCurve3 = SplineCurve3;
exports.SpotLight = SpotLight;
exports.SpotLightHelper = SpotLightHelper;
exports.SpotLightShadow = SpotLightShadow;
exports.Sprite = Sprite;
exports.SpriteMaterial = SpriteMaterial;
exports.StereoCamera = StereoCamera;
exports.StringKeyframeTrack = StringKeyframeTrack;
exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
exports.TetrahedronGeometry = TetrahedronGeometry;
exports.TextBufferGeometry = TextBufferGeometry;
exports.TextGeometry = TextGeometry;
exports.Texture = Texture;
exports.TextureLoader = TextureLoader;
exports.TorusBufferGeometry = TorusBufferGeometry;
exports.TorusGeometry = TorusGeometry;
exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
exports.TorusKnotGeometry = TorusKnotGeometry;
exports.Triangle = Triangle;
exports.TubeBufferGeometry = TubeBufferGeometry;
exports.TubeGeometry = TubeGeometry;
exports.Uint16Attribute = Uint16Attribute;
exports.Uint16BufferAttribute = Uint16BufferAttribute;
exports.Uint32Attribute = Uint32Attribute;
exports.Uint32BufferAttribute = Uint32BufferAttribute;
exports.Uint8Attribute = Uint8Attribute;
exports.Uint8BufferAttribute = Uint8BufferAttribute;
exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
exports.Uniform = Uniform;
exports.Vector2 = Vector2;
exports.Vector3 = Vector3;
exports.Vector4 = Vector4;
exports.VectorKeyframeTrack = VectorKeyframeTrack;
exports.Vertex = Vertex;
exports.VideoTexture = VideoTexture;
exports.WebGL1Renderer = WebGL1Renderer;
exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
exports.WebGLRenderTarget = WebGLRenderTarget;
exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
exports.WebGLRenderer = WebGLRenderer;
exports.WebGLUtils = WebGLUtils;
exports.WireframeGeometry = WireframeGeometry;
exports.WireframeHelper = WireframeHelper;
exports.XHRLoader = XHRLoader;
exports.NearestMipmapLinearFilter = exports.NearestMipMapNearestFilter = exports.NearestMipMapLinearFilter = exports.NearestFilter = exports.MultiplyOperation = exports.MultiplyBlending = exports.MixOperation = exports.MirroredRepeatWrapping = exports.MinEquation = exports.MaxEquation = exports.MathUtils = exports.Math = exports.MOUSE = exports.LuminanceFormat = exports.LuminanceAlphaFormat = exports.LoopRepeat = exports.LoopPingPong = exports.LoopOnce = exports.LogLuvEncoding = exports.LoaderUtils = exports.LinearToneMapping = exports.LinearMipmapNearestFilter = exports.LinearMipmapLinearFilter = exports.LinearMipMapNearestFilter = exports.LinearMipMapLinearFilter = exports.LinearFilter = exports.LinearEncoding = exports.LineStrip = exports.LinePieces = exports.LessStencilFunc = exports.LessEqualStencilFunc = exports.LessEqualDepth = exports.LessDepth = exports.KeepStencilOp = exports.InvertStencilOp = exports.InterpolateSmooth = exports.InterpolateLinear = exports.InterpolateDiscrete = exports.IntType = exports.IncrementWrapStencilOp = exports.IncrementStencilOp = exports.ImageUtils = exports.HalfFloatType = exports.GreaterStencilFunc = exports.GreaterEqualStencilFunc = exports.GreaterEqualDepth = exports.GreaterDepth = exports.GeometryUtils = exports.GammaEncoding = exports.FrontSide = exports.FrontFaceDirectionCW = exports.FrontFaceDirectionCCW = exports.FloatType = exports.FlatShading = exports.FaceColors = exports.EquirectangularRefractionMapping = exports.EquirectangularReflectionMapping = exports.EqualStencilFunc = exports.EqualDepth = exports.DynamicReadUsage = exports.DynamicDrawUsage = exports.DynamicCopyUsage = exports.DstColorFactor = exports.DstAlphaFactor = exports.DoubleSide = exports.DepthStencilFormat = exports.DepthFormat = exports.DefaultLoadingManager = exports.DecrementWrapStencilOp = exports.DecrementStencilOp = exports.CustomToneMapping = exports.CustomBlending = exports.CullFaceNone = exports.CullFaceFrontBack = exports.CullFaceFront = exports.CullFaceBack = exports.CubeUVRefractionMapping = exports.CubeUVReflectionMapping = exports.CubeRefractionMapping = exports.CubeReflectionMapping = exports.ClampToEdgeWrapping = exports.CineonToneMapping = exports.Cache = exports.ByteType = exports.CubeGeometry = exports.BoxGeometry = exports.BoxBufferGeometry = exports.BasicShadowMap = exports.BasicDepthPacking = exports.BackSide = exports.AudioContext = exports.AnimationUtils = exports.AlwaysStencilFunc = exports.AlwaysDepth = exports.AlphaFormat = exports.AdditiveBlending = exports.AdditiveAnimationBlendMode = exports.AddOperation = exports.AddEquation = exports.ACESFilmicToneMapping = void 0;
exports.UVMapping = exports.TrianglesDrawMode = exports.TriangleStripDrawMode = exports.TriangleFanDrawMode = exports.TangentSpaceNormalMap = exports.TOUCH = exports.SubtractiveBlending = exports.SubtractEquation = exports.StreamReadUsage = exports.StreamDrawUsage = exports.StreamCopyUsage = exports.StaticReadUsage = exports.StaticDrawUsage = exports.StaticCopyUsage = exports.SrcColorFactor = exports.SrcAlphaSaturateFactor = exports.SrcAlphaFactor = exports.SmoothShading = exports.ShortType = exports.ShapeUtils = exports.ShaderLib = exports.ShaderChunk = exports.SceneUtils = exports.SRGB8_ALPHA8_ASTC_8x8_Format = exports.SRGB8_ALPHA8_ASTC_8x6_Format = exports.SRGB8_ALPHA8_ASTC_8x5_Format = exports.SRGB8_ALPHA8_ASTC_6x6_Format = exports.SRGB8_ALPHA8_ASTC_6x5_Format = exports.SRGB8_ALPHA8_ASTC_5x5_Format = exports.SRGB8_ALPHA8_ASTC_5x4_Format = exports.SRGB8_ALPHA8_ASTC_4x4_Format = exports.SRGB8_ALPHA8_ASTC_12x12_Format = exports.SRGB8_ALPHA8_ASTC_12x10_Format = exports.SRGB8_ALPHA8_ASTC_10x8_Format = exports.SRGB8_ALPHA8_ASTC_10x6_Format = exports.SRGB8_ALPHA8_ASTC_10x5_Format = exports.SRGB8_ALPHA8_ASTC_10x10_Format = exports.ReverseSubtractEquation = exports.ReplaceStencilOp = exports.RepeatWrapping = exports.ReinhardToneMapping = exports.RedIntegerFormat = exports.RedFormat = exports.RGIntegerFormat = exports.RGFormat = exports.RGB_S3TC_DXT1_Format = exports.RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = exports.RGB_ETC2_Format = exports.RGB_ETC1_Format = exports.RGBM7Encoding = exports.RGBM16Encoding = exports.RGBIntegerFormat = exports.RGBFormat = exports.RGBEFormat = exports.RGBEEncoding = exports.RGBDEncoding = exports.RGBA_S3TC_DXT5_Format = exports.RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT1_Format = exports.RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = exports.RGBA_ETC2_EAC_Format = exports.RGBA_BPTC_Format = exports.RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x10_Format = exports.RGBAIntegerFormat = exports.RGBAFormat = exports.RGBADepthPacking = exports.REVISION = exports.PCFSoftShadowMap = exports.PCFShadowMap = exports.OneMinusSrcColorFactor = exports.OneMinusSrcAlphaFactor = exports.OneMinusDstColorFactor = exports.OneMinusDstAlphaFactor = exports.OneFactor = exports.ObjectSpaceNormalMap = exports.NotEqualStencilFunc = exports.NotEqualDepth = exports.NormalBlending = exports.NormalAnimationBlendMode = exports.NoToneMapping = exports.NoColors = exports.NoBlending = exports.NeverStencilFunc = exports.NeverDepth = exports.NearestMipmapNearestFilter = void 0;
exports.sRGBEncoding = exports.ZeroStencilOp = exports.ZeroSlopeEnding = exports.ZeroFactor = exports.ZeroCurvatureEnding = exports.WrapAroundEnding = exports.VertexColors = exports.VSMShadowMap = exports.UnsignedShortType = exports.UnsignedShort565Type = exports.UnsignedShort5551Type = exports.UnsignedShort4444Type = exports.UnsignedIntType = exports.UnsignedInt248Type = exports.UnsignedByteType = exports.UniformsUtils = exports.UniformsLib = void 0;

// Polyfills
if (Number.EPSILON === undefined) {
  Number.EPSILON = Math.pow(2, -52);
}

if (Number.isInteger === undefined) {
  // Missing in IE
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
  Number.isInteger = function (value) {
    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
  };
} //


if (Math.sign === undefined) {
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
  Math.sign = function (x) {
    return x < 0 ? -1 : x > 0 ? 1 : +x;
  };
}

if ('name' in Function.prototype === false) {
  // Missing in IE
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
  Object.defineProperty(Function.prototype, 'name', {
    get: function () {
      return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
    }
  });
}

if (Object.assign === undefined) {
  // Missing in IE
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
  Object.assign = function (target) {
    if (target === undefined || target === null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    const output = Object(target);

    for (let index = 1; index < arguments.length; index++) {
      const source = arguments[index];

      if (source !== undefined && source !== null) {
        for (const nextKey in source) {
          if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
            output[nextKey] = source[nextKey];
          }
        }
      }
    }

    return output;
  };
}

const REVISION = '118';
exports.REVISION = REVISION;
const MOUSE = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2
};
exports.MOUSE = MOUSE;
const TOUCH = {
  ROTATE: 0,
  PAN: 1,
  DOLLY_PAN: 2,
  DOLLY_ROTATE: 3
};
exports.TOUCH = TOUCH;
const CullFaceNone = 0;
exports.CullFaceNone = CullFaceNone;
const CullFaceBack = 1;
exports.CullFaceBack = CullFaceBack;
const CullFaceFront = 2;
exports.CullFaceFront = CullFaceFront;
const CullFaceFrontBack = 3;
exports.CullFaceFrontBack = CullFaceFrontBack;
const FrontFaceDirectionCW = 0;
exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
const FrontFaceDirectionCCW = 1;
exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
const BasicShadowMap = 0;
exports.BasicShadowMap = BasicShadowMap;
const PCFShadowMap = 1;
exports.PCFShadowMap = PCFShadowMap;
const PCFSoftShadowMap = 2;
exports.PCFSoftShadowMap = PCFSoftShadowMap;
const VSMShadowMap = 3;
exports.VSMShadowMap = VSMShadowMap;
const FrontSide = 0;
exports.FrontSide = FrontSide;
const BackSide = 1;
exports.BackSide = BackSide;
const DoubleSide = 2;
exports.DoubleSide = DoubleSide;
const FlatShading = 1;
exports.FlatShading = FlatShading;
const SmoothShading = 2;
exports.SmoothShading = SmoothShading;
const NoBlending = 0;
exports.NoBlending = NoBlending;
const NormalBlending = 1;
exports.NormalBlending = NormalBlending;
const AdditiveBlending = 2;
exports.AdditiveBlending = AdditiveBlending;
const SubtractiveBlending = 3;
exports.SubtractiveBlending = SubtractiveBlending;
const MultiplyBlending = 4;
exports.MultiplyBlending = MultiplyBlending;
const CustomBlending = 5;
exports.CustomBlending = CustomBlending;
const AddEquation = 100;
exports.AddEquation = AddEquation;
const SubtractEquation = 101;
exports.SubtractEquation = SubtractEquation;
const ReverseSubtractEquation = 102;
exports.ReverseSubtractEquation = ReverseSubtractEquation;
const MinEquation = 103;
exports.MinEquation = MinEquation;
const MaxEquation = 104;
exports.MaxEquation = MaxEquation;
const ZeroFactor = 200;
exports.ZeroFactor = ZeroFactor;
const OneFactor = 201;
exports.OneFactor = OneFactor;
const SrcColorFactor = 202;
exports.SrcColorFactor = SrcColorFactor;
const OneMinusSrcColorFactor = 203;
exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
const SrcAlphaFactor = 204;
exports.SrcAlphaFactor = SrcAlphaFactor;
const OneMinusSrcAlphaFactor = 205;
exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
const DstAlphaFactor = 206;
exports.DstAlphaFactor = DstAlphaFactor;
const OneMinusDstAlphaFactor = 207;
exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
const DstColorFactor = 208;
exports.DstColorFactor = DstColorFactor;
const OneMinusDstColorFactor = 209;
exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
const SrcAlphaSaturateFactor = 210;
exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
const NeverDepth = 0;
exports.NeverDepth = NeverDepth;
const AlwaysDepth = 1;
exports.AlwaysDepth = AlwaysDepth;
const LessDepth = 2;
exports.LessDepth = LessDepth;
const LessEqualDepth = 3;
exports.LessEqualDepth = LessEqualDepth;
const EqualDepth = 4;
exports.EqualDepth = EqualDepth;
const GreaterEqualDepth = 5;
exports.GreaterEqualDepth = GreaterEqualDepth;
const GreaterDepth = 6;
exports.GreaterDepth = GreaterDepth;
const NotEqualDepth = 7;
exports.NotEqualDepth = NotEqualDepth;
const MultiplyOperation = 0;
exports.MultiplyOperation = MultiplyOperation;
const MixOperation = 1;
exports.MixOperation = MixOperation;
const AddOperation = 2;
exports.AddOperation = AddOperation;
const NoToneMapping = 0;
exports.NoToneMapping = NoToneMapping;
const LinearToneMapping = 1;
exports.LinearToneMapping = LinearToneMapping;
const ReinhardToneMapping = 2;
exports.ReinhardToneMapping = ReinhardToneMapping;
const CineonToneMapping = 3;
exports.CineonToneMapping = CineonToneMapping;
const ACESFilmicToneMapping = 4;
exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
const CustomToneMapping = 5;
exports.CustomToneMapping = CustomToneMapping;
const UVMapping = 300;
exports.UVMapping = UVMapping;
const CubeReflectionMapping = 301;
exports.CubeReflectionMapping = CubeReflectionMapping;
const CubeRefractionMapping = 302;
exports.CubeRefractionMapping = CubeRefractionMapping;
const EquirectangularReflectionMapping = 303;
exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
const EquirectangularRefractionMapping = 304;
exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
const CubeUVReflectionMapping = 306;
exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
const CubeUVRefractionMapping = 307;
exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
const RepeatWrapping = 1000;
exports.RepeatWrapping = RepeatWrapping;
const ClampToEdgeWrapping = 1001;
exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
const MirroredRepeatWrapping = 1002;
exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
const NearestFilter = 1003;
exports.NearestFilter = NearestFilter;
const NearestMipmapNearestFilter = 1004;
exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
const NearestMipMapNearestFilter = 1004;
exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
const NearestMipmapLinearFilter = 1005;
exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
const NearestMipMapLinearFilter = 1005;
exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
const LinearFilter = 1006;
exports.LinearFilter = LinearFilter;
const LinearMipmapNearestFilter = 1007;
exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
const LinearMipMapNearestFilter = 1007;
exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
const LinearMipmapLinearFilter = 1008;
exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
const LinearMipMapLinearFilter = 1008;
exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
const UnsignedByteType = 1009;
exports.UnsignedByteType = UnsignedByteType;
const ByteType = 1010;
exports.ByteType = ByteType;
const ShortType = 1011;
exports.ShortType = ShortType;
const UnsignedShortType = 1012;
exports.UnsignedShortType = UnsignedShortType;
const IntType = 1013;
exports.IntType = IntType;
const UnsignedIntType = 1014;
exports.UnsignedIntType = UnsignedIntType;
const FloatType = 1015;
exports.FloatType = FloatType;
const HalfFloatType = 1016;
exports.HalfFloatType = HalfFloatType;
const UnsignedShort4444Type = 1017;
exports.UnsignedShort4444Type = UnsignedShort4444Type;
const UnsignedShort5551Type = 1018;
exports.UnsignedShort5551Type = UnsignedShort5551Type;
const UnsignedShort565Type = 1019;
exports.UnsignedShort565Type = UnsignedShort565Type;
const UnsignedInt248Type = 1020;
exports.UnsignedInt248Type = UnsignedInt248Type;
const AlphaFormat = 1021;
exports.AlphaFormat = AlphaFormat;
const RGBFormat = 1022;
exports.RGBFormat = RGBFormat;
const RGBAFormat = 1023;
exports.RGBAFormat = RGBAFormat;
const LuminanceFormat = 1024;
exports.LuminanceFormat = LuminanceFormat;
const LuminanceAlphaFormat = 1025;
exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
const RGBEFormat = RGBAFormat;
exports.RGBEFormat = RGBEFormat;
const DepthFormat = 1026;
exports.DepthFormat = DepthFormat;
const DepthStencilFormat = 1027;
exports.DepthStencilFormat = DepthStencilFormat;
const RedFormat = 1028;
exports.RedFormat = RedFormat;
const RedIntegerFormat = 1029;
exports.RedIntegerFormat = RedIntegerFormat;
const RGFormat = 1030;
exports.RGFormat = RGFormat;
const RGIntegerFormat = 1031;
exports.RGIntegerFormat = RGIntegerFormat;
const RGBIntegerFormat = 1032;
exports.RGBIntegerFormat = RGBIntegerFormat;
const RGBAIntegerFormat = 1033;
exports.RGBAIntegerFormat = RGBAIntegerFormat;
const RGB_S3TC_DXT1_Format = 33776;
exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
const RGBA_S3TC_DXT1_Format = 33777;
exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
const RGBA_S3TC_DXT3_Format = 33778;
exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
const RGBA_S3TC_DXT5_Format = 33779;
exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
const RGB_PVRTC_4BPPV1_Format = 35840;
exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
const RGB_PVRTC_2BPPV1_Format = 35841;
exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
const RGBA_PVRTC_4BPPV1_Format = 35842;
exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
const RGBA_PVRTC_2BPPV1_Format = 35843;
exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
const RGB_ETC1_Format = 36196;
exports.RGB_ETC1_Format = RGB_ETC1_Format;
const RGB_ETC2_Format = 37492;
exports.RGB_ETC2_Format = RGB_ETC2_Format;
const RGBA_ETC2_EAC_Format = 37496;
exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
const RGBA_ASTC_4x4_Format = 37808;
exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
const RGBA_ASTC_5x4_Format = 37809;
exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
const RGBA_ASTC_5x5_Format = 37810;
exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
const RGBA_ASTC_6x5_Format = 37811;
exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
const RGBA_ASTC_6x6_Format = 37812;
exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
const RGBA_ASTC_8x5_Format = 37813;
exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
const RGBA_ASTC_8x6_Format = 37814;
exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
const RGBA_ASTC_8x8_Format = 37815;
exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
const RGBA_ASTC_10x5_Format = 37816;
exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
const RGBA_ASTC_10x6_Format = 37817;
exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
const RGBA_ASTC_10x8_Format = 37818;
exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
const RGBA_ASTC_10x10_Format = 37819;
exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
const RGBA_ASTC_12x10_Format = 37820;
exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
const RGBA_ASTC_12x12_Format = 37821;
exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
const RGBA_BPTC_Format = 36492;
exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
exports.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format;
const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
exports.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format;
const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
exports.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format;
const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
exports.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format;
const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
exports.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format;
const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
exports.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format;
const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
exports.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format;
const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
exports.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format;
const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
exports.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format;
const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
exports.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format;
const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
exports.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format;
const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
exports.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format;
const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
exports.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format;
const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
exports.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format;
const LoopOnce = 2200;
exports.LoopOnce = LoopOnce;
const LoopRepeat = 2201;
exports.LoopRepeat = LoopRepeat;
const LoopPingPong = 2202;
exports.LoopPingPong = LoopPingPong;
const InterpolateDiscrete = 2300;
exports.InterpolateDiscrete = InterpolateDiscrete;
const InterpolateLinear = 2301;
exports.InterpolateLinear = InterpolateLinear;
const InterpolateSmooth = 2302;
exports.InterpolateSmooth = InterpolateSmooth;
const ZeroCurvatureEnding = 2400;
exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
const ZeroSlopeEnding = 2401;
exports.ZeroSlopeEnding = ZeroSlopeEnding;
const WrapAroundEnding = 2402;
exports.WrapAroundEnding = WrapAroundEnding;
const NormalAnimationBlendMode = 2500;
exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
const AdditiveAnimationBlendMode = 2501;
exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
const TrianglesDrawMode = 0;
exports.TrianglesDrawMode = TrianglesDrawMode;
const TriangleStripDrawMode = 1;
exports.TriangleStripDrawMode = TriangleStripDrawMode;
const TriangleFanDrawMode = 2;
exports.TriangleFanDrawMode = TriangleFanDrawMode;
const LinearEncoding = 3000;
exports.LinearEncoding = LinearEncoding;
const sRGBEncoding = 3001;
exports.sRGBEncoding = sRGBEncoding;
const GammaEncoding = 3007;
exports.GammaEncoding = GammaEncoding;
const RGBEEncoding = 3002;
exports.RGBEEncoding = RGBEEncoding;
const LogLuvEncoding = 3003;
exports.LogLuvEncoding = LogLuvEncoding;
const RGBM7Encoding = 3004;
exports.RGBM7Encoding = RGBM7Encoding;
const RGBM16Encoding = 3005;
exports.RGBM16Encoding = RGBM16Encoding;
const RGBDEncoding = 3006;
exports.RGBDEncoding = RGBDEncoding;
const BasicDepthPacking = 3200;
exports.BasicDepthPacking = BasicDepthPacking;
const RGBADepthPacking = 3201;
exports.RGBADepthPacking = RGBADepthPacking;
const TangentSpaceNormalMap = 0;
exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
const ObjectSpaceNormalMap = 1;
exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
const ZeroStencilOp = 0;
exports.ZeroStencilOp = ZeroStencilOp;
const KeepStencilOp = 7680;
exports.KeepStencilOp = KeepStencilOp;
const ReplaceStencilOp = 7681;
exports.ReplaceStencilOp = ReplaceStencilOp;
const IncrementStencilOp = 7682;
exports.IncrementStencilOp = IncrementStencilOp;
const DecrementStencilOp = 7683;
exports.DecrementStencilOp = DecrementStencilOp;
const IncrementWrapStencilOp = 34055;
exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
const DecrementWrapStencilOp = 34056;
exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
const InvertStencilOp = 5386;
exports.InvertStencilOp = InvertStencilOp;
const NeverStencilFunc = 512;
exports.NeverStencilFunc = NeverStencilFunc;
const LessStencilFunc = 513;
exports.LessStencilFunc = LessStencilFunc;
const EqualStencilFunc = 514;
exports.EqualStencilFunc = EqualStencilFunc;
const LessEqualStencilFunc = 515;
exports.LessEqualStencilFunc = LessEqualStencilFunc;
const GreaterStencilFunc = 516;
exports.GreaterStencilFunc = GreaterStencilFunc;
const NotEqualStencilFunc = 517;
exports.NotEqualStencilFunc = NotEqualStencilFunc;
const GreaterEqualStencilFunc = 518;
exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
const AlwaysStencilFunc = 519;
exports.AlwaysStencilFunc = AlwaysStencilFunc;
const StaticDrawUsage = 35044;
exports.StaticDrawUsage = StaticDrawUsage;
const DynamicDrawUsage = 35048;
exports.DynamicDrawUsage = DynamicDrawUsage;
const StreamDrawUsage = 35040;
exports.StreamDrawUsage = StreamDrawUsage;
const StaticReadUsage = 35045;
exports.StaticReadUsage = StaticReadUsage;
const DynamicReadUsage = 35049;
exports.DynamicReadUsage = DynamicReadUsage;
const StreamReadUsage = 35041;
exports.StreamReadUsage = StreamReadUsage;
const StaticCopyUsage = 35046;
exports.StaticCopyUsage = StaticCopyUsage;
const DynamicCopyUsage = 35050;
exports.DynamicCopyUsage = DynamicCopyUsage;
const StreamCopyUsage = 35042;
/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

exports.StreamCopyUsage = StreamCopyUsage;

function EventDispatcher() {}

Object.assign(EventDispatcher.prototype, {
  addEventListener: function (type, listener) {
    if (this._listeners === undefined) this._listeners = {};
    const listeners = this._listeners;

    if (listeners[type] === undefined) {
      listeners[type] = [];
    }

    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  },
  hasEventListener: function (type, listener) {
    if (this._listeners === undefined) return false;
    const listeners = this._listeners;
    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
  },
  removeEventListener: function (type, listener) {
    if (this._listeners === undefined) return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];

    if (listenerArray !== undefined) {
      const index = listenerArray.indexOf(listener);

      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  },
  dispatchEvent: function (event) {
    if (this._listeners === undefined) return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];

    if (listenerArray !== undefined) {
      event.target = this; // Make a copy, in case listeners are removed while iterating.

      const array = listenerArray.slice(0);

      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
    }
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author thezwap
 */

const _lut = [];

for (let i = 0; i < 256; i++) {
  _lut[i] = (i < 16 ? '0' : '') + i.toString(16);
}

const MathUtils = {
  DEG2RAD: Math.PI / 180,
  RAD2DEG: 180 / Math.PI,
  generateUUID: function () {
    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
    const d0 = Math.random() * 0xffffffff | 0;
    const d1 = Math.random() * 0xffffffff | 0;
    const d2 = Math.random() * 0xffffffff | 0;
    const d3 = Math.random() * 0xffffffff | 0;
    const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.

    return uuid.toUpperCase();
  },
  clamp: function (value, min, max) {
    return Math.max(min, Math.min(max, value));
  },
  // compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  euclideanModulo: function (n, m) {
    return (n % m + m) % m;
  },
  // Linear mapping from range <a1, a2> to range <b1, b2>
  mapLinear: function (x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  },
  // https://en.wikipedia.org/wiki/Linear_interpolation
  lerp: function (x, y, t) {
    return (1 - t) * x + t * y;
  },
  // http://en.wikipedia.org/wiki/Smoothstep
  smoothstep: function (x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  },
  smootherstep: function (x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  },
  // Random integer from <low, high> interval
  randInt: function (low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  },
  // Random float from <low, high> interval
  randFloat: function (low, high) {
    return low + Math.random() * (high - low);
  },
  // Random float from <-range/2, range/2> interval
  randFloatSpread: function (range) {
    return range * (0.5 - Math.random());
  },
  degToRad: function (degrees) {
    return degrees * MathUtils.DEG2RAD;
  },
  radToDeg: function (radians) {
    return radians * MathUtils.RAD2DEG;
  },
  isPowerOfTwo: function (value) {
    return (value & value - 1) === 0 && value !== 0;
  },
  ceilPowerOfTwo: function (value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  },
  floorPowerOfTwo: function (value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  },
  setQuaternionFromProperEuler: function (q, a, b, c, order) {
    // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
    // rotations are applied to the axes in the order specified by 'order'
    // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
    // angles are in radians
    const cos = Math.cos;
    const sin = Math.sin;
    const c2 = cos(b / 2);
    const s2 = sin(b / 2);
    const c13 = cos((a + c) / 2);
    const s13 = sin((a + c) / 2);
    const c1_3 = cos((a - c) / 2);
    const s1_3 = sin((a - c) / 2);
    const c3_1 = cos((c - a) / 2);
    const s3_1 = sin((c - a) / 2);

    switch (order) {
      case 'XYX':
        q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
        break;

      case 'YZY':
        q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
        break;

      case 'ZXZ':
        q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
        break;

      case 'XZX':
        q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
        break;

      case 'YXY':
        q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
        break;

      case 'ZYZ':
        q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
        break;

      default:
        console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
    }
  }
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

exports.MathUtils = exports.Math = MathUtils;

function Vector2(x = 0, y = 0) {
  this.x = x;
  this.y = y;
}

Object.defineProperties(Vector2.prototype, {
  "width": {
    get: function () {
      return this.x;
    },
    set: function (value) {
      this.x = value;
    }
  },
  "height": {
    get: function () {
      return this.y;
    },
    set: function (value) {
      this.y = value;
    }
  }
});
Object.assign(Vector2.prototype, {
  isVector2: true,
  set: function (x, y) {
    this.x = x;
    this.y = y;
    return this;
  },
  setScalar: function (scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  },
  getComponent: function (index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      default:
        throw new Error('index is out of range: ' + index);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y);
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  },
  addScaledVector: function (v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    return this;
  },
  subScalar: function (s) {
    this.x -= s;
    this.y -= s;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  },
  multiply: function (v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  },
  multiplyScalar: function (scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  },
  divide: function (v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  },
  divideScalar: function (scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  applyMatrix3: function (m) {
    const x = this.x,
          y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  },
  min: function (v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  },
  max: function (v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  },
  clamp: function (min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  },
  clampScalar: function (minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  },
  clampLength: function (min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  },
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  },
  roundToZero: function () {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  },
  negate: function () {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y;
  },
  cross: function (v) {
    return this.x * v.y - this.y * v.x;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  manhattanLength: function () {
    return Math.abs(this.x) + Math.abs(this.y);
  },
  normalize: function () {
    return this.divideScalar(this.length() || 1);
  },
  angle: function () {
    // computes the angle in radians with respect to the positive x-axis
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  },
  distanceTo: function (v) {
    return Math.sqrt(this.distanceToSquared(v));
  },
  distanceToSquared: function (v) {
    const dx = this.x - v.x,
          dy = this.y - v.y;
    return dx * dx + dy * dy;
  },
  manhattanDistanceTo: function (v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  },
  setLength: function (length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  },
  lerpVectors: function (v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  },
  fromBufferAttribute: function (attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  },
  rotateAround: function (center, angle) {
    const c = Math.cos(angle),
          s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  },
  random: function () {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */

function Matrix3() {
  this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

  if (arguments.length > 0) {
    console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
  }
}

Object.assign(Matrix3.prototype, {
  isMatrix3: true,
  set: function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  },
  clone: function () {
    return new this.constructor().fromArray(this.elements);
  },
  copy: function (m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  },
  extractBasis: function (xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  },
  setFromMatrix4: function (m) {
    const me = m.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  },
  multiply: function (m) {
    return this.multiplyMatrices(this, m);
  },
  premultiply: function (m) {
    return this.multiplyMatrices(m, this);
  },
  multiplyMatrices: function (a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
          a12 = ae[3],
          a13 = ae[6];
    const a21 = ae[1],
          a22 = ae[4],
          a23 = ae[7];
    const a31 = ae[2],
          a32 = ae[5],
          a33 = ae[8];
    const b11 = be[0],
          b12 = be[3],
          b13 = be[6];
    const b21 = be[1],
          b22 = be[4],
          b23 = be[7];
    const b31 = be[2],
          b32 = be[5],
          b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  },
  multiplyScalar: function (s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  },
  determinant: function () {
    const te = this.elements;
    const a = te[0],
          b = te[1],
          c = te[2],
          d = te[3],
          e = te[4],
          f = te[5],
          g = te[6],
          h = te[7],
          i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  },
  getInverse: function (matrix, throwOnDegenerate) {
    if (throwOnDegenerate !== undefined) {
      console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
    }

    const me = matrix.elements,
          te = this.elements,
          n11 = me[0],
          n21 = me[1],
          n31 = me[2],
          n12 = me[3],
          n22 = me[4],
          n32 = me[5],
          n13 = me[6],
          n23 = me[7],
          n33 = me[8],
          t11 = n33 * n22 - n32 * n23,
          t12 = n32 * n13 - n33 * n12,
          t13 = n23 * n12 - n22 * n13,
          det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  },
  transpose: function () {
    let tmp;
    const m = this.elements;
    tmp = m[1];
    m[1] = m[3];
    m[3] = tmp;
    tmp = m[2];
    m[2] = m[6];
    m[6] = tmp;
    tmp = m[5];
    m[5] = m[7];
    m[7] = tmp;
    return this;
  },
  getNormalMatrix: function (matrix4) {
    return this.setFromMatrix4(matrix4).getInverse(this).transpose();
  },
  transposeIntoArray: function (r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  },
  setUvTransform: function (tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
  },
  scale: function (sx, sy) {
    const te = this.elements;
    te[0] *= sx;
    te[3] *= sx;
    te[6] *= sx;
    te[1] *= sy;
    te[4] *= sy;
    te[7] *= sy;
    return this;
  },
  rotate: function (theta) {
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    const te = this.elements;
    const a11 = te[0],
          a12 = te[3],
          a13 = te[6];
    const a21 = te[1],
          a22 = te[4],
          a23 = te[7];
    te[0] = c * a11 + s * a21;
    te[3] = c * a12 + s * a22;
    te[6] = c * a13 + s * a23;
    te[1] = -s * a11 + c * a21;
    te[4] = -s * a12 + c * a22;
    te[7] = -s * a13 + c * a23;
    return this;
  },
  translate: function (tx, ty) {
    const te = this.elements;
    te[0] += tx * te[2];
    te[3] += tx * te[5];
    te[6] += tx * te[8];
    te[1] += ty * te[2];
    te[4] += ty * te[5];
    te[7] += ty * te[8];
    return this;
  },
  equals: function (matrix) {
    const te = this.elements;
    const me = matrix.elements;

    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;

    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

let _canvas;

const ImageUtils = {
  getDataURL: function (image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }

    if (typeof HTMLCanvasElement == 'undefined') {
      return image.src;
    }

    let canvas;

    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
      _canvas.width = image.width;
      _canvas.height = image.height;

      const context = _canvas.getContext('2d');

      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }

      canvas = _canvas;
    }

    if (canvas.width > 2048 || canvas.height > 2048) {
      return canvas.toDataURL('image/jpeg', 0.6);
    } else {
      return canvas.toDataURL('image/png');
    }
  }
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

exports.ImageUtils = ImageUtils;
let textureId = 0;

function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
  Object.defineProperty(this, 'id', {
    value: textureId++
  });
  this.uuid = MathUtils.generateUUID();
  this.name = '';
  this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
  this.mipmaps = [];
  this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
  this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
  this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
  this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
  this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;
  this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
  this.format = format !== undefined ? format : RGBAFormat;
  this.internalFormat = null;
  this.type = type !== undefined ? type : UnsignedByteType;
  this.offset = new Vector2(0, 0);
  this.repeat = new Vector2(1, 1);
  this.center = new Vector2(0, 0);
  this.rotation = 0;
  this.matrixAutoUpdate = true;
  this.matrix = new Matrix3();
  this.generateMipmaps = true;
  this.premultiplyAlpha = false;
  this.flipY = true;
  this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
  // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
  //
  // Also changing the encoding after already used by a Material will not automatically make the Material
  // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.

  this.encoding = encoding !== undefined ? encoding : LinearEncoding;
  this.version = 0;
  this.onUpdate = null;
}

Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Texture,
  isTexture: true,
  updateMatrix: function () {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.name = source.name;
    this.image = source.image;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.encoding = source.encoding;
    return this;
  },
  toJSON: function (meta) {
    const isRootObject = meta === undefined || typeof meta === 'string';

    if (!isRootObject && meta.textures[this.uuid] !== undefined) {
      return meta.textures[this.uuid];
    }

    const output = {
      metadata: {
        version: 4.5,
        type: 'Texture',
        generator: 'Texture.toJSON'
      },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };

    if (this.image !== undefined) {
      // TODO: Move to THREE.Image
      const image = this.image;

      if (image.uuid === undefined) {
        image.uuid = MathUtils.generateUUID(); // UGH
      }

      if (!isRootObject && meta.images[image.uuid] === undefined) {
        let url;

        if (Array.isArray(image)) {
          // process array of images e.g. CubeTexture
          url = [];

          for (let i = 0, l = image.length; i < l; i++) {
            url.push(ImageUtils.getDataURL(image[i]));
          }
        } else {
          // process single image
          url = ImageUtils.getDataURL(image);
        }

        meta.images[image.uuid] = {
          uuid: image.uuid,
          url: url
        };
      }

      output.image = image.uuid;
    }

    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }

    return output;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  },
  transformUv: function (uv) {
    if (this.mapping !== UVMapping) return uv;
    uv.applyMatrix3(this.matrix);

    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;

        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;

        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }

          break;
      }
    }

    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;

        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;

        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }

          break;
      }
    }

    if (this.flipY) {
      uv.y = 1 - uv.y;
    }

    return uv;
  }
});
Object.defineProperty(Texture.prototype, "needsUpdate", {
  set: function (value) {
    if (value === true) this.version++;
  }
});
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector4(x = 0, y = 0, z = 0, w = 1) {
  this.x = x;
  this.y = y;
  this.z = z;
  this.w = w;
}

Object.defineProperties(Vector4.prototype, {
  "width": {
    get: function () {
      return this.z;
    },
    set: function (value) {
      this.z = value;
    }
  },
  "height": {
    get: function () {
      return this.w;
    },
    set: function (value) {
      this.w = value;
    }
  }
});
Object.assign(Vector4.prototype, {
  isVector4: true,
  set: function (x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  },
  setScalar: function (scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setZ: function (z) {
    this.z = z;
    return this;
  },
  setW: function (w) {
    this.w = w;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      case 2:
        this.z = value;
        break;

      case 3:
        this.w = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  },
  getComponent: function (index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      case 2:
        return this.z;

      case 3:
        return this.w;

      default:
        throw new Error('index is out of range: ' + index);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y, this.z, this.w);
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== undefined ? v.w : 1;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  },
  addScaledVector: function (v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  },
  subScalar: function (s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  },
  multiplyScalar: function (scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  },
  applyMatrix4: function (m) {
    const x = this.x,
          y = this.y,
          z = this.z,
          w = this.w;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  },
  divideScalar: function (scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  setAxisAngleFromQuaternion: function (q) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
    // q is assumed to be normalized
    this.w = 2 * Math.acos(q.w);
    const s = Math.sqrt(1 - q.w * q.w);

    if (s < 0.0001) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }

    return this;
  },
  setAxisAngleFromRotationMatrix: function (m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    let angle, x, y, z; // variables for result

    const epsilon = 0.01,
          // margin to allow for rounding errors
    epsilon2 = 0.1,
          // margin to distinguish between 0 and 180 degrees
    te = m.elements,
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10];

    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      // singularity found
      // first check for identity matrix which must have +1 for all terms
      // in leading diagonal and zero in other terms
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        // this singularity is identity matrix so angle = 0
        this.set(1, 0, 0, 0);
        return this; // zero angle, arbitrary axis
      } // otherwise this singularity is angle = 180


      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;

      if (xx > yy && xx > zz) {
        // m11 is the largest diagonal term
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        // m22 is the largest diagonal term
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        // m33 is the largest diagonal term so base result on this
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }

      this.set(x, y, z, angle);
      return this; // return 180 deg rotation
    } // as we have reached here there are no singularities so we can handle normally


    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

    if (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be
    // caught by singularity test above, but I've left it in just in case

    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  },
  min: function (v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  },
  max: function (v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  },
  clamp: function (min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  },
  clampScalar: function (minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  },
  clampLength: function (min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  },
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  },
  roundToZero: function () {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  },
  negate: function () {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },
  manhattanLength: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },
  normalize: function () {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function (length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  },
  lerpVectors: function (v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  },
  fromBufferAttribute: function (attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  },
  random: function () {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
});
/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 */

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/

function WebGLRenderTarget(width, height, options) {
  this.width = width;
  this.height = height;
  this.scissor = new Vector4(0, 0, width, height);
  this.scissorTest = false;
  this.viewport = new Vector4(0, 0, width, height);
  options = options || {};
  this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
  this.texture.image = {};
  this.texture.image.width = width;
  this.texture.image.height = height;
  this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
  this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
  this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
  this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
}

WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: WebGLRenderTarget,
  isWebGLRenderTarget: true,
  setSize: function (width, height) {
    if (this.width !== width || this.height !== height) {
      this.width = width;
      this.height = height;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.dispose();
    }

    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.width = source.width;
    this.height = source.height;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.depthTexture = source.depthTexture;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});
/**
 * @author Mugen87 / https://github.com/Mugen87
 * @author Matt DesLauriers / @mattdesl
 */

function WebGLMultisampleRenderTarget(width, height, options) {
  WebGLRenderTarget.call(this, width, height, options);
  this.samples = 4;
}

WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
  constructor: WebGLMultisampleRenderTarget,
  isWebGLMultisampleRenderTarget: true,
  copy: function (source) {
    WebGLRenderTarget.prototype.copy.call(this, source);
    this.samples = source.samples;
    return this;
  }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Quaternion(x = 0, y = 0, z = 0, w = 1) {
  this._x = x;
  this._y = y;
  this._z = z;
  this._w = w;
}

Object.assign(Quaternion, {
  slerp: function (qa, qb, qm, t) {
    return qm.copy(qa).slerp(qb, t);
  },
  slerpFlat: function (dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    // fuzz-free, array-based Quaternion SLERP operation
    let x0 = src0[srcOffset0 + 0],
        y0 = src0[srcOffset0 + 1],
        z0 = src0[srcOffset0 + 2],
        w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0],
          y1 = src1[srcOffset1 + 1],
          z1 = src1[srcOffset1 + 2],
          w1 = src1[srcOffset1 + 3];

    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t,
          cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
          dir = cos >= 0 ? 1 : -1,
          sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin),
              len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }

      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }

    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  },
  multiplyQuaternionsFlat: function (dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
});
Object.defineProperties(Quaternion.prototype, {
  x: {
    get: function () {
      return this._x;
    },
    set: function (value) {
      this._x = value;

      this._onChangeCallback();
    }
  },
  y: {
    get: function () {
      return this._y;
    },
    set: function (value) {
      this._y = value;

      this._onChangeCallback();
    }
  },
  z: {
    get: function () {
      return this._z;
    },
    set: function (value) {
      this._z = value;

      this._onChangeCallback();
    }
  },
  w: {
    get: function () {
      return this._w;
    },
    set: function (value) {
      this._w = value;

      this._onChangeCallback();
    }
  }
});
Object.assign(Quaternion.prototype, {
  isQuaternion: true,
  set: function (x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;

    this._onChangeCallback();

    return this;
  },
  clone: function () {
    return new this.constructor(this._x, this._y, this._z, this._w);
  },
  copy: function (quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;

    this._onChangeCallback();

    return this;
  },
  setFromEuler: function (euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
    }

    const x = euler._x,
          y = euler._y,
          z = euler._z,
          order = euler.order; // http://www.mathworks.com/matlabcentral/fileexchange/
    // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //	content/SpinCalc.m

    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);

    switch (order) {
      case 'XYZ':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'YXZ':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      case 'ZXY':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'ZYX':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      case 'YZX':
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;

      case 'XZY':
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;

      default:
        console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
    }

    if (update !== false) this._onChangeCallback();
    return this;
  },
  setFromAxisAngle: function (axis, angle) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
    // assumes axis is normalized
    const halfAngle = angle / 2,
          s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);

    this._onChangeCallback();

    return this;
  },
  setFromRotationMatrix: function (m) {
    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    const te = m.elements,
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10],
          trace = m11 + m22 + m33;

    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1.0);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }

    this._onChangeCallback();

    return this;
  },
  setFromUnitVectors: function (vFrom, vTo) {
    // assumes direction vectors vFrom and vTo are normalized
    const EPS = 0.000001;
    let r = vFrom.dot(vTo) + 1;

    if (r < EPS) {
      r = 0;

      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }

    return this.normalize();
  },
  angleTo: function (q) {
    return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
  },
  rotateTowards: function (q, step) {
    const angle = this.angleTo(q);
    if (angle === 0) return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  },
  inverse: function () {
    // quaternion is assumed to have unit length
    return this.conjugate();
  },
  conjugate: function () {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;

    this._onChangeCallback();

    return this;
  },
  dot: function (v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  },
  lengthSq: function () {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },
  length: function () {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },
  normalize: function () {
    let l = this.length();

    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }

    this._onChangeCallback();

    return this;
  },
  multiply: function (q, p) {
    if (p !== undefined) {
      console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
      return this.multiplyQuaternions(q, p);
    }

    return this.multiplyQuaternions(this, q);
  },
  premultiply: function (q) {
    return this.multiplyQuaternions(q, this);
  },
  multiplyQuaternions: function (a, b) {
    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
    const qax = a._x,
          qay = a._y,
          qaz = a._z,
          qaw = a._w;
    const qbx = b._x,
          qby = b._y,
          qbz = b._z,
          qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    this._onChangeCallback();

    return this;
  },
  slerp: function (qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    const x = this._x,
          y = this._y,
          z = this._z,
          w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }

    if (cosHalfTheta >= 1.0) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }

    const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();

      this._onChangeCallback();

      return this;
    }

    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
          ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;

    this._onChangeCallback();

    return this;
  },
  equals: function (quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];

    this._onChangeCallback();

    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  },
  fromBufferAttribute: function (attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  },
  _onChange: function (callback) {
    this._onChangeCallback = callback;
    return this;
  },
  _onChangeCallback: function () {}
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

const _vector = new Vector3();

const _quaternion = new Quaternion();

function Vector3(x = 0, y = 0, z = 0) {
  this.x = x;
  this.y = y;
  this.z = z;
}

Object.assign(Vector3.prototype, {
  isVector3: true,
  set: function (x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  },
  setScalar: function (scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  },
  setX: function (x) {
    this.x = x;
    return this;
  },
  setY: function (y) {
    this.y = y;
    return this;
  },
  setZ: function (z) {
    this.z = z;
    return this;
  },
  setComponent: function (index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;

      case 1:
        this.y = value;
        break;

      case 2:
        this.z = value;
        break;

      default:
        throw new Error('index is out of range: ' + index);
    }

    return this;
  },
  getComponent: function (index) {
    switch (index) {
      case 0:
        return this.x;

      case 1:
        return this.y;

      case 2:
        return this.z;

      default:
        throw new Error('index is out of range: ' + index);
    }
  },
  clone: function () {
    return new this.constructor(this.x, this.y, this.z);
  },
  copy: function (v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  },
  add: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
      return this.addVectors(v, w);
    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  },
  addScalar: function (s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  },
  addScaledVector: function (v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  },
  sub: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
      return this.subVectors(v, w);
    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  },
  subScalar: function (s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  },
  multiply: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
      return this.multiplyVectors(v, w);
    }

    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  },
  multiplyScalar: function (scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  },
  multiplyVectors: function (a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  },
  applyEuler: function (euler) {
    if (!(euler && euler.isEuler)) {
      console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
    }

    return this.applyQuaternion(_quaternion.setFromEuler(euler));
  },
  applyAxisAngle: function (axis, angle) {
    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
  },
  applyMatrix3: function (m) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  },
  applyNormalMatrix: function (m) {
    return this.applyMatrix3(m).normalize();
  },
  applyMatrix4: function (m) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  },
  applyQuaternion: function (q) {
    const x = this.x,
          y = this.y,
          z = this.z;
    const qx = q.x,
          qy = q.y,
          qz = q.z,
          qw = q.w; // calculate quat * vector

    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  },
  project: function (camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  },
  unproject: function (camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  },
  transformDirection: function (m) {
    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction
    const x = this.x,
          y = this.y,
          z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  },
  divide: function (v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  },
  divideScalar: function (scalar) {
    return this.multiplyScalar(1 / scalar);
  },
  min: function (v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  },
  max: function (v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  },
  clamp: function (min, max) {
    // assumes min < max, componentwise
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  },
  clampScalar: function (minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  },
  clampLength: function (min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  },
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  },
  roundToZero: function () {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  },
  negate: function () {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  },
  dot: function (v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  },
  // TODO lengthSquared?
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  manhattanLength: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function () {
    return this.divideScalar(this.length() || 1);
  },
  setLength: function (length) {
    return this.normalize().multiplyScalar(length);
  },
  lerp: function (v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  },
  lerpVectors: function (v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  },
  cross: function (v, w) {
    if (w !== undefined) {
      console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
      return this.crossVectors(v, w);
    }

    return this.crossVectors(this, v);
  },
  crossVectors: function (a, b) {
    const ax = a.x,
          ay = a.y,
          az = a.z;
    const bx = b.x,
          by = b.y,
          bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  },
  projectOnVector: function (v) {
    const denominator = v.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  },
  projectOnPlane: function (planeNormal) {
    _vector.copy(this).projectOnVector(planeNormal);

    return this.sub(_vector);
  },
  reflect: function (normal) {
    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length
    return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
  },
  angleTo: function (v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator; // clamp, to handle numerical problems

    return Math.acos(MathUtils.clamp(theta, -1, 1));
  },
  distanceTo: function (v) {
    return Math.sqrt(this.distanceToSquared(v));
  },
  distanceToSquared: function (v) {
    const dx = this.x - v.x,
          dy = this.y - v.y,
          dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  },
  manhattanDistanceTo: function (v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  },
  setFromSpherical: function (s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  },
  setFromSphericalCoords: function (radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  },
  setFromCylindrical: function (c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  },
  setFromCylindricalCoords: function (radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  },
  setFromMatrixPosition: function (m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  },
  setFromMatrixScale: function (m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  },
  setFromMatrixColumn: function (m, index) {
    return this.fromArray(m.elements, index * 4);
  },
  setFromMatrix3Column: function (m, index) {
    return this.fromArray(m.elements, index * 3);
  },
  equals: function (v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  },
  fromBufferAttribute: function (attribute, index, offset) {
    if (offset !== undefined) {
      console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
    }

    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  },
  random: function () {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
});

const _v1 = new Vector3();

const _m1 = new Matrix4();

const _zero = new Vector3(0, 0, 0);

const _one = new Vector3(1, 1, 1);

const _x = new Vector3();

const _y = new Vector3();

const _z = new Vector3();
/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */


function Matrix4() {
  this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

  if (arguments.length > 0) {
    console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
  }
}

Object.assign(Matrix4.prototype, {
  isMatrix4: true,
  set: function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  clone: function () {
    return new Matrix4().fromArray(this.elements);
  },
  copy: function (m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  },
  copyPosition: function (m) {
    const te = this.elements,
          me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  },
  extractBasis: function (xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  },
  makeBasis: function (xAxis, yAxis, zAxis) {
    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
    return this;
  },
  extractRotation: function (m) {
    // this method does not support reflection matrices
    const te = this.elements;
    const me = m.elements;

    const scaleX = 1 / _v1.setFromMatrixColumn(m, 0).length();

    const scaleY = 1 / _v1.setFromMatrixColumn(m, 1).length();

    const scaleZ = 1 / _v1.setFromMatrixColumn(m, 2).length();

    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  },
  makeRotationFromEuler: function (euler) {
    if (!(euler && euler.isEuler)) {
      console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
    }

    const te = this.elements;
    const x = euler.x,
          y = euler.y,
          z = euler.z;
    const a = Math.cos(x),
          b = Math.sin(x);
    const c = Math.cos(y),
          d = Math.sin(y);
    const e = Math.cos(z),
          f = Math.sin(z);

    if (euler.order === 'XYZ') {
      const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === 'YXZ') {
      const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === 'ZXY') {
      const ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === 'ZYX') {
      const ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === 'YZX') {
      const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === 'XZY') {
      const ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    } // bottom row


    te[3] = 0;
    te[7] = 0;
    te[11] = 0; // last column

    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  },
  makeRotationFromQuaternion: function (q) {
    return this.compose(_zero, q, _one);
  },
  lookAt: function (eye, target, up) {
    const te = this.elements;

    _z.subVectors(eye, target);

    if (_z.lengthSq() === 0) {
      // eye and target are in the same position
      _z.z = 1;
    }

    _z.normalize();

    _x.crossVectors(up, _z);

    if (_x.lengthSq() === 0) {
      // up and z are parallel
      if (Math.abs(up.z) === 1) {
        _z.x += 0.0001;
      } else {
        _z.z += 0.0001;
      }

      _z.normalize();

      _x.crossVectors(up, _z);
    }

    _x.normalize();

    _y.crossVectors(_z, _x);

    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  },
  multiply: function (m, n) {
    if (n !== undefined) {
      console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
      return this.multiplyMatrices(m, n);
    }

    return this.multiplyMatrices(this, m);
  },
  premultiply: function (m) {
    return this.multiplyMatrices(m, this);
  },
  multiplyMatrices: function (a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
          a12 = ae[4],
          a13 = ae[8],
          a14 = ae[12];
    const a21 = ae[1],
          a22 = ae[5],
          a23 = ae[9],
          a24 = ae[13];
    const a31 = ae[2],
          a32 = ae[6],
          a33 = ae[10],
          a34 = ae[14];
    const a41 = ae[3],
          a42 = ae[7],
          a43 = ae[11],
          a44 = ae[15];
    const b11 = be[0],
          b12 = be[4],
          b13 = be[8],
          b14 = be[12];
    const b21 = be[1],
          b22 = be[5],
          b23 = be[9],
          b24 = be[13];
    const b31 = be[2],
          b32 = be[6],
          b33 = be[10],
          b34 = be[14];
    const b41 = be[3],
          b42 = be[7],
          b43 = be[11],
          b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  },
  multiplyScalar: function (s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  },
  determinant: function () {
    const te = this.elements;
    const n11 = te[0],
          n12 = te[4],
          n13 = te[8],
          n14 = te[12];
    const n21 = te[1],
          n22 = te[5],
          n23 = te[9],
          n24 = te[13];
    const n31 = te[2],
          n32 = te[6],
          n33 = te[10],
          n34 = te[14];
    const n41 = te[3],
          n42 = te[7],
          n43 = te[11],
          n44 = te[15]; //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  },
  transpose: function () {
    const te = this.elements;
    let tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  },
  setPosition: function (x, y, z) {
    const te = this.elements;

    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }

    return this;
  },
  getInverse: function (m, throwOnDegenerate) {
    if (throwOnDegenerate !== undefined) {
      console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
    } // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm


    const te = this.elements,
          me = m.elements,
          n11 = me[0],
          n21 = me[1],
          n31 = me[2],
          n41 = me[3],
          n12 = me[4],
          n22 = me[5],
          n32 = me[6],
          n42 = me[7],
          n13 = me[8],
          n23 = me[9],
          n33 = me[10],
          n43 = me[11],
          n14 = me[12],
          n24 = me[13],
          n34 = me[14],
          n44 = me[15],
          t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
          t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
          t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
          t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  },
  scale: function (v) {
    const te = this.elements;
    const x = v.x,
          y = v.y,
          z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  },
  getMaxScaleOnAxis: function () {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  },
  makeTranslation: function (x, y, z) {
    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
    return this;
  },
  makeRotationX: function (theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationY: function (theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationZ: function (theta) {
    const c = Math.cos(theta),
          s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationAxis: function (axis, angle) {
    // Based on http://www.gamedev.net/reference/articles/article1199.asp
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x,
          y = axis.y,
          z = axis.z;
    const tx = t * x,
          ty = t * y;
    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
    return this;
  },
  makeScale: function (x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  },
  makeShear: function (x, y, z) {
    this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
    return this;
  },
  compose: function (position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x,
          y = quaternion._y,
          z = quaternion._z,
          w = quaternion._w;
    const x2 = x + x,
          y2 = y + y,
          z2 = z + z;
    const xx = x * x2,
          xy = x * y2,
          xz = x * z2;
    const yy = y * y2,
          yz = y * z2,
          zz = z * z2;
    const wx = w * x2,
          wy = w * y2,
          wz = w * z2;
    const sx = scale.x,
          sy = scale.y,
          sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  },
  decompose: function (position, quaternion, scale) {
    const te = this.elements;

    let sx = _v1.set(te[0], te[1], te[2]).length();

    let sy = _v1.set(te[4], te[5], te[6]).length();

    let sz = _v1.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale


    const det = this.determinant();
    if (det < 0) sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14]; // scale the rotation part

    _m1.copy(this);

    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1.elements[0] *= invSX;
    _m1.elements[1] *= invSX;
    _m1.elements[2] *= invSX;
    _m1.elements[4] *= invSY;
    _m1.elements[5] *= invSY;
    _m1.elements[6] *= invSY;
    _m1.elements[8] *= invSZ;
    _m1.elements[9] *= invSZ;
    _m1.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  },
  makePerspective: function (left, right, top, bottom, near, far) {
    if (far === undefined) {
      console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
    }

    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    const c = -(far + near) / (far - near);
    const d = -2 * far * near / (far - near);
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  },
  makeOrthographic: function (left, right, top, bottom, near, far) {
    const te = this.elements;
    const w = 1.0 / (right - left);
    const h = 1.0 / (top - bottom);
    const p = 1.0 / (far - near);
    const x = (right + left) * w;
    const y = (top + bottom) * h;
    const z = (far + near) * p;
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = -2 * p;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  },
  equals: function (matrix) {
    const te = this.elements;
    const me = matrix.elements;

    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false;
    }

    return true;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;

    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }

    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

const _matrix = new Matrix4();

const _quaternion$1 = new Quaternion();

function Euler(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
  this._x = x;
  this._y = y;
  this._z = z;
  this._order = order;
}

Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
Euler.DefaultOrder = 'XYZ';
Object.defineProperties(Euler.prototype, {
  x: {
    get: function () {
      return this._x;
    },
    set: function (value) {
      this._x = value;

      this._onChangeCallback();
    }
  },
  y: {
    get: function () {
      return this._y;
    },
    set: function (value) {
      this._y = value;

      this._onChangeCallback();
    }
  },
  z: {
    get: function () {
      return this._z;
    },
    set: function (value) {
      this._z = value;

      this._onChangeCallback();
    }
  },
  order: {
    get: function () {
      return this._order;
    },
    set: function (value) {
      this._order = value;

      this._onChangeCallback();
    }
  }
});
Object.assign(Euler.prototype, {
  isEuler: true,
  set: function (x, y, z, order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;

    this._onChangeCallback();

    return this;
  },
  clone: function () {
    return new this.constructor(this._x, this._y, this._z, this._order);
  },
  copy: function (euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;

    this._onChangeCallback();

    return this;
  },
  setFromRotationMatrix: function (m, order, update) {
    const clamp = MathUtils.clamp; // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    const te = m.elements;
    const m11 = te[0],
          m12 = te[4],
          m13 = te[8];
    const m21 = te[1],
          m22 = te[5],
          m23 = te[9];
    const m31 = te[2],
          m32 = te[6],
          m33 = te[10];
    order = order || this._order;

    switch (order) {
      case 'XYZ':
        this._y = Math.asin(clamp(m13, -1, 1));

        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }

        break;

      case 'YXZ':
        this._x = Math.asin(-clamp(m23, -1, 1));

        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }

        break;

      case 'ZXY':
        this._x = Math.asin(clamp(m32, -1, 1));

        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }

        break;

      case 'ZYX':
        this._y = Math.asin(-clamp(m31, -1, 1));

        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }

        break;

      case 'YZX':
        this._z = Math.asin(clamp(m21, -1, 1));

        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }

        break;

      case 'XZY':
        this._z = Math.asin(-clamp(m12, -1, 1));

        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }

        break;

      default:
        console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
    }

    this._order = order;
    if (update !== false) this._onChangeCallback();
    return this;
  },
  setFromQuaternion: function (q, order, update) {
    _matrix.makeRotationFromQuaternion(q);

    return this.setFromRotationMatrix(_matrix, order, update);
  },
  setFromVector3: function (v, order) {
    return this.set(v.x, v.y, v.z, order || this._order);
  },
  reorder: function (newOrder) {
    // WARNING: this discards revolution information -bhouston
    _quaternion$1.setFromEuler(this);

    return this.setFromQuaternion(_quaternion$1, newOrder);
  },
  equals: function (euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  },
  fromArray: function (array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== undefined) this._order = array[3];

    this._onChangeCallback();

    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  },
  toVector3: function (optionalResult) {
    if (optionalResult) {
      return optionalResult.set(this._x, this._y, this._z);
    } else {
      return new Vector3(this._x, this._y, this._z);
    }
  },
  _onChange: function (callback) {
    this._onChangeCallback = callback;
    return this;
  },
  _onChangeCallback: function () {}
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function Layers() {
  this.mask = 1 | 0;
}

Object.assign(Layers.prototype, {
  set: function (channel) {
    this.mask = 1 << channel | 0;
  },
  enable: function (channel) {
    this.mask |= 1 << channel | 0;
  },
  enableAll: function () {
    this.mask = 0xffffffff | 0;
  },
  toggle: function (channel) {
    this.mask ^= 1 << channel | 0;
  },
  disable: function (channel) {
    this.mask &= ~(1 << channel | 0);
  },
  disableAll: function () {
    this.mask = 0;
  },
  test: function (layers) {
    return (this.mask & layers.mask) !== 0;
  }
});
let _object3DId = 0;

const _v1$1 = new Vector3();

const _q1 = new Quaternion();

const _m1$1 = new Matrix4();

const _target = new Vector3();

const _position = new Vector3();

const _scale = new Vector3();

const _quaternion$2 = new Quaternion();

const _xAxis = new Vector3(1, 0, 0);

const _yAxis = new Vector3(0, 1, 0);

const _zAxis = new Vector3(0, 0, 1);

const _addedEvent = {
  type: 'added'
};
const _removedEvent = {
  type: 'removed'
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

function Object3D() {
  Object.defineProperty(this, 'id', {
    value: _object3DId++
  });
  this.uuid = MathUtils.generateUUID();
  this.name = '';
  this.type = 'Object3D';
  this.parent = null;
  this.children = [];
  this.up = Object3D.DefaultUp.clone();
  const position = new Vector3();
  const rotation = new Euler();
  const quaternion = new Quaternion();
  const scale = new Vector3(1, 1, 1);

  function onRotationChange() {
    quaternion.setFromEuler(rotation, false);
  }

  function onQuaternionChange() {
    rotation.setFromQuaternion(quaternion, undefined, false);
  }

  rotation._onChange(onRotationChange);

  quaternion._onChange(onQuaternionChange);

  Object.defineProperties(this, {
    position: {
      configurable: true,
      enumerable: true,
      value: position
    },
    rotation: {
      configurable: true,
      enumerable: true,
      value: rotation
    },
    quaternion: {
      configurable: true,
      enumerable: true,
      value: quaternion
    },
    scale: {
      configurable: true,
      enumerable: true,
      value: scale
    },
    modelViewMatrix: {
      value: new Matrix4()
    },
    normalMatrix: {
      value: new Matrix3()
    }
  });
  this.matrix = new Matrix4();
  this.matrixWorld = new Matrix4();
  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;
  this.layers = new Layers();
  this.visible = true;
  this.castShadow = false;
  this.receiveShadow = false;
  this.frustumCulled = true;
  this.renderOrder = 0;
  this.userData = {};
}

Object3D.DefaultUp = new Vector3(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Object3D,
  isObject3D: true,
  onBeforeRender: function () {},
  onAfterRender: function () {},
  applyMatrix4: function (matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  applyQuaternion: function (q) {
    this.quaternion.premultiply(q);
    return this;
  },
  setRotationFromAxisAngle: function (axis, angle) {
    // assumes axis is normalized
    this.quaternion.setFromAxisAngle(axis, angle);
  },
  setRotationFromEuler: function (euler) {
    this.quaternion.setFromEuler(euler, true);
  },
  setRotationFromMatrix: function (m) {
    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    this.quaternion.setFromRotationMatrix(m);
  },
  setRotationFromQuaternion: function (q) {
    // assumes q is normalized
    this.quaternion.copy(q);
  },
  rotateOnAxis: function (axis, angle) {
    // rotate object on axis in object space
    // axis is assumed to be normalized
    _q1.setFromAxisAngle(axis, angle);

    this.quaternion.multiply(_q1);
    return this;
  },
  rotateOnWorldAxis: function (axis, angle) {
    // rotate object on axis in world space
    // axis is assumed to be normalized
    // method assumes no rotated parent
    _q1.setFromAxisAngle(axis, angle);

    this.quaternion.premultiply(_q1);
    return this;
  },
  rotateX: function (angle) {
    return this.rotateOnAxis(_xAxis, angle);
  },
  rotateY: function (angle) {
    return this.rotateOnAxis(_yAxis, angle);
  },
  rotateZ: function (angle) {
    return this.rotateOnAxis(_zAxis, angle);
  },
  translateOnAxis: function (axis, distance) {
    // translate object by distance along axis in object space
    // axis is assumed to be normalized
    _v1$1.copy(axis).applyQuaternion(this.quaternion);

    this.position.add(_v1$1.multiplyScalar(distance));
    return this;
  },
  translateX: function (distance) {
    return this.translateOnAxis(_xAxis, distance);
  },
  translateY: function (distance) {
    return this.translateOnAxis(_yAxis, distance);
  },
  translateZ: function (distance) {
    return this.translateOnAxis(_zAxis, distance);
  },
  localToWorld: function (vector) {
    return vector.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function (vector) {
    return vector.applyMatrix4(_m1$1.getInverse(this.matrixWorld));
  },
  lookAt: function (x, y, z) {
    // This method does not support objects having non-uniformly-scaled parent(s)
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }

    const parent = this.parent;
    this.updateWorldMatrix(true, false);

    _position.setFromMatrixPosition(this.matrixWorld);

    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position, this.up);
    }

    this.quaternion.setFromRotationMatrix(_m1$1);

    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);

      _q1.setFromRotationMatrix(_m1$1);

      this.quaternion.premultiply(_q1.inverse());
    }
  },
  add: function (object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }

      return this;
    }

    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }

    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }

      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }

    return this;
  },
  remove: function (object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }

      return this;
    }

    const index = this.children.indexOf(object);

    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }

    return this;
  },
  attach: function (object) {
    // adds object as a child of this, while maintaining the object's world transform
    this.updateWorldMatrix(true, false);

    _m1$1.getInverse(this.matrixWorld);

    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);

      _m1$1.multiply(object.parent.matrixWorld);
    }

    object.applyMatrix4(_m1$1);
    object.updateWorldMatrix(false, false);
    this.add(object);
    return this;
  },
  getObjectById: function (id) {
    return this.getObjectByProperty('id', id);
  },
  getObjectByName: function (name) {
    return this.getObjectByProperty('name', name);
  },
  getObjectByProperty: function (name, value) {
    if (this[name] === value) return this;

    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name, value);

      if (object !== undefined) {
        return object;
      }
    }

    return undefined;
  },
  getWorldPosition: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldPosition() target is now required');
      target = new Vector3();
    }

    this.updateMatrixWorld(true);
    return target.setFromMatrixPosition(this.matrixWorld);
  },
  getWorldQuaternion: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
      target = new Quaternion();
    }

    this.updateMatrixWorld(true);
    this.matrixWorld.decompose(_position, target, _scale);
    return target;
  },
  getWorldScale: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldScale() target is now required');
      target = new Vector3();
    }

    this.updateMatrixWorld(true);
    this.matrixWorld.decompose(_position, _quaternion$2, target);
    return target;
  },
  getWorldDirection: function (target) {
    if (target === undefined) {
      console.warn('THREE.Object3D: .getWorldDirection() target is now required');
      target = new Vector3();
    }

    this.updateMatrixWorld(true);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  },
  raycast: function () {},
  traverse: function (callback) {
    callback(this);
    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  },
  traverseVisible: function (callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  },
  traverseAncestors: function (callback) {
    const parent = this.parent;

    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  },
  updateMatrix: function () {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  },
  updateMatrixWorld: function (force) {
    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }

      this.matrixWorldNeedsUpdate = false;
      force = true;
    } // update children


    const children = this.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(force);
    }
  },
  updateWorldMatrix: function (updateParents, updateChildren) {
    const parent = this.parent;

    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }

    if (this.matrixAutoUpdate) this.updateMatrix();

    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    } // update children


    if (updateChildren === true) {
      const children = this.children;

      for (let i = 0, l = children.length; i < l; i++) {
        children[i].updateWorldMatrix(false, true);
      }
    }
  },
  toJSON: function (meta) {
    // meta is a string when called from JSON.stringify
    const isRootObject = meta === undefined || typeof meta === 'string';
    const output = {}; // meta is a hash used to collect geometries, materials.
    // not providing it implies that this is the root object
    // being serialized.

    if (isRootObject) {
      // initialize meta obj
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {}
      };
      output.metadata = {
        version: 4.5,
        type: 'Object',
        generator: 'Object3D.toJSON'
      };
    } // standard Object3D serialization


    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== '') object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties

    if (this.isInstancedMesh) {
      object.type = 'InstancedMesh';
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
    } //


    function serialize(library, element) {
      if (library[element.uuid] === undefined) {
        library[element.uuid] = element.toJSON(meta);
      }

      return element.uuid;
    }

    if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;

      if (parameters !== undefined && parameters.shapes !== undefined) {
        const shapes = parameters.shapes;

        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }

    if (this.material !== undefined) {
      if (Array.isArray(this.material)) {
        const uuids = [];

        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }

        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    } //


    if (this.children.length > 0) {
      object.children = [];

      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }

    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
    }

    output.object = object;
    return output; // extract data from the cache hash
    // remove metadata on each item
    // and return as array

    function extractFromCache(cache) {
      const values = [];

      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }

      return values;
    }
  },
  clone: function (recursive) {
    return new this.constructor().copy(this, recursive);
  },
  copy: function (source, recursive) {
    if (recursive === undefined) recursive = true;
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.userData = JSON.parse(JSON.stringify(source.userData));

    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }

    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function Scene() {
  Object3D.call(this);
  this.type = 'Scene';
  this.background = null;
  this.environment = null;
  this.fog = null;
  this.overrideMaterial = null;
  this.autoUpdate = true; // checked by the renderer

  if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
      detail: this
    })); // eslint-disable-line no-undef

  }
}

Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Scene,
  isScene: true,
  copy: function (source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    if (source.background !== null) this.background = source.background.clone();
    if (source.environment !== null) this.environment = source.environment.clone();
    if (source.fog !== null) this.fog = source.fog.clone();
    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
    this.autoUpdate = source.autoUpdate;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  },
  toJSON: function (meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    if (this.background !== null) data.object.background = this.background.toJSON(meta);
    if (this.environment !== null) data.object.environment = this.environment.toJSON(meta);
    if (this.fog !== null) data.object.fog = this.fog.toJSON();
    return data;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});
const _points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];

const _vector$1 = new Vector3();

const _box = new Box3(); // triangle centered vertices


const _v0 = new Vector3();

const _v1$2 = new Vector3();

const _v2 = new Vector3(); // triangle edge vectors


const _f0 = new Vector3();

const _f1 = new Vector3();

const _f2 = new Vector3();

const _center = new Vector3();

const _extents = new Vector3();

const _triangleNormal = new Vector3();

const _testAxis = new Vector3();
/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */


function Box3(min, max) {
  this.min = min !== undefined ? min : new Vector3(+Infinity, +Infinity, +Infinity);
  this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);
}

Object.assign(Box3.prototype, {
  isBox3: true,
  set: function (min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  },
  setFromArray: function (array) {
    let minX = +Infinity;
    let minY = +Infinity;
    let minZ = +Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;

    for (let i = 0, l = array.length; i < l; i += 3) {
      const x = array[i];
      const y = array[i + 1];
      const z = array[i + 2];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }

    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  },
  setFromBufferAttribute: function (attribute) {
    let minX = +Infinity;
    let minY = +Infinity;
    let minZ = +Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let maxZ = -Infinity;

    for (let i = 0, l = attribute.count; i < l; i++) {
      const x = attribute.getX(i);
      const y = attribute.getY(i);
      const z = attribute.getZ(i);
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (z < minZ) minZ = z;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      if (z > maxZ) maxZ = z;
    }

    this.min.set(minX, minY, minZ);
    this.max.set(maxX, maxY, maxZ);
    return this;
  },
  setFromPoints: function (points) {
    this.makeEmpty();

    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }

    return this;
  },
  setFromCenterAndSize: function (center, size) {
    const halfSize = _vector$1.copy(size).multiplyScalar(0.5);

    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  },
  setFromObject: function (object) {
    this.makeEmpty();
    return this.expandByObject(object);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = this.min.z = +Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  },
  isEmpty: function () {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },
  getCenter: function (target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .getCenter() target is now required');
      target = new Vector3();
    }

    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function (target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .getSize() target is now required');
      target = new Vector3();
    }

    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  },
  expandByPoint: function (point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function (vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function (scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  },
  expandByObject: function (object) {
    // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and children's, world transforms
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;

    if (geometry !== undefined) {
      if (geometry.boundingBox === null) {
        geometry.computeBoundingBox();
      }

      _box.copy(geometry.boundingBox);

      _box.applyMatrix4(object.matrixWorld);

      this.union(_box);
    }

    const children = object.children;

    for (let i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i]);
    }

    return this;
  },
  containsPoint: function (point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  },
  containsBox: function (box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  },
  getParameter: function (point, target) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.
    if (target === undefined) {
      console.warn('THREE.Box3: .getParameter() target is now required');
      target = new Vector3();
    }

    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
  },
  intersectsBox: function (box) {
    // using 6 splitting planes to rule out intersections.
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  },
  intersectsSphere: function (sphere) {
    // Find the point on the AABB closest to the sphere center.
    this.clampPoint(sphere.center, _vector$1); // If that point is inside the sphere, the AABB and sphere intersect.

    return _vector$1.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  },
  intersectsPlane: function (plane) {
    // We compute the minimum and maximum dot product values. If those values
    // are on the same side (back or front) of the plane, then there is no intersection.
    let min, max;

    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }

    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }

    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }

    return min <= -plane.constant && max >= -plane.constant;
  },
  intersectsTriangle: function (triangle) {
    if (this.isEmpty()) {
      return false;
    } // compute box center and extents


    this.getCenter(_center);

    _extents.subVectors(this.max, _center); // translate triangle to aabb origin


    _v0.subVectors(triangle.a, _center);

    _v1$2.subVectors(triangle.b, _center);

    _v2.subVectors(triangle.c, _center); // compute edge vectors for triangle


    _f0.subVectors(_v1$2, _v0);

    _f1.subVectors(_v2, _v1$2);

    _f2.subVectors(_v0, _v2); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
    // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
    // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)


    let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];

    if (!satForAxes(axes, _v0, _v1$2, _v2, _extents)) {
      return false;
    } // test 3 face normals from the aabb


    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

    if (!satForAxes(axes, _v0, _v1$2, _v2, _extents)) {
      return false;
    } // finally testing the face normal of the triangle
    // use already existing triangle edge vectors here


    _triangleNormal.crossVectors(_f0, _f1);

    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0, _v1$2, _v2, _extents);
  },
  clampPoint: function (point, target) {
    if (target === undefined) {
      console.warn('THREE.Box3: .clampPoint() target is now required');
      target = new Vector3();
    }

    return target.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function (point) {
    const clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);

    return clampedPoint.sub(point).length();
  },
  getBoundingSphere: function (target) {
    if (target === undefined) {
      console.error('THREE.Box3: .getBoundingSphere() target is now required'); //target = new Sphere(); // removed to avoid cyclic dependency
    }

    this.getCenter(target.center);
    target.radius = this.getSize(_vector$1).length() * 0.5;
    return target;
  },
  intersect: function (box) {
    this.min.max(box.min);
    this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

    if (this.isEmpty()) this.makeEmpty();
    return this;
  },
  union: function (box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  applyMatrix4: function (matrix) {
    // transform of empty box is an empty box.
    if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below

    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000


    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001


    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010


    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011


    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100


    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101


    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110


    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111


    this.setFromPoints(_points);
    return this;
  },
  translate: function (offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  },
  equals: function (box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
});

function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i); // project the aabb onto the seperating axis


    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the seperating axis

    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r

    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      // points of the projected triangle are outside the projected half-length of the aabb
      // the axis is seperating and we can exit
      return false;
    }
  }

  return true;
}

const _box$1 = new Box3();
/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */


function Sphere(center, radius) {
  this.center = center !== undefined ? center : new Vector3();
  this.radius = radius !== undefined ? radius : -1;
}

Object.assign(Sphere.prototype, {
  set: function (center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  },
  setFromPoints: function (points, optionalCenter) {
    const center = this.center;

    if (optionalCenter !== undefined) {
      center.copy(optionalCenter);
    } else {
      _box$1.setFromPoints(points).getCenter(center);
    }

    let maxRadiusSq = 0;

    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }

    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  },
  isEmpty: function () {
    return this.radius < 0;
  },
  makeEmpty: function () {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  },
  containsPoint: function (point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function (point) {
    return point.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function (sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  },
  intersectsBox: function (box) {
    return box.intersectsSphere(this);
  },
  intersectsPlane: function (plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  },
  clampPoint: function (point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);

    if (target === undefined) {
      console.warn('THREE.Sphere: .clampPoint() target is now required');
      target = new Vector3();
    }

    target.copy(point);

    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }

    return target;
  },
  getBoundingBox: function (target) {
    if (target === undefined) {
      console.warn('THREE.Sphere: .getBoundingBox() target is now required');
      target = new Box3();
    }

    if (this.isEmpty()) {
      // Empty sphere produces empty bounding box
      target.makeEmpty();
      return target;
    }

    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  },
  applyMatrix4: function (matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  },
  translate: function (offset) {
    this.center.add(offset);
    return this;
  },
  equals: function (sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
});

const _vector$2 = new Vector3();

const _segCenter = new Vector3();

const _segDir = new Vector3();

const _diff = new Vector3();

const _edge1 = new Vector3();

const _edge2 = new Vector3();

const _normal = new Vector3();
/**
 * @author bhouston / http://clara.io
 */


function Ray(origin, direction) {
  this.origin = origin !== undefined ? origin : new Vector3();
  this.direction = direction !== undefined ? direction : new Vector3(0, 0, -1);
}

Object.assign(Ray.prototype, {
  set: function (origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  },
  at: function (t, target) {
    if (target === undefined) {
      console.warn('THREE.Ray: .at() target is now required');
      target = new Vector3();
    }

    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
  },
  lookAt: function (v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  },
  recast: function (t) {
    this.origin.copy(this.at(t, _vector$2));
    return this;
  },
  closestPointToPoint: function (point, target) {
    if (target === undefined) {
      console.warn('THREE.Ray: .closestPointToPoint() target is now required');
      target = new Vector3();
    }

    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);

    if (directionDistance < 0) {
      return target.copy(this.origin);
    }

    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
  },
  distanceToPoint: function (point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  },
  distanceSqToPoint: function (point) {
    const directionDistance = _vector$2.subVectors(point, this.origin).dot(this.direction); // point behind the ray


    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }

    _vector$2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

    return _vector$2.distanceToSquared(point);
  },
  distanceSqToSegment: function (v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
    // It returns the min distance between the ray and the segment
    // defined by v0 and v1
    // It can also set two optional targets :
    // - The closest point on the ray
    // - The closest point on the segment
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);

    _segDir.copy(v1).sub(v0).normalize();

    _diff.copy(this.origin).sub(_segCenter);

    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);

    const b0 = _diff.dot(this.direction);

    const b1 = -_diff.dot(_segDir);

    const c = _diff.lengthSq();

    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;

    if (det > 0) {
      // The ray and segment are not parallel.
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;

      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            // region 0
            // Minimum at interior points of ray and segment.
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            // region 1
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          // region 5
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          // region 4
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          // region 3
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          // region 2
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      // Ray and segment are parallel.
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }

    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
    }

    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
    }

    return sqrDist;
  },
  intersectSphere: function (sphere, target) {
    _vector$2.subVectors(sphere.center, this.origin);

    const tca = _vector$2.dot(this.direction);

    const d2 = _vector$2.dot(_vector$2) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2) return null;
    const thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere

    const t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere

    const t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null

    if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:
    // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
    // in order to always return an intersect point that is in front of the ray.

    if (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0

    return this.at(t0, target);
  },
  intersectsSphere: function (sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  },
  distanceToPlane: function (plane) {
    const denominator = plane.normal.dot(this.direction);

    if (denominator === 0) {
      // line is coplanar, return origin
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      } // Null is preferable to undefined since undefined means.... it is undefined


      return null;
    }

    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane

    return t >= 0 ? t : null;
  },
  intersectPlane: function (plane, target) {
    const t = this.distanceToPlane(plane);

    if (t === null) {
      return null;
    }

    return this.at(t, target);
  },
  intersectsPlane: function (plane) {
    // check if the ray lies on the plane first
    const distToPoint = plane.distanceToPoint(this.origin);

    if (distToPoint === 0) {
      return true;
    }

    const denominator = plane.normal.dot(this.direction);

    if (denominator * distToPoint < 0) {
      return true;
    } // ray origin is behind the plane (and is pointing behind it)


    return false;
  },
  intersectBox: function (box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x,
          invdiry = 1 / this.direction.y,
          invdirz = 1 / this.direction.z;
    const origin = this.origin;

    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }

    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }

    if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN
    // (result of 0 * Infinity). x !== x returns true if x is NaN

    if (tymin > tmin || tmin !== tmin) tmin = tymin;
    if (tymax < tmax || tmax !== tmax) tmax = tymax;

    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }

    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)

    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  },
  intersectsBox: function (box) {
    return this.intersectBox(box, _vector$2) !== null;
  },
  intersectTriangle: function (a, b, c, backfaceCulling, target) {
    // Compute the offset origin, edges, and normal.
    // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
    _edge1.subVectors(b, a);

    _edge2.subVectors(c, a);

    _normal.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
    // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
    //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
    //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
    //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)


    let DdN = this.direction.dot(_normal);
    let sign;

    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign = 1;
    } else if (DdN < 0) {
      sign = -1;
      DdN = -DdN;
    } else {
      return null;
    }

    _diff.subVectors(this.origin, a);

    const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection

    if (DdQxE2 < 0) {
      return null;
    }

    const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection

    if (DdE1xQ < 0) {
      return null;
    } // b1+b2 > 1, no intersection


    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    } // Line intersects triangle, check if ray does.


    const QdN = -sign * _diff.dot(_normal); // t < 0, no intersection


    if (QdN < 0) {
      return null;
    } // Ray intersects triangle.


    return this.at(QdN / DdN, target);
  },
  applyMatrix4: function (matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  },
  equals: function (ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
});
/**
 * @author bhouston / http://clara.io
 */

const _vector1 = new Vector3();

const _vector2 = new Vector3();

const _normalMatrix = new Matrix3();

function Plane(normal, constant) {
  // normal is assumed to be normalized
  this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
  this.constant = constant !== undefined ? constant : 0;
}

Object.assign(Plane.prototype, {
  isPlane: true,
  set: function (normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  },
  setComponents: function (x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  },
  setFromNormalAndCoplanarPoint: function (normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  },
  setFromCoplanarPoints: function (a, b, c) {
    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?


    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  },
  normalize: function () {
    // Note: will lead to a divide by zero if the plane is invalid.
    const inverseNormalLength = 1.0 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  },
  negate: function () {
    this.constant *= -1;
    this.normal.negate();
    return this;
  },
  distanceToPoint: function (point) {
    return this.normal.dot(point) + this.constant;
  },
  distanceToSphere: function (sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  },
  projectPoint: function (point, target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .projectPoint() target is now required');
      target = new Vector3();
    }

    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
  },
  intersectLine: function (line, target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .intersectLine() target is now required');
      target = new Vector3();
    }

    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);

    if (denominator === 0) {
      // line is coplanar, return origin
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      } // Unsure if this is the correct method to handle this case.


      return undefined;
    }

    const t = -(line.start.dot(this.normal) + this.constant) / denominator;

    if (t < 0 || t > 1) {
      return undefined;
    }

    return target.copy(direction).multiplyScalar(t).add(line.start);
  },
  intersectsLine: function (line) {
    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  },
  intersectsBox: function (box) {
    return box.intersectsPlane(this);
  },
  intersectsSphere: function (sphere) {
    return sphere.intersectsPlane(this);
  },
  coplanarPoint: function (target) {
    if (target === undefined) {
      console.warn('THREE.Plane: .coplanarPoint() target is now required');
      target = new Vector3();
    }

    return target.copy(this.normal).multiplyScalar(-this.constant);
  },
  applyMatrix4: function (matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);

    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  },
  translate: function (offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  },
  equals: function (plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
});
/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

const _v0$1 = new Vector3();

const _v1$3 = new Vector3();

const _v2$1 = new Vector3();

const _v3 = new Vector3();

const _vab = new Vector3();

const _vac = new Vector3();

const _vbc = new Vector3();

const _vap = new Vector3();

const _vbp = new Vector3();

const _vcp = new Vector3();

function Triangle(a, b, c) {
  this.a = a !== undefined ? a : new Vector3();
  this.b = b !== undefined ? b : new Vector3();
  this.c = c !== undefined ? c : new Vector3();
}

Object.assign(Triangle, {
  getNormal: function (a, b, c, target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getNormal() target is now required');
      target = new Vector3();
    }

    target.subVectors(c, b);

    _v0$1.subVectors(a, b);

    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();

    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }

    return target.set(0, 0, 0);
  },
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  getBarycoord: function (point, a, b, c, target) {
    _v0$1.subVectors(c, a);

    _v1$3.subVectors(b, a);

    _v2$1.subVectors(point, a);

    const dot00 = _v0$1.dot(_v0$1);

    const dot01 = _v0$1.dot(_v1$3);

    const dot02 = _v0$1.dot(_v2$1);

    const dot11 = _v1$3.dot(_v1$3);

    const dot12 = _v1$3.dot(_v2$1);

    const denom = dot00 * dot11 - dot01 * dot01;

    if (target === undefined) {
      console.warn('THREE.Triangle: .getBarycoord() target is now required');
      target = new Vector3();
    } // collinear or singular triangle


    if (denom === 0) {
      // arbitrary location outside of triangle?
      // not sure if this is the best idea, maybe should be returning undefined
      return target.set(-2, -1, -1);
    }

    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1

    return target.set(1 - u - v, v, u);
  },
  containsPoint: function (point, a, b, c) {
    Triangle.getBarycoord(point, a, b, c, _v3);
    return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
  },
  getUV: function (point, p1, p2, p3, uv1, uv2, uv3, target) {
    this.getBarycoord(point, p1, p2, p3, _v3);
    target.set(0, 0);
    target.addScaledVector(uv1, _v3.x);
    target.addScaledVector(uv2, _v3.y);
    target.addScaledVector(uv3, _v3.z);
    return target;
  },
  isFrontFacing: function (a, b, c, direction) {
    _v0$1.subVectors(c, b);

    _v1$3.subVectors(a, b); // strictly front facing


    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
});
Object.assign(Triangle.prototype, {
  set: function (a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  },
  setFromPointsAndIndices: function (points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  },
  getArea: function () {
    _v0$1.subVectors(this.c, this.b);

    _v1$3.subVectors(this.a, this.b);

    return _v0$1.cross(_v1$3).length() * 0.5;
  },
  getMidpoint: function (target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getMidpoint() target is now required');
      target = new Vector3();
    }

    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },
  getNormal: function (target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  },
  getPlane: function (target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .getPlane() target is now required');
      target = new Plane();
    }

    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  },
  getBarycoord: function (point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  },
  getUV: function (point, uv1, uv2, uv3, target) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  },
  containsPoint: function (point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  },
  isFrontFacing: function (direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  },
  intersectsBox: function (box) {
    return box.intersectsTriangle(this);
  },
  closestPointToPoint: function (p, target) {
    if (target === undefined) {
      console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
      target = new Vector3();
    }

    const a = this.a,
          b = this.b,
          c = this.c;
    let v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
    // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
    // under the accompanying license; see chapter 5.1.5 for detailed explanation.
    // basically, we're distinguishing which of the voronoi regions of the triangle
    // the point lies in with the minimum amount of redundant computation.

    _vab.subVectors(b, a);

    _vac.subVectors(c, a);

    _vap.subVectors(p, a);

    const d1 = _vab.dot(_vap);

    const d2 = _vac.dot(_vap);

    if (d1 <= 0 && d2 <= 0) {
      // vertex region of A; barycentric coords (1, 0, 0)
      return target.copy(a);
    }

    _vbp.subVectors(p, b);

    const d3 = _vab.dot(_vbp);

    const d4 = _vac.dot(_vbp);

    if (d3 >= 0 && d4 <= d3) {
      // vertex region of B; barycentric coords (0, 1, 0)
      return target.copy(b);
    }

    const vc = d1 * d4 - d3 * d2;

    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)

      return target.copy(a).addScaledVector(_vab, v);
    }

    _vcp.subVectors(p, c);

    const d5 = _vab.dot(_vcp);

    const d6 = _vac.dot(_vcp);

    if (d6 >= 0 && d5 <= d6) {
      // vertex region of C; barycentric coords (0, 0, 1)
      return target.copy(c);
    }

    const vb = d5 * d2 - d1 * d6;

    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)

      return target.copy(a).addScaledVector(_vac, w);
    }

    const va = d3 * d6 - d5 * d4;

    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);

      w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)

      return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
    } // face region


    const denom = 1 / (va + vb + vc); // u = va * denom

    v = vb * denom;
    w = vc * denom;
    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
  },
  equals: function (triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

const _colorKeywords = {
  'aliceblue': 0xF0F8FF,
  'antiquewhite': 0xFAEBD7,
  'aqua': 0x00FFFF,
  'aquamarine': 0x7FFFD4,
  'azure': 0xF0FFFF,
  'beige': 0xF5F5DC,
  'bisque': 0xFFE4C4,
  'black': 0x000000,
  'blanchedalmond': 0xFFEBCD,
  'blue': 0x0000FF,
  'blueviolet': 0x8A2BE2,
  'brown': 0xA52A2A,
  'burlywood': 0xDEB887,
  'cadetblue': 0x5F9EA0,
  'chartreuse': 0x7FFF00,
  'chocolate': 0xD2691E,
  'coral': 0xFF7F50,
  'cornflowerblue': 0x6495ED,
  'cornsilk': 0xFFF8DC,
  'crimson': 0xDC143C,
  'cyan': 0x00FFFF,
  'darkblue': 0x00008B,
  'darkcyan': 0x008B8B,
  'darkgoldenrod': 0xB8860B,
  'darkgray': 0xA9A9A9,
  'darkgreen': 0x006400,
  'darkgrey': 0xA9A9A9,
  'darkkhaki': 0xBDB76B,
  'darkmagenta': 0x8B008B,
  'darkolivegreen': 0x556B2F,
  'darkorange': 0xFF8C00,
  'darkorchid': 0x9932CC,
  'darkred': 0x8B0000,
  'darksalmon': 0xE9967A,
  'darkseagreen': 0x8FBC8F,
  'darkslateblue': 0x483D8B,
  'darkslategray': 0x2F4F4F,
  'darkslategrey': 0x2F4F4F,
  'darkturquoise': 0x00CED1,
  'darkviolet': 0x9400D3,
  'deeppink': 0xFF1493,
  'deepskyblue': 0x00BFFF,
  'dimgray': 0x696969,
  'dimgrey': 0x696969,
  'dodgerblue': 0x1E90FF,
  'firebrick': 0xB22222,
  'floralwhite': 0xFFFAF0,
  'forestgreen': 0x228B22,
  'fuchsia': 0xFF00FF,
  'gainsboro': 0xDCDCDC,
  'ghostwhite': 0xF8F8FF,
  'gold': 0xFFD700,
  'goldenrod': 0xDAA520,
  'gray': 0x808080,
  'green': 0x008000,
  'greenyellow': 0xADFF2F,
  'grey': 0x808080,
  'honeydew': 0xF0FFF0,
  'hotpink': 0xFF69B4,
  'indianred': 0xCD5C5C,
  'indigo': 0x4B0082,
  'ivory': 0xFFFFF0,
  'khaki': 0xF0E68C,
  'lavender': 0xE6E6FA,
  'lavenderblush': 0xFFF0F5,
  'lawngreen': 0x7CFC00,
  'lemonchiffon': 0xFFFACD,
  'lightblue': 0xADD8E6,
  'lightcoral': 0xF08080,
  'lightcyan': 0xE0FFFF,
  'lightgoldenrodyellow': 0xFAFAD2,
  'lightgray': 0xD3D3D3,
  'lightgreen': 0x90EE90,
  'lightgrey': 0xD3D3D3,
  'lightpink': 0xFFB6C1,
  'lightsalmon': 0xFFA07A,
  'lightseagreen': 0x20B2AA,
  'lightskyblue': 0x87CEFA,
  'lightslategray': 0x778899,
  'lightslategrey': 0x778899,
  'lightsteelblue': 0xB0C4DE,
  'lightyellow': 0xFFFFE0,
  'lime': 0x00FF00,
  'limegreen': 0x32CD32,
  'linen': 0xFAF0E6,
  'magenta': 0xFF00FF,
  'maroon': 0x800000,
  'mediumaquamarine': 0x66CDAA,
  'mediumblue': 0x0000CD,
  'mediumorchid': 0xBA55D3,
  'mediumpurple': 0x9370DB,
  'mediumseagreen': 0x3CB371,
  'mediumslateblue': 0x7B68EE,
  'mediumspringgreen': 0x00FA9A,
  'mediumturquoise': 0x48D1CC,
  'mediumvioletred': 0xC71585,
  'midnightblue': 0x191970,
  'mintcream': 0xF5FFFA,
  'mistyrose': 0xFFE4E1,
  'moccasin': 0xFFE4B5,
  'navajowhite': 0xFFDEAD,
  'navy': 0x000080,
  'oldlace': 0xFDF5E6,
  'olive': 0x808000,
  'olivedrab': 0x6B8E23,
  'orange': 0xFFA500,
  'orangered': 0xFF4500,
  'orchid': 0xDA70D6,
  'palegoldenrod': 0xEEE8AA,
  'palegreen': 0x98FB98,
  'paleturquoise': 0xAFEEEE,
  'palevioletred': 0xDB7093,
  'papayawhip': 0xFFEFD5,
  'peachpuff': 0xFFDAB9,
  'peru': 0xCD853F,
  'pink': 0xFFC0CB,
  'plum': 0xDDA0DD,
  'powderblue': 0xB0E0E6,
  'purple': 0x800080,
  'rebeccapurple': 0x663399,
  'red': 0xFF0000,
  'rosybrown': 0xBC8F8F,
  'royalblue': 0x4169E1,
  'saddlebrown': 0x8B4513,
  'salmon': 0xFA8072,
  'sandybrown': 0xF4A460,
  'seagreen': 0x2E8B57,
  'seashell': 0xFFF5EE,
  'sienna': 0xA0522D,
  'silver': 0xC0C0C0,
  'skyblue': 0x87CEEB,
  'slateblue': 0x6A5ACD,
  'slategray': 0x708090,
  'slategrey': 0x708090,
  'snow': 0xFFFAFA,
  'springgreen': 0x00FF7F,
  'steelblue': 0x4682B4,
  'tan': 0xD2B48C,
  'teal': 0x008080,
  'thistle': 0xD8BFD8,
  'tomato': 0xFF6347,
  'turquoise': 0x40E0D0,
  'violet': 0xEE82EE,
  'wheat': 0xF5DEB3,
  'white': 0xFFFFFF,
  'whitesmoke': 0xF5F5F5,
  'yellow': 0xFFFF00,
  'yellowgreen': 0x9ACD32
};
const _hslA = {
  h: 0,
  s: 0,
  l: 0
};
const _hslB = {
  h: 0,
  s: 0,
  l: 0
};

function Color(r, g, b) {
  if (g === undefined && b === undefined) {
    // r is THREE.Color, hex or string
    return this.set(r);
  }

  return this.setRGB(r, g, b);
}

function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}

function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}

function LinearToSRGB(c) {
  return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}

Object.assign(Color.prototype, {
  isColor: true,
  r: 1,
  g: 1,
  b: 1,
  set: function (value) {
    if (value && value.isColor) {
      this.copy(value);
    } else if (typeof value === 'number') {
      this.setHex(value);
    } else if (typeof value === 'string') {
      this.setStyle(value);
    }

    return this;
  },
  setScalar: function (scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  },
  setHex: function (hex) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    return this;
  },
  setRGB: function (r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  },
  setHSL: function (h, s, l) {
    // h,s,l ranges are in 0.0 - 1.0
    h = MathUtils.euclideanModulo(h, 1);
    s = MathUtils.clamp(s, 0, 1);
    l = MathUtils.clamp(l, 0, 1);

    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }

    return this;
  },
  setStyle: function (style) {
    function handleAlpha(string) {
      if (string === undefined) return;

      if (parseFloat(string) < 1) {
        console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
      }
    }

    let m;

    if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
      // rgb / hsl
      let color;
      const name = m[1];
      const components = m[2];

      switch (name) {
        case 'rgb':
        case 'rgba':
          if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            // rgb(255,0,0) rgba(255,0,0,0.5)
            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
            handleAlpha(color[5]);
            return this;
          }

          if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
            handleAlpha(color[5]);
            return this;
          }

          break;

        case 'hsl':
        case 'hsla':
          if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
            // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
            const h = parseFloat(color[1]) / 360;
            const s = parseInt(color[2], 10) / 100;
            const l = parseInt(color[3], 10) / 100;
            handleAlpha(color[5]);
            return this.setHSL(h, s, l);
          }

          break;
      }
    } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
      // hex color
      const hex = m[1];
      const size = hex.length;

      if (size === 3) {
        // #ff0
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
        return this;
      } else if (size === 6) {
        // #ff0000
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
        return this;
      }
    }

    if (style && style.length > 0) {
      return this.setColorName(style);
    }

    return this;
  },
  setColorName: function (style) {
    // color keywords
    const hex = _colorKeywords[style];

    if (hex !== undefined) {
      // red
      this.setHex(hex);
    } else {
      // unknown color
      console.warn('THREE.Color: Unknown color ' + style);
    }

    return this;
  },
  clone: function () {
    return new this.constructor(this.r, this.g, this.b);
  },
  copy: function (color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  },
  copyGammaToLinear: function (color, gammaFactor) {
    if (gammaFactor === undefined) gammaFactor = 2.0;
    this.r = Math.pow(color.r, gammaFactor);
    this.g = Math.pow(color.g, gammaFactor);
    this.b = Math.pow(color.b, gammaFactor);
    return this;
  },
  copyLinearToGamma: function (color, gammaFactor) {
    if (gammaFactor === undefined) gammaFactor = 2.0;
    const safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;
    this.r = Math.pow(color.r, safeInverse);
    this.g = Math.pow(color.g, safeInverse);
    this.b = Math.pow(color.b, safeInverse);
    return this;
  },
  convertGammaToLinear: function (gammaFactor) {
    this.copyGammaToLinear(this, gammaFactor);
    return this;
  },
  convertLinearToGamma: function (gammaFactor) {
    this.copyLinearToGamma(this, gammaFactor);
    return this;
  },
  copySRGBToLinear: function (color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  },
  copyLinearToSRGB: function (color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  },
  convertSRGBToLinear: function () {
    this.copySRGBToLinear(this);
    return this;
  },
  convertLinearToSRGB: function () {
    this.copyLinearToSRGB(this);
    return this;
  },
  getHex: function () {
    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
  },
  getHexString: function () {
    return ('000000' + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function (target) {
    // h,s,l ranges are in 0.0 - 1.0
    if (target === undefined) {
      console.warn('THREE.Color: .getHSL() target is now required');
      target = {
        h: 0,
        s: 0,
        l: 0
      };
    }

    const r = this.r,
          g = this.g,
          b = this.b;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let hue, saturation;
    const lightness = (min + max) / 2.0;

    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;

        case g:
          hue = (b - r) / delta + 2;
          break;

        case b:
          hue = (r - g) / delta + 4;
          break;
      }

      hue /= 6;
    }

    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  },
  getStyle: function () {
    return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
  },
  offsetHSL: function (h, s, l) {
    this.getHSL(_hslA);
    _hslA.h += h;
    _hslA.s += s;
    _hslA.l += l;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  },
  add: function (color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  },
  addColors: function (color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  },
  addScalar: function (s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  },
  sub: function (color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  },
  multiply: function (color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  },
  multiplyScalar: function (s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  },
  lerp: function (color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  },
  lerpHSL: function (color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
    const s = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
    const l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h, s, l);
    return this;
  },
  equals: function (c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  },
  fromBufferAttribute: function (attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);

    if (attribute.normalized === true) {
      // assuming Uint8Array
      this.r /= 255;
      this.g /= 255;
      this.b /= 255;
    }

    return this;
  },
  toJSON: function () {
    return this.getHex();
  }
});
Color.NAMES = _colorKeywords;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Face3(a, b, c, normal, color, materialIndex) {
  this.a = a;
  this.b = b;
  this.c = c;
  this.normal = normal && normal.isVector3 ? normal : new Vector3();
  this.vertexNormals = Array.isArray(normal) ? normal : [];
  this.color = color && color.isColor ? color : new Color();
  this.vertexColors = Array.isArray(color) ? color : [];
  this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
}

Object.assign(Face3.prototype, {
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.a = source.a;
    this.b = source.b;
    this.c = source.c;
    this.normal.copy(source.normal);
    this.color.copy(source.color);
    this.materialIndex = source.materialIndex;

    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {
      this.vertexNormals[i] = source.vertexNormals[i].clone();
    }

    for (let i = 0, il = source.vertexColors.length; i < il; i++) {
      this.vertexColors[i] = source.vertexColors[i].clone();
    }

    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

let materialId = 0;

function Material() {
  Object.defineProperty(this, 'id', {
    value: materialId++
  });
  this.uuid = MathUtils.generateUUID();
  this.name = '';
  this.type = 'Material';
  this.fog = true;
  this.blending = NormalBlending;
  this.side = FrontSide;
  this.flatShading = false;
  this.vertexColors = false;
  this.opacity = 1;
  this.transparent = false;
  this.blendSrc = SrcAlphaFactor;
  this.blendDst = OneMinusSrcAlphaFactor;
  this.blendEquation = AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;
  this.depthFunc = LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;
  this.stencilWriteMask = 0xff;
  this.stencilFunc = AlwaysStencilFunc;
  this.stencilRef = 0;
  this.stencilFuncMask = 0xff;
  this.stencilFail = KeepStencilOp;
  this.stencilZFail = KeepStencilOp;
  this.stencilZPass = KeepStencilOp;
  this.stencilWrite = false;
  this.clippingPlanes = null;
  this.clipIntersection = false;
  this.clipShadows = false;
  this.shadowSide = null;
  this.colorWrite = true;
  this.precision = null; // override the renderer's default precision for this material

  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;
  this.dithering = false;
  this.alphaTest = 0;
  this.premultipliedAlpha = false;
  this.visible = true;
  this.toneMapped = true;
  this.userData = {};
  this.version = 0;
}

Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Material,
  isMaterial: true,
  onBeforeCompile: function ()
  /* shaderobject, renderer */
  {},
  customProgramCacheKey: function () {
    return this.onBeforeCompile.toString();
  },
  setValues: function (values) {
    if (values === undefined) return;

    for (const key in values) {
      const newValue = values[key];

      if (newValue === undefined) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
        continue;
      } // for backward compatability if shading is set in the constructor


      if (key === 'shading') {
        console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
        this.flatShading = newValue === FlatShading ? true : false;
        continue;
      }

      const currentValue = this[key];

      if (currentValue === undefined) {
        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
        continue;
      }

      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  },
  toJSON: function (meta) {
    const isRoot = meta === undefined || typeof meta === 'string';

    if (isRoot) {
      meta = {
        textures: {},
        images: {}
      };
    }

    const data = {
      metadata: {
        version: 4.5,
        type: 'Material',
        generator: 'Material.toJSON'
      }
    }; // standard Material serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (this.color && this.color.isColor) data.color = this.color.getHex();
    if (this.roughness !== undefined) data.roughness = this.roughness;
    if (this.metalness !== undefined) data.metalness = this.metalness;
    if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
    if (this.shininess !== undefined) data.shininess = this.shininess;
    if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;

    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }

    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }

    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }

    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;

    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }

    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }

    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }

    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }

    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;

    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      data.reflectivity = this.reflectivity; // Scale behind envMap

      data.refractionRatio = this.refractionRatio;
      if (this.combine !== undefined) data.combine = this.combine;
      if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
    }

    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }

    if (this.size !== undefined) data.size = this.size;
    if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending) data.blending = this.blending;
    if (this.flatShading === true) data.flatShading = this.flatShading;
    if (this.side !== FrontSide) data.side = this.side;
    if (this.vertexColors) data.vertexColors = true;
    if (this.opacity < 1) data.opacity = this.opacity;
    if (this.transparent === true) data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilWriteMask = this.stencilWriteMask;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilFuncMask = this.stencilFuncMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)

    if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
    if (this.polygonOffset === true) data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
    if (this.dashSize !== undefined) data.dashSize = this.dashSize;
    if (this.gapSize !== undefined) data.gapSize = this.gapSize;
    if (this.scale !== undefined) data.scale = this.scale;
    if (this.dithering === true) data.dithering = true;
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
    if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.wireframe === true) data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.morphTargets === true) data.morphTargets = true;
    if (this.morphNormals === true) data.morphNormals = true;
    if (this.skinning === true) data.skinning = true;
    if (this.visible === false) data.visible = false;
    if (this.toneMapped === false) data.toneMapped = false;
    if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON

    function extractFromCache(cache) {
      const values = [];

      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }

      return values;
    }

    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
    }

    return data;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.name = source.name;
    this.fog = source.fog;
    this.blending = source.blending;
    this.side = source.side;
    this.flatShading = source.flatShading;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;

    if (srcPlanes !== null) {
      const n = srcPlanes.length;
      dstPlanes = new Array(n);

      for (let i = 0; i !== n; ++i) {
        dstPlanes[i] = srcPlanes[i].clone();
      }
    }

    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});
Object.defineProperty(Material.prototype, 'needsUpdate', {
  set: function (value) {
    if (value === true) this.version++;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

function MeshBasicMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshBasicMaterial';
  this.color = new Color(0xffffff); // emissive

  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.setValues(parameters);
}

MeshBasicMaterial.prototype = Object.create(Material.prototype);
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

MeshBasicMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */


const _vector$3 = new Vector3();

const _vector2$1 = new Vector2();

function BufferAttribute(array, itemSize, normalized) {
  if (Array.isArray(array)) {
    throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
  }

  this.name = '';
  this.array = array;
  this.itemSize = itemSize;
  this.count = array !== undefined ? array.length / itemSize : 0;
  this.normalized = normalized === true;
  this.usage = StaticDrawUsage;
  this.updateRange = {
    offset: 0,
    count: -1
  };
  this.version = 0;
}

Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {
  set: function (value) {
    if (value === true) this.version++;
  }
});
Object.assign(BufferAttribute.prototype, {
  isBufferAttribute: true,
  onUploadCallback: function () {},
  setUsage: function (value) {
    this.usage = value;
    return this;
  },
  copy: function (source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    return this;
  },
  copyAt: function (index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;

    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }

    return this;
  },
  copyArray: function (array) {
    this.array.set(array);
    return this;
  },
  copyColorsArray: function (colors) {
    const array = this.array;
    let offset = 0;

    for (let i = 0, l = colors.length; i < l; i++) {
      let color = colors[i];

      if (color === undefined) {
        console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
        color = new Color();
      }

      array[offset++] = color.r;
      array[offset++] = color.g;
      array[offset++] = color.b;
    }

    return this;
  },
  copyVector2sArray: function (vectors) {
    const array = this.array;
    let offset = 0;

    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];

      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
        vector = new Vector2();
      }

      array[offset++] = vector.x;
      array[offset++] = vector.y;
    }

    return this;
  },
  copyVector3sArray: function (vectors) {
    const array = this.array;
    let offset = 0;

    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];

      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
        vector = new Vector3();
      }

      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
    }

    return this;
  },
  copyVector4sArray: function (vectors) {
    const array = this.array;
    let offset = 0;

    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i];

      if (vector === undefined) {
        console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
        vector = new Vector4();
      }

      array[offset++] = vector.x;
      array[offset++] = vector.y;
      array[offset++] = vector.z;
      array[offset++] = vector.w;
    }

    return this;
  },
  applyMatrix3: function (m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2$1.fromBufferAttribute(this, i);

        _vector2$1.applyMatrix3(m);

        this.setXY(i, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$3.fromBufferAttribute(this, i);

        _vector$3.applyMatrix3(m);

        this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
      }
    }

    return this;
  },
  applyMatrix4: function (m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$3.x = this.getX(i);
      _vector$3.y = this.getY(i);
      _vector$3.z = this.getZ(i);

      _vector$3.applyMatrix4(m);

      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
    }

    return this;
  },
  applyNormalMatrix: function (m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$3.x = this.getX(i);
      _vector$3.y = this.getY(i);
      _vector$3.z = this.getZ(i);

      _vector$3.applyNormalMatrix(m);

      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
    }

    return this;
  },
  transformDirection: function (m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$3.x = this.getX(i);
      _vector$3.y = this.getY(i);
      _vector$3.z = this.getZ(i);

      _vector$3.transformDirection(m);

      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
    }

    return this;
  },
  set: function (value, offset) {
    if (offset === undefined) offset = 0;
    this.array.set(value, offset);
    return this;
  },
  getX: function (index) {
    return this.array[index * this.itemSize];
  },
  setX: function (index, x) {
    this.array[index * this.itemSize] = x;
    return this;
  },
  getY: function (index) {
    return this.array[index * this.itemSize + 1];
  },
  setY: function (index, y) {
    this.array[index * this.itemSize + 1] = y;
    return this;
  },
  getZ: function (index) {
    return this.array[index * this.itemSize + 2];
  },
  setZ: function (index, z) {
    this.array[index * this.itemSize + 2] = z;
    return this;
  },
  getW: function (index) {
    return this.array[index * this.itemSize + 3];
  },
  setW: function (index, w) {
    this.array[index * this.itemSize + 3] = w;
    return this;
  },
  setXY: function (index, x, y) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  },
  setXYZ: function (index, x, y, z) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  },
  setXYZW: function (index, x, y, z, w) {
    index *= this.itemSize;
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  },
  onUpload: function (callback) {
    this.onUploadCallback = callback;
    return this;
  },
  clone: function () {
    return new this.constructor(this.array, this.itemSize).copy(this);
  },
  toJSON: function () {
    return {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized
    };
  }
}); //

function Int8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}

Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;

function Uint8BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}

Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;

function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}

Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;

function Int16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}

Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;

function Uint16BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}

Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;

function Int32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}

Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;

function Uint32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}

Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

function Float32BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}

Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;

function Float64BufferAttribute(array, itemSize, normalized) {
  BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}

Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectGeometry() {
  this.vertices = [];
  this.normals = [];
  this.colors = [];
  this.uvs = [];
  this.uvs2 = [];
  this.groups = [];
  this.morphTargets = {};
  this.skinWeights = [];
  this.skinIndices = []; // this.lineDistances = [];

  this.boundingBox = null;
  this.boundingSphere = null; // update flags

  this.verticesNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.groupsNeedUpdate = false;
}

Object.assign(DirectGeometry.prototype, {
  computeGroups: function (geometry) {
    const groups = [];
    let group, i;
    let materialIndex = undefined;
    const faces = geometry.faces;

    for (i = 0; i < faces.length; i++) {
      const face = faces[i]; // materials

      if (face.materialIndex !== materialIndex) {
        materialIndex = face.materialIndex;

        if (group !== undefined) {
          group.count = i * 3 - group.start;
          groups.push(group);
        }

        group = {
          start: i * 3,
          materialIndex: materialIndex
        };
      }
    }

    if (group !== undefined) {
      group.count = i * 3 - group.start;
      groups.push(group);
    }

    this.groups = groups;
  },
  fromGeometry: function (geometry) {
    const faces = geometry.faces;
    const vertices = geometry.vertices;
    const faceVertexUvs = geometry.faceVertexUvs;
    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs

    const morphTargets = geometry.morphTargets;
    const morphTargetsLength = morphTargets.length;
    let morphTargetsPosition;

    if (morphTargetsLength > 0) {
      morphTargetsPosition = [];

      for (let i = 0; i < morphTargetsLength; i++) {
        morphTargetsPosition[i] = {
          name: morphTargets[i].name,
          data: []
        };
      }

      this.morphTargets.position = morphTargetsPosition;
    }

    const morphNormals = geometry.morphNormals;
    const morphNormalsLength = morphNormals.length;
    let morphTargetsNormal;

    if (morphNormalsLength > 0) {
      morphTargetsNormal = [];

      for (let i = 0; i < morphNormalsLength; i++) {
        morphTargetsNormal[i] = {
          name: morphNormals[i].name,
          data: []
        };
      }

      this.morphTargets.normal = morphTargetsNormal;
    } // skins


    const skinIndices = geometry.skinIndices;
    const skinWeights = geometry.skinWeights;
    const hasSkinIndices = skinIndices.length === vertices.length;
    const hasSkinWeights = skinWeights.length === vertices.length; //

    if (vertices.length > 0 && faces.length === 0) {
      console.error('THREE.DirectGeometry: Faceless geometries are not supported.');
    }

    for (let i = 0; i < faces.length; i++) {
      const face = faces[i];
      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
      const vertexNormals = face.vertexNormals;

      if (vertexNormals.length === 3) {
        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
      } else {
        const normal = face.normal;
        this.normals.push(normal, normal, normal);
      }

      const vertexColors = face.vertexColors;

      if (vertexColors.length === 3) {
        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
      } else {
        const color = face.color;
        this.colors.push(color, color, color);
      }

      if (hasFaceVertexUv === true) {
        const vertexUvs = faceVertexUvs[0][i];

        if (vertexUvs !== undefined) {
          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);
          this.uvs.push(new Vector2(), new Vector2(), new Vector2());
        }
      }

      if (hasFaceVertexUv2 === true) {
        const vertexUvs = faceVertexUvs[1][i];

        if (vertexUvs !== undefined) {
          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
        } else {
          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);
          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
        }
      } // morphs


      for (let j = 0; j < morphTargetsLength; j++) {
        const morphTarget = morphTargets[j].vertices;
        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
      }

      for (let j = 0; j < morphNormalsLength; j++) {
        const morphNormal = morphNormals[j].vertexNormals[i];
        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
      } // skins


      if (hasSkinIndices) {
        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
      }

      if (hasSkinWeights) {
        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
      }
    }

    this.computeGroups(geometry);
    this.verticesNeedUpdate = geometry.verticesNeedUpdate;
    this.normalsNeedUpdate = geometry.normalsNeedUpdate;
    this.colorsNeedUpdate = geometry.colorsNeedUpdate;
    this.uvsNeedUpdate = geometry.uvsNeedUpdate;
    this.groupsNeedUpdate = geometry.groupsNeedUpdate;

    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }

    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }

    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function arrayMax(array) {
  if (array.length === 0) return -Infinity;
  let max = array[0];

  for (let i = 1, l = array.length; i < l; ++i) {
    if (array[i] > max) max = array[i];
  }

  return max;
}
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */


let _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

const _m1$2 = new Matrix4();

const _obj = new Object3D();

const _offset = new Vector3();

const _box$2 = new Box3();

const _boxMorphTargets = new Box3();

const _vector$4 = new Vector3();

function BufferGeometry() {
  Object.defineProperty(this, 'id', {
    value: _bufferGeometryId += 2
  });
  this.uuid = MathUtils.generateUUID();
  this.name = '';
  this.type = 'BufferGeometry';
  this.index = null;
  this.attributes = {};
  this.morphAttributes = {};
  this.morphTargetsRelative = false;
  this.groups = [];
  this.boundingBox = null;
  this.boundingSphere = null;
  this.drawRange = {
    start: 0,
    count: Infinity
  };
  this.userData = {};
}

BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: BufferGeometry,
  isBufferGeometry: true,
  getIndex: function () {
    return this.index;
  },
  setIndex: function (index) {
    if (Array.isArray(index)) {
      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
  },
  getAttribute: function (name) {
    return this.attributes[name];
  },
  setAttribute: function (name, attribute) {
    this.attributes[name] = attribute;
    return this;
  },
  deleteAttribute: function (name) {
    delete this.attributes[name];
    return this;
  },
  addGroup: function (start, count, materialIndex) {
    this.groups.push({
      start: start,
      count: count,
      materialIndex: materialIndex !== undefined ? materialIndex : 0
    });
  },
  clearGroups: function () {
    this.groups = [];
  },
  setDrawRange: function (start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  },
  applyMatrix4: function (matrix) {
    const position = this.attributes.position;

    if (position !== undefined) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }

    const normal = this.attributes.normal;

    if (normal !== undefined) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }

    const tangent = this.attributes.tangent;

    if (tangent !== undefined) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }

    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }

    return this;
  },
  rotateX: function (angle) {
    // rotate geometry around world x-axis
    _m1$2.makeRotationX(angle);

    this.applyMatrix4(_m1$2);
    return this;
  },
  rotateY: function (angle) {
    // rotate geometry around world y-axis
    _m1$2.makeRotationY(angle);

    this.applyMatrix4(_m1$2);
    return this;
  },
  rotateZ: function (angle) {
    // rotate geometry around world z-axis
    _m1$2.makeRotationZ(angle);

    this.applyMatrix4(_m1$2);
    return this;
  },
  translate: function (x, y, z) {
    // translate geometry
    _m1$2.makeTranslation(x, y, z);

    this.applyMatrix4(_m1$2);
    return this;
  },
  scale: function (x, y, z) {
    // scale geometry
    _m1$2.makeScale(x, y, z);

    this.applyMatrix4(_m1$2);
    return this;
  },
  lookAt: function (vector) {
    _obj.lookAt(vector);

    _obj.updateMatrix();

    this.applyMatrix4(_obj.matrix);
    return this;
  },
  center: function () {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  },
  setFromObject: function (object) {
    // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
    const geometry = object.geometry;

    if (object.isPoints || object.isLine) {
      const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
      const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
      this.setAttribute('position', positions.copyVector3sArray(geometry.vertices));
      this.setAttribute('color', colors.copyColorsArray(geometry.colors));

      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
        const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
        this.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
      }

      if (geometry.boundingSphere !== null) {
        this.boundingSphere = geometry.boundingSphere.clone();
      }

      if (geometry.boundingBox !== null) {
        this.boundingBox = geometry.boundingBox.clone();
      }
    } else if (object.isMesh) {
      if (geometry && geometry.isGeometry) {
        this.fromGeometry(geometry);
      }
    }

    return this;
  },
  setFromPoints: function (points) {
    const position = [];

    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }

    this.setAttribute('position', new Float32BufferAttribute(position, 3));
    return this;
  },
  updateFromObject: function (object) {
    let geometry = object.geometry;

    if (object.isMesh) {
      let direct = geometry.__directGeometry;

      if (geometry.elementsNeedUpdate === true) {
        direct = undefined;
        geometry.elementsNeedUpdate = false;
      }

      if (direct === undefined) {
        return this.fromGeometry(geometry);
      }

      direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
      direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
      direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
      direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
      direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
      geometry.verticesNeedUpdate = false;
      geometry.normalsNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      geometry.uvsNeedUpdate = false;
      geometry.groupsNeedUpdate = false;
      geometry = direct;
    }

    if (geometry.verticesNeedUpdate === true) {
      const attribute = this.attributes.position;

      if (attribute !== undefined) {
        attribute.copyVector3sArray(geometry.vertices);
        attribute.needsUpdate = true;
      }

      geometry.verticesNeedUpdate = false;
    }

    if (geometry.normalsNeedUpdate === true) {
      const attribute = this.attributes.normal;

      if (attribute !== undefined) {
        attribute.copyVector3sArray(geometry.normals);
        attribute.needsUpdate = true;
      }

      geometry.normalsNeedUpdate = false;
    }

    if (geometry.colorsNeedUpdate === true) {
      const attribute = this.attributes.color;

      if (attribute !== undefined) {
        attribute.copyColorsArray(geometry.colors);
        attribute.needsUpdate = true;
      }

      geometry.colorsNeedUpdate = false;
    }

    if (geometry.uvsNeedUpdate) {
      const attribute = this.attributes.uv;

      if (attribute !== undefined) {
        attribute.copyVector2sArray(geometry.uvs);
        attribute.needsUpdate = true;
      }

      geometry.uvsNeedUpdate = false;
    }

    if (geometry.lineDistancesNeedUpdate) {
      const attribute = this.attributes.lineDistance;

      if (attribute !== undefined) {
        attribute.copyArray(geometry.lineDistances);
        attribute.needsUpdate = true;
      }

      geometry.lineDistancesNeedUpdate = false;
    }

    if (geometry.groupsNeedUpdate) {
      geometry.computeGroups(object.geometry);
      this.groups = geometry.groups;
      geometry.groupsNeedUpdate = false;
    }

    return this;
  },
  fromGeometry: function (geometry) {
    geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
    return this.fromDirectGeometry(geometry.__directGeometry);
  },
  fromDirectGeometry: function (geometry) {
    const positions = new Float32Array(geometry.vertices.length * 3);
    this.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));

    if (geometry.normals.length > 0) {
      const normals = new Float32Array(geometry.normals.length * 3);
      this.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
    }

    if (geometry.colors.length > 0) {
      const colors = new Float32Array(geometry.colors.length * 3);
      this.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
    }

    if (geometry.uvs.length > 0) {
      const uvs = new Float32Array(geometry.uvs.length * 2);
      this.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
    }

    if (geometry.uvs2.length > 0) {
      const uvs2 = new Float32Array(geometry.uvs2.length * 2);
      this.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
    } // groups


    this.groups = geometry.groups; // morphs

    for (const name in geometry.morphTargets) {
      const array = [];
      const morphTargets = geometry.morphTargets[name];

      for (let i = 0, l = morphTargets.length; i < l; i++) {
        const morphTarget = morphTargets[i];
        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
        attribute.name = morphTarget.name;
        array.push(attribute.copyVector3sArray(morphTarget.data));
      }

      this.morphAttributes[name] = array;
    } // skinning


    if (geometry.skinIndices.length > 0) {
      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
      this.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
    }

    if (geometry.skinWeights.length > 0) {
      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
      this.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
    } //


    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }

    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }

    return this;
  },
  computeBoundingBox: function () {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }

    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;

    if (position !== undefined) {
      this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present

      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];

          _box$2.setFromBufferAttribute(morphAttribute);

          if (this.morphTargetsRelative) {
            _vector$4.addVectors(this.boundingBox.min, _box$2.min);

            this.boundingBox.expandByPoint(_vector$4);

            _vector$4.addVectors(this.boundingBox.max, _box$2.max);

            this.boundingBox.expandByPoint(_vector$4);
          } else {
            this.boundingBox.expandByPoint(_box$2.min);
            this.boundingBox.expandByPoint(_box$2.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }

    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  },
  computeBoundingSphere: function () {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }

    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;

    if (position) {
      // first, find the center of the bounding sphere
      const center = this.boundingSphere.center;

      _box$2.setFromBufferAttribute(position); // process morph attributes if present


      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];

          _boxMorphTargets.setFromBufferAttribute(morphAttribute);

          if (this.morphTargetsRelative) {
            _vector$4.addVectors(_box$2.min, _boxMorphTargets.min);

            _box$2.expandByPoint(_vector$4);

            _vector$4.addVectors(_box$2.max, _boxMorphTargets.max);

            _box$2.expandByPoint(_vector$4);
          } else {
            _box$2.expandByPoint(_boxMorphTargets.min);

            _box$2.expandByPoint(_boxMorphTargets.max);
          }
        }
      }

      _box$2.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the
      // boundingSphere of the boundingBox: sqrt(3) smaller in the best case


      let maxRadiusSq = 0;

      for (let i = 0, il = position.count; i < il; i++) {
        _vector$4.fromBufferAttribute(position, i);

        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
      } // process morph attributes if present


      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;

          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$4.fromBufferAttribute(morphAttribute, j);

            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);

              _vector$4.add(_offset);
            }

            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
          }
        }
      }

      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  },
  computeFaceNormals: function () {// backwards compatibility
  },
  computeVertexNormals: function () {
    const index = this.index;
    const positionAttribute = this.getAttribute('position');

    if (positionAttribute !== undefined) {
      let normalAttribute = this.getAttribute('normal');

      if (normalAttribute === undefined) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute('normal', normalAttribute);
      } else {
        // reset existing normals to zero
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }

      const pA = new Vector3(),
            pB = new Vector3(),
            pC = new Vector3();
      const nA = new Vector3(),
            nB = new Vector3(),
            nC = new Vector3();
      const cb = new Vector3(),
            ab = new Vector3(); // indexed elements

      if (index) {
        for (let i = 0, il = index.count; i < il; i += 3) {
          const vA = index.getX(i + 0);
          const vB = index.getX(i + 1);
          const vC = index.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        // non-indexed elements (unconnected triangle soup)
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }

      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  },
  merge: function (geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
      return;
    }

    if (offset === undefined) {
      offset = 0;
      console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
    }

    const attributes = this.attributes;

    for (const key in attributes) {
      if (geometry.attributes[key] === undefined) continue;
      const attribute1 = attributes[key];
      const attributeArray1 = attribute1.array;
      const attribute2 = geometry.attributes[key];
      const attributeArray2 = attribute2.array;
      const attributeOffset = attribute2.itemSize * offset;
      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);

      for (let i = 0, j = attributeOffset; i < length; i++, j++) {
        attributeArray1[j] = attributeArray2[i];
      }
    }

    return this;
  },
  normalizeNormals: function () {
    const normals = this.attributes.normal;

    for (let i = 0, il = normals.count; i < il; i++) {
      _vector$4.fromBufferAttribute(normals, i);

      _vector$4.normalize();

      normals.setXYZ(i, _vector$4.x, _vector$4.y, _vector$4.z);
    }
  },
  toNonIndexed: function () {
    function convertBufferAttribute(attribute, indices) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices.length * itemSize);
      let index = 0,
          index2 = 0;

      for (let i = 0, l = indices.length; i < l; i++) {
        index = indices[i] * itemSize;

        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }

      return new BufferAttribute(array2, itemSize, normalized);
    } //


    if (this.index === null) {
      console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
      return this;
    }

    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes; // attributes

    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    } // morph attributes


    const morphAttributes = this.morphAttributes;

    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }

      geometry2.morphAttributes[name] = morphArray;
    }

    geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups

    const groups = this.groups;

    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }

    return geometry2;
  },
  toJSON: function () {
    const data = {
      metadata: {
        version: 4.5,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    }; // standard BufferGeometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;

    if (this.parameters !== undefined) {
      const parameters = this.parameters;

      for (const key in parameters) {
        if (parameters[key] !== undefined) data[key] = parameters[key];
      }

      return data;
    }

    data.data = {
      attributes: {}
    };
    const index = this.index;

    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }

    const attributes = this.attributes;

    for (const key in attributes) {
      const attribute = attributes[key];
      const attributeData = attribute.toJSON(data.data);
      if (attribute.name !== '') attributeData.name = attribute.name;
      data.data.attributes[key] = attributeData;
    }

    const morphAttributes = {};
    let hasMorphAttributes = false;

    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];

      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i];
        const attributeData = attribute.toJSON(data.data);
        if (attribute.name !== '') attributeData.name = attribute.name;
        array.push(attributeData);
      }

      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }

    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }

    const groups = this.groups;

    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }

    const boundingSphere = this.boundingSphere;

    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }

    return data;
  },
  clone: function () {
    /*
     // Handle primitives
    	 const parameters = this.parameters;
    	 if ( parameters !== undefined ) {
    	 const values = [];
    	 for ( const key in parameters ) {
    	 values.push( parameters[ key ] );
    	 }
    	 const geometry = Object.create( this.constructor.prototype );
     this.constructor.apply( geometry, values );
     return geometry;
    	 }
    	 return new this.constructor().copy( this );
     */
    return new BufferGeometry().copy(this);
  },
  copy: function (source) {
    // reset
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null; // used for storing cloned, shared data

    const data = {}; // name

    this.name = source.name; // index

    const index = source.index;

    if (index !== null) {
      this.setIndex(index.clone(data));
    } // attributes


    const attributes = source.attributes;

    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    } // morph attributes


    const morphAttributes = source.morphAttributes;

    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data));
      }

      this.morphAttributes[name] = array;
    }

    this.morphTargetsRelative = source.morphTargetsRelative; // groups

    const groups = source.groups;

    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    } // bounding box


    const boundingBox = source.boundingBox;

    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    } // bounding sphere


    const boundingSphere = source.boundingSphere;

    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    } // draw range


    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count; // user data

    this.userData = source.userData;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

const _inverseMatrix = new Matrix4();

const _ray = new Ray();

const _sphere = new Sphere();

const _vA = new Vector3();

const _vB = new Vector3();

const _vC = new Vector3();

const _tempA = new Vector3();

const _tempB = new Vector3();

const _tempC = new Vector3();

const _morphA = new Vector3();

const _morphB = new Vector3();

const _morphC = new Vector3();

const _uvA = new Vector2();

const _uvB = new Vector2();

const _uvC = new Vector2();

const _intersectionPoint = new Vector3();

const _intersectionPointWorld = new Vector3();

function Mesh(geometry, material) {
  Object3D.call(this);
  this.type = 'Mesh';
  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  this.material = material !== undefined ? material : new MeshBasicMaterial();
  this.updateMorphTargets();
}

Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Mesh,
  isMesh: true,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);

    if (source.morphTargetInfluences !== undefined) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }

    if (source.morphTargetDictionary !== undefined) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }

    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  updateMorphTargets: function () {
    const geometry = this.geometry;

    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);

      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];

        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};

          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;

      if (morphTargets !== undefined && morphTargets.length > 0) {
        console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  },
  raycast: function (raycaster, intersects) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === undefined) return; // Checking boundingSphere distance to ray

    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

    _sphere.copy(geometry.boundingSphere);

    _sphere.applyMatrix4(matrixWorld);

    if (raycaster.ray.intersectsSphere(_sphere) === false) return; //

    _inverseMatrix.getInverse(matrixWorld);

    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing


    if (geometry.boundingBox !== null) {
      if (_ray.intersectsBox(geometry.boundingBox) === false) return;
    }

    let intersection;

    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const position = geometry.attributes.position;
      const morphPosition = geometry.morphAttributes.position;
      const morphTargetsRelative = geometry.morphTargetsRelative;
      const uv = geometry.attributes.uv;
      const uv2 = geometry.attributes.uv2;
      const groups = geometry.groups;
      const drawRange = geometry.drawRange;

      if (index !== null) {
        // indexed buffer geometry
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

            for (let j = start, jl = end; j < jl; j += 3) {
              const a = index.getX(j);
              const b = index.getX(j + 1);
              const c = index.getX(j + 2);
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics

                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);

          for (let i = start, il = end; i < il; i += 3) {
            const a = index.getX(i);
            const b = index.getX(i + 1);
            const c = index.getX(i + 2);
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics

              intersects.push(intersection);
            }
          }
        }
      } else if (position !== undefined) {
        // non-indexed buffer geometry
        if (Array.isArray(material)) {
          for (let i = 0, il = groups.length; i < il; i++) {
            const group = groups[i];
            const groupMaterial = material[group.materialIndex];
            const start = Math.max(group.start, drawRange.start);
            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

            for (let j = start, jl = end; j < jl; j += 3) {
              const a = j;
              const b = j + 1;
              const c = j + 2;
              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

              if (intersection) {
                intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics

                intersection.face.materialIndex = group.materialIndex;
                intersects.push(intersection);
              }
            }
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(position.count, drawRange.start + drawRange.count);

          for (let i = start, il = end; i < il; i += 3) {
            const a = i;
            const b = i + 1;
            const c = i + 2;
            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

            if (intersection) {
              intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics

              intersects.push(intersection);
            }
          }
        }
      }
    } else if (geometry.isGeometry) {
      const isMultiMaterial = Array.isArray(material);
      const vertices = geometry.vertices;
      const faces = geometry.faces;
      let uvs;
      const faceVertexUvs = geometry.faceVertexUvs[0];
      if (faceVertexUvs.length > 0) uvs = faceVertexUvs;

      for (let f = 0, fl = faces.length; f < fl; f++) {
        const face = faces[f];
        const faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
        if (faceMaterial === undefined) continue;
        const fvA = vertices[face.a];
        const fvB = vertices[face.b];
        const fvC = vertices[face.c];
        intersection = checkIntersection(this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint);

        if (intersection) {
          if (uvs && uvs[f]) {
            const uvs_f = uvs[f];

            _uvA.copy(uvs_f[0]);

            _uvB.copy(uvs_f[1]);

            _uvC.copy(uvs_f[2]);

            intersection.uv = Triangle.getUV(_intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2());
          }

          intersection.face = face;
          intersection.faceIndex = f;
          intersects.push(intersection);
        }
      }
    }
  }
});

function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect;

  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
  }

  if (intersect === null) return null;

  _intersectionPointWorld.copy(point);

  _intersectionPointWorld.applyMatrix4(object.matrixWorld);

  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far) return null;
  return {
    distance: distance,
    point: _intersectionPointWorld.clone(),
    object: object
  };
}

function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
  _vA.fromBufferAttribute(position, a);

  _vB.fromBufferAttribute(position, b);

  _vC.fromBufferAttribute(position, c);

  const morphInfluences = object.morphTargetInfluences;

  if (material.morphTargets && morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);

    _morphB.set(0, 0, 0);

    _morphC.set(0, 0, 0);

    for (let i = 0, il = morphPosition.length; i < il; i++) {
      const influence = morphInfluences[i];
      const morphAttribute = morphPosition[i];
      if (influence === 0) continue;

      _tempA.fromBufferAttribute(morphAttribute, a);

      _tempB.fromBufferAttribute(morphAttribute, b);

      _tempC.fromBufferAttribute(morphAttribute, c);

      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);

        _morphB.addScaledVector(_tempB, influence);

        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA), influence);

        _morphB.addScaledVector(_tempB.sub(_vB), influence);

        _morphC.addScaledVector(_tempC.sub(_vC), influence);
      }
    }

    _vA.add(_morphA);

    _vB.add(_morphB);

    _vC.add(_morphC);
  }

  if (object.isSkinnedMesh) {
    object.boneTransform(a, _vA);
    object.boneTransform(b, _vB);
    object.boneTransform(c, _vC);
  }

  const intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);

  if (intersection) {
    if (uv) {
      _uvA.fromBufferAttribute(uv, a);

      _uvB.fromBufferAttribute(uv, b);

      _uvC.fromBufferAttribute(uv, c);

      intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }

    if (uv2) {
      _uvA.fromBufferAttribute(uv2, a);

      _uvB.fromBufferAttribute(uv2, b);

      _uvC.fromBufferAttribute(uv2, c);

      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }

    const face = new Face3(a, b, c);
    Triangle.getNormal(_vA, _vB, _vC, face.normal);
    intersection.face = face;
  }

  return intersection;
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */


let _geometryId = 0; // Geometry uses even numbers as Id

const _m1$3 = new Matrix4();

const _obj$1 = new Object3D();

const _offset$1 = new Vector3();

function Geometry() {
  Object.defineProperty(this, 'id', {
    value: _geometryId += 2
  });
  this.uuid = MathUtils.generateUUID();
  this.name = '';
  this.type = 'Geometry';
  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [[]];
  this.morphTargets = [];
  this.morphNormals = [];
  this.skinWeights = [];
  this.skinIndices = [];
  this.lineDistances = [];
  this.boundingBox = null;
  this.boundingSphere = null; // update flags

  this.elementsNeedUpdate = false;
  this.verticesNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.lineDistancesNeedUpdate = false;
  this.groupsNeedUpdate = false;
}

Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: Geometry,
  isGeometry: true,
  applyMatrix4: function (matrix) {
    const normalMatrix = new Matrix3().getNormalMatrix(matrix);

    for (let i = 0, il = this.vertices.length; i < il; i++) {
      const vertex = this.vertices[i];
      vertex.applyMatrix4(matrix);
    }

    for (let i = 0, il = this.faces.length; i < il; i++) {
      const face = this.faces[i];
      face.normal.applyMatrix3(normalMatrix).normalize();

      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {
        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
      }
    }

    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }

    this.verticesNeedUpdate = true;
    this.normalsNeedUpdate = true;
    return this;
  },
  rotateX: function (angle) {
    // rotate geometry around world x-axis
    _m1$3.makeRotationX(angle);

    this.applyMatrix4(_m1$3);
    return this;
  },
  rotateY: function (angle) {
    // rotate geometry around world y-axis
    _m1$3.makeRotationY(angle);

    this.applyMatrix4(_m1$3);
    return this;
  },
  rotateZ: function (angle) {
    // rotate geometry around world z-axis
    _m1$3.makeRotationZ(angle);

    this.applyMatrix4(_m1$3);
    return this;
  },
  translate: function (x, y, z) {
    // translate geometry
    _m1$3.makeTranslation(x, y, z);

    this.applyMatrix4(_m1$3);
    return this;
  },
  scale: function (x, y, z) {
    // scale geometry
    _m1$3.makeScale(x, y, z);

    this.applyMatrix4(_m1$3);
    return this;
  },
  lookAt: function (vector) {
    _obj$1.lookAt(vector);

    _obj$1.updateMatrix();

    this.applyMatrix4(_obj$1.matrix);
    return this;
  },
  fromBufferGeometry: function (geometry) {
    const scope = this;
    const index = geometry.index !== null ? geometry.index : undefined;
    const attributes = geometry.attributes;

    if (attributes.position === undefined) {
      console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');
      return this;
    }

    const position = attributes.position;
    const normal = attributes.normal;
    const color = attributes.color;
    const uv = attributes.uv;
    const uv2 = attributes.uv2;
    if (uv2 !== undefined) this.faceVertexUvs[1] = [];

    for (let i = 0; i < position.count; i++) {
      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));

      if (color !== undefined) {
        scope.colors.push(new Color().fromBufferAttribute(color, i));
      }
    }

    function addFace(a, b, c, materialIndex) {
      const vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];
      const vertexNormals = normal === undefined ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];
      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
      scope.faces.push(face);

      if (uv !== undefined) {
        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);
      }

      if (uv2 !== undefined) {
        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);
      }
    }

    const groups = geometry.groups;

    if (groups.length > 0) {
      for (let i = 0; i < groups.length; i++) {
        const group = groups[i];
        const start = group.start;
        const count = group.count;

        for (let j = start, jl = start + count; j < jl; j += 3) {
          if (index !== undefined) {
            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);
          } else {
            addFace(j, j + 1, j + 2, group.materialIndex);
          }
        }
      }
    } else {
      if (index !== undefined) {
        for (let i = 0; i < index.count; i += 3) {
          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));
        }
      } else {
        for (let i = 0; i < position.count; i += 3) {
          addFace(i, i + 1, i + 2);
        }
      }
    }

    this.computeFaceNormals();

    if (geometry.boundingBox !== null) {
      this.boundingBox = geometry.boundingBox.clone();
    }

    if (geometry.boundingSphere !== null) {
      this.boundingSphere = geometry.boundingSphere.clone();
    }

    return this;
  },
  center: function () {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset$1).negate();
    this.translate(_offset$1.x, _offset$1.y, _offset$1.z);
    return this;
  },
  normalize: function () {
    this.computeBoundingSphere();
    const center = this.boundingSphere.center;
    const radius = this.boundingSphere.radius;
    const s = radius === 0 ? 1 : 1.0 / radius;
    const matrix = new Matrix4();
    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
    this.applyMatrix4(matrix);
    return this;
  },
  computeFaceNormals: function () {
    const cb = new Vector3(),
          ab = new Vector3();

    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];
      const vA = this.vertices[face.a];
      const vB = this.vertices[face.b];
      const vC = this.vertices[face.c];
      cb.subVectors(vC, vB);
      ab.subVectors(vA, vB);
      cb.cross(ab);
      cb.normalize();
      face.normal.copy(cb);
    }
  },
  computeVertexNormals: function (areaWeighted) {
    if (areaWeighted === undefined) areaWeighted = true;
    const vertices = new Array(this.vertices.length);

    for (let v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v] = new Vector3();
    }

    if (areaWeighted) {
      // vertex normals weighted by triangle areas
      // http://www.iquilezles.org/www/articles/normals/normals.htm
      const cb = new Vector3(),
            ab = new Vector3();

      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        const vA = this.vertices[face.a];
        const vB = this.vertices[face.b];
        const vC = this.vertices[face.c];
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab);
        vertices[face.a].add(cb);
        vertices[face.b].add(cb);
        vertices[face.c].add(cb);
      }
    } else {
      this.computeFaceNormals();

      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        vertices[face.a].add(face.normal);
        vertices[face.b].add(face.normal);
        vertices[face.c].add(face.normal);
      }
    }

    for (let v = 0, vl = this.vertices.length; v < vl; v++) {
      vertices[v].normalize();
    }

    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];
      const vertexNormals = face.vertexNormals;

      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(vertices[face.a]);
        vertexNormals[1].copy(vertices[face.b]);
        vertexNormals[2].copy(vertices[face.c]);
      } else {
        vertexNormals[0] = vertices[face.a].clone();
        vertexNormals[1] = vertices[face.b].clone();
        vertexNormals[2] = vertices[face.c].clone();
      }
    }

    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  },
  computeFlatVertexNormals: function () {
    this.computeFaceNormals();

    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];
      const vertexNormals = face.vertexNormals;

      if (vertexNormals.length === 3) {
        vertexNormals[0].copy(face.normal);
        vertexNormals[1].copy(face.normal);
        vertexNormals[2].copy(face.normal);
      } else {
        vertexNormals[0] = face.normal.clone();
        vertexNormals[1] = face.normal.clone();
        vertexNormals[2] = face.normal.clone();
      }
    }

    if (this.faces.length > 0) {
      this.normalsNeedUpdate = true;
    }
  },
  computeMorphNormals: function () {
    // save original normals
    // - create temp variables on first access
    //   otherwise just copy (for faster repeated calls)
    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];

      if (!face.__originalFaceNormal) {
        face.__originalFaceNormal = face.normal.clone();
      } else {
        face.__originalFaceNormal.copy(face.normal);
      }

      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];

      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {
        if (!face.__originalVertexNormals[i]) {
          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
        } else {
          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
        }
      }
    } // use temp geometry to compute face and vertex normals for each morph


    const tmpGeo = new Geometry();
    tmpGeo.faces = this.faces;

    for (let i = 0, il = this.morphTargets.length; i < il; i++) {
      // create on first access
      if (!this.morphNormals[i]) {
        this.morphNormals[i] = {};
        this.morphNormals[i].faceNormals = [];
        this.morphNormals[i].vertexNormals = [];
        const dstNormalsFace = this.morphNormals[i].faceNormals;
        const dstNormalsVertex = this.morphNormals[i].vertexNormals;

        for (let f = 0, fl = this.faces.length; f < fl; f++) {
          const faceNormal = new Vector3();
          const vertexNormals = {
            a: new Vector3(),
            b: new Vector3(),
            c: new Vector3()
          };
          dstNormalsFace.push(faceNormal);
          dstNormalsVertex.push(vertexNormals);
        }
      }

      const morphNormals = this.morphNormals[i]; // set vertices to morph target

      tmpGeo.vertices = this.morphTargets[i].vertices; // compute morph normals

      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals(); // store morph normals

      for (let f = 0, fl = this.faces.length; f < fl; f++) {
        const face = this.faces[f];
        const faceNormal = morphNormals.faceNormals[f];
        const vertexNormals = morphNormals.vertexNormals[f];
        faceNormal.copy(face.normal);
        vertexNormals.a.copy(face.vertexNormals[0]);
        vertexNormals.b.copy(face.vertexNormals[1]);
        vertexNormals.c.copy(face.vertexNormals[2]);
      }
    } // restore original normals


    for (let f = 0, fl = this.faces.length; f < fl; f++) {
      const face = this.faces[f];
      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;
    }
  },
  computeBoundingBox: function () {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }

    this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function () {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }

    this.boundingSphere.setFromPoints(this.vertices);
  },
  merge: function (geometry, matrix, materialIndexOffset) {
    if (!(geometry && geometry.isGeometry)) {
      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
      return;
    }

    let normalMatrix,
        vertexOffset = this.vertices.length,
        vertices1 = this.vertices,
        vertices2 = geometry.vertices,
        faces1 = this.faces,
        faces2 = geometry.faces,
        colors1 = this.colors,
        colors2 = geometry.colors;
    if (materialIndexOffset === undefined) materialIndexOffset = 0;

    if (matrix !== undefined) {
      normalMatrix = new Matrix3().getNormalMatrix(matrix);
    } // vertices


    for (let i = 0, il = vertices2.length; i < il; i++) {
      const vertex = vertices2[i];
      const vertexCopy = vertex.clone();
      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);
      vertices1.push(vertexCopy);
    } // colors


    for (let i = 0, il = colors2.length; i < il; i++) {
      colors1.push(colors2[i].clone());
    } // faces


    for (let i = 0, il = faces2.length; i < il; i++) {
      let face = faces2[i],
          faceCopy,
          normal,
          color,
          faceVertexNormals = face.vertexNormals,
          faceVertexColors = face.vertexColors;
      faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
      faceCopy.normal.copy(face.normal);

      if (normalMatrix !== undefined) {
        faceCopy.normal.applyMatrix3(normalMatrix).normalize();
      }

      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {
        normal = faceVertexNormals[j].clone();

        if (normalMatrix !== undefined) {
          normal.applyMatrix3(normalMatrix).normalize();
        }

        faceCopy.vertexNormals.push(normal);
      }

      faceCopy.color.copy(face.color);

      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {
        color = faceVertexColors[j];
        faceCopy.vertexColors.push(color.clone());
      }

      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
      faces1.push(faceCopy);
    } // uvs


    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {
      const faceVertexUvs2 = geometry.faceVertexUvs[i];
      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];

      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {
        const uvs2 = faceVertexUvs2[j],
              uvsCopy = [];

        for (let k = 0, kl = uvs2.length; k < kl; k++) {
          uvsCopy.push(uvs2[k].clone());
        }

        this.faceVertexUvs[i].push(uvsCopy);
      }
    }
  },
  mergeMesh: function (mesh) {
    if (!(mesh && mesh.isMesh)) {
      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
      return;
    }

    if (mesh.matrixAutoUpdate) mesh.updateMatrix();
    this.merge(mesh.geometry, mesh.matrix);
  },

  /*
   * Checks for duplicate vertices with hashmap.
   * Duplicated vertices are removed
   * and faces' vertices are updated.
   */
  mergeVertices: function () {
    const verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)

    const unique = [],
          changes = [];
    const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001

    const precision = Math.pow(10, precisionPoints);

    for (let i = 0, il = this.vertices.length; i < il; i++) {
      const v = this.vertices[i];
      const key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);

      if (verticesMap[key] === undefined) {
        verticesMap[key] = i;
        unique.push(this.vertices[i]);
        changes[i] = unique.length - 1;
      } else {
        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
        changes[i] = changes[verticesMap[key]];
      }
    } // if faces are completely degenerate after merging vertices, we
    // have to remove them from the geometry.


    const faceIndicesToRemove = [];

    for (let i = 0, il = this.faces.length; i < il; i++) {
      const face = this.faces[i];
      face.a = changes[face.a];
      face.b = changes[face.b];
      face.c = changes[face.c];
      const indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3
      // we have to remove the face as nothing can be saved

      for (let n = 0; n < 3; n++) {
        if (indices[n] === indices[(n + 1) % 3]) {
          faceIndicesToRemove.push(i);
          break;
        }
      }
    }

    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {
      const idx = faceIndicesToRemove[i];
      this.faces.splice(idx, 1);

      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
        this.faceVertexUvs[j].splice(idx, 1);
      }
    } // Use unique set of vertices


    const diff = this.vertices.length - unique.length;
    this.vertices = unique;
    return diff;
  },
  setFromPoints: function (points) {
    this.vertices = [];

    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
    }

    return this;
  },
  sortFacesByMaterialIndex: function () {
    const faces = this.faces;
    const length = faces.length; // tag faces

    for (let i = 0; i < length; i++) {
      faces[i]._id = i;
    } // sort faces


    function materialIndexSort(a, b) {
      return a.materialIndex - b.materialIndex;
    }

    faces.sort(materialIndexSort); // sort uvs

    const uvs1 = this.faceVertexUvs[0];
    const uvs2 = this.faceVertexUvs[1];
    let newUvs1, newUvs2;
    if (uvs1 && uvs1.length === length) newUvs1 = [];
    if (uvs2 && uvs2.length === length) newUvs2 = [];

    for (let i = 0; i < length; i++) {
      const id = faces[i]._id;
      if (newUvs1) newUvs1.push(uvs1[id]);
      if (newUvs2) newUvs2.push(uvs2[id]);
    }

    if (newUvs1) this.faceVertexUvs[0] = newUvs1;
    if (newUvs2) this.faceVertexUvs[1] = newUvs2;
  },
  toJSON: function () {
    const data = {
      metadata: {
        version: 4.5,
        type: 'Geometry',
        generator: 'Geometry.toJSON'
      }
    }; // standard Geometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== '') data.name = this.name;

    if (this.parameters !== undefined) {
      const parameters = this.parameters;

      for (const key in parameters) {
        if (parameters[key] !== undefined) data[key] = parameters[key];
      }

      return data;
    }

    const vertices = [];

    for (let i = 0; i < this.vertices.length; i++) {
      const vertex = this.vertices[i];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }

    const faces = [];
    const normals = [];
    const normalsHash = {};
    const colors = [];
    const colorsHash = {};
    const uvs = [];
    const uvsHash = {};

    for (let i = 0; i < this.faces.length; i++) {
      const face = this.faces[i];
      const hasMaterial = true;
      const hasFaceUv = false; // deprecated

      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
      const hasFaceNormal = face.normal.length() > 0;
      const hasFaceVertexNormal = face.vertexNormals.length > 0;
      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
      const hasFaceVertexColor = face.vertexColors.length > 0;
      let faceType = 0;
      faceType = setBit(faceType, 0, 0); // isQuad

      faceType = setBit(faceType, 1, hasMaterial);
      faceType = setBit(faceType, 2, hasFaceUv);
      faceType = setBit(faceType, 3, hasFaceVertexUv);
      faceType = setBit(faceType, 4, hasFaceNormal);
      faceType = setBit(faceType, 5, hasFaceVertexNormal);
      faceType = setBit(faceType, 6, hasFaceColor);
      faceType = setBit(faceType, 7, hasFaceVertexColor);
      faces.push(faceType);
      faces.push(face.a, face.b, face.c);
      faces.push(face.materialIndex);

      if (hasFaceVertexUv) {
        const faceVertexUvs = this.faceVertexUvs[0][i];
        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
      }

      if (hasFaceNormal) {
        faces.push(getNormalIndex(face.normal));
      }

      if (hasFaceVertexNormal) {
        const vertexNormals = face.vertexNormals;
        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
      }

      if (hasFaceColor) {
        faces.push(getColorIndex(face.color));
      }

      if (hasFaceVertexColor) {
        const vertexColors = face.vertexColors;
        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
      }
    }

    function setBit(value, position, enabled) {
      return enabled ? value | 1 << position : value & ~(1 << position);
    }

    function getNormalIndex(normal) {
      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

      if (normalsHash[hash] !== undefined) {
        return normalsHash[hash];
      }

      normalsHash[hash] = normals.length / 3;
      normals.push(normal.x, normal.y, normal.z);
      return normalsHash[hash];
    }

    function getColorIndex(color) {
      const hash = color.r.toString() + color.g.toString() + color.b.toString();

      if (colorsHash[hash] !== undefined) {
        return colorsHash[hash];
      }

      colorsHash[hash] = colors.length;
      colors.push(color.getHex());
      return colorsHash[hash];
    }

    function getUvIndex(uv) {
      const hash = uv.x.toString() + uv.y.toString();

      if (uvsHash[hash] !== undefined) {
        return uvsHash[hash];
      }

      uvsHash[hash] = uvs.length / 2;
      uvs.push(uv.x, uv.y);
      return uvsHash[hash];
    }

    data.data = {};
    data.data.vertices = vertices;
    data.data.normals = normals;
    if (colors.length > 0) data.data.colors = colors;
    if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility

    data.data.faces = faces;
    return data;
  },
  clone: function () {
    /*
     // Handle primitives
    	 const parameters = this.parameters;
    	 if ( parameters !== undefined ) {
    	 const values = [];
    	 for ( const key in parameters ) {
    	 values.push( parameters[ key ] );
    	 }
    	 const geometry = Object.create( this.constructor.prototype );
     this.constructor.apply( geometry, values );
     return geometry;
    	 }
    	 return new this.constructor().copy( this );
     */
    return new Geometry().copy(this);
  },
  copy: function (source) {
    // reset
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null; // name

    this.name = source.name; // vertices

    const vertices = source.vertices;

    for (let i = 0, il = vertices.length; i < il; i++) {
      this.vertices.push(vertices[i].clone());
    } // colors


    const colors = source.colors;

    for (let i = 0, il = colors.length; i < il; i++) {
      this.colors.push(colors[i].clone());
    } // faces


    const faces = source.faces;

    for (let i = 0, il = faces.length; i < il; i++) {
      this.faces.push(faces[i].clone());
    } // face vertex uvs


    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {
      const faceVertexUvs = source.faceVertexUvs[i];

      if (this.faceVertexUvs[i] === undefined) {
        this.faceVertexUvs[i] = [];
      }

      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {
        const uvs = faceVertexUvs[j],
              uvsCopy = [];

        for (let k = 0, kl = uvs.length; k < kl; k++) {
          const uv = uvs[k];
          uvsCopy.push(uv.clone());
        }

        this.faceVertexUvs[i].push(uvsCopy);
      }
    } // morph targets


    const morphTargets = source.morphTargets;

    for (let i = 0, il = morphTargets.length; i < il; i++) {
      const morphTarget = {};
      morphTarget.name = morphTargets[i].name; // vertices

      if (morphTargets[i].vertices !== undefined) {
        morphTarget.vertices = [];

        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {
          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
        }
      } // normals


      if (morphTargets[i].normals !== undefined) {
        morphTarget.normals = [];

        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {
          morphTarget.normals.push(morphTargets[i].normals[j].clone());
        }
      }

      this.morphTargets.push(morphTarget);
    } // morph normals


    const morphNormals = source.morphNormals;

    for (let i = 0, il = morphNormals.length; i < il; i++) {
      const morphNormal = {}; // vertex normals

      if (morphNormals[i].vertexNormals !== undefined) {
        morphNormal.vertexNormals = [];

        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
          const srcVertexNormal = morphNormals[i].vertexNormals[j];
          const destVertexNormal = {};
          destVertexNormal.a = srcVertexNormal.a.clone();
          destVertexNormal.b = srcVertexNormal.b.clone();
          destVertexNormal.c = srcVertexNormal.c.clone();
          morphNormal.vertexNormals.push(destVertexNormal);
        }
      } // face normals


      if (morphNormals[i].faceNormals !== undefined) {
        morphNormal.faceNormals = [];

        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {
          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
        }
      }

      this.morphNormals.push(morphNormal);
    } // skin weights


    const skinWeights = source.skinWeights;

    for (let i = 0, il = skinWeights.length; i < il; i++) {
      this.skinWeights.push(skinWeights[i].clone());
    } // skin indices


    const skinIndices = source.skinIndices;

    for (let i = 0, il = skinIndices.length; i < il; i++) {
      this.skinIndices.push(skinIndices[i].clone());
    } // line distances


    const lineDistances = source.lineDistances;

    for (let i = 0, il = lineDistances.length; i < il; i++) {
      this.lineDistances.push(lineDistances[i]);
    } // bounding box


    const boundingBox = source.boundingBox;

    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    } // bounding sphere


    const boundingSphere = source.boundingSphere;

    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    } // update flags


    this.elementsNeedUpdate = source.elementsNeedUpdate;
    this.verticesNeedUpdate = source.verticesNeedUpdate;
    this.uvsNeedUpdate = source.uvsNeedUpdate;
    this.normalsNeedUpdate = source.normalsNeedUpdate;
    this.colorsNeedUpdate = source.colorsNeedUpdate;
    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
    this.groupsNeedUpdate = source.groupsNeedUpdate;
    return this;
  },
  dispose: function () {
    this.dispatchEvent({
      type: 'dispose'
    });
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */
// BoxGeometry

class BoxGeometry extends Geometry {
  constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {
    super();
    this.type = 'BoxGeometry';
    this.parameters = {
      width: width,
      height: height,
      depth: depth,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      depthSegments: depthSegments
    };
    this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
    this.mergeVertices();
  }

} // BoxBufferGeometry


exports.CubeGeometry = exports.BoxGeometry = BoxGeometry;

class BoxBufferGeometry extends BufferGeometry {
  constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {
    super();
    this.type = 'BoxBufferGeometry';
    this.parameters = {
      width: width,
      height: height,
      depth: depth,
      widthSegments: widthSegments,
      heightSegments: heightSegments,
      depthSegments: depthSegments
    };
    const scope = this;
    width = width || 1;
    height = height || 1;
    depth = depth || 1; // segments

    widthSegments = Math.floor(widthSegments) || 1;
    heightSegments = Math.floor(heightSegments) || 1;
    depthSegments = Math.floor(depthSegments) || 1; // buffers

    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = []; // helper variables

    let numberOfVertices = 0;
    let groupStart = 0; // build each side of the box geometry

    buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px

    buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx

    buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py

    buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny

    buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz

    buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
    // build geometry

    this.setIndex(indices);
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
      const segmentWidth = width / gridX;
      const segmentHeight = height / gridY;
      const widthHalf = width / 2;
      const heightHalf = height / 2;
      const depthHalf = depth / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3(); // generate vertices, normals and uvs

      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight - heightHalf;

        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf; // set values to correct vector component

          vector[u] = x * udir;
          vector[v] = y * vdir;
          vector[w] = depthHalf; // now apply vector to vertex buffer

          vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component

          vector[u] = 0;
          vector[v] = 0;
          vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer

          normals.push(vector.x, vector.y, vector.z); // uvs

          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY); // counters

          vertexCounter += 1;
        }
      } // indices
      // 1. you need three indices to draw a single face
      // 2. a single segment consists of two faces
      // 3. so we need to generate six (2*3) indices per segment


      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces

          indices.push(a, b, d);
          indices.push(b, c, d); // increase counter

          groupCount += 6;
        }
      } // add a group to the geometry. this will ensure multi material support


      scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups

      groupStart += groupCount; // update total number of vertices

      numberOfVertices += vertexCounter;
    }
  }

}
/**
 * Uniform Utilities
 */


exports.BoxBufferGeometry = BoxBufferGeometry;

function cloneUniforms(src) {
  const dst = {};

  for (const u in src) {
    dst[u] = {};

    for (const p in src[u]) {
      const property = src[u][p];

      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) {
        dst[u][p] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }

  return dst;
}

function mergeUniforms(uniforms) {
  const merged = {};

  for (let u = 0; u < uniforms.length; u++) {
    const tmp = cloneUniforms(uniforms[u]);

    for (const p in tmp) {
      merged[p] = tmp[p];
    }
  }

  return merged;
} // Legacy


const UniformsUtils = {
  clone: cloneUniforms,
  merge: mergeUniforms
};
exports.UniformsUtils = UniformsUtils;
var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function ShaderMaterial(parameters) {
  Material.call(this);
  this.type = 'ShaderMaterial';
  this.defines = {};
  this.uniforms = {};
  this.vertexShader = default_vertex;
  this.fragmentShader = default_fragment;
  this.linewidth = 1;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false; // set to use scene fog

  this.lights = false; // set to use scene lights

  this.clipping = false; // set to use user-defined clipping planes

  this.skinning = false; // set to use skinning attribute streams

  this.morphTargets = false; // set to use morph targets

  this.morphNormals = false; // set to use morph normals

  this.extensions = {
    derivatives: false,
    // set to use derivatives
    fragDepth: false,
    // set to use fragment depth values
    drawBuffers: false,
    // set to use draw buffers
    shaderTextureLOD: false // set to use shader texture LOD

  }; // When rendered geometry doesn't include these attributes but the material does,
  // use these default values in WebGL. This avoids errors when buffer data is missing.

  this.defaultAttributeValues = {
    'color': [1, 1, 1],
    'uv': [0, 0],
    'uv2': [0, 0]
  };
  this.index0AttributeName = undefined;
  this.uniformsNeedUpdate = false;

  if (parameters !== undefined) {
    if (parameters.attributes !== undefined) {
      console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
    }

    this.setValues(parameters);
  }
}

ShaderMaterial.prototype = Object.create(Material.prototype);
ShaderMaterial.prototype.constructor = ShaderMaterial;
ShaderMaterial.prototype.isShaderMaterial = true;

ShaderMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.fragmentShader = source.fragmentShader;
  this.vertexShader = source.vertexShader;
  this.uniforms = cloneUniforms(source.uniforms);
  this.defines = Object.assign({}, source.defines);
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.lights = source.lights;
  this.clipping = source.clipping;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.extensions = Object.assign({}, source.extensions);
  return this;
};

ShaderMaterial.prototype.toJSON = function (meta) {
  const data = Material.prototype.toJSON.call(this, meta);
  data.uniforms = {};

  for (const name in this.uniforms) {
    const uniform = this.uniforms[name];
    const value = uniform.value;

    if (value && value.isTexture) {
      data.uniforms[name] = {
        type: 't',
        value: value.toJSON(meta).uuid
      };
    } else if (value && value.isColor) {
      data.uniforms[name] = {
        type: 'c',
        value: value.getHex()
      };
    } else if (value && value.isVector2) {
      data.uniforms[name] = {
        type: 'v2',
        value: value.toArray()
      };
    } else if (value && value.isVector3) {
      data.uniforms[name] = {
        type: 'v3',
        value: value.toArray()
      };
    } else if (value && value.isVector4) {
      data.uniforms[name] = {
        type: 'v4',
        value: value.toArray()
      };
    } else if (value && value.isMatrix3) {
      data.uniforms[name] = {
        type: 'm3',
        value: value.toArray()
      };
    } else if (value && value.isMatrix4) {
      data.uniforms[name] = {
        type: 'm4',
        value: value.toArray()
      };
    } else {
      data.uniforms[name] = {
        value: value
      }; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
    }
  }

  if (Object.keys(this.defines).length > 0) data.defines = this.defines;
  data.vertexShader = this.vertexShader;
  data.fragmentShader = this.fragmentShader;
  const extensions = {};

  for (const key in this.extensions) {
    if (this.extensions[key] === true) extensions[key] = true;
  }

  if (Object.keys(extensions).length > 0) data.extensions = extensions;
  return data;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/


function Camera() {
  Object3D.call(this);
  this.type = 'Camera';
  this.matrixWorldInverse = new Matrix4();
  this.projectionMatrix = new Matrix4();
  this.projectionMatrixInverse = new Matrix4();
}

Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Camera,
  isCamera: true,
  copy: function (source, recursive) {
    Object3D.prototype.copy.call(this, source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    return this;
  },
  getWorldDirection: function (target) {
    if (target === undefined) {
      console.warn('THREE.Camera: .getWorldDirection() target is now required');
      target = new Vector3();
    }

    this.updateMatrixWorld(true);
    const e = this.matrixWorld.elements;
    return target.set(-e[8], -e[9], -e[10]).normalize();
  },
  updateMatrixWorld: function (force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  updateWorldMatrix: function (updateParents, updateChildren) {
    Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
    this.matrixWorldInverse.getInverse(this.matrixWorld);
  },
  clone: function () {
    return new this.constructor().copy(this);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author tschw
 */

function PerspectiveCamera(fov, aspect, near, far) {
  Camera.call(this);
  this.type = 'PerspectiveCamera';
  this.fov = fov !== undefined ? fov : 50;
  this.zoom = 1;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;
  this.focus = 10;
  this.aspect = aspect !== undefined ? aspect : 1;
  this.view = null;
  this.filmGauge = 35; // width of the film (default in millimeters)

  this.filmOffset = 0; // horizontal film offset (same unit as gauge)

  this.updateProjectionMatrix();
}

PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: PerspectiveCamera,
  isPerspectiveCamera: true,
  copy: function (source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  },

  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength: function (focalLength) {
    // see http://www.bobatkins.com/photography/technical/field_of_view.html
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  },

  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength: function () {
    const vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  },
  getEffectiveFOV: function () {
    return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
  },
  getFilmWidth: function () {
    // film not completely covered in portrait format (aspect < 1)
    return this.filmGauge * Math.min(this.aspect, 1);
  },
  getFilmHeight: function () {
    // film not completely covered in landscape format (aspect > 1)
    return this.filmGauge / Math.max(this.aspect, 1);
  },

  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;

    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }

    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function () {
    if (this.view !== null) {
      this.view.enabled = false;
    }

    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function () {
    let near = this.near,
        top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom,
        height = 2 * top,
        width = this.aspect * height,
        left = -0.5 * width,
        view = this.view;

    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth,
            fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }

    const skew = this.filmOffset;
    if (skew !== 0) left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function (meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
});
/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

const fov = 90,
      aspect = 1;

function CubeCamera(near, far, renderTarget) {
  Object3D.call(this);
  this.type = 'CubeCamera';

  if (renderTarget.isWebGLCubeRenderTarget !== true) {
    console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
    return;
  }

  this.renderTarget = renderTarget;
  const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
  cameraPX.layers = this.layers;
  cameraPX.up.set(0, -1, 0);
  cameraPX.lookAt(new Vector3(1, 0, 0));
  this.add(cameraPX);
  const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
  cameraNX.layers = this.layers;
  cameraNX.up.set(0, -1, 0);
  cameraNX.lookAt(new Vector3(-1, 0, 0));
  this.add(cameraNX);
  const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
  cameraPY.layers = this.layers;
  cameraPY.up.set(0, 0, 1);
  cameraPY.lookAt(new Vector3(0, 1, 0));
  this.add(cameraPY);
  const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
  cameraNY.layers = this.layers;
  cameraNY.up.set(0, 0, -1);
  cameraNY.lookAt(new Vector3(0, -1, 0));
  this.add(cameraNY);
  const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
  cameraPZ.layers = this.layers;
  cameraPZ.up.set(0, -1, 0);
  cameraPZ.lookAt(new Vector3(0, 0, 1));
  this.add(cameraPZ);
  const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
  cameraNZ.layers = this.layers;
  cameraNZ.up.set(0, -1, 0);
  cameraNZ.lookAt(new Vector3(0, 0, -1));
  this.add(cameraNZ);

  this.update = function (renderer, scene) {
    if (this.parent === null) this.updateMatrixWorld();
    const currentXrEnabled = renderer.xr.enabled;
    const currentRenderTarget = renderer.getRenderTarget();
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.xr.enabled = currentXrEnabled;
  };

  this.clear = function (renderer, color, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();

    for (let i = 0; i < 6; i++) {
      renderer.setRenderTarget(renderTarget, i);
      renderer.clear(color, depth, stencil);
    }

    renderer.setRenderTarget(currentRenderTarget);
  };
}

CubeCamera.prototype = Object.create(Object3D.prototype);
CubeCamera.prototype.constructor = CubeCamera;
/**
 * @author alteredq / http://alteredqualia.com
 * @author WestLangley / http://github.com/WestLangley
 */

function WebGLCubeRenderTarget(size, options, dummy) {
  if (Number.isInteger(options)) {
    console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
    options = dummy;
  }

  WebGLRenderTarget.call(this, size, size, options);
}

WebGLCubeRenderTarget.prototype = Object.create(WebGLRenderTarget.prototype);
WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function (renderer, texture) {
  this.texture.type = texture.type;
  this.texture.format = texture.format;
  this.texture.encoding = texture.encoding;
  const scene = new Scene();
  const shader = {
    uniforms: {
      tEquirect: {
        value: null
      }
    },
    vertexShader: ["varying vec3 vWorldDirection;", "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {", "	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );", "}", "void main() {", "	vWorldDirection = transformDirection( position, modelMatrix );", "	#include <begin_vertex>", "	#include <project_vertex>", "}"].join('\n'),
    fragmentShader: ["uniform sampler2D tEquirect;", "varying vec3 vWorldDirection;", "#include <common>", "void main() {", "	vec3 direction = normalize( vWorldDirection );", "	vec2 sampleUV = equirectUv( direction );", "	gl_FragColor = texture2D( tEquirect, sampleUV );", "}"].join('\n')
  };
  const material = new ShaderMaterial({
    name: 'CubemapFromEquirect',
    uniforms: cloneUniforms(shader.uniforms),
    vertexShader: shader.vertexShader,
    fragmentShader: shader.fragmentShader,
    side: BackSide,
    blending: NoBlending
  });
  material.uniforms.tEquirect.value = texture;
  const mesh = new Mesh(new BoxBufferGeometry(5, 5, 5), material);
  scene.add(mesh);
  const camera = new CubeCamera(1, 10, this);
  camera.update(renderer, scene);
  mesh.geometry.dispose();
  mesh.material.dispose();
  return this;
};
/**
 * @author alteredq / http://alteredqualia.com/
 */


function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.image = {
    data: data || null,
    width: width || 1,
    height: height || 1
  };
  this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
  this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
  this.generateMipmaps = false;
  this.flipY = false;
  this.unpackAlignment = 1;
  this.needsUpdate = true;
}

DataTexture.prototype = Object.create(Texture.prototype);
DataTexture.prototype.constructor = DataTexture;
DataTexture.prototype.isDataTexture = true;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

const _sphere$1 = new Sphere();

const _vector$5 = new Vector3();

function Frustum(p0, p1, p2, p3, p4, p5) {
  this.planes = [p0 !== undefined ? p0 : new Plane(), p1 !== undefined ? p1 : new Plane(), p2 !== undefined ? p2 : new Plane(), p3 !== undefined ? p3 : new Plane(), p4 !== undefined ? p4 : new Plane(), p5 !== undefined ? p5 : new Plane()];
}

Object.assign(Frustum.prototype, {
  set: function (p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (frustum) {
    const planes = this.planes;

    for (let i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }

    return this;
  },
  setFromProjectionMatrix: function (m) {
    const planes = this.planes;
    const me = m.elements;
    const me0 = me[0],
          me1 = me[1],
          me2 = me[2],
          me3 = me[3];
    const me4 = me[4],
          me5 = me[5],
          me6 = me[6],
          me7 = me[7];
    const me8 = me[8],
          me9 = me[9],
          me10 = me[10],
          me11 = me[11];
    const me12 = me[12],
          me13 = me[13],
          me14 = me[14],
          me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    return this;
  },
  intersectsObject: function (object) {
    const geometry = object.geometry;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

    _sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);

    return this.intersectsSphere(_sphere$1);
  },
  intersectsSprite: function (sprite) {
    _sphere$1.center.set(0, 0, 0);

    _sphere$1.radius = 0.7071067811865476;

    _sphere$1.applyMatrix4(sprite.matrixWorld);

    return this.intersectsSphere(_sphere$1);
  },
  intersectsSphere: function (sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;

    for (let i = 0; i < 6; i++) {
      const distance = planes[i].distanceToPoint(center);

      if (distance < negRadius) {
        return false;
      }
    }

    return true;
  },
  intersectsBox: function (box) {
    const planes = this.planes;

    for (let i = 0; i < 6; i++) {
      const plane = planes[i]; // corner at max distance

      _vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;

      if (plane.distanceToPoint(_vector$5) < 0) {
        return false;
      }
    }

    return true;
  },
  containsPoint: function (point) {
    const planes = this.planes;

    for (let i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }

    return true;
  }
});
/**
 * Uniforms library for shared webgl shaders
 */

const UniformsLib = {
  common: {
    diffuse: {
      value: new Color(0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    map: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    },
    uv2Transform: {
      value: new Matrix3()
    },
    alphaMap: {
      value: null
    }
  },
  specularmap: {
    specularMap: {
      value: null
    }
  },
  envmap: {
    envMap: {
      value: null
    },
    flipEnvMap: {
      value: -1
    },
    reflectivity: {
      value: 1.0
    },
    refractionRatio: {
      value: 0.98
    },
    maxMipLevel: {
      value: 0
    }
  },
  aomap: {
    aoMap: {
      value: null
    },
    aoMapIntensity: {
      value: 1
    }
  },
  lightmap: {
    lightMap: {
      value: null
    },
    lightMapIntensity: {
      value: 1
    }
  },
  emissivemap: {
    emissiveMap: {
      value: null
    }
  },
  bumpmap: {
    bumpMap: {
      value: null
    },
    bumpScale: {
      value: 1
    }
  },
  normalmap: {
    normalMap: {
      value: null
    },
    normalScale: {
      value: new Vector2(1, 1)
    }
  },
  displacementmap: {
    displacementMap: {
      value: null
    },
    displacementScale: {
      value: 1
    },
    displacementBias: {
      value: 0
    }
  },
  roughnessmap: {
    roughnessMap: {
      value: null
    }
  },
  metalnessmap: {
    metalnessMap: {
      value: null
    }
  },
  gradientmap: {
    gradientMap: {
      value: null
    }
  },
  fog: {
    fogDensity: {
      value: 0.00025
    },
    fogNear: {
      value: 1
    },
    fogFar: {
      value: 2000
    },
    fogColor: {
      value: new Color(0xffffff)
    }
  },
  lights: {
    ambientLightColor: {
      value: []
    },
    lightProbe: {
      value: []
    },
    directionalLights: {
      value: [],
      properties: {
        direction: {},
        color: {}
      }
    },
    directionalLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    directionalShadowMap: {
      value: []
    },
    directionalShadowMatrix: {
      value: []
    },
    spotLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {}
      }
    },
    spotLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      }
    },
    spotShadowMap: {
      value: []
    },
    spotShadowMatrix: {
      value: []
    },
    pointLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        decay: {},
        distance: {}
      }
    },
    pointLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      }
    },
    pointShadowMap: {
      value: []
    },
    pointShadowMatrix: {
      value: []
    },
    hemisphereLights: {
      value: [],
      properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      }
    },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      }
    }
  },
  points: {
    diffuse: {
      value: new Color(0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    size: {
      value: 1.0
    },
    scale: {
      value: 1.0
    },
    map: {
      value: null
    },
    alphaMap: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    }
  },
  sprite: {
    diffuse: {
      value: new Color(0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    center: {
      value: new Vector2(0.5, 0.5)
    },
    rotation: {
      value: 0.0
    },
    map: {
      value: null
    },
    alphaMap: {
      value: null
    },
    uvTransform: {
      value: new Matrix3()
    }
  }
};
/**
 * @author mrdoob / http://mrdoob.com/
 */

exports.UniformsLib = UniformsLib;

function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;

  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }

  return {
    start: function () {
      if (isAnimating === true) return;
      if (animationLoop === null) return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function () {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function (callback) {
      animationLoop = callback;
    },
    setContext: function (value) {
      context = value;
    }
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = new WeakMap();

  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type = 5126;

    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Float64Array) {
      console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
    } else if (array instanceof Uint16Array) {
      type = 5123;
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    }

    return {
      buffer: buffer,
      type: type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }

  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);

    if (updateRange.count === -1) {
      // Not using update ranges
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      } else {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }

      updateRange.count = -1; // reset range
    }
  } //


  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers.get(attribute);
  }

  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers.get(attribute);

    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }

  function update(attribute, bufferType) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers.get(attribute);

    if (data === undefined) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }

  return {
    get: get,
    remove: remove,
    update: update
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */
// PlaneGeometry


function PlaneGeometry(width, height, widthSegments, heightSegments) {
  Geometry.call(this);
  this.type = 'PlaneGeometry';
  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };
  this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
  this.mergeVertices();
}

PlaneGeometry.prototype = Object.create(Geometry.prototype);
PlaneGeometry.prototype.constructor = PlaneGeometry; // PlaneBufferGeometry

function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
  BufferGeometry.call(this);
  this.type = 'PlaneBufferGeometry';
  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };
  width = width || 1;
  height = height || 1;
  const width_half = width / 2;
  const height_half = height / 2;
  const gridX = Math.floor(widthSegments) || 1;
  const gridY = Math.floor(heightSegments) || 1;
  const gridX1 = gridX + 1;
  const gridY1 = gridY + 1;
  const segment_width = width / gridX;
  const segment_height = height / gridY; // buffers

  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = []; // generate vertices, normals and uvs

  for (let iy = 0; iy < gridY1; iy++) {
    const y = iy * segment_height - height_half;

    for (let ix = 0; ix < gridX1; ix++) {
      const x = ix * segment_width - width_half;
      vertices.push(x, -y, 0);
      normals.push(0, 0, 1);
      uvs.push(ix / gridX);
      uvs.push(1 - iy / gridY);
    }
  } // indices


  for (let iy = 0; iy < gridY; iy++) {
    for (let ix = 0; ix < gridX; ix++) {
      const a = ix + gridX1 * iy;
      const b = ix + gridX1 * (iy + 1);
      const c = ix + 1 + gridX1 * (iy + 1);
      const d = ix + 1 + gridX1 * iy; // faces

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";
var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";
var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";
var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";
var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";
var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
const ShaderChunk = {
  alphamap_fragment: alphamap_fragment,
  alphamap_pars_fragment: alphamap_pars_fragment,
  alphatest_fragment: alphatest_fragment,
  aomap_fragment: aomap_fragment,
  aomap_pars_fragment: aomap_pars_fragment,
  begin_vertex: begin_vertex,
  beginnormal_vertex: beginnormal_vertex,
  bsdfs: bsdfs,
  bumpmap_pars_fragment: bumpmap_pars_fragment,
  clipping_planes_fragment: clipping_planes_fragment,
  clipping_planes_pars_fragment: clipping_planes_pars_fragment,
  clipping_planes_pars_vertex: clipping_planes_pars_vertex,
  clipping_planes_vertex: clipping_planes_vertex,
  color_fragment: color_fragment,
  color_pars_fragment: color_pars_fragment,
  color_pars_vertex: color_pars_vertex,
  color_vertex: color_vertex,
  common: common,
  cube_uv_reflection_fragment: cube_uv_reflection_fragment,
  defaultnormal_vertex: defaultnormal_vertex,
  displacementmap_pars_vertex: displacementmap_pars_vertex,
  displacementmap_vertex: displacementmap_vertex,
  emissivemap_fragment: emissivemap_fragment,
  emissivemap_pars_fragment: emissivemap_pars_fragment,
  encodings_fragment: encodings_fragment,
  encodings_pars_fragment: encodings_pars_fragment,
  envmap_fragment: envmap_fragment,
  envmap_common_pars_fragment: envmap_common_pars_fragment,
  envmap_pars_fragment: envmap_pars_fragment,
  envmap_pars_vertex: envmap_pars_vertex,
  envmap_physical_pars_fragment: envmap_physical_pars_fragment,
  envmap_vertex: envmap_vertex,
  fog_vertex: fog_vertex,
  fog_pars_vertex: fog_pars_vertex,
  fog_fragment: fog_fragment,
  fog_pars_fragment: fog_pars_fragment,
  gradientmap_pars_fragment: gradientmap_pars_fragment,
  lightmap_fragment: lightmap_fragment,
  lightmap_pars_fragment: lightmap_pars_fragment,
  lights_lambert_vertex: lights_lambert_vertex,
  lights_pars_begin: lights_pars_begin,
  lights_toon_fragment: lights_toon_fragment,
  lights_toon_pars_fragment: lights_toon_pars_fragment,
  lights_phong_fragment: lights_phong_fragment,
  lights_phong_pars_fragment: lights_phong_pars_fragment,
  lights_physical_fragment: lights_physical_fragment,
  lights_physical_pars_fragment: lights_physical_pars_fragment,
  lights_fragment_begin: lights_fragment_begin,
  lights_fragment_maps: lights_fragment_maps,
  lights_fragment_end: lights_fragment_end,
  logdepthbuf_fragment: logdepthbuf_fragment,
  logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
  logdepthbuf_vertex: logdepthbuf_vertex,
  map_fragment: map_fragment,
  map_pars_fragment: map_pars_fragment,
  map_particle_fragment: map_particle_fragment,
  map_particle_pars_fragment: map_particle_pars_fragment,
  metalnessmap_fragment: metalnessmap_fragment,
  metalnessmap_pars_fragment: metalnessmap_pars_fragment,
  morphnormal_vertex: morphnormal_vertex,
  morphtarget_pars_vertex: morphtarget_pars_vertex,
  morphtarget_vertex: morphtarget_vertex,
  normal_fragment_begin: normal_fragment_begin,
  normal_fragment_maps: normal_fragment_maps,
  normalmap_pars_fragment: normalmap_pars_fragment,
  clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment: clearcoat_pars_fragment,
  packing: packing,
  premultiplied_alpha_fragment: premultiplied_alpha_fragment,
  project_vertex: project_vertex,
  dithering_fragment: dithering_fragment,
  dithering_pars_fragment: dithering_pars_fragment,
  roughnessmap_fragment: roughnessmap_fragment,
  roughnessmap_pars_fragment: roughnessmap_pars_fragment,
  shadowmap_pars_fragment: shadowmap_pars_fragment,
  shadowmap_pars_vertex: shadowmap_pars_vertex,
  shadowmap_vertex: shadowmap_vertex,
  shadowmask_pars_fragment: shadowmask_pars_fragment,
  skinbase_vertex: skinbase_vertex,
  skinning_pars_vertex: skinning_pars_vertex,
  skinning_vertex: skinning_vertex,
  skinnormal_vertex: skinnormal_vertex,
  specularmap_fragment: specularmap_fragment,
  specularmap_pars_fragment: specularmap_pars_fragment,
  tonemapping_fragment: tonemapping_fragment,
  tonemapping_pars_fragment: tonemapping_pars_fragment,
  uv_pars_fragment: uv_pars_fragment,
  uv_pars_vertex: uv_pars_vertex,
  uv_vertex: uv_vertex,
  uv2_pars_fragment: uv2_pars_fragment,
  uv2_pars_vertex: uv2_pars_vertex,
  uv2_vertex: uv2_vertex,
  worldpos_vertex: worldpos_vertex,
  background_frag: background_frag,
  background_vert: background_vert,
  cube_frag: cube_frag,
  cube_vert: cube_vert,
  depth_frag: depth_frag,
  depth_vert: depth_vert,
  distanceRGBA_frag: distanceRGBA_frag,
  distanceRGBA_vert: distanceRGBA_vert,
  equirect_frag: equirect_frag,
  equirect_vert: equirect_vert,
  linedashed_frag: linedashed_frag,
  linedashed_vert: linedashed_vert,
  meshbasic_frag: meshbasic_frag,
  meshbasic_vert: meshbasic_vert,
  meshlambert_frag: meshlambert_frag,
  meshlambert_vert: meshlambert_vert,
  meshmatcap_frag: meshmatcap_frag,
  meshmatcap_vert: meshmatcap_vert,
  meshtoon_frag: meshtoon_frag,
  meshtoon_vert: meshtoon_vert,
  meshphong_frag: meshphong_frag,
  meshphong_vert: meshphong_vert,
  meshphysical_frag: meshphysical_frag,
  meshphysical_vert: meshphysical_vert,
  normal_frag: normal_frag,
  normal_vert: normal_vert,
  points_frag: points_frag,
  points_vert: points_vert,
  shadow_frag: shadow_frag,
  shadow_vert: shadow_vert,
  sprite_frag: sprite_frag,
  sprite_vert: sprite_vert
};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */

exports.ShaderChunk = ShaderChunk;
const ShaderLib = {
  basic: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      }
    }]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      },
      specular: {
        value: new Color(0x111111)
      },
      shininess: {
        value: 30
      }
    }]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      },
      roughness: {
        value: 1.0
      },
      metalness: {
        value: 0.0
      },
      envMapIntensity: {
        value: 1
      } // temporary

    }]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
      emissive: {
        value: new Color(0x000000)
      }
    }]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
      matcap: {
        value: null
      }
    }]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
      scale: {
        value: 1
      },
      dashSize: {
        value: 1
      },
      totalSize: {
        value: 2
      }
    }]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.normal_vert,
    fragmentShader: ShaderChunk.normal_frag
  },
  sprite: {
    uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: {
        value: new Matrix3()
      },
      t2D: {
        value: null
      }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },

  /* -------------------------------------------------------------------------
  //	Cube map shader
   ------------------------------------------------------------------------- */
  cube: {
    uniforms: mergeUniforms([UniformsLib.envmap, {
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: {
        value: null
      }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
      referencePosition: {
        value: new Vector3()
      },
      nearDistance: {
        value: 1
      },
      farDistance: {
        value: 1000
      }
    }]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
      color: {
        value: new Color(0x00000)
      },
      opacity: {
        value: 1.0
      }
    }]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
exports.ShaderLib = ShaderLib;
ShaderLib.physical = {
  uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
    clearcoat: {
      value: 0
    },
    clearcoatMap: {
      value: null
    },
    clearcoatRoughness: {
      value: 0
    },
    clearcoatRoughnessMap: {
      value: null
    },
    clearcoatNormalScale: {
      value: new Vector2(1, 1)
    },
    clearcoatNormalMap: {
      value: null
    },
    sheen: {
      value: new Color(0x000000)
    },
    transparency: {
      value: 0
    }
  }]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLBackground(renderer, state, objects, premultipliedAlpha) {
  const clearColor = new Color(0x000000);
  let clearAlpha = 0;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;

  function render(renderList, scene, camera, forceClear) {
    let background = scene.isScene === true ? scene.background : null; // Ignore background in AR
    // TODO: Reconsider this.

    const xr = renderer.xr;
    const session = xr.getSession && xr.getSession();

    if (session && session.environmentBlendMode === 'additive') {
      background = null;
    }

    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }

    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }

    if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === undefined) {
        boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
          name: 'BackgroundCubeMaterial',
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute('normal');
        boxMesh.geometry.deleteAttribute('uv');

        boxMesh.onBeforeRender = function (renderer, scene, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        }; // enable code injection for non-built-in material


        Object.defineProperty(boxMesh.material, 'envMap', {
          get: function () {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }

      const texture = background.isWebGLCubeRenderTarget ? background.texture : background;
      boxMesh.material.uniforms.envMap.value = texture;
      boxMesh.material.uniforms.flipEnvMap.value = texture.isCubeTexture ? -1 : 1;

      if (currentBackground !== background || currentBackgroundVersion !== texture.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = texture.version;
        currentTonemapping = renderer.toneMapping;
      } // push to the pre-sorted opaque render list


      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === undefined) {
        planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new ShaderMaterial({
          name: 'BackgroundMaterial',
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute('normal'); // enable code injection for non-built-in material

        Object.defineProperty(planeMesh.material, 'map', {
          get: function () {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }

      planeMesh.material.uniforms.t2D.value = background;

      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }

      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      } // push to the pre-sorted opaque render list


      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }

  function setClear(color, alpha) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
  }

  return {
    getClearColor: function () {
      return clearColor;
    },
    setClearColor: function (color, alpha) {
      clearColor.set(color);
      clearAlpha = alpha !== undefined ? alpha : 1;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function () {
      return clearAlpha;
    },
    setClearAlpha: function (alpha) {
      clearAlpha = alpha;
      setClear(clearColor, clearAlpha);
    },
    render: render
  };
}
/**
 * @author Mugen87 / https://github.com/Mugen87
 * @author Takahiro / https://github.com/takahirox
 */


function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(34921);
  const extension = null; //capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );

  const vaoAvailable = false; // capabilities.isWebGL2 || extension !== null;

  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;

  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;

    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);

      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }

      updateBuffers = needsUpdate(geometry);
      if (updateBuffers) saveCache(geometry);
    } else {
      const wireframe = material.wireframe === true;

      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }

    if (object.isInstancedMesh === true) {
      updateBuffers = true;
    }

    if (index !== null) {
      attributes.update(index, 34963);
    }

    if (updateBuffers) {
      setupVertexAttributes(object, material, program, geometry);

      if (index !== null) {
        gl.bindBuffer(34963, attributes.get(index).buffer);
      }
    }
  }

  function createVertexArrayObject() {
    if (capabilities.isWebGL2) return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }

  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }

  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }

  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];

    if (programMap === undefined) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }

    let stateMap = programMap[program.id];

    if (stateMap === undefined) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }

    let state = stateMap[wireframe];

    if (state === undefined) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }

    return state;
  }

  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];

    for (let i = 0; i < maxVertexAttributes; i++) {
      newAttributes[i] = 0;
      enabledAttributes[i] = 0;
      attributeDivisors[i] = 0;
    }

    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes: newAttributes,
      enabledAttributes: enabledAttributes,
      attributeDivisors: attributeDivisors,
      object: vao,
      attributes: {}
    };
  }

  function needsUpdate(geometry) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    if (Object.keys(cachedAttributes).length !== Object.keys(geometryAttributes).length) return true;

    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute.attribute !== geometryAttribute) return true;
      if (cachedAttribute.data !== geometryAttribute.data) return true;
    }

    return false;
  }

  function saveCache(geometry) {
    const cache = {};
    const attributes = geometry.attributes;

    for (const key in attributes) {
      const attribute = attributes[key];
      const data = {};
      data.attribute = attribute;

      if (attribute.data) {
        data.data = attribute.data;
      }

      cache[key] = data;
    }

    currentState.attributes = cache;
  }

  function initAttributes() {
    const newAttributes = currentState.newAttributes;

    for (let i = 0, il = newAttributes.length; i < il; i++) {
      newAttributes[i] = 0;
    }
  }

  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }

  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;

    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }

    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
      extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }

  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;

    for (let i = 0, il = enabledAttributes.length; i < il; i++) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }

  function vertexAttribPointer(index, size, type, normalized, stride, offset) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index, size, type, normalized, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }

  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get('ANGLE_instanced_arrays') === null) return;
    }

    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;

    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];

      if (programAttribute >= 0) {
        const geometryAttribute = geometryAttributes[name];

        if (geometryAttribute !== undefined) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore

          if (attribute === undefined) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;

          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;

            if (data && data.isInstancedInterleavedBuffer) {
              enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);

              if (geometry._maxInstanceCount === undefined) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              enableAttribute(programAttribute);
            }

            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);

              if (geometry._maxInstanceCount === undefined) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              enableAttribute(programAttribute);
            }

            gl.bindBuffer(34962, buffer);
            vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
          }
        } else if (name === 'instanceMatrix') {
          const attribute = attributes.get(object.instanceMatrix); // TODO Attribute may not be available on context restore

          if (attribute === undefined) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          enableAttributeAndDivisor(programAttribute + 0, 1);
          enableAttributeAndDivisor(programAttribute + 1, 1);
          enableAttributeAndDivisor(programAttribute + 2, 1);
          enableAttributeAndDivisor(programAttribute + 3, 1);
          gl.bindBuffer(34962, buffer);
          gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
          gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
          gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
          gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
        } else if (materialDefaultAttributeValues !== undefined) {
          const value = materialDefaultAttributeValues[name];

          if (value !== undefined) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute, value);
                break;

              case 3:
                gl.vertexAttrib3fv(programAttribute, value);
                break;

              case 4:
                gl.vertexAttrib4fv(programAttribute, value);
                break;

              default:
                gl.vertexAttrib1fv(programAttribute, value);
            }
          }
        }
      }
    }

    disableUnusedAttributes();
  }

  function dispose() {
    reset();

    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];

      for (const programId in programMap) {
        const stateMap = programMap[programId];

        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }

        delete programMap[programId];
      }

      delete bindingStates[geometryId];
    }
  }

  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === undefined) return;
    const programMap = bindingStates[geometry.id];

    for (const programId in programMap) {
      const stateMap = programMap[programId];

      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }

      delete programMap[programId];
    }

    delete bindingStates[geometry.id];
  }

  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === undefined) continue;
      const stateMap = programMap[program.id];

      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }

      delete programMap[program.id];
    }
  }

  function reset() {
    resetDefaultState();
    if (currentState === defaultState) return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  } // for backward-compatilibity


  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }

  return {
    setup: setup,
    reset: reset,
    resetDefaultState: resetDefaultState,
    dispose: dispose,
    releaseStatesOfGeometry: releaseStatesOfGeometry,
    releaseStatesOfProgram: releaseStatesOfProgram,
    initAttributes: initAttributes,
    enableAttribute: enableAttribute,
    disableUnusedAttributes: disableUnusedAttributes
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;

  function setMode(value) {
    mode = value;
  }

  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode);
  }

  function renderInstances(geometry, start, count, primcount) {
    if (primcount === 0) return;
    let extension, methodName;

    if (isWebGL2) {
      extension = gl;
      methodName = 'drawArraysInstanced';
    } else {
      extension = extensions.get('ANGLE_instanced_arrays');
      methodName = 'drawArraysInstancedANGLE';

      if (extension === null) {
        console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }

    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  } //


  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;

  function getMaxAnisotropy() {
    if (maxAnisotropy !== undefined) return maxAnisotropy;
    const extension = extensions.get('EXT_texture_filter_anisotropic');

    if (extension !== null) {
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }

    return maxAnisotropy;
  }

  function getMaxPrecision(precision) {
    if (precision === 'highp') {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return 'highp';
      }

      precision = 'mediump';
    }

    if (precision === 'mediump') {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return 'mediump';
      }
    }

    return 'lowp';
  }
  /* eslint-disable no-undef */


  const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
  /* eslint-enable no-undef */

  let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
  const maxPrecision = getMaxPrecision(precision);

  if (maxPrecision !== precision) {
    console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
    precision = maxPrecision;
  }

  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(34930);
  const maxVertexTextures = gl.getParameter(35660);
  const maxTextureSize = gl.getParameter(3379);
  const maxCubemapSize = gl.getParameter(34076);
  const maxAttributes = gl.getParameter(34921);
  const maxVertexUniforms = gl.getParameter(36347);
  const maxVaryings = gl.getParameter(36348);
  const maxFragmentUniforms = gl.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2: isWebGL2,
    getMaxAnisotropy: getMaxAnisotropy,
    getMaxPrecision: getMaxPrecision,
    precision: precision,
    logarithmicDepthBuffer: logarithmicDepthBuffer,
    maxTextures: maxTextures,
    maxVertexTextures: maxVertexTextures,
    maxTextureSize: maxTextureSize,
    maxCubemapSize: maxCubemapSize,
    maxAttributes: maxAttributes,
    maxVertexUniforms: maxVertexUniforms,
    maxVaryings: maxVaryings,
    maxFragmentUniforms: maxFragmentUniforms,
    vertexTextures: vertexTextures,
    floatFragmentTextures: floatFragmentTextures,
    floatVertexTextures: floatVertexTextures,
    maxSamples: maxSamples
  };
}
/**
 * @author tschw
 */


function WebGLClipping() {
  const scope = this;
  let globalState = null,
      numGlobalPlanes = 0,
      localClippingEnabled = false,
      renderingShadows = false;
  const plane = new Plane(),
        viewNormalMatrix = new Matrix3(),
        uniform = {
    value: null,
    needsUpdate: false
  };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;

  this.init = function (planes, enableLocalClipping, camera) {
    const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };

  this.beginShadows = function () {
    renderingShadows = true;
    projectPlanes(null);
  };

  this.endShadows = function () {
    renderingShadows = false;
    resetGlobalState();
  };

  this.setState = function (planes, clipIntersection, clipShadows, camera, cache, fromCache) {
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      // there's no local clipping
      if (renderingShadows) {
        // there's no global clipping
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
            lGlobal = nGlobal * 4;
      let dstArray = cache.clippingState || null;
      uniform.value = dstArray; // ensure unique state

      dstArray = projectPlanes(planes, camera, lGlobal, fromCache);

      for (let i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }

      cache.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };

  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }

    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }

  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    let nPlanes = planes !== null ? planes.length : 0,
        dstArray = null;

    if (nPlanes !== 0) {
      dstArray = uniform.value;

      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4,
              viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);

        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }

        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }

      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }

    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLExtensions(gl) {
  const extensions = {};
  return {
    get: function (name) {
      if (extensions[name] !== undefined) {
        return extensions[name];
      }

      let extension;

      switch (name) {
        case 'WEBGL_depth_texture':
          extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
          break;

        case 'EXT_texture_filter_anisotropic':
          extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
          break;

        case 'WEBGL_compressed_texture_s3tc':
          extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
          break;

        case 'WEBGL_compressed_texture_pvrtc':
          extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
          break;

        default:
          extension = gl.getExtension(name);
      }

      if (extension === null) {
        console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
      }

      extensions[name] = extension;
      return extension;
    }
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = new WeakMap();
  const wireframeAttributes = new WeakMap();

  function onGeometryDispose(event) {
    const geometry = event.target;
    const buffergeometry = geometries.get(geometry);

    if (buffergeometry.index !== null) {
      attributes.remove(buffergeometry.index);
    }

    for (const name in buffergeometry.attributes) {
      attributes.remove(buffergeometry.attributes[name]);
    }

    geometry.removeEventListener('dispose', onGeometryDispose);
    geometries.delete(geometry);
    const attribute = wireframeAttributes.get(buffergeometry);

    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(buffergeometry);
    }

    bindingStates.releaseStatesOfGeometry(geometry);

    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    } //


    info.memory.geometries--;
  }

  function get(object, geometry) {
    let buffergeometry = geometries.get(geometry);
    if (buffergeometry) return buffergeometry;
    geometry.addEventListener('dispose', onGeometryDispose);

    if (geometry.isBufferGeometry) {
      buffergeometry = geometry;
    } else if (geometry.isGeometry) {
      if (geometry._bufferGeometry === undefined) {
        geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
      }

      buffergeometry = geometry._bufferGeometry;
    }

    geometries.set(geometry, buffergeometry);
    info.memory.geometries++;
    return buffergeometry;
  }

  function update(geometry) {
    const geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.

    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962);
    } // morph targets


    const morphAttributes = geometry.morphAttributes;

    for (const name in morphAttributes) {
      const array = morphAttributes[name];

      for (let i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], 34962);
      }
    }
  }

  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;

    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;

      for (let i = 0, l = array.length; i < l; i += 3) {
        const a = array[i + 0];
        const b = array[i + 1];
        const c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else {
      const array = geometryPosition.array;
      version = geometryPosition.version;

      for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        const a = i + 0;
        const b = i + 1;
        const c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    }

    const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates
    //

    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute) attributes.remove(previousAttribute); //

    wireframeAttributes.set(geometry, attribute);
  }

  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);

    if (currentAttribute) {
      const geometryIndex = geometry.index;

      if (geometryIndex !== null) {
        // if the attribute is obsolete, create a new one
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }

    return wireframeAttributes.get(geometry);
  }

  return {
    get: get,
    update: update,
    getWireframeAttribute: getWireframeAttribute
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;

  function setMode(value) {
    mode = value;
  }

  let type, bytesPerElement;

  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }

  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode);
  }

  function renderInstances(geometry, start, count, primcount) {
    if (primcount === 0) return;
    let extension, methodName;

    if (isWebGL2) {
      extension = gl;
      methodName = 'drawElementsInstanced';
    } else {
      extension = extensions.get('ANGLE_instanced_arrays');
      methodName = 'drawElementsInstancedANGLE';

      if (extension === null) {
        console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
        return;
      }
    }

    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  } //


  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
/**
 * @author Mugen87 / https://github.com/Mugen87
 */


function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };

  function update(count, mode, instanceCount) {
    instanceCount = instanceCount || 1;
    render.calls++;

    switch (mode) {
      case 4:
        render.triangles += instanceCount * (count / 3);
        break;

      case 1:
        render.lines += instanceCount * (count / 2);
        break;

      case 3:
        render.lines += instanceCount * (count - 1);
        break;

      case 2:
        render.lines += instanceCount * count;
        break;

      case 0:
        render.points += instanceCount * count;
        break;

      default:
        console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
        break;
    }
  }

  function reset() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }

  return {
    memory: memory,
    render: render,
    programs: null,
    autoReset: true,
    reset: reset,
    update: update
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function numericalSort(a, b) {
  return a[0] - b[0];
}

function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}

function WebGLMorphtargets(gl) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const workInfluences = [];

  for (let i = 0; i < 8; i++) {
    workInfluences[i] = [i, 0];
  }

  function update(object, geometry, material, program) {
    const objectInfluences = object.morphTargetInfluences; // When object doesn't have morph target influences defined, we treat it as a 0-length array
    // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

    const length = objectInfluences === undefined ? 0 : objectInfluences.length;
    let influences = influencesList[geometry.id];

    if (influences === undefined) {
      // initialise list
      influences = [];

      for (let i = 0; i < length; i++) {
        influences[i] = [i, 0];
      }

      influencesList[geometry.id] = influences;
    } // Collect influences


    for (let i = 0; i < length; i++) {
      const influence = influences[i];
      influence[0] = i;
      influence[1] = objectInfluences[i];
    }

    influences.sort(absNumericalSort);

    for (let i = 0; i < 8; i++) {
      if (i < length && influences[i][1]) {
        workInfluences[i][0] = influences[i][0];
        workInfluences[i][1] = influences[i][1];
      } else {
        workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
        workInfluences[i][1] = 0;
      }
    }

    workInfluences.sort(numericalSort);
    const morphTargets = material.morphTargets && geometry.morphAttributes.position;
    const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
    let morphInfluencesSum = 0;

    for (let i = 0; i < 8; i++) {
      const influence = workInfluences[i];
      const index = influence[0];
      const value = influence[1];

      if (index !== Number.MAX_SAFE_INTEGER && value) {
        if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {
          geometry.setAttribute('morphTarget' + i, morphTargets[index]);
        }

        if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {
          geometry.setAttribute('morphNormal' + i, morphNormals[index]);
        }

        morphInfluences[i] = value;
        morphInfluencesSum += value;
      } else {
        if (morphTargets && geometry.getAttribute('morphTarget' + i) !== undefined) {
          geometry.deleteAttribute('morphTarget' + i);
        }

        if (morphNormals && geometry.getAttribute('morphNormal' + i) !== undefined) {
          geometry.deleteAttribute('morphNormal' + i);
        }

        morphInfluences[i] = 0;
      }
    } // GLSL shader uses formula baseinfluence * base + sum(target * influence)
    // This allows us to switch between absolute morphs and relative morphs without changing shader code
    // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)


    const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
    program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
  }

  return {
    update: update
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = new WeakMap();

  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry); // Update once per frame

    if (updateMap.get(buffergeometry) !== frame) {
      if (geometry.isGeometry) {
        buffergeometry.updateFromObject(object);
      }

      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }

    if (object.isInstancedMesh) {
      attributes.update(object.instanceMatrix, 34962);
    }

    return buffergeometry;
  }

  function dispose() {
    updateMap = new WeakMap();
  }

  return {
    update: update,
    dispose: dispose
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
  images = images !== undefined ? images : [];
  mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
  format = format !== undefined ? format : RGBFormat;
  Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.flipY = false;
}

CubeTexture.prototype = Object.create(Texture.prototype);
CubeTexture.prototype.constructor = CubeTexture;
CubeTexture.prototype.isCubeTexture = true;
Object.defineProperty(CubeTexture.prototype, 'images', {
  get: function () {
    return this.image;
  },
  set: function (value) {
    this.image = value;
  }
});
/**
 * @author Takahiro https://github.com/takahirox
 */

function DataTexture2DArray(data, width, height, depth) {
  Texture.call(this, null);
  this.image = {
    data: data || null,
    width: width || 1,
    height: height || 1,
    depth: depth || 1
  };
  this.magFilter = NearestFilter;
  this.minFilter = NearestFilter;
  this.wrapR = ClampToEdgeWrapping;
  this.generateMipmaps = false;
  this.flipY = false;
  this.needsUpdate = true;
}

DataTexture2DArray.prototype = Object.create(Texture.prototype);
DataTexture2DArray.prototype.constructor = DataTexture2DArray;
DataTexture2DArray.prototype.isDataTexture2DArray = true;
/**
 * @author Artur Trzesiok
 */

function DataTexture3D(data, width, height, depth) {
  // We're going to add .setXXX() methods for setting properties later.
  // Users can still set in DataTexture3D directly.
  //
  //	const texture = new THREE.DataTexture3D( data, width, height, depth );
  // 	texture.anisotropy = 16;
  //
  // See #14839
  Texture.call(this, null);
  this.image = {
    data: data || null,
    width: width || 1,
    height: height || 1,
    depth: depth || 1
  };
  this.magFilter = NearestFilter;
  this.minFilter = NearestFilter;
  this.wrapR = ClampToEdgeWrapping;
  this.generateMipmaps = false;
  this.flipY = false;
  this.needsUpdate = true;
}

DataTexture3D.prototype = Object.create(Texture.prototype);
DataTexture3D.prototype.constructor = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = true;
/**
 * @author tschw
 * @author Mugen87 / https://github.com/Mugen87
 * @author mrdoob / http://mrdoob.com/
 *
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

const emptyTexture = new Texture();
const emptyTexture2dArray = new DataTexture2DArray();
const emptyTexture3d = new DataTexture3D();
const emptyCubeTexture = new CubeTexture(); // --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)

const arrayCacheF32 = [];
const arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms

const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices

function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )
  // see http://jacksondunstan.com/articles/983

  let n = nBlocks * blockSize,
      r = arrayCacheF32[n];

  if (r === undefined) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }

  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);

    for (let i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }

  return r;
}

function arraysEqual(a, b) {
  if (a.length !== b.length) return false;

  for (let i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i]) return false;
  }

  return true;
}

function copyArray(a, b) {
  for (let i = 0, l = b.length; i < l; i++) {
    a[i] = b[i];
  }
} // Texture unit allocation


function allocTexUnits(textures, n) {
  let r = arrayCacheI32[n];

  if (r === undefined) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }

  for (let i = 0; i !== n; ++i) {
    r[i] = textures.allocateTextureUnit();
  }

  return r;
} // --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar


function setValueV1f(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
} // Single float vector (from flat array or THREE.VectorN)


function setValueV2f(gl, v) {
  const cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}

function setValueV3f(gl, v) {
  const cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== undefined) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}

function setValueV4f(gl, v) {
  const cache = this.cache;

  if (v.x !== undefined) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
} // Single matrix (from flat array or MatrixN)


function setValueM2(gl, v) {
  const cache = this.cache;
  const elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}

function setValueM3(gl, v) {
  const cache = this.cache;
  const elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}

function setValueM4(gl, v) {
  const cache = this.cache;
  const elements = v.elements;

  if (elements === undefined) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
} // Single texture (2D / Cube)


function setValueT1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.safeSetTexture2D(v || emptyTexture, unit);
}

function setValueT2DArray1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.setTexture2DArray(v || emptyTexture2dArray, unit);
}

function setValueT3D1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.setTexture3D(v || emptyTexture3d, unit);
}

function setValueT6(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();

  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }

  textures.safeSetTextureCube(v || emptyCubeTexture, unit);
} // Integer / Boolean vectors or arrays thereof (always flat arrays)


function setValueV1i(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
}

function setValueV2i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform2iv(this.addr, v);
  copyArray(cache, v);
}

function setValueV3i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform3iv(this.addr, v);
  copyArray(cache, v);
}

function setValueV4i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v)) return;
  gl.uniform4iv(this.addr, v);
  copyArray(cache, v);
} // uint


function setValueV1ui(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1ui(this.addr, v);
  cache[0] = v;
} // Helper to pick the right setter for the singular case


function getSingularSetter(type) {
  switch (type) {
    case 0x1406:
      return setValueV1f;
    // FLOAT

    case 0x8b50:
      return setValueV2f;
    // _VEC2

    case 0x8b51:
      return setValueV3f;
    // _VEC3

    case 0x8b52:
      return setValueV4f;
    // _VEC4

    case 0x8b5a:
      return setValueM2;
    // _MAT2

    case 0x8b5b:
      return setValueM3;
    // _MAT3

    case 0x8b5c:
      return setValueM4;
    // _MAT4

    case 0x1404:
    case 0x8b56:
      return setValueV1i;
    // INT, BOOL

    case 0x8b53:
    case 0x8b57:
      return setValueV2i;
    // _VEC2

    case 0x8b54:
    case 0x8b58:
      return setValueV3i;
    // _VEC3

    case 0x8b55:
    case 0x8b59:
      return setValueV4i;
    // _VEC4

    case 0x1405:
      return setValueV1ui;
    // UINT

    case 0x8b5e: // SAMPLER_2D

    case 0x8d66: // SAMPLER_EXTERNAL_OES

    case 0x8dca: // INT_SAMPLER_2D

    case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

    case 0x8b62:
      // SAMPLER_2D_SHADOW
      return setValueT1;

    case 0x8b5f: // SAMPLER_3D

    case 0x8dcb: // INT_SAMPLER_3D

    case 0x8dd3:
      // UNSIGNED_INT_SAMPLER_3D
      return setValueT3D1;

    case 0x8b60: // SAMPLER_CUBE

    case 0x8dcc: // INT_SAMPLER_CUBE

    case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

    case 0x8dc5:
      // SAMPLER_CUBE_SHADOW
      return setValueT6;

    case 0x8dc1: // SAMPLER_2D_ARRAY

    case 0x8dcf: // INT_SAMPLER_2D_ARRAY

    case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY

    case 0x8dc4:
      // SAMPLER_2D_ARRAY_SHADOW
      return setValueT2DArray1;
  }
} // Array of scalars


function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
} // Integer / Boolean vectors or arrays thereof (always flat arrays)


function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
}

function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}

function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}

function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
} // Array of vectors (flat or from THREE classes)


function setValueV2fArray(gl, v) {
  const data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}

function setValueV3fArray(gl, v) {
  const data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}

function setValueV4fArray(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
} // Array of matrices (flat or from THREE clases)


function setValueM2Array(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}

function setValueM3Array(gl, v) {
  const data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}

function setValueM4Array(gl, v) {
  const data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
} // Array of textures (2D / Cube)


function setValueT1Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);

  for (let i = 0; i !== n; ++i) {
    textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
  }
}

function setValueT6Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);

  for (let i = 0; i !== n; ++i) {
    textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
  }
} // Helper to pick the right setter for a pure (bottom-level) array


function getPureArraySetter(type) {
  switch (type) {
    case 0x1406:
      return setValueV1fArray;
    // FLOAT

    case 0x8b50:
      return setValueV2fArray;
    // _VEC2

    case 0x8b51:
      return setValueV3fArray;
    // _VEC3

    case 0x8b52:
      return setValueV4fArray;
    // _VEC4

    case 0x8b5a:
      return setValueM2Array;
    // _MAT2

    case 0x8b5b:
      return setValueM3Array;
    // _MAT3

    case 0x8b5c:
      return setValueM4Array;
    // _MAT4

    case 0x1404:
    case 0x8b56:
      return setValueV1iArray;
    // INT, BOOL

    case 0x8b53:
    case 0x8b57:
      return setValueV2iArray;
    // _VEC2

    case 0x8b54:
    case 0x8b58:
      return setValueV3iArray;
    // _VEC3

    case 0x8b55:
    case 0x8b59:
      return setValueV4iArray;
    // _VEC4

    case 0x8b5e: // SAMPLER_2D

    case 0x8d66: // SAMPLER_EXTERNAL_OES

    case 0x8dca: // INT_SAMPLER_2D

    case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

    case 0x8b62:
      // SAMPLER_2D_SHADOW
      return setValueT1Array;

    case 0x8b60: // SAMPLER_CUBE

    case 0x8dcc: // INT_SAMPLER_CUBE

    case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

    case 0x8dc5:
      // SAMPLER_CUBE_SHADOW
      return setValueT6Array;
  }
} // --- Uniform Classes ---


function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
}

function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
}

PureArrayUniform.prototype.updateCache = function (data) {
  let cache = this.cache;

  if (data instanceof Float32Array && cache.length !== data.length) {
    this.cache = new Float32Array(data.length);
  }

  copyArray(cache, data);
};

function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}

StructuredUniform.prototype.setValue = function (gl, value, textures) {
  const seq = this.seq;

  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i];
    u.setValue(gl, value[u.id], textures);
  }
}; // --- Top-level ---
// Parser - builds up the property tree from the path strings


const RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g; // extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}

function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name,
        pathLength = path.length; // reset RegExp object, because of the early exit of a previous run

  RePathPart.lastIndex = 0;

  while (true) {
    const match = RePathPart.exec(path),
          matchEnd = RePathPart.lastIndex;
    let id = match[1],
        idIsIndex = match[2] === ']',
        subscript = match[3];
    if (idIsIndex) id = id | 0; // convert to integer

    if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
      // bare name or "pure" bottom-level array "[0]" suffix
      addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      // step into inner node / create it in case it doesn't exist
      const map = container.map;
      let next = map[id];

      if (next === undefined) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }

      container = next;
    }
  }
} // Root Container


function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  const n = gl.getProgramParameter(program, 35718);

  for (let i = 0; i < n; ++i) {
    const info = gl.getActiveUniform(program, i),
          addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}

WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {
  const u = this.map[name];
  if (u !== undefined) u.setValue(gl, value, textures);
};

WebGLUniforms.prototype.setOptional = function (gl, object, name) {
  const v = object[name];
  if (v !== undefined) this.setValue(gl, name, v);
}; // Static interface


WebGLUniforms.upload = function (gl, seq, values, textures) {
  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i],
          v = values[u.id];

    if (v.needsUpdate !== false) {
      // note: always updating when .needsUpdate is undefined
      u.setValue(gl, v.value, textures);
    }
  }
};

WebGLUniforms.seqWithValue = function (seq, values) {
  const r = [];

  for (let i = 0, n = seq.length; i !== n; ++i) {
    const u = seq[i];
    if (u.id in values) r.push(u);
  }

  return r;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


let programIdCount = 0;

function addLineNumbers(string) {
  const lines = string.split('\n');

  for (let i = 0; i < lines.length; i++) {
    lines[i] = i + 1 + ': ' + lines[i];
  }

  return lines.join('\n');
}

function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ['Linear', '( value )'];

    case sRGBEncoding:
      return ['sRGB', '( value )'];

    case RGBEEncoding:
      return ['RGBE', '( value )'];

    case RGBM7Encoding:
      return ['RGBM', '( value, 7.0 )'];

    case RGBM16Encoding:
      return ['RGBM', '( value, 16.0 )'];

    case RGBDEncoding:
      return ['RGBD', '( value, 256.0 )'];

    case GammaEncoding:
      return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];

    case LogLuvEncoding:
      return ['LogLuv', '( value )'];

    default:
      console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
      return ['Linear', '( value )'];
  }
}

function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, 35713);
  const log = gl.getShaderInfoLog(shader).trim();
  if (status && log === '') return ''; // --enable-privileged-webgl-extension
  // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

  const source = gl.getShaderSource(shader);
  return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);
}

function getTexelDecodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
}

function getTexelEncodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
}

function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;

  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = 'Linear';
      break;

    case ReinhardToneMapping:
      toneMappingName = 'Reinhard';
      break;

    case CineonToneMapping:
      toneMappingName = 'OptimizedCineon';
      break;

    case ACESFilmicToneMapping:
      toneMappingName = 'ACESFilmic';
      break;

    case CustomToneMapping:
      toneMappingName = 'Custom';
      break;

    default:
      console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
      toneMappingName = 'Linear';
  }

  return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}

function generateExtensions(parameters) {
  const chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
  return chunks.filter(filterEmptyLine).join('\n');
}

function generateDefines(defines) {
  const chunks = [];

  for (const name in defines) {
    const value = defines[name];
    if (value === false) continue;
    chunks.push('#define ' + name + ' ' + value);
  }

  return chunks.join('\n');
}

function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, 35721);

  for (let i = 0; i < n; i++) {
    const info = gl.getActiveAttrib(program, i);
    const name = info.name; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

    attributes[name] = gl.getAttribLocation(program, name);
  }

  return attributes;
}

function filterEmptyLine(string) {
  return string !== '';
}

function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}

function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
} // Resolve Includes


const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}

function includeReplacer(match, include) {
  const string = ShaderChunk[include];

  if (string === undefined) {
    throw new Error('Can not resolve #include <' + include + '>');
  }

  return resolveIncludes(string);
} // Unroll Loops


const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;

function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}

function deprecatedLoopReplacer(match, start, end, snippet) {
  console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
  return loopReplacer(match, start, end, snippet);
}

function loopReplacer(match, start, end, snippet) {
  let string = '';

  for (let i = parseInt(start); i < parseInt(end); i++) {
    string += snippet.replace(/\[ i \]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);
  }

  return string;
} //


function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";

  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }

  return precisionstring;
}

function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
  }

  return shadowMapTypeDefine;
}

function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
        break;

      case CubeUVReflectionMapping:
      case CubeUVRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
        break;

      case EquirectangularReflectionMapping:
      case EquirectangularRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
        break;
    }
  }

  return envMapTypeDefine;
}

function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
      case EquirectangularRefractionMapping:
        envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
        break;
    }
  }

  return envMapModeDefine;
}

function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
        break;

      case MixOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
        break;

      case AddOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
        break;
    }
  }

  return envMapBlendingDefine;
}

function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;
  const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;

  if (parameters.isRawShaderMaterial) {
    prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');

    if (prefixVertex.length > 0) {
      prefixVertex += '\n';
    }

    prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');

    if (prefixFragment.length > 0) {
      prefixFragment += '\n';
    }
  } else {
    prefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', ' attribute mat4 instanceMatrix;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#ifdef USE_COLOR', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
    prefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer
    '#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
    parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', ShaderChunk['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below
    parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '', getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding), parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
  }

  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);

  if (parameters.isWebGL2 && !parameters.isRawShaderMaterial) {
    let isGLSL3ShaderMaterial = false;
    const versionRegex = /^\s*#version\s+300\s+es\s*\n/;

    if (parameters.isShaderMaterial && vertexShader.match(versionRegex) !== null && fragmentShader.match(versionRegex) !== null) {
      isGLSL3ShaderMaterial = true;
      vertexShader = vertexShader.replace(versionRegex, '');
      fragmentShader = fragmentShader.replace(versionRegex, '');
    } // GLSL 3.0 conversion


    prefixVertex = ['#version 300 es\n', '#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
    prefixFragment = ['#version 300 es\n', '#define varying in', isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;', isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
  }

  const vertexGlsl = prefixVertex + vertexShader;
  const fragmentGlsl = prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );
  // console.log( '*FRAGMENT*', fragmentGlsl );

  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.

  if (parameters.index0AttributeName !== undefined) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    // programs with morphTargets displace position out of attribute 0
    gl.bindAttribLocation(program, 0, 'position');
  }

  gl.linkProgram(program); // check for link errors

  if (renderer.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;

    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
      console.error('THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter(program, 35715), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
    } else if (programLog !== '') {
      console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
    } else if (vertexLog === '' || fragmentLog === '') {
      haveDiagnostics = false;
    }

    if (haveDiagnostics) {
      this.diagnostics = {
        runnable: runnable,
        programLog: programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  } // Clean up
  // Crashes in iOS9 and iOS10. #18402
  // gl.detachShader( program, glVertexShader );
  // gl.detachShader( program, glFragmentShader );


  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader); // set up caching for uniform locations

  let cachedUniforms;

  this.getUniforms = function () {
    if (cachedUniforms === undefined) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }

    return cachedUniforms;
  }; // set up caching for attribute locations


  let cachedAttributes;

  this.getAttributes = function () {
    if (cachedAttributes === undefined) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }

    return cachedAttributes;
  }; // free resource


  this.destroy = function () {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = undefined;
  }; //


  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLPrograms(renderer, extensions, capabilities, bindingStates) {
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities.floatVertexTextures;
  const maxVertexUniforms = capabilities.maxVertexUniforms;
  const vertexTextures = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'toon',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite'
  };
  const parameterNames = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights', "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"];

  function getShaderObject(material, shaderID) {
    let shaderobject;

    if (shaderID) {
      const shader = ShaderLib[shaderID];
      shaderobject = {
        name: material.name || material.type,
        uniforms: UniformsUtils.clone(shader.uniforms),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      };
    } else {
      shaderobject = {
        name: material.name || material.type,
        uniforms: material.uniforms,
        vertexShader: material.vertexShader,
        fragmentShader: material.fragmentShader
      };
    }

    return shaderobject;
  }

  function allocateBones(object) {
    const skeleton = object.skeleton;
    const bones = skeleton.bones;

    if (floatVertexTextures) {
      return 1024;
    } else {
      // default for when object is not specified
      // ( for example when prebuilding shader to be used with multiple objects )
      //
      //  - leave some extra space for other uniforms
      //  - limit here is ANGLE's 254 max uniform vectors
      //    (up to 54 should be safe)
      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);

      if (maxBones < bones.length) {
        console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
        return 0;
      }

      return maxBones;
    }
  }

  function getTextureEncodingFromMap(map) {
    let encoding;

    if (!map) {
      encoding = LinearEncoding;
    } else if (map.isTexture) {
      encoding = map.encoding;
    } else if (map.isWebGLRenderTarget) {
      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
      encoding = map.texture.encoding;
    }

    return encoding;
  }

  function getParameters(material, lights, shadows, scene, nClipPlanes, nClipIntersection, object) {
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = material.envMap || environment;
    const shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene
    // (not to blow over maxLights budget)

    const maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;

    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);

      if (precision !== material.precision) {
        console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
      }
    }

    const shaderobject = getShaderObject(material, shaderID);
    material.onBeforeCompile(shaderobject, renderer);
    const currentRenderTarget = renderer.getRenderTarget();
    const parameters = {
      isWebGL2: isWebGL2,
      shaderID: shaderID,
      shaderName: shaderobject.name,
      uniforms: shaderobject.uniforms,
      vertexShader: shaderobject.vertexShader,
      fragmentShader: shaderobject.fragmentShader,
      defines: material.defines,
      isRawShaderMaterial: material.isRawShaderMaterial,
      isShaderMaterial: material.isShaderMaterial,
      precision: precision,
      instancing: object.isInstancedMesh === true,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
      map: !!material.map,
      mapEncoding: getTextureEncodingFromMap(material.map),
      matcap: !!material.matcap,
      matcapEncoding: getTextureEncodingFromMap(material.matcap),
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapEncoding: getTextureEncodingFromMap(envMap),
      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
      lightMap: !!material.lightMap,
      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      clearcoatMap: !!material.clearcoatMap,
      clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      alphaMap: !!material.alphaMap,
      gradientMap: !!material.gradientMap,
      sheen: !!material.sheen,
      combine: material.combine,
      vertexTangents: material.normalMap && material.vertexTangents,
      vertexColors: material.vertexColors,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer: logarithmicDepthBuffer,
      skinning: material.skinning && maxBones > 0,
      maxBones: maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: renderer.maxMorphTargets,
      maxMorphNormals: renderer.maxMorphNormals,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: nClipPlanes,
      numClipIntersection: nClipIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      alphaTest: material.alphaTest,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.get('EXT_frag_depth') !== null,
      rendererExtensionDrawBuffers: isWebGL2 || extensions.get('WEBGL_draw_buffers') !== null,
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.get('EXT_shader_texture_lod') !== null,
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }

  function getProgramCacheKey(parameters) {
    const array = [];

    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.fragmentShader);
      array.push(parameters.vertexShader);
    }

    if (parameters.defines !== undefined) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }

    if (parameters.isRawShaderMaterial === undefined) {
      for (let i = 0; i < parameterNames.length; i++) {
        array.push(parameters[parameterNames[i]]);
      }

      array.push(renderer.outputEncoding);
      array.push(renderer.gammaFactor);
    }

    array.push(parameters.customProgramCacheKey);
    return array.join();
  }

  function acquireProgram(parameters, cacheKey) {
    let program; // Check if code has been already compiled

    for (let p = 0, pl = programs.length; p < pl; p++) {
      const preexistingProgram = programs[p];

      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }

    if (program === undefined) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }

    return program;
  }

  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      // Remove from unordered set
      const i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop(); // Free WebGL resources

      program.destroy();
    }
  }

  return {
    getParameters: getParameters,
    getProgramCacheKey: getProgramCacheKey,
    acquireProgram: acquireProgram,
    releaseProgram: releaseProgram,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: programs
  };
}
/**
 * @author fordacious / fordacious.github.io
 */


function WebGLProperties() {
  let properties = new WeakMap();

  function get(object) {
    let map = properties.get(object);

    if (map === undefined) {
      map = {};
      properties.set(object, map);
    }

    return map;
  }

  function remove(object) {
    properties.delete(object);
  }

  function update(object, key, value) {
    properties.get(object)[key] = value;
  }

  function dispose() {
    properties = new WeakMap();
  }

  return {
    get: get,
    remove: remove,
    update: update,
    dispose: dispose
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.program !== b.program) {
    return a.program.id - b.program.id;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}

function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}

function WebGLRenderList() {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transparent = [];
  const defaultProgram = {
    id: -1
  };

  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transparent.length = 0;
  }

  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = renderItems[renderItemsIndex];

    if (renderItem === undefined) {
      renderItem = {
        id: object.id,
        object: object,
        geometry: geometry,
        material: material,
        program: material.program || defaultProgram,
        groupOrder: groupOrder,
        renderOrder: object.renderOrder,
        z: z,
        group: group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.program = material.program || defaultProgram;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }

    renderItemsIndex++;
    return renderItem;
  }

  function push(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? transparent : opaque).push(renderItem);
  }

  function unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    (material.transparent === true ? transparent : opaque).unshift(renderItem);
  }

  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
  }

  function finish() {
    // Clear references from inactive renderItems in the list
    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
      const renderItem = renderItems[i];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.program = null;
      renderItem.group = null;
    }
  }

  return {
    opaque: opaque,
    transparent: transparent,
    init: init,
    push: push,
    unshift: unshift,
    finish: finish,
    sort: sort
  };
}

function WebGLRenderLists() {
  let lists = new WeakMap();

  function onSceneDispose(event) {
    const scene = event.target;
    scene.removeEventListener('dispose', onSceneDispose);
    lists.delete(scene);
  }

  function get(scene, camera) {
    const cameras = lists.get(scene);
    let list;

    if (cameras === undefined) {
      list = new WebGLRenderList();
      lists.set(scene, new WeakMap());
      lists.get(scene).set(camera, list);
      scene.addEventListener('dispose', onSceneDispose);
    } else {
      list = cameras.get(camera);

      if (list === undefined) {
        list = new WebGLRenderList();
        cameras.set(camera, list);
      }
    }

    return list;
  }

  function dispose() {
    lists = new WeakMap();
  }

  return {
    get: get,
    dispose: dispose
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function UniformsCache() {
  const lights = {};
  return {
    get: function (light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }

      let uniforms;

      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;

        case 'SpotLight':
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;

        case 'PointLight':
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;

        case 'HemisphereLight':
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;

        case 'RectAreaLight':
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }

      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}

function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function (light) {
      if (lights[light.id] !== undefined) {
        return lights[light.id];
      }

      let uniforms;

      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;

        case 'SpotLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;

        case 'PointLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1000
          };
          break;
        // TODO (abelnation): set RectAreaLight shadow uniforms
      }

      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}

let nextVersion = 0;

function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}

function WebGLLights() {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };

  for (let i = 0; i < 9; i++) state.probe.push(new Vector3());

  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();

  function setup(lights, shadows, camera) {
    let r = 0,
        g = 0,
        b = 0;

    for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);

    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    const viewMatrix = camera.matrixWorldInverse;
    lights.sort(shadowCastingLightsFirst);

    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

      if (light.isAmbientLight) {
        r += color.r * intensity;
        g += color.g * intensity;
        b += color.b * intensity;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);

        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }

        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;

        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }

        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light); // (a) intensity is the total visible light emitted
        //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
        // (b) intensity is the brightness of the light

        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors

        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
        uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42); // TODO (abelnation): RectAreaLight distance?
        // uniforms.distance = distance;

        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;

        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }

        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }

    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    const hash = state.hash;

    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }

  return {
    setup: setup,
    state: state
  };
}
/**
 * @author Mugen87 / https://github.com/Mugen87
 */


function WebGLRenderState() {
  const lights = new WebGLLights();
  const lightsArray = [];
  const shadowsArray = [];

  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }

  function pushLight(light) {
    lightsArray.push(light);
  }

  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }

  function setupLights(camera) {
    lights.setup(lightsArray, shadowsArray, camera);
  }

  const state = {
    lightsArray: lightsArray,
    shadowsArray: shadowsArray,
    lights: lights
  };
  return {
    init: init,
    state: state,
    setupLights: setupLights,
    pushLight: pushLight,
    pushShadow: pushShadow
  };
}

function WebGLRenderStates() {
  let renderStates = new WeakMap();

  function onSceneDispose(event) {
    const scene = event.target;
    scene.removeEventListener('dispose', onSceneDispose);
    renderStates.delete(scene);
  }

  function get(scene, camera) {
    let renderState;

    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState();
      renderStates.set(scene, new WeakMap());
      renderStates.get(scene).set(camera, renderState);
      scene.addEventListener('dispose', onSceneDispose);
    } else {
      if (renderStates.get(scene).has(camera) === false) {
        renderState = new WebGLRenderState();
        renderStates.get(scene).set(camera, renderState);
      } else {
        renderState = renderStates.get(scene).get(camera);
      }
    }

    return renderState;
  }

  function dispose() {
    renderStates = new WeakMap();
  }

  return {
    get: get,
    dispose: dispose
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / https://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */


function MeshDepthMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshDepthMaterial';
  this.depthPacking = BasicDepthPacking;
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.setValues(parameters);
}

MeshDepthMaterial.prototype = Object.create(Material.prototype);
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

MeshDepthMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.depthPacking = source.depthPacking;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  return this;
};
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */


function MeshDistanceMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshDistanceMaterial';
  this.referencePosition = new Vector3();
  this.nearDistance = 1;
  this.farDistance = 1000;
  this.skinning = false;
  this.morphTargets = false;
  this.map = null;
  this.alphaMap = null;
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.fog = false;
  this.setValues(parameters);
}

MeshDistanceMaterial.prototype = Object.create(Material.prototype);
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

MeshDistanceMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.referencePosition.copy(source.referencePosition);
  this.nearDistance = source.nearDistance;
  this.farDistance = source.farDistance;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  return this;
};

var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
  let _frustum = new Frustum();

  const _shadowMapSize = new Vector2(),
        _viewportSize = new Vector2(),
        _viewport = new Vector4(),
        _depthMaterials = [],
        _distanceMaterials = [],
        _materialCache = {};

  const shadowSide = {
    0: BackSide,
    1: FrontSide,
    2: DoubleSide
  };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      SAMPLE_RATE: 2.0 / 8.0,
      HALF_SAMPLE_RATE: 1.0 / 8.0
    },
    uniforms: {
      shadow_pass: {
        value: null
      },
      resolution: {
        value: new Vector2()
      },
      radius: {
        value: 4.0
      }
    },
    vertexShader: vsm_vert,
    fragmentShader: vsm_frag
  });
  const shadowMaterialHorizonal = shadowMaterialVertical.clone();
  shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;

  this.render = function (lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;

    const currentRenderTarget = _renderer.getRenderTarget();

    const activeCubeFace = _renderer.getActiveCubeFace();

    const activeMipmapLevel = _renderer.getActiveMipmapLevel();

    const _state = _renderer.state; // Set GL state for depth map.

    _state.setBlending(NoBlending);

    _state.buffers.color.setClear(1, 1, 1, 1);

    _state.buffers.depth.setTest(true);

    _state.setScissorTest(false); // render depth map


    for (let i = 0, il = lights.length; i < il; i++) {
      const light = lights[i];
      const shadow = light.shadow;
      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;

      if (shadow === undefined) {
        console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
        continue;
      }

      _shadowMapSize.copy(shadow.mapSize);

      const shadowFrameExtents = shadow.getFrameExtents();

      _shadowMapSize.multiply(shadowFrameExtents);

      _viewportSize.copy(shadow.mapSize);

      if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
        if (_shadowMapSize.x > maxTextureSize) {
          _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }

        if (_shadowMapSize.y > maxTextureSize) {
          _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }

      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        const pars = {
          minFilter: LinearFilter,
          magFilter: LinearFilter,
          format: RGBAFormat
        };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.camera.updateProjectionMatrix();
      }

      if (shadow.map === null) {
        const pars = {
          minFilter: NearestFilter,
          magFilter: NearestFilter,
          format: RGBAFormat
        };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }

      _renderer.setRenderTarget(shadow.map);

      _renderer.clear();

      const viewportCount = shadow.getViewportCount();

      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);

        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);

        _state.viewport(_viewport);

        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      } // do blur pass for VSM


      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }

      shadow.needsUpdate = false;
    }

    scope.needsUpdate = false;

    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };

  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh); // vertical pass


    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;

    _renderer.setRenderTarget(shadow.mapPass);

    _renderer.clear();

    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizonal pass


    shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;

    _renderer.setRenderTarget(shadow.map);

    _renderer.clear();

    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null);
  }

  function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _depthMaterials[index];

    if (material === undefined) {
      material = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking,
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _depthMaterials[index] = material;
    }

    return material;
  }

  function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
    const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    let material = _distanceMaterials[index];

    if (material === undefined) {
      material = new MeshDistanceMaterial({
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _distanceMaterials[index] = material;
    }

    return material;
  }

  function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    let getMaterialVariant = getDepthMaterialVariant;
    let customMaterial = object.customDepthMaterial;

    if (light.isPointLight === true) {
      getMaterialVariant = getDistanceMaterialVariant;
      customMaterial = object.customDistanceMaterial;
    }

    if (customMaterial === undefined) {
      let useMorphing = false;

      if (material.morphTargets === true) {
        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
      }

      let useSkinning = false;

      if (object.isSkinnedMesh === true) {
        if (material.skinning === true) {
          useSkinning = true;
        } else {
          console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
        }
      }

      const useInstancing = object.isInstancedMesh === true;
      result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
    } else {
      result = customMaterial;
    }

    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
      // in this case we need a unique material instance reflecting the
      // appropriate state
      const keyA = result.uuid,
            keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];

      if (materialsForVariant === undefined) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }

      let cachedMaterial = materialsForVariant[keyB];

      if (cachedMaterial === undefined) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }

      result = cachedMaterial;
    }

    result.visible = material.visible;
    result.wireframe = material.wireframe;

    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }

    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;

    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }

    return result;
  }

  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera.layers);

    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

        const geometry = _objects.update(object);

        const material = object.material;

        if (Array.isArray(material)) {
          const groups = geometry.groups;

          for (let k = 0, kl = groups.length; k < kl; k++) {
            const group = groups[k];
            const groupMaterial = material[group.materialIndex];

            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);

              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);

          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }

    const children = object.children;

    for (let i = 0, l = children.length; i < l; i++) {
      renderObject(children[i], camera, shadowCamera, light, type);
    }
  }
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;

  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function (colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }

        color.set(r, g, b, a);

        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function () {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0); // set to invalid state
      }
    };
  }

  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function (depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function (depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function (depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;

              case AlwaysDepth:
                gl.depthFunc(519);
                break;

              case LessDepth:
                gl.depthFunc(513);
                break;

              case LessEqualDepth:
                gl.depthFunc(515);
                break;

              case EqualDepth:
                gl.depthFunc(514);
                break;

              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;

              case GreaterDepth:
                gl.depthFunc(516);
                break;

              case NotEqualDepth:
                gl.depthFunc(517);
                break;

              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }

          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function () {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }

  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function (stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function (stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function (stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function (stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function () {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  } //


  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let currentProgram = null;
  let currentBlendingEnabled = null;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(35661);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(7938);

  if (glVersion.indexOf('WebGL') !== -1) {
    version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1.0;
  } else if (glVersion.indexOf('OpenGL ES') !== -1) {
    version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2.0;
  }

  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const currentScissor = new Vector4();
  const currentViewport = new Vector4();

  function createTexture(type, target, count) {
    const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.

    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);

    for (let i = 0; i < count; i++) {
      gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }

    return texture;
  }

  const emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6); // init

  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending); //

  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }

  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }

  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }

    return false;
  }

  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };

  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions.get('EXT_blend_minmax');

    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }

  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };

  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled) {
        disable(3042);
        currentBlendingEnabled = false;
      }

      return;
    }

    if (!currentBlendingEnabled) {
      enable(3042);
      currentBlendingEnabled = true;
    }

    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }

        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;

            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;

            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 0, 769, 771);
              break;

            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;

            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;

            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;

            case SubtractiveBlending:
              gl.blendFunc(0, 769);
              break;

            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;

            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending);
              break;
          }
        }

        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }

      return;
    } // custom blending


    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;

    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }

    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }

    currentBlending = blending;
    currentPremultipledAlpha = null;
  }

  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    let flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);

    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }

    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
  } //


  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }

      currentFlipSided = flipSided;
    }
  }

  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);

      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }

    currentCullFace = cullFace;
  }

  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width);
      currentLineWidth = width;
    }
  }

  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);

      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }

  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  } // texture


  function activeTexture(webglSlot) {
    if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;

    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }

  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }

    let boundTexture = currentBoundTextures[currentTextureSlot];

    if (boundTexture === undefined) {
      boundTexture = {
        type: undefined,
        texture: undefined
      };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }

    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }

  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];

    if (boundTexture !== undefined && boundTexture.type !== undefined) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = undefined;
      boundTexture.texture = undefined;
    }
  }

  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  }

  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error('THREE.WebGLState:', error);
    }
  } //


  function scissor(scissor) {
    if (currentScissor.equals(scissor) === false) {
      gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
      currentScissor.copy(scissor);
    }
  }

  function viewport(viewport) {
    if (currentViewport.equals(viewport) === false) {
      gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
      currentViewport.copy(viewport);
    }
  } //


  function reset() {
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentProgram = null;
    currentBlending = null;
    currentFlipSided = null;
    currentCullFace = null;
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }

  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable: enable,
    disable: disable,
    useProgram: useProgram,
    setBlending: setBlending,
    setMaterial: setMaterial,
    setFlipSided: setFlipSided,
    setCullFace: setCullFace,
    setLineWidth: setLineWidth,
    setPolygonOffset: setPolygonOffset,
    setScissorTest: setScissorTest,
    activeTexture: activeTexture,
    bindTexture: bindTexture,
    unbindTexture: unbindTexture,
    compressedTexImage2D: compressedTexImage2D,
    texImage2D: texImage2D,
    texImage3D: texImage3D,
    scissor: scissor,
    viewport: viewport,
    reset: reset
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;

  const _videoTextures = new WeakMap();

  let _canvas; // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
  // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
  // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).


  let useOffscreenCanvas = false;

  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {// Ignore any errors
  }

  function createCanvas(width, height) {
    // Use OffscreenCanvas when available. Specially needed in web workers
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
  }

  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1; // handle case if texture exceeds max size

    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    } // only perform resize if necessary


    if (scale < 1 || needsPowerOfTwo === true) {
      // only perform resize for certain image types
      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can't reuse the same canvas

        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext('2d');
        context.drawImage(image, 0, 0, width, height);
        console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
        return canvas;
      } else {
        if ('data' in image) {
          console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
        }

        return image;
      }
    }

    return image;
  }

  function isPowerOfTwo(image) {
    return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
  }

  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2) return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }

  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }

  function generateMipmap(target, texture, width, height) {
    _gl.generateMipmap(target);

    const textureProperties = properties.get(texture); // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11

    textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
  }

  function getInternalFormat(internalFormatName, glFormat, glType) {
    if (isWebGL2 === false) return glFormat;

    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
      console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
    }

    let internalFormat = glFormat;

    if (glFormat === 6403) {
      if (glType === 5126) internalFormat = 33326;
      if (glType === 5131) internalFormat = 33325;
      if (glType === 5121) internalFormat = 33321;
    }

    if (glFormat === 6407) {
      if (glType === 5126) internalFormat = 34837;
      if (glType === 5131) internalFormat = 34843;
      if (glType === 5121) internalFormat = 32849;
    }

    if (glFormat === 6408) {
      if (glType === 5126) internalFormat = 34836;
      if (glType === 5131) internalFormat = 34842;
      if (glType === 5121) internalFormat = 32856;
    }

    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get('EXT_color_buffer_float');
    }

    return internalFormat;
  } // Fallback filters for non-power-of-2 textures


  function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
      return 9728;
    }

    return 9729;
  } //


  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    deallocateTexture(texture);

    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }

    info.memory.textures--;
  }

  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener('dispose', onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
    info.memory.textures--;
  } //


  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === undefined) return;

    _gl.deleteTexture(textureProperties.__webglTexture);

    properties.remove(texture);
  }

  function deallocateRenderTarget(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(renderTarget.texture);
    if (!renderTarget) return;

    if (textureProperties.__webglTexture !== undefined) {
      _gl.deleteTexture(textureProperties.__webglTexture);
    }

    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }

    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i = 0; i < 6; i++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);

        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);

      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }

    properties.remove(renderTarget.texture);
    properties.remove(renderTarget);
  } //


  let textureUnits = 0;

  function resetTextureUnits() {
    textureUnits = 0;
  }

  function allocateTextureUnit() {
    const textureUnit = textureUnits;

    if (textureUnit >= maxTextures) {
      console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
    }

    textureUnits += 1;
    return textureUnit;
  } //


  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;

      if (image === undefined) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
      } else if (image.complete === false) {
        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }

  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }

  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }

    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }

  function setTextureCube(texture, slot) {
    if (texture.image.length !== 6) return;
    const textureProperties = properties.get(texture);

    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      initTexture(textureProperties, texture);
      state.activeTexture(33984 + slot);
      state.bindTexture(34067, textureProperties.__webglTexture);

      _gl.pixelStorei(37440, texture.flipY);

      const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];

      for (let i = 0; i < 6; i++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
        } else {
          cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
        }
      }

      const image = cubeImage[0],
            supportsMips = isPowerOfTwo(image) || isWebGL2,
            glFormat = utils.convert(texture.format),
            glType = utils.convert(texture.type),
            glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
      setTextureParameters(34067, texture, supportsMips);
      let mipmaps;

      if (isCompressed) {
        for (let i = 0; i < 6; i++) {
          mipmaps = cubeImage[i].mipmaps;

          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];

            if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
              if (glFormat !== null) {
                state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              } else {
                console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
              }
            } else {
              state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
        }

        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        mipmaps = texture.mipmaps;

        for (let i = 0; i < 6; i++) {
          if (isDataTexture) {
            state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);

            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              const mipmapImage = mipmap.image[i].image;
              state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
            }
          } else {
            state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);

            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
            }
          }
        }

        textureProperties.__maxMipLevel = mipmaps.length;
      }

      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        // We assume images for cube map have the same size.
        generateMipmap(34067, texture, image.width, image.height);
      }

      textureProperties.__version = texture.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    } else {
      state.activeTexture(33984 + slot);
      state.bindTexture(34067, textureProperties.__webglTexture);
    }
  }

  function setTextureCubeDynamic(texture, slot) {
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, properties.get(texture).__webglTexture);
  }

  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };

  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);

      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);

      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }

      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);

      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);

      _gl.texParameteri(textureType, 10243, 33071);

      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }

      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
      }

      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));

      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));

      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
      }
    }

    const extension = extensions.get('EXT_texture_filter_anisotropic');

    if (extension) {
      if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null) return;
      if (texture.type === HalfFloatType && (isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null) return;

      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));

        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }

  function initTexture(textureProperties, texture) {
    if (textureProperties.__webglInit === undefined) {
      textureProperties.__webglInit = true;
      texture.addEventListener('dispose', onTextureDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
    }
  }

  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553;
    if (texture.isDataTexture2DArray) textureType = 35866;
    if (texture.isDataTexture3D) textureType = 32879;
    initTexture(textureProperties, texture);
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);

    _gl.pixelStorei(37440, texture.flipY);

    _gl.pixelStorei(37441, texture.premultiplyAlpha);

    _gl.pixelStorei(3317, texture.unpackAlignment);

    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
    const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
    const supportsMips = isPowerOfTwo(image) || isWebGL2,
          glFormat = utils.convert(texture.format);
    let glType = utils.convert(texture.type),
        glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
    setTextureParameters(textureType, texture, supportsMips);
    let mipmap;
    const mipmaps = texture.mipmaps;

    if (texture.isDepthTexture) {
      // populate depth texture with dummy data
      glInternalFormat = 6402;

      if (isWebGL2) {
        if (texture.type === FloatType) {
          glInternalFormat = 36012;
        } else if (texture.type === UnsignedIntType) {
          glInternalFormat = 33190;
        } else if (texture.type === UnsignedInt248Type) {
          glInternalFormat = 35056;
        } else {
          glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D
        }
      } else {
        if (texture.type === FloatType) {
          console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
        }
      } // validation checks for WebGL 1


      if (texture.format === DepthFormat && glInternalFormat === 6402) {
        // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
        // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
          console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
          texture.type = UnsignedShortType;
          glType = utils.convert(texture.type);
        }
      }

      if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
        // Depth stencil textures need the DEPTH_STENCIL internal format
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
        glInternalFormat = 34041; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
        // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)

        if (texture.type !== UnsignedInt248Type) {
          console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
          texture.type = UnsignedInt248Type;
          glType = utils.convert(texture.type);
        }
      } //


      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
    } else if (texture.isDataTexture) {
      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels
      if (mipmaps.length > 0 && supportsMips) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }

        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      }
    } else if (texture.isCompressedTexture) {
      for (let i = 0, il = mipmaps.length; i < il; i++) {
        mipmap = mipmaps[i];

        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
          if (glFormat !== null) {
            state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
          } else {
            console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
          }
        } else {
          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
        }
      }

      textureProperties.__maxMipLevel = mipmaps.length - 1;
    } else if (texture.isDataTexture2DArray) {
      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else if (texture.isDataTexture3D) {
      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
      textureProperties.__maxMipLevel = 0;
    } else {
      // regular Texture (image, video, canvas)
      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels
      if (mipmaps.length > 0 && supportsMips) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
        }

        texture.generateMipmaps = false;
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
        textureProperties.__maxMipLevel = 0;
      }
    }

    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      generateMipmap(textureType, texture, image.width, image.height);
    }

    textureProperties.__version = texture.version;
    if (texture.onUpdate) texture.onUpdate(texture);
  } // Render targets
  // Setup storage for target texture and bind it to correct framebuffer


  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
    const glFormat = utils.convert(renderTarget.texture.format);
    const glType = utils.convert(renderTarget.texture.type);
    const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
    state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);

    _gl.bindFramebuffer(36160, framebuffer);

    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);

    _gl.bindFramebuffer(36160, null);
  } // Setup storage for internal depth/stencil buffers and bind to correct framebuffer


  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);

    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;

      if (isMultisample) {
        const depthTexture = renderTarget.depthTexture;

        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }

        const samples = getRenderTargetSamples(renderTarget);

        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }

      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);

        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }

      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      const glFormat = utils.convert(renderTarget.texture.format);
      const glType = utils.convert(renderTarget.texture.type);
      const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);

      if (isMultisample) {
        const samples = getRenderTargetSamples(renderTarget);

        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }

    _gl.bindRenderbuffer(36161, null);
  } // Setup resources for a Depth Texture for a FBO (needs an extension)


  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube) throw new Error('Depth Texture with cube render targets is not supported');

    _gl.bindFramebuffer(36160, framebuffer);

    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
    } // upload an empty depth texture with framebuffer size


    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }

    setTexture2D(renderTarget.depthTexture, 0);

    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

    if (renderTarget.depthTexture.format === DepthFormat) {
      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
    } else {
      throw new Error('Unknown depthTexture format');
    }
  } // Setup GL resources for a non-texture depth buffer


  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;

    if (renderTarget.depthTexture) {
      if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];

        for (let i = 0; i < 6; i++) {
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);

          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
        }
      } else {
        _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);

        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }

    _gl.bindFramebuffer(36160, null);
  } // Set up GL resources for the render target


  function setupRenderTarget(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(renderTarget.texture);
    renderTarget.addEventListener('dispose', onRenderTargetDispose);
    textureProperties.__webglTexture = _gl.createTexture();
    info.memory.textures++;
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2; // Handles WebGL2 RGBFormat fallback - #18858

    if (isWebGL2 && renderTarget.texture.format === RGBFormat && (renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType)) {
      renderTarget.texture.format = RGBAFormat;
      console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');
    } // Setup framebuffer


    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];

      for (let i = 0; i < 6; i++) {
        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

      if (isMultisample) {
        if (isWebGL2) {
          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);

          const glFormat = utils.convert(renderTarget.texture.format);
          const glType = utils.convert(renderTarget.texture.type);
          const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
          const samples = getRenderTargetSamples(renderTarget);

          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);

          _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);

          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);

          _gl.bindRenderbuffer(36161, null);

          if (renderTarget.depthBuffer) {
            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
          }

          _gl.bindFramebuffer(36160, null);
        } else {
          console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
        }
      }
    } // Setup color buffer


    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, renderTarget.texture, supportsMips);

      for (let i = 0; i < 6; i++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);
      }

      if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
        generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);
      }

      state.bindTexture(34067, null);
    } else {
      state.bindTexture(3553, textureProperties.__webglTexture);
      setTextureParameters(3553, renderTarget.texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);

      if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
        generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);
      }

      state.bindTexture(3553, null);
    } // Setup depth and stencil buffers


    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }

  function updateRenderTargetMipmap(renderTarget) {
    const texture = renderTarget.texture;
    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;

    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
      const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;

      const webglTexture = properties.get(texture).__webglTexture;

      state.bindTexture(target, webglTexture);
      generateMipmap(target, texture, renderTarget.width, renderTarget.height);
      state.bindTexture(target, null);
    }
  }

  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.isWebGLMultisampleRenderTarget) {
      if (isWebGL2) {
        const renderTargetProperties = properties.get(renderTarget);

        _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);

        _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);

        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = 16384;
        if (renderTarget.depthBuffer) mask |= 256;
        if (renderTarget.stencilBuffer) mask |= 1024;

        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);

        _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer); // see #18905

      } else {
        console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
      }
    }
  }

  function getRenderTargetSamples(renderTarget) {
    return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
  }

  function updateVideoTexture(texture) {
    const frame = info.render.frame; // Check the last frame we updated the VideoTexture

    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);

      texture.update();
    }
  } // backwards compatibility


  let warnedTexture2D = false;
  let warnedTextureCube = false;

  function safeSetTexture2D(texture, slot) {
    if (texture && texture.isWebGLRenderTarget) {
      if (warnedTexture2D === false) {
        console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
        warnedTexture2D = true;
      }

      texture = texture.texture;
    }

    setTexture2D(texture, slot);
  }

  function safeSetTextureCube(texture, slot) {
    if (texture && texture.isWebGLCubeRenderTarget) {
      if (warnedTextureCube === false) {
        console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
        warnedTextureCube = true;
      }

      texture = texture.texture;
    } // currently relying on the fact that WebGLCubeRenderTarget.texture is a Texture and NOT a CubeTexture
    // TODO: unify these code paths


    if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
      // CompressedTexture can have Array in image :/
      // this function alone should take care of cube textures
      setTextureCube(texture, slot);
    } else {
      // assumed: texture property of THREE.WebGLCubeRenderTarget
      setTextureCubeDynamic(texture, slot);
    }
  } //


  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.setTextureCubeDynamic = setTextureCubeDynamic;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.safeSetTexture2D = safeSetTexture2D;
  this.safeSetTextureCube = safeSetTextureCube;
}
/**
 * @author thespite / http://www.twitter.com/thespite
 */


function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;

  function convert(p) {
    let extension;
    if (p === UnsignedByteType) return 5121;
    if (p === UnsignedShort4444Type) return 32819;
    if (p === UnsignedShort5551Type) return 32820;
    if (p === UnsignedShort565Type) return 33635;
    if (p === ByteType) return 5120;
    if (p === ShortType) return 5122;
    if (p === UnsignedShortType) return 5123;
    if (p === IntType) return 5124;
    if (p === UnsignedIntType) return 5125;
    if (p === FloatType) return 5126;

    if (p === HalfFloatType) {
      if (isWebGL2) return 5131;
      extension = extensions.get('OES_texture_half_float');

      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }

    if (p === AlphaFormat) return 6406;
    if (p === RGBFormat) return 6407;
    if (p === RGBAFormat) return 6408;
    if (p === LuminanceFormat) return 6409;
    if (p === LuminanceAlphaFormat) return 6410;
    if (p === DepthFormat) return 6402;
    if (p === DepthStencilFormat) return 34041;
    if (p === RedFormat) return 6403; // WebGL2 formats.

    if (p === RedIntegerFormat) return 36244;
    if (p === RGFormat) return 33319;
    if (p === RGIntegerFormat) return 33320;
    if (p === RGBIntegerFormat) return 36248;
    if (p === RGBAIntegerFormat) return 36249;

    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      extension = extensions.get('WEBGL_compressed_texture_s3tc');

      if (extension !== null) {
        if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else {
        return null;
      }
    }

    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get('WEBGL_compressed_texture_pvrtc');

      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }

    if (p === RGB_ETC1_Format) {
      extension = extensions.get('WEBGL_compressed_texture_etc1');

      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }

    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get('WEBGL_compressed_texture_etc');

      if (extension !== null) {
        if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
      }
    }

    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
      extension = extensions.get('WEBGL_compressed_texture_astc');

      if (extension !== null) {
        // TODO Complete?
        return p;
      } else {
        return null;
      }
    }

    if (p === RGBA_BPTC_Format) {
      extension = extensions.get('EXT_texture_compression_bptc');

      if (extension !== null) {
        // TODO Complete?
        return p;
      } else {
        return null;
      }
    }

    if (p === UnsignedInt248Type) {
      if (isWebGL2) return 34042;
      extension = extensions.get('WEBGL_depth_texture');

      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }

  return {
    convert: convert
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function ArrayCamera(array) {
  PerspectiveCamera.call(this);
  this.cameras = array || [];
}

ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
  constructor: ArrayCamera,
  isArrayCamera: true
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function Group() {
  Object3D.call(this);
  this.type = 'Group';
}

Group.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Group,
  isGroup: true
});
/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function WebXRController() {
  this._targetRay = null;
  this._grip = null;
}

Object.assign(WebXRController.prototype, {
  constructor: WebXRController,
  getTargetRaySpace: function () {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
    }

    return this._targetRay;
  },
  getGripSpace: function () {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
    }

    return this._grip;
  },
  dispatchEvent: function (event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }

    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }

    return this;
  },
  disconnect: function (inputSource) {
    this.dispatchEvent({
      type: 'disconnected',
      data: inputSource
    });

    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }

    if (this._grip !== null) {
      this._grip.visible = false;
    }

    return this;
  },
  update: function (inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;

    if (inputSource) {
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
        }
      }

      if (grip !== null && inputSource.gripSpace) {
        gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);

        if (gripPose !== null) {
          grip.matrix.fromArray(gripPose.transform.matrix);
          grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
        }
      }
    }

    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }

    if (grip !== null) {
      grip.visible = gripPose !== null;
    }

    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebXRManager(renderer, gl) {
  const scope = this;
  let session = null;
  let framebufferScaleFactor = 1.0;
  let referenceSpace = null;
  let referenceSpaceType = 'local-floor';
  let pose = null;
  const controllers = [];
  const inputSourcesMap = new Map(); //

  const cameraL = new PerspectiveCamera();
  cameraL.layers.enable(1);
  cameraL.viewport = new Vector4();
  const cameraR = new PerspectiveCamera();
  cameraR.layers.enable(2);
  cameraR.viewport = new Vector4();
  const cameras = [cameraL, cameraR];
  const cameraVR = new ArrayCamera();
  cameraVR.layers.enable(1);
  cameraVR.layers.enable(2);
  let _currentDepthNear = null;
  let _currentDepthFar = null; //

  this.enabled = false;
  this.isPresenting = false;

  this.getController = function (index) {
    let controller = controllers[index];

    if (controller === undefined) {
      controller = new WebXRController();
      controllers[index] = controller;
    }

    return controller.getTargetRaySpace();
  };

  this.getControllerGrip = function (index) {
    let controller = controllers[index];

    if (controller === undefined) {
      controller = new WebXRController();
      controllers[index] = controller;
    }

    return controller.getGripSpace();
  }; //


  function onSessionEvent(event) {
    const controller = inputSourcesMap.get(event.inputSource);

    if (controller) {
      controller.dispatchEvent({
        type: event.type
      });
    }
  }

  function onSessionEnd() {
    inputSourcesMap.forEach(function (controller, inputSource) {
      controller.disconnect(inputSource);
    });
    inputSourcesMap.clear(); //

    renderer.setFramebuffer(null);
    renderer.setRenderTarget(renderer.getRenderTarget()); // Hack #15830

    animation.stop();
    scope.isPresenting = false;
    scope.dispatchEvent({
      type: 'sessionend'
    });
  }

  function onRequestReferenceSpace(value) {
    referenceSpace = value;
    animation.setContext(session);
    animation.start();
    scope.isPresenting = true;
    scope.dispatchEvent({
      type: 'sessionstart'
    });
  }

  this.setFramebufferScaleFactor = function (value) {
    framebufferScaleFactor = value;

    if (scope.isPresenting === true) {
      console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
    }
  };

  this.setReferenceSpaceType = function (value) {
    referenceSpaceType = value;

    if (scope.isPresenting === true) {
      console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
    }
  };

  this.getReferenceSpace = function () {
    return referenceSpace;
  };

  this.getSession = function () {
    return session;
  };

  this.setSession = function (value) {
    session = value;

    if (session !== null) {
      session.addEventListener('select', onSessionEvent);
      session.addEventListener('selectstart', onSessionEvent);
      session.addEventListener('selectend', onSessionEvent);
      session.addEventListener('squeeze', onSessionEvent);
      session.addEventListener('squeezestart', onSessionEvent);
      session.addEventListener('squeezeend', onSessionEvent);
      session.addEventListener('end', onSessionEnd);
      const attributes = gl.getContextAttributes();

      if (attributes.xrCompatible !== true) {
        gl.makeXRCompatible();
      }

      const layerInit = {
        antialias: attributes.antialias,
        alpha: attributes.alpha,
        depth: attributes.depth,
        stencil: attributes.stencil,
        framebufferScaleFactor: framebufferScaleFactor
      }; // eslint-disable-next-line no-undef

      const baseLayer = new XRWebGLLayer(session, gl, layerInit);
      session.updateRenderState({
        baseLayer: baseLayer
      });
      session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace); //

      session.addEventListener('inputsourceschange', updateInputSources);
    }
  };

  function updateInputSources(event) {
    const inputSources = session.inputSources; // Assign inputSources to available controllers

    for (let i = 0; i < controllers.length; i++) {
      inputSourcesMap.set(inputSources[i], controllers[i]);
    } // Notify disconnected


    for (let i = 0; i < event.removed.length; i++) {
      const inputSource = event.removed[i];
      const controller = inputSourcesMap.get(inputSource);

      if (controller) {
        controller.dispatchEvent({
          type: 'disconnected',
          data: inputSource
        });
        inputSourcesMap.delete(inputSource);
      }
    } // Notify connected


    for (let i = 0; i < event.added.length; i++) {
      const inputSource = event.added[i];
      const controller = inputSourcesMap.get(inputSource);

      if (controller) {
        controller.dispatchEvent({
          type: 'connected',
          data: inputSource
        });
      }
    }
  } //


  const cameraLPos = new Vector3();
  const cameraRPos = new Vector3();
  /**
   * @author jsantell / https://www.jsantell.com/
   *
   * Assumes 2 cameras that are parallel and share an X-axis, and that
   * the cameras' projection and world matrices have already been set.
   * And that near and far planes are identical for both cameras.
   * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
   */

  function setProjectionFromUnion(camera, cameraL, cameraR) {
    cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
    cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
    const ipd = cameraLPos.distanceTo(cameraRPos);
    const projL = cameraL.projectionMatrix.elements;
    const projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and
    // most likely identical top and bottom frustum extents.
    // Use the left camera for these values.

    const near = projL[14] / (projL[10] - 1);
    const far = projL[14] / (projL[10] + 1);
    const topFov = (projL[9] + 1) / projL[5];
    const bottomFov = (projL[9] - 1) / projL[5];
    const leftFov = (projL[8] - 1) / projL[0];
    const rightFov = (projR[8] + 1) / projR[0];
    const left = near * leftFov;
    const right = near * rightFov; // Calculate the new camera's position offset from the
    // left camera. xOffset should be roughly half `ipd`.

    const zOffset = ipd / (-leftFov + rightFov);
    const xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?

    cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
    camera.translateX(xOffset);
    camera.translateZ(zOffset);
    camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
    camera.matrixWorldInverse.getInverse(camera.matrixWorld); // Find the union of the frustum values of the cameras and scale
    // the values so that the near plane's position does not change in world space,
    // although must now be relative to the new union camera.

    const near2 = near + zOffset;
    const far2 = far + zOffset;
    const left2 = left - xOffset;
    const right2 = right + (ipd - xOffset);
    const top2 = topFov * far / far2 * near2;
    const bottom2 = bottomFov * far / far2 * near2;
    camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
  }

  function updateCamera(camera, parent) {
    if (parent === null) {
      camera.matrixWorld.copy(camera.matrix);
    } else {
      camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
    }

    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
  }

  this.getCamera = function (camera) {
    cameraVR.near = cameraR.near = cameraL.near = camera.near;
    cameraVR.far = cameraR.far = cameraL.far = camera.far;

    if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
      // Note that the new renderState won't apply until the next frame. See #18320
      session.updateRenderState({
        depthNear: cameraVR.near,
        depthFar: cameraVR.far
      });
      _currentDepthNear = cameraVR.near;
      _currentDepthFar = cameraVR.far;
    }

    const parent = camera.parent;
    const cameras = cameraVR.cameras;
    updateCamera(cameraVR, parent);

    for (let i = 0; i < cameras.length; i++) {
      updateCamera(cameras[i], parent);
    } // update camera and its children


    camera.matrixWorld.copy(cameraVR.matrixWorld);
    const children = camera.children;

    for (let i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(true);
    } // update projection matrix for proper view frustum culling


    if (cameras.length === 2) {
      setProjectionFromUnion(cameraVR, cameraL, cameraR);
    } else {
      // assume single camera setup (AR)
      cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
    }

    return cameraVR;
  }; // Animation Loop


  let onAnimationFrameCallback = null;

  function onAnimationFrame(time, frame) {
    pose = frame.getViewerPose(referenceSpace);

    if (pose !== null) {
      const views = pose.views;
      const baseLayer = session.renderState.baseLayer;
      renderer.setFramebuffer(baseLayer.framebuffer);
      let cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list

      if (views.length !== cameraVR.cameras.length) {
        cameraVR.cameras.length = 0;
        cameraVRNeedsUpdate = true;
      }

      for (let i = 0; i < views.length; i++) {
        const view = views[i];
        const viewport = baseLayer.getViewport(view);
        const camera = cameras[i];
        camera.matrix.fromArray(view.transform.matrix);
        camera.projectionMatrix.fromArray(view.projectionMatrix);
        camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

        if (i === 0) {
          cameraVR.matrix.copy(camera.matrix);
        }

        if (cameraVRNeedsUpdate === true) {
          cameraVR.cameras.push(camera);
        }
      }
    } //


    const inputSources = session.inputSources;

    for (let i = 0; i < controllers.length; i++) {
      const controller = controllers[i];
      const inputSource = inputSources[i];
      controller.update(inputSource, frame, referenceSpace);
    }

    if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
  }

  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);

  this.setAnimationLoop = function (callback) {
    onAnimationFrameCallback = callback;
  };

  this.dispose = function () {};
}

Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLMaterials(properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);

    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }

  function refreshMaterialUniforms(uniforms, material, environment, pixelRatio, height) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsLambert(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material, environment);

      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, environment);
      } else {
        refreshUniformsStandard(uniforms, material, environment);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDepth(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsNormal(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);

      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false; // #15581
    }
  }

  function refreshUniformsCommon(uniforms, material, environment) {
    uniforms.opacity.value = material.opacity;

    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }

    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }

    if (material.map) {
      uniforms.map.value = material.map;
    }

    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }

    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }

    const envMap = material.envMap || environment;

    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.refractionRatio.value = material.refractionRatio;
      uniforms.maxMipLevel.value = properties.get(envMap).__maxMipLevel;
    }

    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
    }

    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    } // uv repeat and offset setting priorities
    // 1. color map
    // 2. specular map
    // 3. normal map
    // 4. bump map
    // 5. alpha map
    // 6. emissive map


    let uvScaleMap;

    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    }

    if (uvScaleMap !== undefined) {
      // backwards compatibility
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }

      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }

      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    } // uv repeat and offset setting priorities for uv2
    // 1. ao map
    // 2. light map


    let uv2ScaleMap;

    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }

    if (uv2ScaleMap !== undefined) {
      // backwards compatibility
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }

      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }

      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }

  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }

  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }

  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;

    if (material.map) {
      uniforms.map.value = material.map;
    }

    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    } // uv repeat and offset setting priorities
    // 1. color map
    // 2. alpha map


    let uvScaleMap;

    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }

    if (uvScaleMap !== undefined) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }

      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }

  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;

    if (material.map) {
      uniforms.map.value = material.map;
    }

    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    } // uv repeat and offset setting priorities
    // 1. color map
    // 2. alpha map


    let uvScaleMap;

    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }

    if (uvScaleMap !== undefined) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }

      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }

  function refreshUniformsLambert(uniforms, material) {
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
  }

  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsStandard(uniforms, material, environment) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;

    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }

    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }

    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }

    if (material.envMap || environment) {
      //uniforms.envMap.value = material.envMap; // part of uniforms common
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }

  function refreshUniformsPhysical(uniforms, material, environment) {
    refreshUniformsStandard(uniforms, material, environment);
    uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

    uniforms.clearcoat.value = material.clearcoat;
    uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
    if (material.sheen) uniforms.sheen.value.copy(material.sheen);

    if (material.clearcoatMap) {
      uniforms.clearcoatMap.value = material.clearcoatMap;
    }

    if (material.clearcoatRoughnessMap) {
      uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
    }

    if (material.clearcoatNormalMap) {
      uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
      uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

      if (material.side === BackSide) {
        uniforms.clearcoatNormalScale.value.negate();
      }
    }

    uniforms.transparency.value = material.transparency;
  }

  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }

    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsDepth(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  function refreshUniformsDistance(uniforms, material) {
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }

    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }

  function refreshUniformsNormal(uniforms, material) {
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
    }

    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) uniforms.normalScale.value.negate();
    }

    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
  }

  return {
    refreshFogUniforms: refreshFogUniforms,
    refreshMaterialUniforms: refreshMaterialUniforms
  };
}
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author tschw
 */


function WebGLRenderer(parameters) {
  parameters = parameters || {};

  const _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'),
        _context = parameters.context !== undefined ? parameters.context : null,
        _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
        _depth = parameters.depth !== undefined ? parameters.depth : true,
        _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
        _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
        _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
        _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
        _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
        _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

  let currentRenderList = null;
  let currentRenderState = null; // public properties

  this.domElement = _canvas; // Debug configuration container

  this.debug = {
    /**
     * Enables error checking and reporting when shader programs are being compiled
     * @type {boolean}
     */
    checkShaderErrors: true
  }; // clearing

  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true; // scene graph

  this.sortObjects = true; // user-defined clipping

  this.clippingPlanes = [];
  this.localClippingEnabled = false; // physically based shading

  this.gammaFactor = 2.0; // for backwards compatibility

  this.outputEncoding = LinearEncoding; // physical lights

  this.physicallyCorrectLights = false; // tone mapping

  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1.0; // morphs

  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4; // internal properties

  const _this = this;

  let _isContextLost = false; // internal state cache

  let _framebuffer = null;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentFramebuffer = null;

  let _currentMaterialId = -1;

  let _currentCamera = null;
  let _currentArrayCamera = null;

  const _currentViewport = new Vector4();

  const _currentScissor = new Vector4();

  let _currentScissorTest = null; //

  let _width = _canvas.width;
  let _height = _canvas.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;

  const _viewport = new Vector4(0, 0, _width, _height);

  const _scissor = new Vector4(0, 0, _width, _height);

  let _scissorTest = false; // frustum

  const _frustum = new Frustum(); // clipping


  const _clipping = new WebGLClipping();

  let _clippingEnabled = false;
  let _localClippingEnabled = false; // camera matrices cache

  const _projScreenMatrix = new Matrix4();

  const _vector3 = new Vector3();

  const _emptyScene = {
    background: null,
    fog: null,
    environment: null,
    overrideMaterial: null,
    isScene: true
  };

  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  } // initialize


  let _gl = _context;

  function getContext(contextNames, contextAttributes) {
    for (let i = 0; i < contextNames.length; i++) {
      const contextName = contextNames[i];

      const context = _canvas.getContext(contextName, contextAttributes);

      if (context !== null) return context;
    }

    return null;
  }

  try {
    const contextAttributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    }; // event listeners must be registered before WebGL context is created, see #12753

    _canvas.addEventListener('webglcontextlost', onContextLost, false);

    _canvas.addEventListener('webglcontextrestored', onContextRestore, false);

    if (_gl === null) {
      const contextNames = ['webgl2', 'webgl', 'experimental-webgl'];

      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }

      _gl = getContext(contextNames, contextAttributes);

      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error('Error creating WebGL context with your selected attributes.');
        } else {
          throw new Error('Error creating WebGL context.');
        }
      }
    } // Some experimental-webgl implementations do not have getShaderPrecisionFormat


    if (_gl.getShaderPrecisionFormat === undefined) {
      _gl.getShaderPrecisionFormat = function () {
        return {
          'rangeMin': 1,
          'rangeMax': 1,
          'precision': 1
        };
      };
    }
  } catch (error) {
    console.error('THREE.WebGLRenderer: ' + error.message);
    throw error;
  }

  let extensions, capabilities, state, info;
  let properties, textures, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils, bindingStates;

  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);

    if (capabilities.isWebGL2 === false) {
      extensions.get('WEBGL_depth_texture');
      extensions.get('OES_texture_float');
      extensions.get('OES_texture_half_float');
      extensions.get('OES_texture_half_float_linear');
      extensions.get('OES_standard_derivatives');
      extensions.get('OES_element_index_uint');
      extensions.get('OES_vertex_array_object');
      extensions.get('ANGLE_instanced_arrays');
    }

    extensions.get('OES_texture_float_linear');
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, capabilities);
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl);
    programCache = new WebGLPrograms(_this, extensions, capabilities, bindingStates);
    materials = new WebGLMaterials(properties);
    renderLists = new WebGLRenderLists();
    renderStates = new WebGLRenderStates();
    background = new WebGLBackground(_this, state, objects, _premultipliedAlpha);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.state = state;
    _this.info = info;
  }

  initGLContext(); // xr

  const xr = new WebXRManager(_this, _gl);
  this.xr = xr; // shadow map

  const shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
  this.shadowMap = shadowMap; // API

  this.getContext = function () {
    return _gl;
  };

  this.getContextAttributes = function () {
    return _gl.getContextAttributes();
  };

  this.forceContextLoss = function () {
    const extension = extensions.get('WEBGL_lose_context');
    if (extension) extension.loseContext();
  };

  this.forceContextRestore = function () {
    const extension = extensions.get('WEBGL_lose_context');
    if (extension) extension.restoreContext();
  };

  this.getPixelRatio = function () {
    return _pixelRatio;
  };

  this.setPixelRatio = function (value) {
    if (value === undefined) return;
    _pixelRatio = value;
    this.setSize(_width, _height, false);
  };

  this.getSize = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');
      target = new Vector2();
    }

    return target.set(_width, _height);
  };

  this.setSize = function (width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
      return;
    }

    _width = width;
    _height = height;
    _canvas.width = Math.floor(width * _pixelRatio);
    _canvas.height = Math.floor(height * _pixelRatio);

    if (updateStyle !== false) {
      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';
    }

    this.setViewport(0, 0, width, height);
  };

  this.getDrawingBufferSize = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');
      target = new Vector2();
    }

    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
  };

  this.setDrawingBufferSize = function (width, height, pixelRatio) {
    _width = width;
    _height = height;
    _pixelRatio = pixelRatio;
    _canvas.width = Math.floor(width * pixelRatio);
    _canvas.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
  };

  this.getCurrentViewport = function (target) {
    if (target === undefined) {
      console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');
      target = new Vector4();
    }

    return target.copy(_currentViewport);
  };

  this.getViewport = function (target) {
    return target.copy(_viewport);
  };

  this.setViewport = function (x, y, width, height) {
    if (x.isVector4) {
      _viewport.set(x.x, x.y, x.z, x.w);
    } else {
      _viewport.set(x, y, width, height);
    }

    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };

  this.getScissor = function (target) {
    return target.copy(_scissor);
  };

  this.setScissor = function (x, y, width, height) {
    if (x.isVector4) {
      _scissor.set(x.x, x.y, x.z, x.w);
    } else {
      _scissor.set(x, y, width, height);
    }

    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };

  this.getScissorTest = function () {
    return _scissorTest;
  };

  this.setScissorTest = function (boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };

  this.setOpaqueSort = function (method) {
    _opaqueSort = method;
  };

  this.setTransparentSort = function (method) {
    _transparentSort = method;
  }; // Clearing


  this.getClearColor = function () {
    return background.getClearColor();
  };

  this.setClearColor = function () {
    background.setClearColor.apply(background, arguments);
  };

  this.getClearAlpha = function () {
    return background.getClearAlpha();
  };

  this.setClearAlpha = function () {
    background.setClearAlpha.apply(background, arguments);
  };

  this.clear = function (color, depth, stencil) {
    let bits = 0;
    if (color === undefined || color) bits |= 16384;
    if (depth === undefined || depth) bits |= 256;
    if (stencil === undefined || stencil) bits |= 1024;

    _gl.clear(bits);
  };

  this.clearColor = function () {
    this.clear(true, false, false);
  };

  this.clearDepth = function () {
    this.clear(false, true, false);
  };

  this.clearStencil = function () {
    this.clear(false, false, true);
  }; //


  this.dispose = function () {
    _canvas.removeEventListener('webglcontextlost', onContextLost, false);

    _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    objects.dispose();
    bindingStates.dispose();
    xr.dispose();
    animation.stop();
  }; // Events


  function onContextLost(event) {
    event.preventDefault();
    console.log('THREE.WebGLRenderer: Context Lost.');
    _isContextLost = true;
  }

  function onContextRestore()
  /* event */
  {
    console.log('THREE.WebGLRenderer: Context Restored.');
    _isContextLost = false;
    initGLContext();
  }

  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener('dispose', onMaterialDispose);
    deallocateMaterial(material);
  } // Buffer deallocation


  function deallocateMaterial(material) {
    releaseMaterialProgramReference(material);
    properties.remove(material);
  }

  function releaseMaterialProgramReference(material) {
    const programInfo = properties.get(material).program;
    material.program = undefined;

    if (programInfo !== undefined) {
      programCache.releaseProgram(programInfo);
    }
  } // Buffer rendering


  function renderObjectImmediate(object, program) {
    object.render(function (object) {
      _this.renderBufferImmediate(object, program);
    });
  }

  this.renderBufferImmediate = function (object, program) {
    bindingStates.initAttributes();
    const buffers = properties.get(object);
    if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
    if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
    if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
    if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
    const programAttributes = program.getAttributes();

    if (object.hasPositions) {
      _gl.bindBuffer(34962, buffers.position);

      _gl.bufferData(34962, object.positionArray, 35048);

      bindingStates.enableAttribute(programAttributes.position);

      _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
    }

    if (object.hasNormals) {
      _gl.bindBuffer(34962, buffers.normal);

      _gl.bufferData(34962, object.normalArray, 35048);

      bindingStates.enableAttribute(programAttributes.normal);

      _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
    }

    if (object.hasUvs) {
      _gl.bindBuffer(34962, buffers.uv);

      _gl.bufferData(34962, object.uvArray, 35048);

      bindingStates.enableAttribute(programAttributes.uv);

      _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
    }

    if (object.hasColors) {
      _gl.bindBuffer(34962, buffers.color);

      _gl.bufferData(34962, object.colorArray, 35048);

      bindingStates.enableAttribute(programAttributes.color);

      _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
    }

    bindingStates.disableUnusedAttributes();

    _gl.drawArrays(4, 0, object.count);

    object.count = 0;
  };

  this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
    if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    const program = setProgram(camera, scene, material, object);
    state.setMaterial(material, frontFaceCW); //

    let index = geometry.index;
    const position = geometry.attributes.position; //

    if (index === null) {
      if (position === undefined || position.count === 0) return;
    } else if (index.count === 0) {
      return;
    } //


    let rangeFactor = 1;

    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }

    if (material.morphTargets || material.morphNormals) {
      morphtargets.update(object, geometry, material, program);
    }

    bindingStates.setup(object, material, program, geometry, index);
    let attribute;
    let renderer = bufferRenderer;

    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    } //


    const dataCount = index !== null ? index.count : position.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0) return; //

    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        renderer.setMode(4);
      }
    } else if (object.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

      state.setLineWidth(lineWidth * getTargetPixelRatio());

      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }

    if (object.isInstancedMesh) {
      renderer.renderInstances(geometry, drawStart, drawCount, object.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer.renderInstances(geometry, drawStart, drawCount, instanceCount);
    } else {
      renderer.render(drawStart, drawCount);
    }
  }; // Compile


  this.compile = function (scene, camera) {
    currentRenderState = renderStates.get(scene, camera);
    currentRenderState.init();
    scene.traverse(function (object) {
      if (object.isLight) {
        currentRenderState.pushLight(object);

        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights(camera);
    const compiled = new WeakMap();
    scene.traverse(function (object) {
      let material = object.material;

      if (material) {
        if (Array.isArray(material)) {
          for (let i = 0; i < material.length; i++) {
            let material2 = material[i];

            if (compiled.has(material2) === false) {
              initMaterial(material2, scene, object);
              compiled.set(material2);
            }
          }
        } else if (compiled.has(material) === false) {
          initMaterial(material, scene, object);
          compiled.set(material);
        }
      }
    });
  }; // Animation Loop


  let onAnimationFrameCallback = null;

  function onAnimationFrame(time) {
    if (xr.isPresenting) return;
    if (onAnimationFrameCallback) onAnimationFrameCallback(time);
  }

  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof window !== 'undefined') animation.setContext(window);

  this.setAnimationLoop = function (callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  }; // Rendering


  this.render = function (scene, camera) {
    let renderTarget, forceClear;

    if (arguments[2] !== undefined) {
      console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
      renderTarget = arguments[2];
    }

    if (arguments[3] !== undefined) {
      console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');
      forceClear = arguments[3];
    }

    if (camera !== undefined && camera.isCamera !== true) {
      console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
      return;
    }

    if (_isContextLost === true) return; // reset caching for this frame

    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null; // update scene graph

    if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum

    if (camera.parent === null) camera.updateMatrixWorld();

    if (xr.enabled === true && xr.isPresenting === true) {
      camera = xr.getCamera(camera);
    } //


    if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
    currentRenderState = renderStates.get(scene, camera);
    currentRenderState.init();

    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

    _frustum.setFromProjectionMatrix(_projScreenMatrix);

    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, camera);
    currentRenderList.init();
    projectObject(scene, camera, 0, _this.sortObjects);
    currentRenderList.finish();

    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    } //


    if (_clippingEnabled === true) _clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    currentRenderState.setupLights(camera);
    if (_clippingEnabled === true) _clipping.endShadows(); //

    if (this.info.autoReset === true) this.info.reset();

    if (renderTarget !== undefined) {
      this.setRenderTarget(renderTarget);
    } //


    background.render(currentRenderList, scene, camera, forceClear); // render scene

    const opaqueObjects = currentRenderList.opaque;
    const transparentObjects = currentRenderList.transparent;
    if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
    if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera); //

    if (scene.isScene === true) scene.onAfterRender(_this, scene, camera); //

    if (_currentRenderTarget !== null) {
      // Generate mipmap if we're using any kind of mipmap filtering
      textures.updateRenderTargetMipmap(_currentRenderTarget); // resolve multisample renderbuffers to a single-sample texture if necessary

      textures.updateMultisampleRenderTarget(_currentRenderTarget);
    } // Ensure depth buffer writing is enabled so it can be cleared on next render


    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false); // _gl.finish();

    currentRenderList = null;
    currentRenderState = null;
  };

  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera.layers);

    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true) object.update(camera);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);

        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }

          const geometry = objects.update(object);
          const material = object.material;

          if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isImmediateRenderObject) {
        if (sortObjects) {
          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
        }

        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          // update skeleton only once in a frame
          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update();
            object.skeleton.frame = info.render.frame;
          }
        }

        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }

          const geometry = objects.update(object);
          const material = object.material;

          if (Array.isArray(material)) {
            const groups = geometry.groups;

            for (let i = 0, l = groups.length; i < l; i++) {
              const group = groups[i];
              const groupMaterial = material[group.materialIndex];

              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }

    const children = object.children;

    for (let i = 0, l = children.length; i < l; i++) {
      projectObject(children[i], camera, groupOrder, sortObjects);
    }
  }

  function renderObjects(renderList, scene, camera) {
    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

    for (let i = 0, l = renderList.length; i < l; i++) {
      const renderItem = renderList[i];
      const object = renderItem.object;
      const geometry = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group = renderItem.group;

      if (camera.isArrayCamera) {
        _currentArrayCamera = camera;
        const cameras = camera.cameras;

        for (let j = 0, jl = cameras.length; j < jl; j++) {
          const camera2 = cameras[j];

          if (object.layers.test(camera2.layers)) {
            state.viewport(_currentViewport.copy(camera2.viewport));
            currentRenderState.setupLights(camera2);
            renderObject(object, scene, camera2, geometry, material, group);
          }
        }
      } else {
        _currentArrayCamera = null;
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }

  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

    if (object.isImmediateRenderObject) {
      const program = setProgram(camera, scene, material, object);
      state.setMaterial(material);
      bindingStates.reset();
      renderObjectImmediate(object, program);
    } else {
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
    }

    object.onAfterRender(_this, scene, camera, geometry, material, group);
    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
  }

  function initMaterial(material, scene, object) {
    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, _clipping.numPlanes, _clipping.numIntersection, object);
    const programCacheKey = programCache.getProgramCacheKey(parameters);
    let program = materialProperties.program;
    let programChange = true;

    if (program === undefined) {
      // new material
      material.addEventListener('dispose', onMaterialDispose);
    } else if (program.cacheKey !== programCacheKey) {
      // changed glsl or parameters
      releaseMaterialProgramReference(material);
    } else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
      materialProperties.lightsStateVersion = lightsStateVersion;
      programChange = false;
    } else if (parameters.shaderID !== undefined) {
      // same glsl and uniform list
      return;
    } else {
      // only rebuild uniform list
      programChange = false;
    }

    if (programChange) {
      program = programCache.acquireProgram(parameters, programCacheKey);
      materialProperties.program = program;
      materialProperties.uniforms = parameters.uniforms;
      materialProperties.outputEncoding = parameters.outputEncoding;
      material.program = program;
    }

    const programAttributes = program.getAttributes();

    if (material.morphTargets) {
      material.numSupportedMorphTargets = 0;

      for (let i = 0; i < _this.maxMorphTargets; i++) {
        if (programAttributes['morphTarget' + i] >= 0) {
          material.numSupportedMorphTargets++;
        }
      }
    }

    if (material.morphNormals) {
      material.numSupportedMorphNormals = 0;

      for (let i = 0; i < _this.maxMorphNormals; i++) {
        if (programAttributes['morphNormal' + i] >= 0) {
          material.numSupportedMorphNormals++;
        }
      }
    }

    const uniforms = materialProperties.uniforms;

    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      materialProperties.numClippingPlanes = _clipping.numPlanes;
      materialProperties.numIntersection = _clipping.numIntersection;
      uniforms.clippingPlanes = _clipping.uniform;
    }

    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
    materialProperties.fog = scene.fog; // store the light setup it was created for

    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;

    if (materialProperties.needsLights) {
      // wire up the material to this renderer's lighting state
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms
    }

    const progUniforms = materialProperties.program.getUniforms(),
          uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.uniformsList = uniformsList;
  }

  function setProgram(camera, scene, material, object) {
    if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

    textures.resetTextureUnits();
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;

    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        const useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup
        // object instead of the material, once it becomes feasible
        // (#8465, #8379)

        _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
      }
    }

    if (material.version === materialProperties.__version) {
      if (materialProperties.program === undefined) {
        initMaterial(material, scene, object);
      } else if (material.fog && materialProperties.fog !== fog) {
        initMaterial(material, scene, object);
      } else if (materialProperties.environment !== environment) {
        initMaterial(material, scene, object);
      } else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        initMaterial(material, scene, object);
      } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {
        initMaterial(material, scene, object);
      } else if (materialProperties.outputEncoding !== encoding) {
        initMaterial(material, scene, object);
      }
    } else {
      initMaterial(material, scene, object);
      materialProperties.__version = material.version;
    }

    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const program = materialProperties.program,
          p_uniforms = program.getUniforms(),
          m_uniforms = materialProperties.uniforms;

    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }

    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }

    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
      }

      if (_currentCamera !== camera) {
        _currentCamera = camera; // lighting uniforms depend on the camera so enforce an update
        // now, in case this material supports lights - or later, when
        // the next material that does gets activated:

        refreshMaterial = true; // set to true on material change

        refreshLights = true; // remains set until update done
      } // load material specific uniforms
      // (shader material also gets them for the sake of genericity)


      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;

        if (uCamPos !== undefined) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }

      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
      }

      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) {
        p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
      }
    } // skinning uniforms must be set even if material didn't change
    // auto-setting of texture unit for bone texture must go before other textures
    // otherwise textures used for skinning can take over texture units reserved for other material textures


    if (material.skinning) {
      p_uniforms.setOptional(_gl, object, 'bindMatrix');
      p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
      const skeleton = object.skeleton;

      if (skeleton) {
        const bones = skeleton.bones;

        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === undefined) {
            // layout (1 matrix = 4 pixels)
            //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
            //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
            //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
            //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
            //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
            let size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix

            size = MathUtils.ceilPowerOfTwo(size);
            size = Math.max(size, 4);
            const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel

            boneMatrices.set(skeleton.boneMatrices); // copy current values

            const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
            skeleton.boneMatrices = boneMatrices;
            skeleton.boneTexture = boneTexture;
            skeleton.boneTextureSize = size;
          }

          p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
        }
      }
    }

    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
      materialProperties.receiveShadow = object.receiveShadow;
      p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
    }

    if (refreshMaterial) {
      p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);

      if (materialProperties.needsLights) {
        // the current material requires lighting info
        // note: all lighting uniforms are always set correctly
        // they simply reference the renderer's state for their
        // values
        //
        // use the current material's .needsUpdate flags to set
        // the GL state when required
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      } // refresh uniforms common to several materials


      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }

      materials.refreshMaterialUniforms(m_uniforms, material, environment, _pixelRatio, _height); // RectAreaLight Texture
      // TODO (mrdoob): Find a nicer implementation

      if (m_uniforms.ltc_1 !== undefined) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
      if (m_uniforms.ltc_2 !== undefined) m_uniforms.ltc_2.value = UniformsLib.LTC_2;
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }

    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }

    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, 'center', object.center);
    } // common matrices


    p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
    p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
    p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
    return program;
  } // If uniforms are marked as clean, they don't need to be loaded to the GPU.


  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }

  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  } //


  this.setFramebuffer = function (value) {
    if (_framebuffer !== value && _currentRenderTarget === null) _gl.bindFramebuffer(36160, value);
    _framebuffer = value;
  };

  this.getActiveCubeFace = function () {
    return _currentActiveCubeFace;
  };

  this.getActiveMipmapLevel = function () {
    return _currentActiveMipmapLevel;
  };

  this.getRenderTarget = function () {
    return _currentRenderTarget;
  };

  this.setRenderTarget = function (renderTarget, activeCubeFace, activeMipmapLevel) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;

    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
      textures.setupRenderTarget(renderTarget);
    }

    let framebuffer = _framebuffer;
    let isCube = false;

    if (renderTarget) {
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;

      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace || 0];
        isCube = true;
      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }

      _currentViewport.copy(renderTarget.viewport);

      _currentScissor.copy(renderTarget.scissor);

      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();

      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();

      _currentScissorTest = _scissorTest;
    }

    if (_currentFramebuffer !== framebuffer) {
      _gl.bindFramebuffer(36160, framebuffer);

      _currentFramebuffer = framebuffer;
    }

    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);

    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);

      _gl.framebufferTexture2D(36160, 36064, 34069 + (activeCubeFace || 0), textureProperties.__webglTexture, activeMipmapLevel || 0);
    }
  };

  this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
      return;
    }

    let framebuffer = properties.get(renderTarget).__webglFramebuffer;

    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }

    if (framebuffer) {
      let restore = false;

      if (framebuffer !== _currentFramebuffer) {
        _gl.bindFramebuffer(36160, framebuffer);

        restore = true;
      }

      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;

        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
          return;
        }

        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && // IE11, Edge and Chrome Mac < 52 (#9513)
        !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
        !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get('EXT_color_buffer_float') : extensions.get('EXT_color_buffer_half_float')))) {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
          return;
        }

        if (_gl.checkFramebufferStatus(36160) === 36053) {
          // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
          if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } else {
          console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
        }
      } finally {
        if (restore) {
          _gl.bindFramebuffer(36160, _currentFramebuffer);
        }
      }
    }
  };

  this.copyFramebufferToTexture = function (position, texture, level) {
    if (level === undefined) level = 0;
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    const glFormat = utils.convert(texture.format);
    textures.setTexture2D(texture, 0);

    _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);

    state.unbindTexture();
  };

  this.copyTextureToTexture = function (position, srcTexture, dstTexture, level) {
    if (level === undefined) level = 0;
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0); // As another texture upload may have changed pixelStorei
    // parameters, make sure they are correct for the dstTexture

    _gl.pixelStorei(37440, dstTexture.flipY);

    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);

    _gl.pixelStorei(3317, dstTexture.unpackAlignment);

    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    } // Generate mipmaps only when copying level 0


    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553);
    state.unbindTexture();
  };

  this.initTexture = function (texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };

  if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
      detail: this
    })); // eslint-disable-line no-undef

  }
}
/**
 * @author Mugen87 / https://github.com/Mugen87
 */


function WebGL1Renderer(parameters) {
  WebGLRenderer.call(this, parameters);
}

WebGL1Renderer.prototype = Object.assign(Object.create(WebGLRenderer.prototype), {
  constructor: WebGL1Renderer,
  isWebGL1Renderer: true
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function FogExp2(color, density) {
  this.name = '';
  this.color = new Color(color);
  this.density = density !== undefined ? density : 0.00025;
}

Object.assign(FogExp2.prototype, {
  isFogExp2: true,
  clone: function () {
    return new FogExp2(this.color, this.density);
  },
  toJSON: function ()
  /* meta */
  {
    return {
      type: 'FogExp2',
      color: this.color.getHex(),
      density: this.density
    };
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Fog(color, near, far) {
  this.name = '';
  this.color = new Color(color);
  this.near = near !== undefined ? near : 1;
  this.far = far !== undefined ? far : 1000;
}

Object.assign(Fog.prototype, {
  isFog: true,
  clone: function () {
    return new Fog(this.color, this.near, this.far);
  },
  toJSON: function ()
  /* meta */
  {
    return {
      type: 'Fog',
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
});
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InterleavedBuffer(array, stride) {
  this.array = array;
  this.stride = stride;
  this.count = array !== undefined ? array.length / stride : 0;
  this.usage = StaticDrawUsage;
  this.updateRange = {
    offset: 0,
    count: -1
  };
  this.version = 0;
  this.uuid = MathUtils.generateUUID();
}

Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {
  set: function (value) {
    if (value === true) this.version++;
  }
});
Object.assign(InterleavedBuffer.prototype, {
  isInterleavedBuffer: true,
  onUploadCallback: function () {},
  setUsage: function (value) {
    this.usage = value;
    return this;
  },
  copy: function (source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  },
  copyAt: function (index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;

    for (let i = 0, l = this.stride; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }

    return this;
  },
  set: function (value, offset) {
    if (offset === undefined) offset = 0;
    this.array.set(value, offset);
    return this;
  },
  clone: function (data) {
    if (data.arrayBuffers === undefined) {
      data.arrayBuffers = {};
    }

    if (this.array.buffer._uuid === undefined) {
      this.array.buffer._uuid = MathUtils.generateUUID();
    }

    if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }

    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib = new InterleavedBuffer(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  },
  onUpload: function (callback) {
    this.onUploadCallback = callback;
    return this;
  },
  toJSON: function (data) {
    if (data.arrayBuffers === undefined) {
      data.arrayBuffers = {};
    } // generate UUID for array buffer if necessary


    if (this.array.buffer._uuid === undefined) {
      this.array.buffer._uuid = MathUtils.generateUUID();
    }

    if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
    } //


    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
});
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

const _vector$6 = new Vector3();

function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
  this.name = '';
  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset;
  this.normalized = normalized === true;
}

Object.defineProperties(InterleavedBufferAttribute.prototype, {
  count: {
    get: function () {
      return this.data.count;
    }
  },
  array: {
    get: function () {
      return this.data.array;
    }
  }
});
Object.assign(InterleavedBufferAttribute.prototype, {
  isInterleavedBufferAttribute: true,
  applyMatrix4: function (m) {
    for (let i = 0, l = this.data.count; i < l; i++) {
      _vector$6.x = this.getX(i);
      _vector$6.y = this.getY(i);
      _vector$6.z = this.getZ(i);

      _vector$6.applyMatrix4(m);

      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }

    return this;
  },
  setX: function (index, x) {
    this.data.array[index * this.data.stride + this.offset] = x;
    return this;
  },
  setY: function (index, y) {
    this.data.array[index * this.data.stride + this.offset + 1] = y;
    return this;
  },
  setZ: function (index, z) {
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  },
  setW: function (index, w) {
    this.data.array[index * this.data.stride + this.offset + 3] = w;
    return this;
  },
  getX: function (index) {
    return this.data.array[index * this.data.stride + this.offset];
  },
  getY: function (index) {
    return this.data.array[index * this.data.stride + this.offset + 1];
  },
  getZ: function (index) {
    return this.data.array[index * this.data.stride + this.offset + 2];
  },
  getW: function (index) {
    return this.data.array[index * this.data.stride + this.offset + 3];
  },
  setXY: function (index, x, y) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    return this;
  },
  setXYZ: function (index, x, y, z) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    return this;
  },
  setXYZW: function (index, x, y, z, w) {
    index = index * this.data.stride + this.offset;
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w;
    return this;
  },
  clone: function (data) {
    if (data === undefined) {
      console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
      const array = [];

      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;

        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }

      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === undefined) {
        data.interleavedBuffers = {};
      }

      if (data.interleavedBuffers[this.data.uuid] === undefined) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }

      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  },
  toJSON: function (data) {
    if (data === undefined) {
      console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
      const array = [];

      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;

        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      } // deinterleave data and save it as an ordinary buffer attribute for now


      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: array,
        normalized: this.normalized
      };
    } else {
      // save as true interlaved attribtue
      if (data.interleavedBuffers === undefined) {
        data.interleavedBuffers = {};
      }

      if (data.interleavedBuffers[this.data.uuid] === undefined) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }

      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

function SpriteMaterial(parameters) {
  Material.call(this);
  this.type = 'SpriteMaterial';
  this.color = new Color(0xffffff);
  this.map = null;
  this.alphaMap = null;
  this.rotation = 0;
  this.sizeAttenuation = true;
  this.transparent = true;
  this.setValues(parameters);
}

SpriteMaterial.prototype = Object.create(Material.prototype);
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;

SpriteMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.rotation = source.rotation;
  this.sizeAttenuation = source.sizeAttenuation;
  return this;
};
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */


let _geometry;

const _intersectPoint = new Vector3();

const _worldScale = new Vector3();

const _mvPosition = new Vector3();

const _alignedPosition = new Vector2();

const _rotatedPosition = new Vector2();

const _viewWorldMatrix = new Matrix4();

const _vA$1 = new Vector3();

const _vB$1 = new Vector3();

const _vC$1 = new Vector3();

const _uvA$1 = new Vector2();

const _uvB$1 = new Vector2();

const _uvC$1 = new Vector2();

function Sprite(material) {
  Object3D.call(this);
  this.type = 'Sprite';

  if (_geometry === undefined) {
    _geometry = new BufferGeometry();
    const float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
    const interleavedBuffer = new InterleavedBuffer(float32Array, 5);

    _geometry.setIndex([0, 1, 2, 0, 2, 3]);

    _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));

    _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
  }

  this.geometry = _geometry;
  this.material = material !== undefined ? material : new SpriteMaterial();
  this.center = new Vector2(0.5, 0.5);
}

Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Sprite,
  isSprite: true,
  raycast: function (raycaster, intersects) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }

    _worldScale.setFromMatrixScale(this.matrixWorld);

    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);

    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);

    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);

    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }

    const rotation = this.material.rotation;
    let sin, cos;

    if (rotation !== 0) {
      cos = Math.cos(rotation);
      sin = Math.sin(rotation);
    }

    const center = this.center;
    transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

    _uvA$1.set(0, 0);

    _uvB$1.set(1, 0);

    _uvC$1.set(1, 1); // check first triangle


    let intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);

    if (intersect === null) {
      // check second triangle
      transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

      _uvB$1.set(0, 1);

      intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);

      if (intersect === null) {
        return;
      }
    }

    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects.push({
      distance: distance,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
      face: null,
      object: this
    });
  },
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    if (source.center !== undefined) this.center.copy(source.center);
    this.material = source.material;
    return this;
  }
});

function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  // compute position in camera space
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero


  if (sin !== undefined) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }

  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y; // transform to world space

  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */


const _v1$4 = new Vector3();

const _v2$2 = new Vector3();

function LOD() {
  Object3D.call(this);
  this._currentLevel = 0;
  this.type = 'LOD';
  Object.defineProperties(this, {
    levels: {
      enumerable: true,
      value: []
    }
  });
  this.autoUpdate = true;
}

LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: LOD,
  isLOD: true,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source, false);
    const levels = source.levels;

    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      this.addLevel(level.object.clone(), level.distance);
    }

    this.autoUpdate = source.autoUpdate;
    return this;
  },
  addLevel: function (object, distance) {
    if (distance === undefined) distance = 0;
    distance = Math.abs(distance);
    const levels = this.levels;
    let l;

    for (l = 0; l < levels.length; l++) {
      if (distance < levels[l].distance) {
        break;
      }
    }

    levels.splice(l, 0, {
      distance: distance,
      object: object
    });
    this.add(object);
    return this;
  },
  getCurrentLevel: function () {
    return this._currentLevel;
  },
  getObjectForDistance: function (distance) {
    const levels = this.levels;

    if (levels.length > 0) {
      let i, l;

      for (i = 1, l = levels.length; i < l; i++) {
        if (distance < levels[i].distance) {
          break;
        }
      }

      return levels[i - 1].object;
    }

    return null;
  },
  raycast: function (raycaster, intersects) {
    const levels = this.levels;

    if (levels.length > 0) {
      _v1$4.setFromMatrixPosition(this.matrixWorld);

      const distance = raycaster.ray.origin.distanceTo(_v1$4);
      this.getObjectForDistance(distance).raycast(raycaster, intersects);
    }
  },
  update: function (camera) {
    const levels = this.levels;

    if (levels.length > 1) {
      _v1$4.setFromMatrixPosition(camera.matrixWorld);

      _v2$2.setFromMatrixPosition(this.matrixWorld);

      const distance = _v1$4.distanceTo(_v2$2) / camera.zoom;
      levels[0].object.visible = true;
      let i, l;

      for (i = 1, l = levels.length; i < l; i++) {
        if (distance >= levels[i].distance) {
          levels[i - 1].object.visible = false;
          levels[i].object.visible = true;
        } else {
          break;
        }
      }

      this._currentLevel = i - 1;

      for (; i < l; i++) {
        levels[i].object.visible = false;
      }
    }
  },
  toJSON: function (meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    if (this.autoUpdate === false) data.object.autoUpdate = false;
    data.object.levels = [];
    const levels = this.levels;

    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance
      });
    }

    return data;
  }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

function SkinnedMesh(geometry, material) {
  if (geometry && geometry.isGeometry) {
    console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
  }

  Mesh.call(this, geometry, material);
  this.type = 'SkinnedMesh';
  this.bindMode = 'attached';
  this.bindMatrix = new Matrix4();
  this.bindMatrixInverse = new Matrix4();
}

SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: SkinnedMesh,
  isSkinnedMesh: true,
  copy: function (source) {
    Mesh.prototype.copy.call(this, source);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    return this;
  },
  bind: function (skeleton, bindMatrix) {
    this.skeleton = skeleton;

    if (bindMatrix === undefined) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }

    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.getInverse(bindMatrix);
  },
  pose: function () {
    this.skeleton.pose();
  },
  normalizeSkinWeights: function () {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;

    for (let i = 0, l = skinWeight.count; i < l; i++) {
      vector.x = skinWeight.getX(i);
      vector.y = skinWeight.getY(i);
      vector.z = skinWeight.getZ(i);
      vector.w = skinWeight.getW(i);
      const scale = 1.0 / vector.manhattanLength();

      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0); // do something reasonable
      }

      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
    }
  },
  updateMatrixWorld: function (force) {
    Mesh.prototype.updateMatrixWorld.call(this, force);

    if (this.bindMode === 'attached') {
      this.bindMatrixInverse.getInverse(this.matrixWorld);
    } else if (this.bindMode === 'detached') {
      this.bindMatrixInverse.getInverse(this.bindMatrix);
    } else {
      console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
    }
  },
  boneTransform: function () {
    const basePosition = new Vector3();
    const skinIndex = new Vector4();
    const skinWeight = new Vector4();
    const vector = new Vector3();
    const matrix = new Matrix4();
    return function (index, target) {
      const skeleton = this.skeleton;
      const geometry = this.geometry;
      skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
      skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
      basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);
      target.set(0, 0, 0);

      for (let i = 0; i < 4; i++) {
        const weight = skinWeight.getComponent(i);

        if (weight !== 0) {
          const boneIndex = skinIndex.getComponent(i);
          matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
          target.addScaledVector(vector.copy(basePosition).applyMatrix4(matrix), weight);
        }
      }

      return target.applyMatrix4(this.bindMatrixInverse);
    };
  }()
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

const _offsetMatrix = new Matrix4();

const _identityMatrix = new Matrix4();

function Skeleton(bones, boneInverses) {
  // copy the bone array
  bones = bones || [];
  this.bones = bones.slice(0);
  this.boneMatrices = new Float32Array(this.bones.length * 16);
  this.frame = -1; // use the supplied bone inverses or calculate the inverses

  if (boneInverses === undefined) {
    this.calculateInverses();
  } else {
    if (this.bones.length === boneInverses.length) {
      this.boneInverses = boneInverses.slice(0);
    } else {
      console.warn('THREE.Skeleton boneInverses is the wrong length.');
      this.boneInverses = [];

      for (let i = 0, il = this.bones.length; i < il; i++) {
        this.boneInverses.push(new Matrix4());
      }
    }
  }
}

Object.assign(Skeleton.prototype, {
  calculateInverses: function () {
    this.boneInverses = [];

    for (let i = 0, il = this.bones.length; i < il; i++) {
      const inverse = new Matrix4();

      if (this.bones[i]) {
        inverse.getInverse(this.bones[i].matrixWorld);
      }

      this.boneInverses.push(inverse);
    }
  },
  pose: function () {
    // recover the bind-time world matrices
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];

      if (bone) {
        bone.matrixWorld.getInverse(this.boneInverses[i]);
      }
    } // compute the local matrices, positions, rotations and scales


    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];

      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.getInverse(bone.parent.matrixWorld);
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }

        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  },
  update: function () {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture; // flatten bone matrices to array

    for (let i = 0, il = bones.length; i < il; i++) {
      // compute the offset between the current and the original transform
      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;

      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);

      _offsetMatrix.toArray(boneMatrices, i * 16);
    }

    if (boneTexture !== undefined) {
      boneTexture.needsUpdate = true;
    }
  },
  clone: function () {
    return new Skeleton(this.bones, this.boneInverses);
  },
  getBoneByName: function (name) {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];

      if (bone.name === name) {
        return bone;
      }
    }

    return undefined;
  },
  dispose: function () {
    if (this.boneTexture) {
      this.boneTexture.dispose();
      this.boneTexture = undefined;
    }
  }
});
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

function Bone() {
  Object3D.call(this);
  this.type = 'Bone';
}

Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Bone,
  isBone: true
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

const _instanceLocalMatrix = new Matrix4();

const _instanceWorldMatrix = new Matrix4();

const _instanceIntersects = [];

const _mesh = new Mesh();

function InstancedMesh(geometry, material, count) {
  Mesh.call(this, geometry, material);
  this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
  this.count = count;
  this.frustumCulled = false;
}

InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
  constructor: InstancedMesh,
  isInstancedMesh: true,
  copy: function (source) {
    Mesh.prototype.copy.call(this, source);
    this.instanceMatrix.copy(source.instanceMatrix);
    this.count = source.count;
    return this;
  },
  getMatrixAt: function (index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  },
  raycast: function (raycaster, intersects) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === undefined) return;

    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      // calculate the world matrix for each instance
      this.getMatrixAt(instanceId, _instanceLocalMatrix);

      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance


      _mesh.matrixWorld = _instanceWorldMatrix;

      _mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast


      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
        const intersect = _instanceIntersects[i];
        intersect.instanceId = instanceId;
        intersect.object = this;
        intersects.push(intersect);
      }

      _instanceIntersects.length = 0;
    }
  },
  setMatrixAt: function (index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  },
  updateMorphTargets: function () {}
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

function LineBasicMaterial(parameters) {
  Material.call(this);
  this.type = 'LineBasicMaterial';
  this.color = new Color(0xffffff);
  this.linewidth = 1;
  this.linecap = 'round';
  this.linejoin = 'round';
  this.morphTargets = false;
  this.setValues(parameters);
}

LineBasicMaterial.prototype = Object.create(Material.prototype);
LineBasicMaterial.prototype.constructor = LineBasicMaterial;
LineBasicMaterial.prototype.isLineBasicMaterial = true;

LineBasicMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.linewidth = source.linewidth;
  this.linecap = source.linecap;
  this.linejoin = source.linejoin;
  this.morphTargets = source.morphTargets;
  return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */


const _start = new Vector3();

const _end = new Vector3();

const _inverseMatrix$1 = new Matrix4();

const _ray$1 = new Ray();

const _sphere$2 = new Sphere();

function Line(geometry, material, mode) {
  if (mode === 1) {
    console.error('THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.');
  }

  Object3D.call(this);
  this.type = 'Line';
  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  this.material = material !== undefined ? material : new LineBasicMaterial();
  this.updateMorphTargets();
}

Line.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Line,
  isLine: true,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  computeLineDistances: function () {
    const geometry = this.geometry;

    if (geometry.isBufferGeometry) {
      // we assume non-indexed geometry
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [0];

        for (let i = 1, l = positionAttribute.count; i < l; i++) {
          _start.fromBufferAttribute(positionAttribute, i - 1);

          _end.fromBufferAttribute(positionAttribute, i);

          lineDistances[i] = lineDistances[i - 1];
          lineDistances[i] += _start.distanceTo(_end);
        }

        geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
      }
    } else if (geometry.isGeometry) {
      const vertices = geometry.vertices;
      const lineDistances = geometry.lineDistances;
      lineDistances[0] = 0;

      for (let i = 1, l = vertices.length; i < l; i++) {
        lineDistances[i] = lineDistances[i - 1];
        lineDistances[i] += vertices[i - 1].distanceTo(vertices[i]);
      }
    }

    return this;
  },
  raycast: function (raycaster, intersects) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold; // Checking boundingSphere distance to ray

    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

    _sphere$2.copy(geometry.boundingSphere);

    _sphere$2.applyMatrix4(matrixWorld);

    _sphere$2.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$2) === false) return; //

    _inverseMatrix$1.getInverse(matrixWorld);

    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);

    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step = this && this.isLineSegments ? 2 : 1;

    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positions = attributes.position.array;

      if (index !== null) {
        const indices = index.array;

        for (let i = 0, l = indices.length - 1; i < l; i += step) {
          const a = indices[i];
          const b = indices[i + 1];
          vStart.fromArray(positions, a * 3);
          vEnd.fromArray(positions, b * 3);

          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

          if (distSq > localThresholdSq) continue;
          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far) continue;
          intersects.push({
            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        for (let i = 0, l = positions.length / 3 - 1; i < l; i += step) {
          vStart.fromArray(positions, 3 * i);
          vEnd.fromArray(positions, 3 * i + 3);

          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

          if (distSq > localThresholdSq) continue;
          interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

          const distance = raycaster.ray.origin.distanceTo(interRay);
          if (distance < raycaster.near || distance > raycaster.far) continue;
          intersects.push({
            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    } else if (geometry.isGeometry) {
      const vertices = geometry.vertices;
      const nbVertices = vertices.length;

      for (let i = 0; i < nbVertices - 1; i += step) {
        const distSq = _ray$1.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);

        if (distSq > localThresholdSq) continue;
        interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

        const distance = raycaster.ray.origin.distanceTo(interRay);
        if (distance < raycaster.near || distance > raycaster.far) continue;
        intersects.push({
          distance: distance,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: interSegment.clone().applyMatrix4(this.matrixWorld),
          index: i,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  },
  updateMorphTargets: function () {
    const geometry = this.geometry;

    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);

      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];

        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};

          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;

      if (morphTargets !== undefined && morphTargets.length > 0) {
        console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

const _start$1 = new Vector3();

const _end$1 = new Vector3();

function LineSegments(geometry, material) {
  Line.call(this, geometry, material);
  this.type = 'LineSegments';
}

LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineSegments,
  isLineSegments: true,
  computeLineDistances: function () {
    const geometry = this.geometry;

    if (geometry.isBufferGeometry) {
      // we assume non-indexed geometry
      if (geometry.index === null) {
        const positionAttribute = geometry.attributes.position;
        const lineDistances = [];

        for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
          _start$1.fromBufferAttribute(positionAttribute, i);

          _end$1.fromBufferAttribute(positionAttribute, i + 1);

          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
          lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
        }

        geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
      } else {
        console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
      }
    } else if (geometry.isGeometry) {
      const vertices = geometry.vertices;
      const lineDistances = geometry.lineDistances;

      for (let i = 0, l = vertices.length; i < l; i += 2) {
        _start$1.copy(vertices[i]);

        _end$1.copy(vertices[i + 1]);

        lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
        lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
      }
    }

    return this;
  }
});
/**
 * @author mgreter / http://github.com/mgreter
 */

function LineLoop(geometry, material) {
  Line.call(this, geometry, material);
  this.type = 'LineLoop';
}

LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
  constructor: LineLoop,
  isLineLoop: true
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */

function PointsMaterial(parameters) {
  Material.call(this);
  this.type = 'PointsMaterial';
  this.color = new Color(0xffffff);
  this.map = null;
  this.alphaMap = null;
  this.size = 1;
  this.sizeAttenuation = true;
  this.morphTargets = false;
  this.setValues(parameters);
}

PointsMaterial.prototype = Object.create(Material.prototype);
PointsMaterial.prototype.constructor = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = true;

PointsMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.alphaMap = source.alphaMap;
  this.size = source.size;
  this.sizeAttenuation = source.sizeAttenuation;
  this.morphTargets = source.morphTargets;
  return this;
};
/**
 * @author alteredq / http://alteredqualia.com/
 */


const _inverseMatrix$2 = new Matrix4();

const _ray$2 = new Ray();

const _sphere$3 = new Sphere();

const _position$1 = new Vector3();

function Points(geometry, material) {
  Object3D.call(this);
  this.type = 'Points';
  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
  this.material = material !== undefined ? material : new PointsMaterial();
  this.updateMorphTargets();
}

Points.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Points,
  isPoints: true,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  },
  raycast: function (raycaster, intersects) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold; // Checking boundingSphere distance to ray

    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

    _sphere$3.copy(geometry.boundingSphere);

    _sphere$3.applyMatrix4(matrixWorld);

    _sphere$3.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$3) === false) return; //

    _inverseMatrix$2.getInverse(matrixWorld);

    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);

    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;

    if (geometry.isBufferGeometry) {
      const index = geometry.index;
      const attributes = geometry.attributes;
      const positions = attributes.position.array;

      if (index !== null) {
        const indices = index.array;

        for (let i = 0, il = indices.length; i < il; i++) {
          const a = indices[i];

          _position$1.fromArray(positions, a * 3);

          testPoint(_position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      } else {
        for (let i = 0, l = positions.length / 3; i < l; i++) {
          _position$1.fromArray(positions, i * 3);

          testPoint(_position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
      }
    } else {
      const vertices = geometry.vertices;

      for (let i = 0, l = vertices.length; i < l; i++) {
        testPoint(vertices[i], i, localThresholdSq, matrixWorld, raycaster, intersects, this);
      }
    }
  },
  updateMorphTargets: function () {
    const geometry = this.geometry;

    if (geometry.isBufferGeometry) {
      const morphAttributes = geometry.morphAttributes;
      const keys = Object.keys(morphAttributes);

      if (keys.length > 0) {
        const morphAttribute = morphAttributes[keys[0]];

        if (morphAttribute !== undefined) {
          this.morphTargetInfluences = [];
          this.morphTargetDictionary = {};

          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
            const name = morphAttribute[m].name || String(m);
            this.morphTargetInfluences.push(0);
            this.morphTargetDictionary[name] = m;
          }
        }
      }
    } else {
      const morphTargets = geometry.morphTargets;

      if (morphTargets !== undefined && morphTargets.length > 0) {
        console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
      }
    }
  }
});

function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
  const rayPointDistanceSq = _ray$2.distanceSqToPoint(point);

  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();

    _ray$2.closestPointToPoint(point, intersectPoint);

    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects.push({
      distance: distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index: index,
      face: null,
      object: object
    });
  }
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.format = format !== undefined ? format : RGBFormat;
  this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
  this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
  this.generateMipmaps = false;
}

VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
  constructor: VideoTexture,
  isVideoTexture: true,
  update: function () {
    const video = this.image;

    if (video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */

function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
  this.image = {
    width: width,
    height: height
  };
  this.mipmaps = mipmaps; // no flipping for cube textures
  // (also flipping doesn't work for compressed textures )

  this.flipY = false; // can't generate mipmaps for compressed textures
  // mips must be embedded in DDS files

  this.generateMipmaps = false;
}

CompressedTexture.prototype = Object.create(Texture.prototype);
CompressedTexture.prototype.constructor = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = true;
/**
 * @author mrdoob / http://mrdoob.com/
 */

function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
  Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.needsUpdate = true;
}

CanvasTexture.prototype = Object.create(Texture.prototype);
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;
/**
 * @author Matt DesLauriers / @mattdesl
 * @author atix / arthursilber.de
 */

function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
  format = format !== undefined ? format : DepthFormat;

  if (format !== DepthFormat && format !== DepthStencilFormat) {
    throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
  }

  if (type === undefined && format === DepthFormat) type = UnsignedShortType;
  if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
  this.image = {
    width: width,
    height: height
  };
  this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
  this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
  this.flipY = false;
  this.generateMipmaps = false;
}

DepthTexture.prototype = Object.create(Texture.prototype);
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

function WireframeGeometry(geometry) {
  BufferGeometry.call(this);
  this.type = 'WireframeGeometry'; // buffer

  const vertices = []; // helper variables

  const edge = [0, 0],
        edges = {};
  const keys = ['a', 'b', 'c']; // different logic for Geometry and BufferGeometry

  if (geometry && geometry.isGeometry) {
    // create a data structure that contains all edges without duplicates
    const faces = geometry.faces;

    for (let i = 0, l = faces.length; i < l; i++) {
      const face = faces[i];

      for (let j = 0; j < 3; j++) {
        const edge1 = face[keys[j]];
        const edge2 = face[keys[(j + 1) % 3]];
        edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates

        edge[1] = Math.max(edge1, edge2);
        const key = edge[0] + ',' + edge[1];

        if (edges[key] === undefined) {
          edges[key] = {
            index1: edge[0],
            index2: edge[1]
          };
        }
      }
    } // generate vertices


    for (const key in edges) {
      const e = edges[key];
      let vertex = geometry.vertices[e.index1];
      vertices.push(vertex.x, vertex.y, vertex.z);
      vertex = geometry.vertices[e.index2];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
  } else if (geometry && geometry.isBufferGeometry) {
    let vertex = new Vector3();

    if (geometry.index !== null) {
      // indexed BufferGeometry
      const position = geometry.attributes.position;
      const indices = geometry.index;
      let groups = geometry.groups;

      if (groups.length === 0) {
        groups = [{
          start: 0,
          count: indices.count,
          materialIndex: 0
        }];
      } // create a data structure that contains all eges without duplicates


      for (let o = 0, ol = groups.length; o < ol; ++o) {
        const group = groups[o];
        const start = group.start;
        const count = group.count;

        for (let i = start, l = start + count; i < l; i += 3) {
          for (let j = 0; j < 3; j++) {
            const edge1 = indices.getX(i + j);
            const edge2 = indices.getX(i + (j + 1) % 3);
            edge[0] = Math.min(edge1, edge2); // sorting prevents duplicates

            edge[1] = Math.max(edge1, edge2);
            const key = edge[0] + ',' + edge[1];

            if (edges[key] === undefined) {
              edges[key] = {
                index1: edge[0],
                index2: edge[1]
              };
            }
          }
        }
      } // generate vertices


      for (const key in edges) {
        const e = edges[key];
        vertex.fromBufferAttribute(position, e.index1);
        vertices.push(vertex.x, vertex.y, vertex.z);
        vertex.fromBufferAttribute(position, e.index2);
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    } else {
      // non-indexed BufferGeometry
      const position = geometry.attributes.position;

      for (let i = 0, l = position.count / 3; i < l; i++) {
        for (let j = 0; j < 3; j++) {
          // three edges per triangle, an edge is represented as (index1, index2)
          // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
          const index1 = 3 * i + j;
          vertex.fromBufferAttribute(position, index1);
          vertices.push(vertex.x, vertex.y, vertex.z);
          const index2 = 3 * i + (j + 1) % 3;
          vertex.fromBufferAttribute(position, index2);
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      }
    }
  } // build geometry


  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
}

WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
WireframeGeometry.prototype.constructor = WireframeGeometry;
/**
 * @author zz85 / https://github.com/zz85
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */
// ParametricGeometry

function ParametricGeometry(func, slices, stacks) {
  Geometry.call(this);
  this.type = 'ParametricGeometry';
  this.parameters = {
    func: func,
    slices: slices,
    stacks: stacks
  };
  this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
  this.mergeVertices();
}

ParametricGeometry.prototype = Object.create(Geometry.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry; // ParametricBufferGeometry

function ParametricBufferGeometry(func, slices, stacks) {
  BufferGeometry.call(this);
  this.type = 'ParametricBufferGeometry';
  this.parameters = {
    func: func,
    slices: slices,
    stacks: stacks
  }; // buffers

  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  const EPS = 0.00001;
  const normal = new Vector3();
  const p0 = new Vector3(),
        p1 = new Vector3();
  const pu = new Vector3(),
        pv = new Vector3();

  if (func.length < 3) {
    console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
  } // generate vertices, normals and uvs


  const sliceCount = slices + 1;

  for (let i = 0; i <= stacks; i++) {
    const v = i / stacks;

    for (let j = 0; j <= slices; j++) {
      const u = j / slices; // vertex

      func(u, v, p0);
      vertices.push(p0.x, p0.y, p0.z); // normal
      // approximate tangent vectors via finite differences

      if (u - EPS >= 0) {
        func(u - EPS, v, p1);
        pu.subVectors(p0, p1);
      } else {
        func(u + EPS, v, p1);
        pu.subVectors(p1, p0);
      }

      if (v - EPS >= 0) {
        func(u, v - EPS, p1);
        pv.subVectors(p0, p1);
      } else {
        func(u, v + EPS, p1);
        pv.subVectors(p1, p0);
      } // cross product of tangent vectors returns surface normal


      normal.crossVectors(pu, pv).normalize();
      normals.push(normal.x, normal.y, normal.z); // uv

      uvs.push(u, v);
    }
  } // generate indices


  for (let i = 0; i < stacks; i++) {
    for (let j = 0; j < slices; j++) {
      const a = i * sliceCount + j;
      const b = i * sliceCount + j + 1;
      const c = (i + 1) * sliceCount + j + 1;
      const d = (i + 1) * sliceCount + j; // faces one and two

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */
// PolyhedronGeometry

function PolyhedronGeometry(vertices, indices, radius, detail) {
  Geometry.call(this);
  this.type = 'PolyhedronGeometry';
  this.parameters = {
    vertices: vertices,
    indices: indices,
    radius: radius,
    detail: detail
  };
  this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
  this.mergeVertices();
}

PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
PolyhedronGeometry.prototype.constructor = PolyhedronGeometry; // PolyhedronBufferGeometry

function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
  BufferGeometry.call(this);
  this.type = 'PolyhedronBufferGeometry';
  this.parameters = {
    vertices: vertices,
    indices: indices,
    radius: radius,
    detail: detail
  };
  radius = radius || 1;
  detail = detail || 0; // default buffer data

  const vertexBuffer = [];
  const uvBuffer = []; // the subdivision creates the vertex buffer data

  subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius

  applyRadius(radius); // finally, create the uv data

  generateUVs(); // build non-indexed geometry

  this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
  this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
  this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));

  if (detail === 0) {
    this.computeVertexNormals(); // flat normals
  } else {
    this.normalizeNormals(); // smooth normals
  } // helper functions


  function subdivide(detail) {
    const a = new Vector3();
    const b = new Vector3();
    const c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value

    for (let i = 0; i < indices.length; i += 3) {
      // get the vertices of the face
      getVertexByIndex(indices[i + 0], a);
      getVertexByIndex(indices[i + 1], b);
      getVertexByIndex(indices[i + 2], c); // perform subdivision

      subdivideFace(a, b, c, detail);
    }
  }

  function subdivideFace(a, b, c, detail) {
    const cols = Math.pow(2, detail); // we use this multidimensional array as a data structure for creating the subdivision

    const v = []; // construct all of the vertices for this subdivision

    for (let i = 0; i <= cols; i++) {
      v[i] = [];
      const aj = a.clone().lerp(c, i / cols);
      const bj = b.clone().lerp(c, i / cols);
      const rows = cols - i;

      for (let j = 0; j <= rows; j++) {
        if (j === 0 && i === cols) {
          v[i][j] = aj;
        } else {
          v[i][j] = aj.clone().lerp(bj, j / rows);
        }
      }
    } // construct all of the faces


    for (let i = 0; i < cols; i++) {
      for (let j = 0; j < 2 * (cols - i) - 1; j++) {
        const k = Math.floor(j / 2);

        if (j % 2 === 0) {
          pushVertex(v[i][k + 1]);
          pushVertex(v[i + 1][k]);
          pushVertex(v[i][k]);
        } else {
          pushVertex(v[i][k + 1]);
          pushVertex(v[i + 1][k + 1]);
          pushVertex(v[i + 1][k]);
        }
      }
    }
  }

  function applyRadius(radius) {
    const vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex

    for (let i = 0; i < vertexBuffer.length; i += 3) {
      vertex.x = vertexBuffer[i + 0];
      vertex.y = vertexBuffer[i + 1];
      vertex.z = vertexBuffer[i + 2];
      vertex.normalize().multiplyScalar(radius);
      vertexBuffer[i + 0] = vertex.x;
      vertexBuffer[i + 1] = vertex.y;
      vertexBuffer[i + 2] = vertex.z;
    }
  }

  function generateUVs() {
    const vertex = new Vector3();

    for (let i = 0; i < vertexBuffer.length; i += 3) {
      vertex.x = vertexBuffer[i + 0];
      vertex.y = vertexBuffer[i + 1];
      vertex.z = vertexBuffer[i + 2];
      const u = azimuth(vertex) / 2 / Math.PI + 0.5;
      const v = inclination(vertex) / Math.PI + 0.5;
      uvBuffer.push(u, 1 - v);
    }

    correctUVs();
    correctSeam();
  }

  function correctSeam() {
    // handle case when face straddles the seam, see #3269
    for (let i = 0; i < uvBuffer.length; i += 6) {
      // uv data of a single face
      const x0 = uvBuffer[i + 0];
      const x1 = uvBuffer[i + 2];
      const x2 = uvBuffer[i + 4];
      const max = Math.max(x0, x1, x2);
      const min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary

      if (max > 0.9 && min < 0.1) {
        if (x0 < 0.2) uvBuffer[i + 0] += 1;
        if (x1 < 0.2) uvBuffer[i + 2] += 1;
        if (x2 < 0.2) uvBuffer[i + 4] += 1;
      }
    }
  }

  function pushVertex(vertex) {
    vertexBuffer.push(vertex.x, vertex.y, vertex.z);
  }

  function getVertexByIndex(index, vertex) {
    const stride = index * 3;
    vertex.x = vertices[stride + 0];
    vertex.y = vertices[stride + 1];
    vertex.z = vertices[stride + 2];
  }

  function correctUVs() {
    const a = new Vector3();
    const b = new Vector3();
    const c = new Vector3();
    const centroid = new Vector3();
    const uvA = new Vector2();
    const uvB = new Vector2();
    const uvC = new Vector2();

    for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
      a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
      b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
      c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
      uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
      uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
      uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
      centroid.copy(a).add(b).add(c).divideScalar(3);
      const azi = azimuth(centroid);
      correctUV(uvA, j + 0, a, azi);
      correctUV(uvB, j + 2, b, azi);
      correctUV(uvC, j + 4, c, azi);
    }
  }

  function correctUV(uv, stride, vector, azimuth) {
    if (azimuth < 0 && uv.x === 1) {
      uvBuffer[stride] = uv.x - 1;
    }

    if (vector.x === 0 && vector.z === 0) {
      uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
    }
  } // Angle around the Y axis, counter-clockwise when looking from above.


  function azimuth(vector) {
    return Math.atan2(vector.z, -vector.x);
  } // Angle above the XZ plane.


  function inclination(vector) {
    return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
  }
}

PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */
// TetrahedronGeometry

function TetrahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = 'TetrahedronGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
  this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}

TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
TetrahedronGeometry.prototype.constructor = TetrahedronGeometry; // TetrahedronBufferGeometry

function TetrahedronBufferGeometry(radius, detail) {
  const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
  const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = 'TetrahedronBufferGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
}

TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */
// OctahedronGeometry

function OctahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = 'OctahedronGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
  this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}

OctahedronGeometry.prototype = Object.create(Geometry.prototype);
OctahedronGeometry.prototype.constructor = OctahedronGeometry; // OctahedronBufferGeometry

function OctahedronBufferGeometry(radius, detail) {
  const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
  const indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = 'OctahedronBufferGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
}

OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */
// IcosahedronGeometry

function IcosahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = 'IcosahedronGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
  this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}

IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
IcosahedronGeometry.prototype.constructor = IcosahedronGeometry; // IcosahedronBufferGeometry

function IcosahedronBufferGeometry(radius, detail) {
  const t = (1 + Math.sqrt(5)) / 2;
  const vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
  const indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = 'IcosahedronBufferGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
}

IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
/**
 * @author Abe Pazos / https://hamoid.com
 * @author Mugen87 / https://github.com/Mugen87
 */
// DodecahedronGeometry

function DodecahedronGeometry(radius, detail) {
  Geometry.call(this);
  this.type = 'DodecahedronGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
  this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
  this.mergeVertices();
}

DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
DodecahedronGeometry.prototype.constructor = DodecahedronGeometry; // DodecahedronBufferGeometry

function DodecahedronBufferGeometry(radius, detail) {
  const t = (1 + Math.sqrt(5)) / 2;
  const r = 1 / t;
  const vertices = [// (±1, ±1, ±1)
  -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, ±1/φ, ±φ)
  0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (±1/φ, ±φ, 0)
  -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (±φ, 0, ±1/φ)
  -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
  const indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
  this.type = 'DodecahedronBufferGeometry';
  this.parameters = {
    radius: radius,
    detail: detail
  };
}

DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
/**
 * @author oosmoxiecode / https://github.com/oosmoxiecode
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 * @author Mugen87 / https://github.com/Mugen87
 *
 */
// TubeGeometry

function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
  Geometry.call(this);
  this.type = 'TubeGeometry';
  this.parameters = {
    path: path,
    tubularSegments: tubularSegments,
    radius: radius,
    radialSegments: radialSegments,
    closed: closed
  };
  if (taper !== undefined) console.warn('THREE.TubeGeometry: taper has been removed.');
  const bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed); // expose internals

  this.tangents = bufferGeometry.tangents;
  this.normals = bufferGeometry.normals;
  this.binormals = bufferGeometry.binormals; // create geometry

  this.fromBufferGeometry(bufferGeometry);
  this.mergeVertices();
}

TubeGeometry.prototype = Object.create(Geometry.prototype);
TubeGeometry.prototype.constructor = TubeGeometry; // TubeBufferGeometry

function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
  BufferGeometry.call(this);
  this.type = 'TubeBufferGeometry';
  this.parameters = {
    path: path,
    tubularSegments: tubularSegments,
    radius: radius,
    radialSegments: radialSegments,
    closed: closed
  };
  tubularSegments = tubularSegments || 64;
  radius = radius || 1;
  radialSegments = radialSegments || 8;
  closed = closed || false;
  const frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals

  this.tangents = frames.tangents;
  this.normals = frames.normals;
  this.binormals = frames.binormals; // helper variables

  const vertex = new Vector3();
  const normal = new Vector3();
  const uv = new Vector2();
  let P = new Vector3(); // buffer

  const vertices = [];
  const normals = [];
  const uvs = [];
  const indices = []; // create buffer data

  generateBufferData(); // build geometry

  this.setIndex(indices);
  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // functions

  function generateBufferData() {
    for (let i = 0; i < tubularSegments; i++) {
      generateSegment(i);
    } // if the geometry is not closed, generate the last row of vertices and normals
    // at the regular position on the given path
    //
    // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)


    generateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.
    // this makes it easy compute correct values for closed geometries

    generateUVs(); // finally create faces

    generateIndices();
  }

  function generateSegment(i) {
    // we use getPointAt to sample evenly distributed points from the given path
    P = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal

    const N = frames.normals[i];
    const B = frames.binormals[i]; // generate normals and vertices for the current segment

    for (let j = 0; j <= radialSegments; j++) {
      const v = j / radialSegments * Math.PI * 2;
      const sin = Math.sin(v);
      const cos = -Math.cos(v); // normal

      normal.x = cos * N.x + sin * B.x;
      normal.y = cos * N.y + sin * B.y;
      normal.z = cos * N.z + sin * B.z;
      normal.normalize();
      normals.push(normal.x, normal.y, normal.z); // vertex

      vertex.x = P.x + radius * normal.x;
      vertex.y = P.y + radius * normal.y;
      vertex.z = P.z + radius * normal.z;
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
  }

  function generateIndices() {
    for (let j = 1; j <= tubularSegments; j++) {
      for (let i = 1; i <= radialSegments; i++) {
        const a = (radialSegments + 1) * (j - 1) + (i - 1);
        const b = (radialSegments + 1) * j + (i - 1);
        const c = (radialSegments + 1) * j + i;
        const d = (radialSegments + 1) * (j - 1) + i; // faces

        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
  }

  function generateUVs() {
    for (let i = 0; i <= tubularSegments; i++) {
      for (let j = 0; j <= radialSegments; j++) {
        uv.x = i / tubularSegments;
        uv.y = j / radialSegments;
        uvs.push(uv.x, uv.y);
      }
    }
  }
}

TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

TubeBufferGeometry.prototype.toJSON = function () {
  const data = BufferGeometry.prototype.toJSON.call(this);
  data.path = this.parameters.path.toJSON();
  return data;
};
/**
 * @author oosmoxiecode
 * @author Mugen87 / https://github.com/Mugen87
 *
 * based on http://www.blackpawn.com/texts/pqtorus/
 */
// TorusKnotGeometry


function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
  Geometry.call(this);
  this.type = 'TorusKnotGeometry';
  this.parameters = {
    radius: radius,
    tube: tube,
    tubularSegments: tubularSegments,
    radialSegments: radialSegments,
    p: p,
    q: q
  };
  if (heightScale !== undefined) console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');
  this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
  this.mergeVertices();
}

TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
TorusKnotGeometry.prototype.constructor = TorusKnotGeometry; // TorusKnotBufferGeometry

function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
  BufferGeometry.call(this);
  this.type = 'TorusKnotBufferGeometry';
  this.parameters = {
    radius: radius,
    tube: tube,
    tubularSegments: tubularSegments,
    radialSegments: radialSegments,
    p: p,
    q: q
  };
  radius = radius || 1;
  tube = tube || 0.4;
  tubularSegments = Math.floor(tubularSegments) || 64;
  radialSegments = Math.floor(radialSegments) || 8;
  p = p || 2;
  q = q || 3; // buffers

  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = []; // helper variables

  const vertex = new Vector3();
  const normal = new Vector3();
  const P1 = new Vector3();
  const P2 = new Vector3();
  const B = new Vector3();
  const T = new Vector3();
  const N = new Vector3(); // generate vertices, normals and uvs

  for (let i = 0; i <= tubularSegments; ++i) {
    // the radian "u" is used to calculate the position on the torus curve of the current tubular segement
    const u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
    // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

    calculatePositionOnCurve(u, p, q, radius, P1);
    calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis

    T.subVectors(P2, P1);
    N.addVectors(P2, P1);
    B.crossVectors(T, N);
    N.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it

    B.normalize();
    N.normalize();

    for (let j = 0; j <= radialSegments; ++j) {
      // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
      // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
      const v = j / radialSegments * Math.PI * 2;
      const cx = -tube * Math.cos(v);
      const cy = tube * Math.sin(v); // now calculate the final vertex position.
      // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

      vertex.x = P1.x + (cx * N.x + cy * B.x);
      vertex.y = P1.y + (cx * N.y + cy * B.y);
      vertex.z = P1.z + (cx * N.z + cy * B.z);
      vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

      normal.subVectors(vertex, P1).normalize();
      normals.push(normal.x, normal.y, normal.z); // uv

      uvs.push(i / tubularSegments);
      uvs.push(j / radialSegments);
    }
  } // generate indices


  for (let j = 1; j <= tubularSegments; j++) {
    for (let i = 1; i <= radialSegments; i++) {
      // indices
      const a = (radialSegments + 1) * (j - 1) + (i - 1);
      const b = (radialSegments + 1) * j + (i - 1);
      const c = (radialSegments + 1) * j + i;
      const d = (radialSegments + 1) * (j - 1) + i; // faces

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve

  function calculatePositionOnCurve(u, p, q, radius, position) {
    const cu = Math.cos(u);
    const su = Math.sin(u);
    const quOverP = q / p * u;
    const cs = Math.cos(quOverP);
    position.x = radius * (2 + cs) * 0.5 * cu;
    position.y = radius * (2 + cs) * su * 0.5;
    position.z = radius * Math.sin(quOverP) * 0.5;
  }
}

TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */
// TorusGeometry

function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
  Geometry.call(this);
  this.type = 'TorusGeometry';
  this.parameters = {
    radius: radius,
    tube: tube,
    radialSegments: radialSegments,
    tubularSegments: tubularSegments,
    arc: arc
  };
  this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
  this.mergeVertices();
}

TorusGeometry.prototype = Object.create(Geometry.prototype);
TorusGeometry.prototype.constructor = TorusGeometry; // TorusBufferGeometry

function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
  BufferGeometry.call(this);
  this.type = 'TorusBufferGeometry';
  this.parameters = {
    radius: radius,
    tube: tube,
    radialSegments: radialSegments,
    tubularSegments: tubularSegments,
    arc: arc
  };
  radius = radius || 1;
  tube = tube || 0.4;
  radialSegments = Math.floor(radialSegments) || 8;
  tubularSegments = Math.floor(tubularSegments) || 6;
  arc = arc || Math.PI * 2; // buffers

  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = []; // helper variables

  const center = new Vector3();
  const vertex = new Vector3();
  const normal = new Vector3(); // generate vertices, normals and uvs

  for (let j = 0; j <= radialSegments; j++) {
    for (let i = 0; i <= tubularSegments; i++) {
      const u = i / tubularSegments * arc;
      const v = j / radialSegments * Math.PI * 2; // vertex

      vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
      vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
      vertex.z = tube * Math.sin(v);
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      center.x = radius * Math.cos(u);
      center.y = radius * Math.sin(u);
      normal.subVectors(vertex, center).normalize();
      normals.push(normal.x, normal.y, normal.z); // uv

      uvs.push(i / tubularSegments);
      uvs.push(j / radialSegments);
    }
  } // generate indices


  for (let j = 1; j <= radialSegments; j++) {
    for (let i = 1; i <= tubularSegments; i++) {
      // indices
      const a = (tubularSegments + 1) * j + i - 1;
      const b = (tubularSegments + 1) * (j - 1) + i - 1;
      const c = (tubularSegments + 1) * (j - 1) + i;
      const d = (tubularSegments + 1) * j + i; // faces

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
/**
 * @author Mugen87 / https://github.com/Mugen87
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */

const Earcut = {
  triangulate: function (data, holeIndices, dim) {
    dim = dim || 2;
    let hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    let minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];

      for (let i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      } // minX, minY and invSize are later used to transform coords into integers for z-order calculation


      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  }
}; // create a circular doubly linked list from polygon points in the specified winding order

function linkedList(data, start, end, dim, clockwise) {
  let i, last;

  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
  }

  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }

  return last;
} // eliminate colinear or duplicate points


function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p = start,
      again;

  do {
    again = false;

    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);

  return end;
} // main ear slicing loop which triangulates a polygon (given as a linked list)


function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return; // interlink polygon nodes in z-order

  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear,
      prev,
      next; // iterate through ears, slicing them one by one

  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;

    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      // cut off the triangle
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear); // skipping the next vertex leads to less sliver triangles

      ear = next.next;
      stop = next.next;
      continue;
    }

    ear = next; // if we looped through the whole remaining polygon and can't find any more ears

    if (ear === stop) {
      // try filtering points and slicing again
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }

      break;
    }
  }
} // check whether a polygon node forms a valid ear with adjacent nodes


function isEar(ear) {
  let a = ear.prev,
      b = ear,
      c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
  // now make sure we don't have other points inside the potential ear

  let p = ear.next.next;

  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }

  return true;
}

function isEarHashed(ear, minX, minY, invSize) {
  let a = ear.prev,
      b = ear,
      c = ear.next;
  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
  // triangle bbox; min & max are calculated like this for speed

  let minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
      minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
      maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
      maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;

  let minZ = zOrder(minTX, minTY, minX, minY, invSize),
      maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p = ear.prevZ,
      n = ear.nextZ; // look for points inside the triangle in both directions

  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  } // look for remaining points in decreasing z-order


  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  } // look for remaining points in increasing z-order


  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }

  return true;
} // go through all polygon nodes and cure small local self-intersections


function cureLocalIntersections(start, triangles, dim) {
  let p = start;

  do {
    let a = p.prev,
        b = p.next.next;

    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim); // remove two nodes involved

      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }

    p = p.next;
  } while (p !== start);

  return filterPoints(p);
} // try splitting polygon into two and triangulate them independently


function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  // look for a valid diagonal that divides the polygon into two
  let a = start;

  do {
    let b = a.next.next;

    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        // split the polygon in two by the diagonal
        let c = splitPolygon(a, b); // filter colinear points around the cuts

        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next); // run earcut on each half

        earcutLinked(a, triangles, dim, minX, minY, invSize);
        earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }

      b = b.next;
    }

    a = a.next;
  } while (a !== start);
} // link every hole into the outer loop, producing a single-ring polygon without holes


function eliminateHoles(data, holeIndices, outerNode, dim) {
  let queue = [],
      i,
      len,
      start,
      end,
      list;

  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }

  queue.sort(compareX); // process holes from left to right

  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }

  return outerNode;
}

function compareX(a, b) {
  return a.x - b.x;
} // find a bridge between vertices that connects hole with an outer ring and and link it


function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);

  if (outerNode) {
    const b = splitPolygon(outerNode, hole); // filter collinear points around the cuts

    filterPoints(outerNode, outerNode.next);
    filterPoints(b, b.next);
  }
} // David Eberly's algorithm for finding a bridge between hole and outer polygon


function findHoleBridge(hole, outerNode) {
  let p = outerNode,
      hx = hole.x,
      hy = hole.y,
      qx = -Infinity,
      m; // find a segment intersected by a ray from the hole's leftmost point to the left;
  // segment's endpoint with lesser x will be potential connection point

  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      let x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

      if (x <= hx && x > qx) {
        qx = x;

        if (x === hx) {
          if (hy === p.y) return p;
          if (hy === p.next.y) return p.next;
        }

        m = p.x < p.next.x ? p : p.next;
      }
    }

    p = p.next;
  } while (p !== outerNode);

  if (!m) return null;
  if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
  // look for points inside the triangle of hole point, segment intersection and endpoint;
  // if there are no points found, we have a valid connection;
  // otherwise choose the point of the minimum angle with the ray as connection point

  let stop = m,
      mx = m.x,
      my = m.y,
      tanMin = Infinity,
      tan;
  p = m;

  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }

    p = p.next;
  } while (p !== stop);

  return m;
} // whether sector in vertex m contains sector in vertex p in the same coordinates


function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
} // interlink polygon nodes in z-order


function indexCurve(start, minX, minY, invSize) {
  let p = start;

  do {
    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);

  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
} // Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


function sortLinked(list) {
  let i,
      p,
      q,
      e,
      tail,
      numMerges,
      pSize,
      qSize,
      inSize = 1;

  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;

    while (p) {
      numMerges++;
      q = p;
      pSize = 0;

      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }

      qSize = inSize;

      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }

        if (tail) tail.nextZ = e;else list = e;
        e.prevZ = tail;
        tail = e;
      }

      p = q;
    }

    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);

  return list;
} // z-order of a point given coords and inverse of the longer side of data bbox


function zOrder(x, y, minX, minY, invSize) {
  // coords are transformed into non-negative 15-bit integer range
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | x << 8) & 0x00FF00FF;
  x = (x | x << 4) & 0x0F0F0F0F;
  x = (x | x << 2) & 0x33333333;
  x = (x | x << 1) & 0x55555555;
  y = (y | y << 8) & 0x00FF00FF;
  y = (y | y << 4) & 0x0F0F0F0F;
  y = (y | y << 2) & 0x33333333;
  y = (y | y << 1) & 0x55555555;
  return x | y << 1;
} // find the leftmost node of a polygon ring


function getLeftmost(start) {
  let p = start,
      leftmost = start;

  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);

  return leftmost;
} // check if a point lies within a convex triangle


function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges
  locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible
  area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
} // signed area of a triangle


function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
} // check if two points are equal


function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
} // check if two segments intersect


function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true; // general case

  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1

  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1

  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2

  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

  return false;
} // for collinear points p, q, r, check if point q lies on segment pr


function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
} // check if a polygon diagonal intersects any polygon segments


function intersectsPolygon(a, b) {
  let p = a;

  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);

  return false;
} // check if a polygon diagonal is locally inside the polygon


function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
} // check if the middle point of a polygon diagonal is inside the polygon


function middleInside(a, b) {
  let p = a,
      inside = false,
      px = (a.x + b.x) / 2,
      py = (a.y + b.y) / 2;

  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
    p = p.next;
  } while (p !== a);

  return inside;
} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring


function splitPolygon(a, b) {
  let a2 = new Node(a.i, a.x, a.y),
      b2 = new Node(b.i, b.x, b.y),
      an = a.next,
      bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
} // create a node and optionally link it with previous one (in a circular doubly linked list)


function insertNode(i, x, y, last) {
  const p = new Node(i, x, y);

  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }

  return p;
}

function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
  // vertex index in coordinates array
  this.i = i; // vertex coordinates

  this.x = x;
  this.y = y; // previous and next vertex nodes in a polygon ring

  this.prev = null;
  this.next = null; // z-order curve value

  this.z = null; // previous and next nodes in z-order

  this.prevZ = null;
  this.nextZ = null; // indicates whether this is a steiner point

  this.steiner = false;
}

function signedArea(data, start, end, dim) {
  let sum = 0;

  for (let i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }

  return sum;
}
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */


const ShapeUtils = {
  // calculate area of the contour polygon
  area: function (contour) {
    const n = contour.length;
    let a = 0.0;

    for (let p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }

    return a * 0.5;
  },
  isClockWise: function (pts) {
    return ShapeUtils.area(pts) < 0;
  },
  triangulateShape: function (contour, holes) {
    const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]

    const holeIndices = []; // array of hole indices

    const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

    removeDupEndPts(contour);
    addContour(vertices, contour); //

    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);

    for (let i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    } //


    const triangles = Earcut.triangulate(vertices, holeIndices); //

    for (let i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }

    return faces;
  }
};
exports.ShapeUtils = ShapeUtils;

function removeDupEndPts(points) {
  const l = points.length;

  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}

function addContour(vertices, contour) {
  for (let i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */
// ExtrudeGeometry


function ExtrudeGeometry(shapes, options) {
  Geometry.call(this);
  this.type = 'ExtrudeGeometry';
  this.parameters = {
    shapes: shapes,
    options: options
  };
  this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
  this.mergeVertices();
}

ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

ExtrudeGeometry.prototype.toJSON = function () {
  const data = Geometry.prototype.toJSON.call(this);
  const shapes = this.parameters.shapes;
  const options = this.parameters.options;
  return toJSON(shapes, options, data);
}; // ExtrudeBufferGeometry


function ExtrudeBufferGeometry(shapes, options) {
  BufferGeometry.call(this);
  this.type = 'ExtrudeBufferGeometry';
  this.parameters = {
    shapes: shapes,
    options: options
  };
  shapes = Array.isArray(shapes) ? shapes : [shapes];
  const scope = this;
  const verticesArray = [];
  const uvArray = [];

  for (let i = 0, l = shapes.length; i < l; i++) {
    const shape = shapes[i];
    addShape(shape);
  } // build geometry


  this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
  this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
  this.computeVertexNormals(); // functions

  function addShape(shape) {
    const placeholder = []; // options

    const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
    const steps = options.steps !== undefined ? options.steps : 1;
    let depth = options.depth !== undefined ? options.depth : 100;
    let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
    let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
    let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
    let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
    let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
    const extrudePath = options.extrudePath;
    const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options

    if (options.amount !== undefined) {
      console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
      depth = options.amount;
    } //


    let extrudePts,
        extrudeByPath = false;
    let splineTube, binormal, normal, position2;

    if (extrudePath) {
      extrudePts = extrudePath.getSpacedPoints(steps);
      extrudeByPath = true;
      bevelEnabled = false; // bevels not supported for path extrusion
      // SETUP TNB variables
      // TODO1 - have a .isClosed in spline?

      splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

      binormal = new Vector3();
      normal = new Vector3();
      position2 = new Vector3();
    } // Safeguards if bevels are not enabled


    if (!bevelEnabled) {
      bevelSegments = 0;
      bevelThickness = 0;
      bevelSize = 0;
      bevelOffset = 0;
    } // Variables initialization


    const shapePoints = shape.extractPoints(curveSegments);
    let vertices = shapePoints.shape;
    const holes = shapePoints.holes;
    const reverse = !ShapeUtils.isClockWise(vertices);

    if (reverse) {
      vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...

      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];

        if (ShapeUtils.isClockWise(ahole)) {
          holes[h] = ahole.reverse();
        }
      }
    }

    const faces = ShapeUtils.triangulateShape(vertices, holes);
    /* Vertices */

    const contour = vertices; // vertices has all points but contour has only points of circumference

    for (let h = 0, hl = holes.length; h < hl; h++) {
      const ahole = holes[h];
      vertices = vertices.concat(ahole);
    }

    function scalePt2(pt, vec, size) {
      if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
      return vec.clone().multiplyScalar(size).add(pt);
    }

    const vlen = vertices.length,
          flen = faces.length; // Find directions for point movement

    function getBevelVec(inPt, inPrev, inNext) {
      // computes for inPt the corresponding point inPt' on a new contour
      //   shifted by 1 unit (length of normalized vector) to the left
      // if we walk along contour clockwise, this new contour is outside the old one
      //
      // inPt' is the intersection of the two lines parallel to the two
      //  adjacent edges of inPt at a distance of 1 unit on the left side.
      let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
      // good reading for geometry algorithms (here: line-line intersection)
      // http://geomalgorithms.com/a05-_intersect-1.html

      const v_prev_x = inPt.x - inPrev.x,
            v_prev_y = inPt.y - inPrev.y;
      const v_next_x = inNext.x - inPt.x,
            v_next_y = inNext.y - inPt.y;
      const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges

      const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;

      if (Math.abs(collinear0) > Number.EPSILON) {
        // not collinear
        // length of vectors for normalizing
        const v_prev_len = Math.sqrt(v_prev_lensq);
        const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left

        const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
        const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
        const ptNextShift_x = inNext.x - v_next_y / v_next_len;
        const ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point

        const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point

        v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
        v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly
        //  but prevent crazy spikes

        const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;

        if (v_trans_lensq <= 2) {
          return new Vector2(v_trans_x, v_trans_y);
        } else {
          shrink_by = Math.sqrt(v_trans_lensq / 2);
        }
      } else {
        // handle special case of collinear edges
        let direction_eq = false; // assumes: opposite

        if (v_prev_x > Number.EPSILON) {
          if (v_next_x > Number.EPSILON) {
            direction_eq = true;
          }
        } else {
          if (v_prev_x < -Number.EPSILON) {
            if (v_next_x < -Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
              direction_eq = true;
            }
          }
        }

        if (direction_eq) {
          // console.log("Warning: lines are a straight sequence");
          v_trans_x = -v_prev_y;
          v_trans_y = v_prev_x;
          shrink_by = Math.sqrt(v_prev_lensq);
        } else {
          // console.log("Warning: lines are a straight spike");
          v_trans_x = v_prev_x;
          v_trans_y = v_prev_y;
          shrink_by = Math.sqrt(v_prev_lensq / 2);
        }
      }

      return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
    }

    const contourMovements = [];

    for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
      if (j === il) j = 0;
      if (k === il) k = 0; //  (j)---(i)---(k)
      // console.log('i,j,k', i, j , k)

      contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
    }

    const holesMovements = [];
    let oneHoleMovements,
        verticesMovements = contourMovements.concat();

    for (let h = 0, hl = holes.length; h < hl; h++) {
      const ahole = holes[h];
      oneHoleMovements = [];

      for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il) j = 0;
        if (k === il) k = 0; //  (j)---(i)---(k)

        oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
      }

      holesMovements.push(oneHoleMovements);
      verticesMovements = verticesMovements.concat(oneHoleMovements);
    } // Loop bevelSegments, 1 for the front, 1 for the back


    for (let b = 0; b < bevelSegments; b++) {
      //for ( b = bevelSegments; b > 0; b -- ) {
      const t = b / bevelSegments;
      const z = bevelThickness * Math.cos(t * Math.PI / 2);
      const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

      for (let i = 0, il = contour.length; i < il; i++) {
        const vert = scalePt2(contour[i], contourMovements[i], bs);
        v(vert.x, vert.y, -z);
      } // expand holes


      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        oneHoleMovements = holesMovements[h];

        for (let i = 0, il = ahole.length; i < il; i++) {
          const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
          v(vert.x, vert.y, -z);
        }
      }
    }

    const bs = bevelSize + bevelOffset; // Back facing vertices

    for (let i = 0; i < vlen; i++) {
      const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

      if (!extrudeByPath) {
        v(vert.x, vert.y, 0);
      } else {
        // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
        normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
        binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
        position2.copy(extrudePts[0]).add(normal).add(binormal);
        v(position2.x, position2.y, position2.z);
      }
    } // Add stepped vertices...
    // Including front facing vertices


    for (let s = 1; s <= steps; s++) {
      for (let i = 0; i < vlen; i++) {
        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

        if (!extrudeByPath) {
          v(vert.x, vert.y, depth / steps * s);
        } else {
          // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
          normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
          position2.copy(extrudePts[s]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
    } // Add bevel segments planes
    //for ( b = 1; b <= bevelSegments; b ++ ) {


    for (let b = bevelSegments - 1; b >= 0; b--) {
      const t = b / bevelSegments;
      const z = bevelThickness * Math.cos(t * Math.PI / 2);
      const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

      for (let i = 0, il = contour.length; i < il; i++) {
        const vert = scalePt2(contour[i], contourMovements[i], bs);
        v(vert.x, vert.y, depth + z);
      } // expand holes


      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        oneHoleMovements = holesMovements[h];

        for (let i = 0, il = ahole.length; i < il; i++) {
          const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

          if (!extrudeByPath) {
            v(vert.x, vert.y, depth + z);
          } else {
            v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
          }
        }
      }
    }
    /* Faces */
    // Top and bottom faces


    buildLidFaces(); // Sides faces

    buildSideFaces(); /////  Internal functions

    function buildLidFaces() {
      const start = verticesArray.length / 3;

      if (bevelEnabled) {
        let layer = 0; // steps + 1

        let offset = vlen * layer; // Bottom faces

        for (let i = 0; i < flen; i++) {
          const face = faces[i];
          f3(face[2] + offset, face[1] + offset, face[0] + offset);
        }

        layer = steps + bevelSegments * 2;
        offset = vlen * layer; // Top faces

        for (let i = 0; i < flen; i++) {
          const face = faces[i];
          f3(face[0] + offset, face[1] + offset, face[2] + offset);
        }
      } else {
        // Bottom faces
        for (let i = 0; i < flen; i++) {
          const face = faces[i];
          f3(face[2], face[1], face[0]);
        } // Top faces


        for (let i = 0; i < flen; i++) {
          const face = faces[i];
          f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
        }
      }

      scope.addGroup(start, verticesArray.length / 3 - start, 0);
    } // Create faces for the z-sides of the shape


    function buildSideFaces() {
      const start = verticesArray.length / 3;
      let layeroffset = 0;
      sidewalls(contour, layeroffset);
      layeroffset += contour.length;

      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        sidewalls(ahole, layeroffset); //, true

        layeroffset += ahole.length;
      }

      scope.addGroup(start, verticesArray.length / 3 - start, 1);
    }

    function sidewalls(contour, layeroffset) {
      let i = contour.length;

      while (--i >= 0) {
        const j = i;
        let k = i - 1;
        if (k < 0) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);

        for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
          const slen1 = vlen * s;
          const slen2 = vlen * (s + 1);
          const a = layeroffset + j + slen1,
                b = layeroffset + k + slen1,
                c = layeroffset + k + slen2,
                d = layeroffset + j + slen2;
          f4(a, b, c, d);
        }
      }
    }

    function v(x, y, z) {
      placeholder.push(x);
      placeholder.push(y);
      placeholder.push(z);
    }

    function f3(a, b, c) {
      addVertex(a);
      addVertex(b);
      addVertex(c);
      const nextIndex = verticesArray.length / 3;
      const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
      addUV(uvs[0]);
      addUV(uvs[1]);
      addUV(uvs[2]);
    }

    function f4(a, b, c, d) {
      addVertex(a);
      addVertex(b);
      addVertex(d);
      addVertex(b);
      addVertex(c);
      addVertex(d);
      const nextIndex = verticesArray.length / 3;
      const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
      addUV(uvs[0]);
      addUV(uvs[1]);
      addUV(uvs[3]);
      addUV(uvs[1]);
      addUV(uvs[2]);
      addUV(uvs[3]);
    }

    function addVertex(index) {
      verticesArray.push(placeholder[index * 3 + 0]);
      verticesArray.push(placeholder[index * 3 + 1]);
      verticesArray.push(placeholder[index * 3 + 2]);
    }

    function addUV(vector2) {
      uvArray.push(vector2.x);
      uvArray.push(vector2.y);
    }
  }
}

ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

ExtrudeBufferGeometry.prototype.toJSON = function () {
  const data = BufferGeometry.prototype.toJSON.call(this);
  const shapes = this.parameters.shapes;
  const options = this.parameters.options;
  return toJSON(shapes, options, data);
}; //


const WorldUVGenerator = {
  generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
  },
  generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];

    if (Math.abs(a_y - b_y) < 0.01) {
      return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
    } else {
      return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
    }
  }
};

function toJSON(shapes, options, data) {
  //
  data.shapes = [];

  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  } //


  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */
// TextGeometry


function TextGeometry(text, parameters) {
  Geometry.call(this);
  this.type = 'TextGeometry';
  this.parameters = {
    text: text,
    parameters: parameters
  };
  this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
  this.mergeVertices();
}

TextGeometry.prototype = Object.create(Geometry.prototype);
TextGeometry.prototype.constructor = TextGeometry; // TextBufferGeometry

function TextBufferGeometry(text, parameters) {
  parameters = parameters || {};
  const font = parameters.font;

  if (!(font && font.isFont)) {
    console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
    return new Geometry();
  }

  const shapes = font.generateShapes(text, parameters.size); // translate parameters to ExtrudeGeometry API

  parameters.depth = parameters.height !== undefined ? parameters.height : 50; // defaults

  if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
  if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
  if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
  ExtrudeBufferGeometry.call(this, shapes, parameters);
  this.type = 'TextBufferGeometry';
}

TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
TextBufferGeometry.prototype.constructor = TextBufferGeometry;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 */
// SphereGeometry

function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = 'SphereGeometry';
  this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
  this.mergeVertices();
}

SphereGeometry.prototype = Object.create(Geometry.prototype);
SphereGeometry.prototype.constructor = SphereGeometry; // SphereBufferGeometry

function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = 'SphereBufferGeometry';
  this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  radius = radius || 1;
  widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
  heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
  phiStart = phiStart !== undefined ? phiStart : 0;
  phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
  const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
  let index = 0;
  const grid = [];
  const vertex = new Vector3();
  const normal = new Vector3(); // buffers

  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = []; // generate vertices, normals and uvs

  for (let iy = 0; iy <= heightSegments; iy++) {
    const verticesRow = [];
    const v = iy / heightSegments; // special case for the poles

    let uOffset = 0;

    if (iy == 0 && thetaStart == 0) {
      uOffset = 0.5 / widthSegments;
    } else if (iy == heightSegments && thetaEnd == Math.PI) {
      uOffset = -0.5 / widthSegments;
    }

    for (let ix = 0; ix <= widthSegments; ix++) {
      const u = ix / widthSegments; // vertex

      vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
      vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
      vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      normal.copy(vertex).normalize();
      normals.push(normal.x, normal.y, normal.z); // uv

      uvs.push(u + uOffset, 1 - v);
      verticesRow.push(index++);
    }

    grid.push(verticesRow);
  } // indices


  for (let iy = 0; iy < heightSegments; iy++) {
    for (let ix = 0; ix < widthSegments; ix++) {
      const a = grid[iy][ix + 1];
      const b = grid[iy][ix];
      const c = grid[iy + 1][ix];
      const d = grid[iy + 1][ix + 1];
      if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
      if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
/**
 * @author Kaleb Murphy
 * @author Mugen87 / https://github.com/Mugen87
 */
// RingGeometry

function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = 'RingGeometry';
  this.parameters = {
    innerRadius: innerRadius,
    outerRadius: outerRadius,
    thetaSegments: thetaSegments,
    phiSegments: phiSegments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
  this.mergeVertices();
}

RingGeometry.prototype = Object.create(Geometry.prototype);
RingGeometry.prototype.constructor = RingGeometry; // RingBufferGeometry

function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = 'RingBufferGeometry';
  this.parameters = {
    innerRadius: innerRadius,
    outerRadius: outerRadius,
    thetaSegments: thetaSegments,
    phiSegments: phiSegments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  innerRadius = innerRadius || 0.5;
  outerRadius = outerRadius || 1;
  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
  thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
  phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1; // buffers

  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = []; // some helper variables

  let radius = innerRadius;
  const radiusStep = (outerRadius - innerRadius) / phiSegments;
  const vertex = new Vector3();
  const uv = new Vector2(); // generate vertices, normals and uvs

  for (let j = 0; j <= phiSegments; j++) {
    for (let i = 0; i <= thetaSegments; i++) {
      // values are generate from the inside of the ring to the outside
      const segment = thetaStart + i / thetaSegments * thetaLength; // vertex

      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      normals.push(0, 0, 1); // uv

      uv.x = (vertex.x / outerRadius + 1) / 2;
      uv.y = (vertex.y / outerRadius + 1) / 2;
      uvs.push(uv.x, uv.y);
    } // increase the radius for next row of vertices


    radius += radiusStep;
  } // indices


  for (let j = 0; j < phiSegments; j++) {
    const thetaSegmentLevel = j * (thetaSegments + 1);

    for (let i = 0; i < thetaSegments; i++) {
      const segment = i + thetaSegmentLevel;
      const a = segment;
      const b = segment + thetaSegments + 1;
      const c = segment + thetaSegments + 2;
      const d = segment + 1; // faces

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
RingBufferGeometry.prototype.constructor = RingBufferGeometry;
/**
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 * @author Mugen87 / https://github.com/Mugen87
 */
// LatheGeometry

function LatheGeometry(points, segments, phiStart, phiLength) {
  Geometry.call(this);
  this.type = 'LatheGeometry';
  this.parameters = {
    points: points,
    segments: segments,
    phiStart: phiStart,
    phiLength: phiLength
  };
  this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
  this.mergeVertices();
}

LatheGeometry.prototype = Object.create(Geometry.prototype);
LatheGeometry.prototype.constructor = LatheGeometry; // LatheBufferGeometry

function LatheBufferGeometry(points, segments, phiStart, phiLength) {
  BufferGeometry.call(this);
  this.type = 'LatheBufferGeometry';
  this.parameters = {
    points: points,
    segments: segments,
    phiStart: phiStart,
    phiLength: phiLength
  };
  segments = Math.floor(segments) || 12;
  phiStart = phiStart || 0;
  phiLength = phiLength || Math.PI * 2; // clamp phiLength so it's in range of [ 0, 2PI ]

  phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2); // buffers

  const indices = [];
  const vertices = [];
  const uvs = []; // helper variables

  const inverseSegments = 1.0 / segments;
  const vertex = new Vector3();
  const uv = new Vector2(); // generate vertices and uvs

  for (let i = 0; i <= segments; i++) {
    const phi = phiStart + i * inverseSegments * phiLength;
    const sin = Math.sin(phi);
    const cos = Math.cos(phi);

    for (let j = 0; j <= points.length - 1; j++) {
      // vertex
      vertex.x = points[j].x * sin;
      vertex.y = points[j].y;
      vertex.z = points[j].x * cos;
      vertices.push(vertex.x, vertex.y, vertex.z); // uv

      uv.x = i / segments;
      uv.y = j / (points.length - 1);
      uvs.push(uv.x, uv.y);
    }
  } // indices


  for (let i = 0; i < segments; i++) {
    for (let j = 0; j < points.length - 1; j++) {
      const base = j + i * points.length;
      const a = base;
      const b = base + points.length;
      const c = base + points.length + 1;
      const d = base + 1; // faces

      indices.push(a, b, d);
      indices.push(b, c, d);
    }
  } // build geometry


  this.setIndex(indices);
  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals

  this.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.
  // because the corresponding vertices are identical (but still have different UVs).

  if (phiLength === Math.PI * 2) {
    const normals = this.attributes.normal.array;
    const n1 = new Vector3();
    const n2 = new Vector3();
    const n = new Vector3(); // this is the buffer offset for the last line of vertices

    const base = segments * points.length * 3;

    for (let i = 0, j = 0; i < points.length; i++, j += 3) {
      // select the normal of the vertex in the first line
      n1.x = normals[j + 0];
      n1.y = normals[j + 1];
      n1.z = normals[j + 2]; // select the normal of the vertex in the last line

      n2.x = normals[base + j + 0];
      n2.y = normals[base + j + 1];
      n2.z = normals[base + j + 2]; // average normals

      n.addVectors(n1, n2).normalize(); // assign the new values to both normals

      normals[j + 0] = normals[base + j + 0] = n.x;
      normals[j + 1] = normals[base + j + 1] = n.y;
      normals[j + 2] = normals[base + j + 2] = n.z;
    }
  }
}

LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
/**
 * @author jonobr1 / http://jonobr1.com
 * @author Mugen87 / https://github.com/Mugen87
 */
// ShapeGeometry

function ShapeGeometry(shapes, curveSegments) {
  Geometry.call(this);
  this.type = 'ShapeGeometry';

  if (typeof curveSegments === 'object') {
    console.warn('THREE.ShapeGeometry: Options parameter has been removed.');
    curveSegments = curveSegments.curveSegments;
  }

  this.parameters = {
    shapes: shapes,
    curveSegments: curveSegments
  };
  this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
  this.mergeVertices();
}

ShapeGeometry.prototype = Object.create(Geometry.prototype);
ShapeGeometry.prototype.constructor = ShapeGeometry;

ShapeGeometry.prototype.toJSON = function () {
  const data = Geometry.prototype.toJSON.call(this);
  const shapes = this.parameters.shapes;
  return toJSON$1(shapes, data);
}; // ShapeBufferGeometry


function ShapeBufferGeometry(shapes, curveSegments) {
  BufferGeometry.call(this);
  this.type = 'ShapeBufferGeometry';
  this.parameters = {
    shapes: shapes,
    curveSegments: curveSegments
  };
  curveSegments = curveSegments || 12; // buffers

  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = []; // helper variables

  let groupStart = 0;
  let groupCount = 0; // allow single and array values for "shapes" parameter

  if (Array.isArray(shapes) === false) {
    addShape(shapes);
  } else {
    for (let i = 0; i < shapes.length; i++) {
      addShape(shapes[i]);
      this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

      groupStart += groupCount;
      groupCount = 0;
    }
  } // build geometry


  this.setIndex(indices);
  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions

  function addShape(shape) {
    const indexOffset = vertices.length / 3;
    const points = shape.extractPoints(curveSegments);
    let shapeVertices = points.shape;
    const shapeHoles = points.holes; // check direction of vertices

    if (ShapeUtils.isClockWise(shapeVertices) === false) {
      shapeVertices = shapeVertices.reverse();
    }

    for (let i = 0, l = shapeHoles.length; i < l; i++) {
      const shapeHole = shapeHoles[i];

      if (ShapeUtils.isClockWise(shapeHole) === true) {
        shapeHoles[i] = shapeHole.reverse();
      }
    }

    const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array

    for (let i = 0, l = shapeHoles.length; i < l; i++) {
      const shapeHole = shapeHoles[i];
      shapeVertices = shapeVertices.concat(shapeHole);
    } // vertices, normals, uvs


    for (let i = 0, l = shapeVertices.length; i < l; i++) {
      const vertex = shapeVertices[i];
      vertices.push(vertex.x, vertex.y, 0);
      normals.push(0, 0, 1);
      uvs.push(vertex.x, vertex.y); // world uvs
    } // incides


    for (let i = 0, l = faces.length; i < l; i++) {
      const face = faces[i];
      const a = face[0] + indexOffset;
      const b = face[1] + indexOffset;
      const c = face[2] + indexOffset;
      indices.push(a, b, c);
      groupCount += 3;
    }
  }
}

ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

ShapeBufferGeometry.prototype.toJSON = function () {
  const data = BufferGeometry.prototype.toJSON.call(this);
  const shapes = this.parameters.shapes;
  return toJSON$1(shapes, data);
}; //


function toJSON$1(shapes, data) {
  data.shapes = [];

  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }

  return data;
}
/**
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */


function EdgesGeometry(geometry, thresholdAngle) {
  BufferGeometry.call(this);
  this.type = 'EdgesGeometry';
  this.parameters = {
    thresholdAngle: thresholdAngle
  };
  thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1; // buffer

  const vertices = []; // helper variables

  const thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
  const edge = [0, 0],
        edges = {};
  let edge1, edge2, key;
  const keys = ['a', 'b', 'c']; // prepare source geometry

  let geometry2;

  if (geometry.isBufferGeometry) {
    geometry2 = new Geometry();
    geometry2.fromBufferGeometry(geometry);
  } else {
    geometry2 = geometry.clone();
  }

  geometry2.mergeVertices();
  geometry2.computeFaceNormals();
  const sourceVertices = geometry2.vertices;
  const faces = geometry2.faces; // now create a data structure where each entry represents an edge with its adjoining faces

  for (let i = 0, l = faces.length; i < l; i++) {
    const face = faces[i];

    for (let j = 0; j < 3; j++) {
      edge1 = face[keys[j]];
      edge2 = face[keys[(j + 1) % 3]];
      edge[0] = Math.min(edge1, edge2);
      edge[1] = Math.max(edge1, edge2);
      key = edge[0] + ',' + edge[1];

      if (edges[key] === undefined) {
        edges[key] = {
          index1: edge[0],
          index2: edge[1],
          face1: i,
          face2: undefined
        };
      } else {
        edges[key].face2 = i;
      }
    }
  } // generate vertices


  for (key in edges) {
    const e = edges[key]; // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

    if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
      let vertex = sourceVertices[e.index1];
      vertices.push(vertex.x, vertex.y, vertex.z);
      vertex = sourceVertices[e.index2];
      vertices.push(vertex.x, vertex.y, vertex.z);
    }
  } // build geometry


  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
}

EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
EdgesGeometry.prototype.constructor = EdgesGeometry;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */
// CylinderGeometry

function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = 'CylinderGeometry';
  this.parameters = {
    radiusTop: radiusTop,
    radiusBottom: radiusBottom,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
  this.mergeVertices();
}

CylinderGeometry.prototype = Object.create(Geometry.prototype);
CylinderGeometry.prototype.constructor = CylinderGeometry; // CylinderBufferGeometry

function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = 'CylinderBufferGeometry';
  this.parameters = {
    radiusTop: radiusTop,
    radiusBottom: radiusBottom,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  const scope = this;
  radiusTop = radiusTop !== undefined ? radiusTop : 1;
  radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
  height = height || 1;
  radialSegments = Math.floor(radialSegments) || 8;
  heightSegments = Math.floor(heightSegments) || 1;
  openEnded = openEnded !== undefined ? openEnded : false;
  thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2; // buffers

  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = []; // helper variables

  let index = 0;
  const indexArray = [];
  const halfHeight = height / 2;
  let groupStart = 0; // generate geometry

  generateTorso();

  if (openEnded === false) {
    if (radiusTop > 0) generateCap(true);
    if (radiusBottom > 0) generateCap(false);
  } // build geometry


  this.setIndex(indices);
  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

  function generateTorso() {
    const normal = new Vector3();
    const vertex = new Vector3();
    let groupCount = 0; // this will be used to calculate the normal

    const slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs

    for (let y = 0; y <= heightSegments; y++) {
      const indexRow = [];
      const v = y / heightSegments; // calculate the radius of the current row

      const radius = v * (radiusBottom - radiusTop) + radiusTop;

      for (let x = 0; x <= radialSegments; x++) {
        const u = x / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta); // vertex

        vertex.x = radius * sinTheta;
        vertex.y = -v * height + halfHeight;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z); // normal

        normal.set(sinTheta, slope, cosTheta).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(u, 1 - v); // save index of vertex in respective row

        indexRow.push(index++);
      } // now save vertices of the row in our index array


      indexArray.push(indexRow);
    } // generate indices


    for (let x = 0; x < radialSegments; x++) {
      for (let y = 0; y < heightSegments; y++) {
        // we use the index array to access the correct indices
        const a = indexArray[y][x];
        const b = indexArray[y + 1][x];
        const c = indexArray[y + 1][x + 1];
        const d = indexArray[y][x + 1]; // faces

        indices.push(a, b, d);
        indices.push(b, c, d); // update group counter

        groupCount += 6;
      }
    } // add a group to the geometry. this will ensure multi material support


    scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups

    groupStart += groupCount;
  }

  function generateCap(top) {
    let centerIndexStart, centerIndexEnd;
    const uv = new Vector2();
    const vertex = new Vector3();
    let groupCount = 0;
    const radius = top === true ? radiusTop : radiusBottom;
    const sign = top === true ? 1 : -1; // save the index of the first center vertex

    centerIndexStart = index; // first we generate the center vertex data of the cap.
    // because the geometry needs one set of uvs per face,
    // we must generate a center vertex per face/segment

    for (let x = 1; x <= radialSegments; x++) {
      // vertex
      vertices.push(0, halfHeight * sign, 0); // normal

      normals.push(0, sign, 0); // uv

      uvs.push(0.5, 0.5); // increase index

      index++;
    } // save the index of the last center vertex


    centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs

    for (let x = 0; x <= radialSegments; x++) {
      const u = x / radialSegments;
      const theta = u * thetaLength + thetaStart;
      const cosTheta = Math.cos(theta);
      const sinTheta = Math.sin(theta); // vertex

      vertex.x = radius * sinTheta;
      vertex.y = halfHeight * sign;
      vertex.z = radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      normals.push(0, sign, 0); // uv

      uv.x = cosTheta * 0.5 + 0.5;
      uv.y = sinTheta * 0.5 * sign + 0.5;
      uvs.push(uv.x, uv.y); // increase index

      index++;
    } // generate indices


    for (let x = 0; x < radialSegments; x++) {
      const c = centerIndexStart + x;
      const i = centerIndexEnd + x;

      if (top === true) {
        // face top
        indices.push(i, i + 1, c);
      } else {
        // face bottom
        indices.push(i + 1, i, c);
      }

      groupCount += 3;
    } // add a group to the geometry. this will ensure multi material support


    scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups

    groupStart += groupCount;
  }
}

CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
/**
 * @author abelnation / http://github.com/abelnation
 */
// ConeGeometry

function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
  this.type = 'ConeGeometry';
  this.parameters = {
    radius: radius,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
}

ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
ConeGeometry.prototype.constructor = ConeGeometry; // ConeBufferGeometry

function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
  CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
  this.type = 'ConeBufferGeometry';
  this.parameters = {
    radius: radius,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
}

ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 * @author hughes
 */
// CircleGeometry

function CircleGeometry(radius, segments, thetaStart, thetaLength) {
  Geometry.call(this);
  this.type = 'CircleGeometry';
  this.parameters = {
    radius: radius,
    segments: segments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
  this.mergeVertices();
}

CircleGeometry.prototype = Object.create(Geometry.prototype);
CircleGeometry.prototype.constructor = CircleGeometry; // CircleBufferGeometry

function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
  BufferGeometry.call(this);
  this.type = 'CircleBufferGeometry';
  this.parameters = {
    radius: radius,
    segments: segments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  radius = radius || 1;
  segments = segments !== undefined ? Math.max(3, segments) : 8;
  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2; // buffers

  const indices = [];
  const vertices = [];
  const normals = [];
  const uvs = []; // helper variables

  const vertex = new Vector3();
  const uv = new Vector2(); // center point

  vertices.push(0, 0, 0);
  normals.push(0, 0, 1);
  uvs.push(0.5, 0.5);

  for (let s = 0, i = 3; s <= segments; s++, i += 3) {
    const segment = thetaStart + s / segments * thetaLength; // vertex

    vertex.x = radius * Math.cos(segment);
    vertex.y = radius * Math.sin(segment);
    vertices.push(vertex.x, vertex.y, vertex.z); // normal

    normals.push(0, 0, 1); // uvs

    uv.x = (vertices[i] / radius + 1) / 2;
    uv.y = (vertices[i + 1] / radius + 1) / 2;
    uvs.push(uv.x, uv.y);
  } // indices


  for (let i = 1; i <= segments; i++) {
    indices.push(i, i + 1, 0);
  } // build geometry


  this.setIndex(indices);
  this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
  this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
}

CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
var Geometries = /*#__PURE__*/Object.freeze({
  __proto__: null,
  WireframeGeometry: WireframeGeometry,
  ParametricGeometry: ParametricGeometry,
  ParametricBufferGeometry: ParametricBufferGeometry,
  TetrahedronGeometry: TetrahedronGeometry,
  TetrahedronBufferGeometry: TetrahedronBufferGeometry,
  OctahedronGeometry: OctahedronGeometry,
  OctahedronBufferGeometry: OctahedronBufferGeometry,
  IcosahedronGeometry: IcosahedronGeometry,
  IcosahedronBufferGeometry: IcosahedronBufferGeometry,
  DodecahedronGeometry: DodecahedronGeometry,
  DodecahedronBufferGeometry: DodecahedronBufferGeometry,
  PolyhedronGeometry: PolyhedronGeometry,
  PolyhedronBufferGeometry: PolyhedronBufferGeometry,
  TubeGeometry: TubeGeometry,
  TubeBufferGeometry: TubeBufferGeometry,
  TorusKnotGeometry: TorusKnotGeometry,
  TorusKnotBufferGeometry: TorusKnotBufferGeometry,
  TorusGeometry: TorusGeometry,
  TorusBufferGeometry: TorusBufferGeometry,
  TextGeometry: TextGeometry,
  TextBufferGeometry: TextBufferGeometry,
  SphereGeometry: SphereGeometry,
  SphereBufferGeometry: SphereBufferGeometry,
  RingGeometry: RingGeometry,
  RingBufferGeometry: RingBufferGeometry,
  PlaneGeometry: PlaneGeometry,
  PlaneBufferGeometry: PlaneBufferGeometry,
  LatheGeometry: LatheGeometry,
  LatheBufferGeometry: LatheBufferGeometry,
  ShapeGeometry: ShapeGeometry,
  ShapeBufferGeometry: ShapeBufferGeometry,
  ExtrudeGeometry: ExtrudeGeometry,
  ExtrudeBufferGeometry: ExtrudeBufferGeometry,
  EdgesGeometry: EdgesGeometry,
  ConeGeometry: ConeGeometry,
  ConeBufferGeometry: ConeBufferGeometry,
  CylinderGeometry: CylinderGeometry,
  CylinderBufferGeometry: CylinderBufferGeometry,
  CircleGeometry: CircleGeometry,
  CircleBufferGeometry: CircleBufferGeometry,
  BoxGeometry: BoxGeometry,
  BoxBufferGeometry: BoxBufferGeometry
});
/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  color: <THREE.Color>
 * }
 */

function ShadowMaterial(parameters) {
  Material.call(this);
  this.type = 'ShadowMaterial';
  this.color = new Color(0x000000);
  this.transparent = true;
  this.setValues(parameters);
}

ShadowMaterial.prototype = Object.create(Material.prototype);
ShadowMaterial.prototype.constructor = ShadowMaterial;
ShadowMaterial.prototype.isShadowMaterial = true;

ShadowMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 */


function RawShaderMaterial(parameters) {
  ShaderMaterial.call(this, parameters);
  this.type = 'RawShaderMaterial';
}

RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
RawShaderMaterial.prototype.constructor = RawShaderMaterial;
RawShaderMaterial.prototype.isRawShaderMaterial = true;
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshStandardMaterial(parameters) {
  Material.call(this);
  this.defines = {
    'STANDARD': ''
  };
  this.type = 'MeshStandardMaterial';
  this.color = new Color(0xffffff); // diffuse

  this.roughness = 1.0;
  this.metalness = 0.0;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.emissive = new Color(0x000000);
  this.emissiveIntensity = 1.0;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.roughnessMap = null;
  this.metalnessMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.envMapIntensity = 1.0;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.vertexTangents = false;
  this.setValues(parameters);
}

MeshStandardMaterial.prototype = Object.create(Material.prototype);
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

MeshStandardMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.defines = {
    'STANDARD': ''
  };
  this.color.copy(source.color);
  this.roughness = source.roughness;
  this.metalness = source.metalness;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.roughnessMap = source.roughnessMap;
  this.metalnessMap = source.metalnessMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.envMapIntensity = source.envMapIntensity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  this.vertexTangents = source.vertexTangents;
  return this;
};
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  reflectivity: <float>,
 *
 *  sheen: <Color>,
 *
 *  transparency: <float>
 * }
 */


function MeshPhysicalMaterial(parameters) {
  MeshStandardMaterial.call(this);
  this.defines = {
    'STANDARD': '',
    'PHYSICAL': ''
  };
  this.type = 'MeshPhysicalMaterial';
  this.clearcoat = 0.0;
  this.clearcoatMap = null;
  this.clearcoatRoughness = 0.0;
  this.clearcoatRoughnessMap = null;
  this.clearcoatNormalScale = new Vector2(1, 1);
  this.clearcoatNormalMap = null;
  this.reflectivity = 0.5; // maps to F0 = 0.04

  this.sheen = null; // null will disable sheen bsdf

  this.transparency = 0.0;
  this.setValues(parameters);
}

MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

MeshPhysicalMaterial.prototype.copy = function (source) {
  MeshStandardMaterial.prototype.copy.call(this, source);
  this.defines = {
    'STANDARD': '',
    'PHYSICAL': ''
  };
  this.clearcoat = source.clearcoat;
  this.clearcoatMap = source.clearcoatMap;
  this.clearcoatRoughness = source.clearcoatRoughness;
  this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
  this.clearcoatNormalMap = source.clearcoatNormalMap;
  this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
  this.reflectivity = source.reflectivity;

  if (source.sheen) {
    this.sheen = (this.sheen || new Color()).copy(source.sheen);
  } else {
    this.sheen = null;
  }

  this.transparency = source.transparency;
  return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */


function MeshPhongMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshPhongMaterial';
  this.color = new Color(0xffffff); // diffuse

  this.specular = new Color(0x111111);
  this.shininess = 30;
  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.emissive = new Color(0x000000);
  this.emissiveIntensity = 1.0;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}

MeshPhongMaterial.prototype = Object.create(Material.prototype);
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

MeshPhongMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.specular.copy(source.specular);
  this.shininess = source.shininess;
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * @author takahirox / http://github.com/takahirox
 *
 * parameters = {
 *  color: <hex>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */


function MeshToonMaterial(parameters) {
  Material.call(this);
  this.defines = {
    'TOON': ''
  };
  this.type = 'MeshToonMaterial';
  this.color = new Color(0xffffff);
  this.map = null;
  this.gradientMap = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.emissive = new Color(0x000000);
  this.emissiveIntensity = 1.0;
  this.emissiveMap = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.alphaMap = null;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}

MeshToonMaterial.prototype = Object.create(Material.prototype);
MeshToonMaterial.prototype.constructor = MeshToonMaterial;
MeshToonMaterial.prototype.isMeshToonMaterial = true;

MeshToonMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.gradientMap = source.gradientMap;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.alphaMap = source.alphaMap;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */


function MeshNormalMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshNormalMaterial';
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.fog = false;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}

MeshNormalMaterial.prototype = Object.create(Material.prototype);
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

MeshNormalMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */


function MeshLambertMaterial(parameters) {
  Material.call(this);
  this.type = 'MeshLambertMaterial';
  this.color = new Color(0xffffff); // diffuse

  this.map = null;
  this.lightMap = null;
  this.lightMapIntensity = 1.0;
  this.aoMap = null;
  this.aoMapIntensity = 1.0;
  this.emissive = new Color(0x000000);
  this.emissiveIntensity = 1.0;
  this.emissiveMap = null;
  this.specularMap = null;
  this.alphaMap = null;
  this.envMap = null;
  this.combine = MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}

MeshLambertMaterial.prototype = Object.create(Material.prototype);
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

MeshLambertMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.map = source.map;
  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;
  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;
  this.emissive.copy(source.emissive);
  this.emissiveMap = source.emissiveMap;
  this.emissiveIntensity = source.emissiveIntensity;
  this.specularMap = source.specularMap;
  this.alphaMap = source.alphaMap;
  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;
  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */


function MeshMatcapMaterial(parameters) {
  Material.call(this);
  this.defines = {
    'MATCAP': ''
  };
  this.type = 'MeshMatcapMaterial';
  this.color = new Color(0xffffff); // diffuse

  this.matcap = null;
  this.map = null;
  this.bumpMap = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalMapType = TangentSpaceNormalMap;
  this.normalScale = new Vector2(1, 1);
  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;
  this.alphaMap = null;
  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;
  this.setValues(parameters);
}

MeshMatcapMaterial.prototype = Object.create(Material.prototype);
MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

MeshMatcapMaterial.prototype.copy = function (source) {
  Material.prototype.copy.call(this, source);
  this.defines = {
    'MATCAP': ''
  };
  this.color.copy(source.color);
  this.matcap = source.matcap;
  this.map = source.map;
  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;
  this.normalMap = source.normalMap;
  this.normalMapType = source.normalMapType;
  this.normalScale.copy(source.normalScale);
  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;
  this.alphaMap = source.alphaMap;
  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;
  return this;
};
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */


function LineDashedMaterial(parameters) {
  LineBasicMaterial.call(this);
  this.type = 'LineDashedMaterial';
  this.scale = 1;
  this.dashSize = 3;
  this.gapSize = 1;
  this.setValues(parameters);
}

LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
LineDashedMaterial.prototype.constructor = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = true;

LineDashedMaterial.prototype.copy = function (source) {
  LineBasicMaterial.prototype.copy.call(this, source);
  this.scale = source.scale;
  this.dashSize = source.dashSize;
  this.gapSize = source.gapSize;
  return this;
};

var Materials = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ShadowMaterial: ShadowMaterial,
  SpriteMaterial: SpriteMaterial,
  RawShaderMaterial: RawShaderMaterial,
  ShaderMaterial: ShaderMaterial,
  PointsMaterial: PointsMaterial,
  MeshPhysicalMaterial: MeshPhysicalMaterial,
  MeshStandardMaterial: MeshStandardMaterial,
  MeshPhongMaterial: MeshPhongMaterial,
  MeshToonMaterial: MeshToonMaterial,
  MeshNormalMaterial: MeshNormalMaterial,
  MeshLambertMaterial: MeshLambertMaterial,
  MeshDepthMaterial: MeshDepthMaterial,
  MeshDistanceMaterial: MeshDistanceMaterial,
  MeshBasicMaterial: MeshBasicMaterial,
  MeshMatcapMaterial: MeshMatcapMaterial,
  LineDashedMaterial: LineDashedMaterial,
  LineBasicMaterial: LineBasicMaterial,
  Material: Material
});
/**
 * @author tschw
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

const AnimationUtils = {
  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function (array, from, to) {
    if (AnimationUtils.isTypedArray(array)) {
      // in ios9 array.subarray(from, undefined) will return empty array
      // but array.subarray(from) or array.subarray(from, len) is correct
      return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
    }

    return array.slice(from, to);
  },
  // converts an array to a specific type
  convertArray: function (array, type, forceClone) {
    if (!array || // let 'undefined' and 'null' pass
    !forceClone && array.constructor === type) return array;

    if (typeof type.BYTES_PER_ELEMENT === 'number') {
      return new type(array); // create typed array
    }

    return Array.prototype.slice.call(array); // create Array
  },
  isTypedArray: function (object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  },
  // returns an array by which times and values can be sorted
  getKeyframeOrder: function (times) {
    function compareTime(i, j) {
      return times[i] - times[j];
    }

    const n = times.length;
    const result = new Array(n);

    for (let i = 0; i !== n; ++i) result[i] = i;

    result.sort(compareTime);
    return result;
  },
  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function (values, stride, order) {
    const nValues = values.length;
    const result = new values.constructor(nValues);

    for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
      const srcOffset = order[i] * stride;

      for (let j = 0; j !== stride; ++j) {
        result[dstOffset++] = values[srcOffset + j];
      }
    }

    return result;
  },
  // function for parsing AOS keyframe formats
  flattenJSON: function (jsonKeys, times, values, valuePropertyName) {
    let i = 1,
        key = jsonKeys[0];

    while (key !== undefined && key[valuePropertyName] === undefined) {
      key = jsonKeys[i++];
    }

    if (key === undefined) return; // no data

    let value = key[valuePropertyName];
    if (value === undefined) return; // no data

    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];

        if (value !== undefined) {
          times.push(key.time);
          values.push.apply(values, value); // push all elements
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    } else if (value.toArray !== undefined) {
      // ...assume THREE.Math-ish
      do {
        value = key[valuePropertyName];

        if (value !== undefined) {
          times.push(key.time);
          value.toArray(values, values.length);
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    } else {
      // otherwise push as-is
      do {
        value = key[valuePropertyName];

        if (value !== undefined) {
          times.push(key.time);
          values.push(value);
        }

        key = jsonKeys[i++];
      } while (key !== undefined);
    }
  },
  subclip: function (sourceClip, name, startFrame, endFrame, fps) {
    fps = fps || 30;
    const clip = sourceClip.clone();
    clip.name = name;
    const tracks = [];

    for (let i = 0; i < clip.tracks.length; ++i) {
      const track = clip.tracks[i];
      const valueSize = track.getValueSize();
      const times = [];
      const values = [];

      for (let j = 0; j < track.times.length; ++j) {
        const frame = track.times[j] * fps;
        if (frame < startFrame || frame >= endFrame) continue;
        times.push(track.times[j]);

        for (let k = 0; k < valueSize; ++k) {
          values.push(track.values[j * valueSize + k]);
        }
      }

      if (times.length === 0) continue;
      track.times = AnimationUtils.convertArray(times, track.times.constructor);
      track.values = AnimationUtils.convertArray(values, track.values.constructor);
      tracks.push(track);
    }

    clip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip

    let minStartTime = Infinity;

    for (let i = 0; i < clip.tracks.length; ++i) {
      if (minStartTime > clip.tracks[i].times[0]) {
        minStartTime = clip.tracks[i].times[0];
      }
    } // shift all tracks such that clip begins at t=0


    for (let i = 0; i < clip.tracks.length; ++i) {
      clip.tracks[i].shift(-1 * minStartTime);
    }

    clip.resetDuration();
    return clip;
  },
  makeClipAdditive: function (targetClip, referenceFrame, referenceClip, fps) {
    if (referenceFrame === undefined) referenceFrame = 0;
    if (referenceClip === undefined) referenceClip = targetClip;
    if (fps === undefined || fps <= 0) fps = 30;
    const numTracks = targetClip.tracks.length;
    const referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame

    for (let i = 0; i < numTracks; ++i) {
      const referenceTrack = referenceClip.tracks[i];
      const referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric

      if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue; // Find the track in the target clip whose name and type matches the reference track

      const targetTrack = targetClip.tracks.find(function (track) {
        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
      });
      if (targetTrack === undefined) continue;
      const valueSize = referenceTrack.getValueSize();
      const lastIndex = referenceTrack.times.length - 1;
      let referenceValue; // Find the value to subtract out of the track

      if (referenceTime <= referenceTrack.times[0]) {
        // Reference frame is earlier than the first keyframe, so just use the first keyframe
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, 0, referenceTrack.valueSize);
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        // Reference frame is after the last keyframe, so just use the last keyframe
        const startIndex = lastIndex * valueSize;
        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex);
      } else {
        // Interpolate to the reference value
        const interpolant = referenceTrack.createInterpolant();
        interpolant.evaluate(referenceTime);
        referenceValue = interpolant.resultBuffer;
      } // Conjugate the quaternion


      if (referenceTrackType === 'quaternion') {
        const referenceQuat = new Quaternion(referenceValue[0], referenceValue[1], referenceValue[2], referenceValue[3]).normalize().conjugate();
        referenceQuat.toArray(referenceValue);
      } // Subtract the reference value from all of the track values


      const numTimes = targetTrack.times.length;

      for (let j = 0; j < numTimes; ++j) {
        const valueStart = j * valueSize;

        if (referenceTrackType === 'quaternion') {
          // Multiply the conjugate for quaternion track types
          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
        } else {
          // Subtract each value for all other numeric track types
          for (let k = 0; k < valueSize; ++k) {
            targetTrack.values[valueStart + k] -= referenceValue[k];
          }
        }
      }
    }

    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
};
/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 * @author tschw
 */

exports.AnimationUtils = AnimationUtils;

function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  this.parameterPositions = parameterPositions;
  this._cachedIndex = 0;
  this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
  this.sampleValues = sampleValues;
  this.valueSize = sampleSize;
}

Object.assign(Interpolant.prototype, {
  evaluate: function (t) {
    let pp = this.parameterPositions,
        i1 = this._cachedIndex,
        t1 = pp[i1],
        t0 = pp[i1 - 1];

    validate_interval: {
      seek: {
        let right;

        linear_scan: {
          //- See http://jsperf.com/comparison-to-undefined/3
          //- slower code:
          //-
          //- 				if ( t >= t1 || t1 === undefined ) {
          forward_scan: if (!(t < t1)) {
            for (let giveUpAt = i1 + 2;;) {
              if (t1 === undefined) {
                if (t < t0) break forward_scan; // after end

                i1 = pp.length;
                this._cachedIndex = i1;
                return this.afterEnd_(i1 - 1, t, t0);
              }

              if (i1 === giveUpAt) break; // this loop

              t0 = t1;
              t1 = pp[++i1];

              if (t < t1) {
                // we have arrived at the sought interval
                break seek;
              }
            } // prepare binary search on the right side of the index


            right = pp.length;
            break linear_scan;
          } //- slower code:
          //-					if ( t < t0 || t0 === undefined ) {


          if (!(t >= t0)) {
            // looping?
            const t1global = pp[1];

            if (t < t1global) {
              i1 = 2; // + 1, using the scan for the details

              t0 = t1global;
            } // linear reverse scan


            for (let giveUpAt = i1 - 2;;) {
              if (t0 === undefined) {
                // before start
                this._cachedIndex = 0;
                return this.beforeStart_(0, t, t1);
              }

              if (i1 === giveUpAt) break; // this loop

              t1 = t0;
              t0 = pp[--i1 - 1];

              if (t >= t0) {
                // we have arrived at the sought interval
                break seek;
              }
            } // prepare binary search on the left side of the index


            right = i1;
            i1 = 0;
            break linear_scan;
          } // the interval is valid


          break validate_interval;
        } // linear scan
        // binary search


        while (i1 < right) {
          const mid = i1 + right >>> 1;

          if (t < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }

        t1 = pp[i1];
        t0 = pp[i1 - 1]; // check boundary cases, again

        if (t0 === undefined) {
          this._cachedIndex = 0;
          return this.beforeStart_(0, t, t1);
        }

        if (t1 === undefined) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_(i1 - 1, t0, t);
        }
      } // seek


      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    } // validate_interval


    return this.interpolate_(i1, t0, t, t1);
  },
  settings: null,
  // optional, subclass-specific settings structure
  // Note: The indirection allows central control of many interpolants.
  // --- Protected interface
  DefaultSettings_: {},
  getSettings_: function () {
    return this.settings || this.DefaultSettings_;
  },
  copySampleValue_: function (index) {
    // copies a sample value to the result buffer
    const result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          offset = index * stride;

    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset + i];
    }

    return result;
  },
  // Template methods for derived classes:
  interpolate_: function ()
  /* i1, t0, t, t1 */
  {
    throw new Error('call to abstract method'); // implementations shall return this.resultBuffer
  },
  intervalChanged_: function ()
  /* i1, t0, t1 */
  {// empty
  }
}); // DECLARE ALIAS AFTER assign prototype

Object.assign(Interpolant.prototype, {
  //( 0, t, t0 ), returns this.resultBuffer
  beforeStart_: Interpolant.prototype.copySampleValue_,
  //( N-1, tN-1, t ), returns this.resultBuffer
  afterEnd_: Interpolant.prototype.copySampleValue_
});
/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 *
 * @author tschw
 */

function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  this._weightPrev = -0;
  this._offsetPrev = -0;
  this._weightNext = -0;
  this._offsetNext = -0;
}

CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: CubicInterpolant,
  DefaultSettings_: {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  },
  intervalChanged_: function (i1, t0, t1) {
    let pp = this.parameterPositions,
        iPrev = i1 - 2,
        iNext = i1 + 1,
        tPrev = pp[iPrev],
        tNext = pp[iNext];

    if (tPrev === undefined) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          // f'(t0) = 0
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;

        case WrapAroundEnding:
          // use the other end of the curve
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;

        default:
          // ZeroCurvatureEnding
          // f''(t0) = 0 a.k.a. Natural Spline
          iPrev = i1;
          tPrev = t1;
      }
    }

    if (tNext === undefined) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          // f'(tN) = 0
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;

        case WrapAroundEnding:
          // use the other end of the curve
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;

        default:
          // ZeroCurvatureEnding
          // f''(tN) = 0, a.k.a. Natural Spline
          iNext = i1 - 1;
          tNext = t0;
      }
    }

    const halfDt = (t1 - t0) * 0.5,
          stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  },
  interpolate_: function (i1, t0, t, t1) {
    const result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          o1 = i1 * stride,
          o0 = o1 - stride,
          oP = this._offsetPrev,
          oN = this._offsetNext,
          wP = this._weightPrev,
          wN = this._weightNext,
          p = (t - t0) / (t1 - t0),
          pp = p * p,
          ppp = pp * p; // evaluate polynomials

    const sP = -wP * ppp + 2 * wP * pp - wP * p;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    const sN = wN * ppp - wN * pp; // combine data linearly

    for (let i = 0; i !== stride; ++i) {
      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
    }

    return result;
  }
});
/**
 * @author tschw
 */

function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}

LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: LinearInterpolant,
  interpolate_: function (i1, t0, t, t1) {
    const result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          offset1 = i1 * stride,
          offset0 = offset1 - stride,
          weight1 = (t - t0) / (t1 - t0),
          weight0 = 1 - weight1;

    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
    }

    return result;
  }
});
/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 *
 * @author tschw
 */

function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}

DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: DiscreteInterpolant,
  interpolate_: function (i1
  /*, t0, t, t1 */
  ) {
    return this.copySampleValue_(i1 - 1);
  }
});
/**
 *
 * A timed sequence of keyframes for a specific property.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function KeyframeTrack(name, times, values, interpolation) {
  if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
  if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
  this.name = name;
  this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
  this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
  this.setInterpolation(interpolation || this.DefaultInterpolation);
} // Static methods


Object.assign(KeyframeTrack, {
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  toJSON: function (track) {
    const trackType = track.constructor;
    let json; // derived classes can define a static toJSON method

    if (trackType.toJSON !== undefined) {
      json = trackType.toJSON(track);
    } else {
      // by default, we assume the data can be serialized as-is
      json = {
        'name': track.name,
        'times': AnimationUtils.convertArray(track.times, Array),
        'values': AnimationUtils.convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();

      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }

    json.type = track.ValueTypeName; // mandatory

    return json;
  }
});
Object.assign(KeyframeTrack.prototype, {
  constructor: KeyframeTrack,
  TimeBufferType: Float32Array,
  ValueBufferType: Float32Array,
  DefaultInterpolation: InterpolateLinear,
  InterpolantFactoryMethodDiscrete: function (result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodLinear: function (result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodSmooth: function (result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  setInterpolation: function (interpolation) {
    let factoryMethod;

    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;

      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;

      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }

    if (factoryMethod === undefined) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;

      if (this.createInterpolant === undefined) {
        // fall back to default, unless the default itself is messed up
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message); // fatal, in this case
        }
      }

      console.warn('THREE.KeyframeTrack:', message);
      return this;
    }

    this.createInterpolant = factoryMethod;
    return this;
  },
  getInterpolation: function () {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;

      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;

      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  },
  getValueSize: function () {
    return this.values.length / this.times.length;
  },
  // move all keyframes either forwards or backwards in time
  shift: function (timeOffset) {
    if (timeOffset !== 0.0) {
      const times = this.times;

      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset;
      }
    }

    return this;
  },
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale: function (timeScale) {
    if (timeScale !== 1.0) {
      const times = this.times;

      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale;
      }
    }

    return this;
  },
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim: function (startTime, endTime) {
    const times = this.times,
          nKeys = times.length;
    let from = 0,
        to = nKeys - 1;

    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }

    while (to !== -1 && times[to] > endTime) {
      --to;
    }

    ++to; // inclusive -> exclusive bound

    if (from !== 0 || to !== nKeys) {
      // empty tracks are forbidden, so keep at least one keyframe
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }

      const stride = this.getValueSize();
      this.times = AnimationUtils.arraySlice(times, from, to);
      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
    }

    return this;
  },
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate: function () {
    let valid = true;
    const valueSize = this.getValueSize();

    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
      valid = false;
    }

    const times = this.times,
          values = this.values,
          nKeys = times.length;

    if (nKeys === 0) {
      console.error('THREE.KeyframeTrack: Track is empty.', this);
      valid = false;
    }

    let prevTime = null;

    for (let i = 0; i !== nKeys; i++) {
      const currTime = times[i];

      if (typeof currTime === 'number' && isNaN(currTime)) {
        console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
        valid = false;
        break;
      }

      if (prevTime !== null && prevTime > currTime) {
        console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
        valid = false;
        break;
      }

      prevTime = currTime;
    }

    if (values !== undefined) {
      if (AnimationUtils.isTypedArray(values)) {
        for (let i = 0, n = values.length; i !== n; ++i) {
          const value = values[i];

          if (isNaN(value)) {
            console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
            valid = false;
            break;
          }
        }
      }
    }

    return valid;
  },
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize: function () {
    // times or values may be shared with other tracks, so overwriting is unsafe
    const times = AnimationUtils.arraySlice(this.times),
          values = AnimationUtils.arraySlice(this.values),
          stride = this.getValueSize(),
          smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
          lastIndex = times.length - 1;
    let writeIndex = 1;

    for (let i = 1; i < lastIndex; ++i) {
      let keep = false;
      const time = times[i];
      const timeNext = times[i + 1]; // remove adjacent keyframes scheduled at the same time

      if (time !== timeNext && (i !== 1 || time !== time[0])) {
        if (!smoothInterpolation) {
          // remove unnecessary keyframes same as their neighbors
          const offset = i * stride,
                offsetP = offset - stride,
                offsetN = offset + stride;

          for (let j = 0; j !== stride; ++j) {
            const value = values[offset + j];

            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      } // in-place compaction


      if (keep) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i];
          const readOffset = i * stride,
                writeOffset = writeIndex * stride;

          for (let j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }

        ++writeIndex;
      }
    } // flush last keyframe (compaction looks ahead)


    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];

      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }

      ++writeIndex;
    }

    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }

    return this;
  },
  clone: function () {
    const times = AnimationUtils.arraySlice(this.times, 0);
    const values = AnimationUtils.arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.

    track.createInterpolant = this.createInterpolant;
    return track;
  }
});
/**
 *
 * A Track of Boolean keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function BooleanKeyframeTrack(name, times, values) {
  KeyframeTrack.call(this, name, times, values);
}

BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: BooleanKeyframeTrack,
  ValueTypeName: 'bool',
  ValueBufferType: Array,
  DefaultInterpolation: InterpolateDiscrete,
  InterpolantFactoryMethodLinear: undefined,
  InterpolantFactoryMethodSmooth: undefined // Note: Actually this track could have a optimized / compressed
  // representation of a single value and a custom interpolant that
  // computes "firstValue ^ isOdd( index )".

});
/**
 *
 * A Track of keyframe values that represent color.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function ColorKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: ColorKeyframeTrack,
  ValueTypeName: 'color' // ValueBufferType is inherited
  // DefaultInterpolation is inherited
  // Note: Very basic implementation and nothing special yet.
  // However, this is the place for color space parameterization.

});
/**
 *
 * A Track of numeric keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function NumberKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: NumberKeyframeTrack,
  ValueTypeName: 'number' // ValueBufferType is inherited
  // DefaultInterpolation is inherited

});
/**
 * Spherical linear unit quaternion interpolant.
 *
 * @author tschw
 */

function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}

QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
  constructor: QuaternionLinearInterpolant,
  interpolate_: function (i1, t0, t, t1) {
    const result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          alpha = (t - t0) / (t1 - t0);
    let offset = i1 * stride;

    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }

    return result;
  }
});
/**
 *
 * A Track of quaternion keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function QuaternionKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: QuaternionKeyframeTrack,
  ValueTypeName: 'quaternion',
  // ValueBufferType is inherited
  DefaultInterpolation: InterpolateLinear,
  InterpolantFactoryMethodLinear: function (result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  },
  InterpolantFactoryMethodSmooth: undefined // not yet implemented

});
/**
 *
 * A Track that interpolates Strings
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function StringKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: StringKeyframeTrack,
  ValueTypeName: 'string',
  ValueBufferType: Array,
  DefaultInterpolation: InterpolateDiscrete,
  InterpolantFactoryMethodLinear: undefined,
  InterpolantFactoryMethodSmooth: undefined
});
/**
 *
 * A Track of vectored keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function VectorKeyframeTrack(name, times, values, interpolation) {
  KeyframeTrack.call(this, name, times, values, interpolation);
}

VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
  constructor: VectorKeyframeTrack,
  ValueTypeName: 'vector' // ValueBufferType is inherited
  // DefaultInterpolation is inherited

});
/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

function AnimationClip(name, duration, tracks, blendMode) {
  this.name = name;
  this.tracks = tracks;
  this.duration = duration !== undefined ? duration : -1;
  this.blendMode = blendMode !== undefined ? blendMode : NormalAnimationBlendMode;
  this.uuid = MathUtils.generateUUID(); // this means it should figure out its duration by scanning the tracks

  if (this.duration < 0) {
    this.resetDuration();
  }
}

function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case 'scalar':
    case 'double':
    case 'float':
    case 'number':
    case 'integer':
      return NumberKeyframeTrack;

    case 'vector':
    case 'vector2':
    case 'vector3':
    case 'vector4':
      return VectorKeyframeTrack;

    case 'color':
      return ColorKeyframeTrack;

    case 'quaternion':
      return QuaternionKeyframeTrack;

    case 'bool':
    case 'boolean':
      return BooleanKeyframeTrack;

    case 'string':
      return StringKeyframeTrack;
  }

  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
}

function parseKeyframeTrack(json) {
  if (json.type === undefined) {
    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
  }

  const trackType = getTrackTypeForValueTypeName(json.type);

  if (json.times === undefined) {
    const times = [],
          values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, 'value');
    json.times = times;
    json.values = values;
  } // derived classes can define a static parse method


  if (trackType.parse !== undefined) {
    return trackType.parse(json);
  } else {
    // by default, we assume a constructor compatible with the base
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}

Object.assign(AnimationClip, {
  parse: function (json) {
    const tracks = [],
          jsonTracks = json.tracks,
          frameTime = 1.0 / (json.fps || 1.0);

    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
    }

    return new AnimationClip(json.name, json.duration, tracks, json.blendMode);
  },
  toJSON: function (clip) {
    const tracks = [],
          clipTracks = clip.tracks;
    const json = {
      'name': clip.name,
      'duration': clip.duration,
      'tracks': tracks,
      'uuid': clip.uuid,
      'blendMode': clip.blendMode
    };

    for (let i = 0, n = clipTracks.length; i !== n; ++i) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
    }

    return json;
  },
  CreateFromMorphTargetSequence: function (name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];

    for (let i = 0; i < numMorphTargets; i++) {
      let times = [];
      let values = [];
      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
      values.push(0, 1, 0);
      const order = AnimationUtils.getKeyframeOrder(times);
      times = AnimationUtils.sortedArray(times, 1, order);
      values = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the
      // last frame as well for perfect loop.

      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }

      tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
    }

    return new AnimationClip(name, -1, tracks);
  },
  findByName: function (objectOrClipArray, name) {
    let clipArray = objectOrClipArray;

    if (!Array.isArray(objectOrClipArray)) {
      const o = objectOrClipArray;
      clipArray = o.geometry && o.geometry.animations || o.animations;
    }

    for (let i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name) {
        return clipArray[i];
      }
    }

    return null;
  },
  CreateClipsFromMorphTargetSequences: function (morphTargets, fps, noLoop) {
    const animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences
    // such flamingo_flyA_003, flamingo_run1_003, crdeath0059

    const pattern = /^([\w-]*?)([\d]+)$/; // sort morph target names into animation groups based
    // patterns like Walk_001, Walk_002, Run_001, Run_002

    for (let i = 0, il = morphTargets.length; i < il; i++) {
      const morphTarget = morphTargets[i];
      const parts = morphTarget.name.match(pattern);

      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];

        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }

        animationMorphTargets.push(morphTarget);
      }
    }

    const clips = [];

    for (const name in animationToMorphTargets) {
      clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }

    return clips;
  },
  // parse the animation.hierarchy format
  parseAnimation: function (animation, bones) {
    if (!animation) {
      console.error('THREE.AnimationClip: No animation in JSONLoader data.');
      return null;
    }

    const addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
      // only return track if there are actually keys.
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again

        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };

    const tracks = [];
    const clipName = animation.name || 'default';
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode; // automatic length determination in AnimationClip.

    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];

    for (let h = 0; h < hierarchyTracks.length; h++) {
      const animationKeys = hierarchyTracks[h].keys; // skip empty tracks

      if (!animationKeys || animationKeys.length === 0) continue; // process morph targets

      if (animationKeys[0].morphTargets) {
        // figure out all morph targets used in this track
        const morphTargetNames = {};
        let k;

        for (k = 0; k < animationKeys.length; k++) {
          if (animationKeys[k].morphTargets) {
            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
            }
          }
        } // create a track for each morph target with all zero
        // morphTargetInfluences except for the keys in which
        // the morphTarget is named.


        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];

          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
            const animationKey = animationKeys[k];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }

          tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
        }

        duration = morphTargetNames.length * (fps || 1.0);
      } else {
        // ...assume skeletal animation
        const boneName = '.bones[' + bones[h].name + ']';
        addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
        addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
        addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
      }
    }

    if (tracks.length === 0) {
      return null;
    }

    const clip = new AnimationClip(clipName, duration, tracks, blendMode);
    return clip;
  }
});
Object.assign(AnimationClip.prototype, {
  resetDuration: function () {
    const tracks = this.tracks;
    let duration = 0;

    for (let i = 0, n = tracks.length; i !== n; ++i) {
      const track = this.tracks[i];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }

    this.duration = duration;
    return this;
  },
  trim: function () {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].trim(0, this.duration);
    }

    return this;
  },
  validate: function () {
    let valid = true;

    for (let i = 0; i < this.tracks.length; i++) {
      valid = valid && this.tracks[i].validate();
    }

    return valid;
  },
  optimize: function () {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].optimize();
    }

    return this;
  },
  clone: function () {
    const tracks = [];

    for (let i = 0; i < this.tracks.length; i++) {
      tracks.push(this.tracks[i].clone());
    }

    return new AnimationClip(this.name, this.duration, tracks, this.blendMode);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

const Cache = {
  enabled: false,
  files: {},
  add: function (key, file) {
    if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );

    this.files[key] = file;
  },
  get: function (key) {
    if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );

    return this.files[key];
  },
  remove: function (key) {
    delete this.files[key];
  },
  clear: function () {
    this.files = {};
  }
};
/**
 * @author mrdoob / http://mrdoob.com/
 */

exports.Cache = Cache;

function LoadingManager(onLoad, onProgress, onError) {
  const scope = this;
  let isLoading = false;
  let itemsLoaded = 0;
  let itemsTotal = 0;
  let urlModifier = undefined;
  const handlers = []; // Refer to #5689 for the reason why we don't set .onStart
  // in the constructor

  this.onStart = undefined;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;

  this.itemStart = function (url) {
    itemsTotal++;

    if (isLoading === false) {
      if (scope.onStart !== undefined) {
        scope.onStart(url, itemsLoaded, itemsTotal);
      }
    }

    isLoading = true;
  };

  this.itemEnd = function (url) {
    itemsLoaded++;

    if (scope.onProgress !== undefined) {
      scope.onProgress(url, itemsLoaded, itemsTotal);
    }

    if (itemsLoaded === itemsTotal) {
      isLoading = false;

      if (scope.onLoad !== undefined) {
        scope.onLoad();
      }
    }
  };

  this.itemError = function (url) {
    if (scope.onError !== undefined) {
      scope.onError(url);
    }
  };

  this.resolveURL = function (url) {
    if (urlModifier) {
      return urlModifier(url);
    }

    return url;
  };

  this.setURLModifier = function (transform) {
    urlModifier = transform;
    return this;
  };

  this.addHandler = function (regex, loader) {
    handlers.push(regex, loader);
    return this;
  };

  this.removeHandler = function (regex) {
    const index = handlers.indexOf(regex);

    if (index !== -1) {
      handlers.splice(index, 2);
    }

    return this;
  };

  this.getHandler = function (file) {
    for (let i = 0, l = handlers.length; i < l; i += 2) {
      const regex = handlers[i];
      const loader = handlers[i + 1];
      if (regex.global) regex.lastIndex = 0; // see #17920

      if (regex.test(file)) {
        return loader;
      }
    }

    return null;
  };
}

const DefaultLoadingManager = new LoadingManager();
/**
 * @author alteredq / http://alteredqualia.com/
 */

exports.DefaultLoadingManager = DefaultLoadingManager;

function Loader(manager) {
  this.manager = manager !== undefined ? manager : DefaultLoadingManager;
  this.crossOrigin = 'anonymous';
  this.path = '';
  this.resourcePath = '';
  this.requestHeader = {};
}

Object.assign(Loader.prototype, {
  load: function ()
  /* url, onLoad, onProgress, onError */
  {},
  loadAsync: function (url, onProgress) {
    const scope = this;
    return new Promise(function (resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  },
  parse: function ()
  /* data */
  {},
  setCrossOrigin: function (crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  },
  setPath: function (path) {
    this.path = path;
    return this;
  },
  setResourcePath: function (resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  },
  setRequestHeader: function (requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

const loading = {};

function FileLoader(manager) {
  Loader.call(this, manager);
}

FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: FileLoader,
  load: function (url, onLoad, onProgress, onError) {
    if (url === undefined) url = '';
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);

    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    } // Check if request is duplicate


    if (loading[url] !== undefined) {
      loading[url].push({
        onLoad: onLoad,
        onProgress: onProgress,
        onError: onError
      });
      return;
    } // Check for data: URI


    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
    const dataUriRegexResult = url.match(dataUriRegex);
    let request; // Safari can not handle Data URIs through XMLHttpRequest so process manually

    if (dataUriRegexResult) {
      const mimeType = dataUriRegexResult[1];
      const isBase64 = !!dataUriRegexResult[2];
      let data = dataUriRegexResult[3];
      data = decodeURIComponent(data);
      if (isBase64) data = atob(data);

      try {
        let response;
        const responseType = (this.responseType || '').toLowerCase();

        switch (responseType) {
          case 'arraybuffer':
          case 'blob':
            const view = new Uint8Array(data.length);

            for (let i = 0; i < data.length; i++) {
              view[i] = data.charCodeAt(i);
            }

            if (responseType === 'blob') {
              response = new Blob([view.buffer], {
                type: mimeType
              });
            } else {
              response = view.buffer;
            }

            break;

          case 'document':
            const parser = new DOMParser();
            response = parser.parseFromString(data, mimeType);
            break;

          case 'json':
            response = JSON.parse(data);
            break;

          default:
            // 'text' or other
            response = data;
            break;
        } // Wait for next browser tick like standard XMLHttpRequest event dispatching does


        setTimeout(function () {
          if (onLoad) onLoad(response);
          scope.manager.itemEnd(url);
        }, 0);
      } catch (error) {
        // Wait for next browser tick like standard XMLHttpRequest event dispatching does
        setTimeout(function () {
          if (onError) onError(error);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, 0);
      }
    } else {
      // Initialise array for duplicate requests
      loading[url] = [];
      loading[url].push({
        onLoad: onLoad,
        onProgress: onProgress,
        onError: onError
      });
      request = new XMLHttpRequest();
      request.open('GET', url, true);
      request.addEventListener('load', function (event) {
        const response = this.response;
        const callbacks = loading[url];
        delete loading[url];

        if (this.status === 200 || this.status === 0) {
          // Some browsers return HTTP Status 0 when using non-http protocol
          // e.g. 'file://' or 'data://'. Handle as success.
          if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.'); // Add to cache only on HTTP success, so that we do not cache
          // error response bodies as proper responses to requests.

          Cache.add(url, response);

          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onLoad) callback.onLoad(response);
          }

          scope.manager.itemEnd(url);
        } else {
          for (let i = 0, il = callbacks.length; i < il; i++) {
            const callback = callbacks[i];
            if (callback.onError) callback.onError(event);
          }

          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
      }, false);
      request.addEventListener('progress', function (event) {
        const callbacks = loading[url];

        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onProgress) callback.onProgress(event);
        }
      }, false);
      request.addEventListener('error', function (event) {
        const callbacks = loading[url];
        delete loading[url];

        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onError) callback.onError(event);
        }

        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      request.addEventListener('abort', function (event) {
        const callbacks = loading[url];
        delete loading[url];

        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onError) callback.onError(event);
        }

        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }, false);
      if (this.responseType !== undefined) request.responseType = this.responseType;
      if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
      if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

      for (const header in this.requestHeader) {
        request.setRequestHeader(header, this.requestHeader[header]);
      }

      request.send(null);
    }

    scope.manager.itemStart(url);
    return request;
  },
  setResponseType: function (value) {
    this.responseType = value;
    return this;
  },
  setWithCredentials: function (value) {
    this.withCredentials = value;
    return this;
  },
  setMimeType: function (value) {
    this.mimeType = value;
    return this;
  }
});
/**
 * @author bhouston / http://clara.io/
 */

function AnimationLoader(manager) {
  Loader.call(this, manager);
}

AnimationLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: AnimationLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.load(url, function (text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }

        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  },
  parse: function (json) {
    const animations = [];

    for (let i = 0; i < json.length; i++) {
      const clip = AnimationClip.parse(json[i]);
      animations.push(clip);
    }

    return animations;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

function CompressedTextureLoader(manager) {
  Loader.call(this, manager);
}

CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: CompressedTextureLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const images = [];
    const texture = new CompressedTexture();
    texture.image = images;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType('arraybuffer');
    let loaded = 0;

    function loadTexture(i) {
      loader.load(url[i], function (buffer) {
        const texDatas = scope.parse(buffer, true);
        images[i] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };
        loaded += 1;

        if (loaded === 6) {
          if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, onProgress, onError);
    }

    if (Array.isArray(url)) {
      for (let i = 0, il = url.length; i < il; ++i) {
        loadTexture(i);
      }
    } else {
      // compressed cubemap texture stored in a single DDS file
      loader.load(url, function (buffer) {
        const texDatas = scope.parse(buffer, true);

        if (texDatas.isCubemap) {
          const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

          for (let f = 0; f < faces; f++) {
            images[f] = {
              mipmaps: []
            };

            for (let i = 0; i < texDatas.mipmapCount; i++) {
              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
              images[f].format = texDatas.format;
              images[f].width = texDatas.width;
              images[f].height = texDatas.height;
            }
          }
        } else {
          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;
        }

        if (texDatas.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }

        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad) onLoad(texture);
      }, onProgress, onError);
    }

    return texture;
  }
});
/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

function DataTextureLoader(manager) {
  Loader.call(this, manager);
}

DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: DataTextureLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const texture = new DataTexture();
    const loader = new FileLoader(this.manager);
    loader.setResponseType('arraybuffer');
    loader.setPath(this.path);
    loader.load(url, function (buffer) {
      const texData = scope.parse(buffer);
      if (!texData) return;

      if (texData.image !== undefined) {
        texture.image = texData.image;
      } else if (texData.data !== undefined) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }

      texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
      texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

      if (texData.format !== undefined) {
        texture.format = texData.format;
      }

      if (texData.type !== undefined) {
        texture.type = texData.type;
      }

      if (texData.mipmaps !== undefined) {
        texture.mipmaps = texData.mipmaps;
        texture.minFilter = LinearMipmapLinearFilter; // presumably...
      }

      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }

      texture.needsUpdate = true;
      if (onLoad) onLoad(texture, texData);
    }, onProgress, onError);
    return texture;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function ImageLoader(manager) {
  Loader.call(this, manager);
}

ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ImageLoader,
  load: function (url, onLoad, onProgress, onError) {
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);

    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }

    const image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');

    function onImageLoad() {
      image.removeEventListener('load', onImageLoad, false);
      image.removeEventListener('error', onImageError, false);
      Cache.add(url, this);
      if (onLoad) onLoad(this);
      scope.manager.itemEnd(url);
    }

    function onImageError(event) {
      image.removeEventListener('load', onImageLoad, false);
      image.removeEventListener('error', onImageError, false);
      if (onError) onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }

    image.addEventListener('load', onImageLoad, false);
    image.addEventListener('error', onImageError, false);

    if (url.substr(0, 5) !== 'data:') {
      if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
    }

    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function CubeTextureLoader(manager) {
  Loader.call(this, manager);
}

CubeTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: CubeTextureLoader,
  load: function (urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;

    function loadTexture(i) {
      loader.load(urls[i], function (image) {
        texture.images[i] = image;
        loaded++;

        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, undefined, onError);
    }

    for (let i = 0; i < urls.length; ++i) {
      loadTexture(i);
    }

    return texture;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function TextureLoader(manager) {
  Loader.call(this, manager);
}

TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: TextureLoader,
  load: function (url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function (image) {
      texture.image = image; // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.

      const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
      texture.format = isJPEG ? RGBFormat : RGBAFormat;
      texture.needsUpdate = true;

      if (onLoad !== undefined) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

function Curve() {
  this.type = 'Curve';
  this.arcLengthDivisions = 200;
}

Object.assign(Curve.prototype, {
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint: function ()
  /* t, optionalTarget */
  {
    console.warn('THREE.Curve: .getPoint() not implemented.');
    return null;
  },
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt: function (u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  },
  // Get sequence of points using getPoint( t )
  getPoints: function (divisions) {
    if (divisions === undefined) divisions = 5;
    const points = [];

    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }

    return points;
  },
  // Get sequence of points using getPointAt( u )
  getSpacedPoints: function (divisions) {
    if (divisions === undefined) divisions = 5;
    const points = [];

    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }

    return points;
  },
  // Get total curve arc length
  getLength: function () {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  },
  // Get list of cumulative segment lengths
  getLengths: function (divisions) {
    if (divisions === undefined) divisions = this.arcLengthDivisions;

    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }

    this.needsUpdate = false;
    const cache = [];
    let current,
        last = this.getPoint(0);
    let sum = 0;
    cache.push(0);

    for (let p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }

    this.cacheArcLengths = cache;
    return cache; // { sums: cache, sum: sum }; Sum is in the last element.
  },
  updateArcLengths: function () {
    this.needsUpdate = true;
    this.getLengths();
  },
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping: function (u, distance) {
    const arcLengths = this.getLengths();
    let i = 0,
        il = arcLengths.length;
    let targetArcLength; // The targeted u distance value to get

    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    } // binary search for the index with largest value smaller than target u distance


    let low = 0,
        high = il - 1,
        comparison;

    while (low <= high) {
      i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

      comparison = arcLengths[i] - targetArcLength;

      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break; // DONE
      }
    }

    i = high;

    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    } // we could get finer grain at lengths, or use simple interpolation between two points


    const lengthBefore = arcLengths[i];
    const lengthAfter = arcLengths[i + 1];
    const segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points

    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t

    const t = (i + segmentFraction) / (il - 1);
    return t;
  },
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent: function (t, optionalTarget) {
    const delta = 0.0001;
    let t1 = t - delta;
    let t2 = t + delta; // Capping in case of danger

    if (t1 < 0) t1 = 0;
    if (t2 > 1) t2 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t2);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  },
  getTangentAt: function (u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getTangent(t, optionalTarget);
  },
  computeFrenetFrames: function (segments, closed) {
    // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4(); // compute the tangent vectors for each segment on the curve

    for (let i = 0; i <= segments; i++) {
      const u = i / segments;
      tangents[i] = this.getTangentAt(u, new Vector3());
      tangents[i].normalize();
    } // select an initial normal vector perpendicular to the first tangent vector,
    // and in the direction of the minimum tangent xyz component


    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);

    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }

    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }

    if (tz <= min) {
      normal.set(0, 0, 1);
    }

    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve

    for (let i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);

      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(MathUtils.clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors

        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }

      binormals[i].crossVectors(tangents[i], normals[i]);
    } // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same


    if (closed === true) {
      let theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;

      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }

      for (let i = 1; i <= segments; i++) {
        // twist a little...
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }

    return {
      tangents: tangents,
      normals: normals,
      binormals: binormals
    };
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  },
  toJSON: function () {
    const data = {
      metadata: {
        version: 4.5,
        type: 'Curve',
        generator: 'Curve.toJSON'
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  },
  fromJSON: function (json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
});

function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
  Curve.call(this);
  this.type = 'EllipseCurve';
  this.aX = aX || 0;
  this.aY = aY || 0;
  this.xRadius = xRadius || 1;
  this.yRadius = yRadius || 1;
  this.aStartAngle = aStartAngle || 0;
  this.aEndAngle = aEndAngle || 2 * Math.PI;
  this.aClockwise = aClockwise || false;
  this.aRotation = aRotation || 0;
}

EllipseCurve.prototype = Object.create(Curve.prototype);
EllipseCurve.prototype.constructor = EllipseCurve;
EllipseCurve.prototype.isEllipseCurve = true;

EllipseCurve.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector2();
  const twoPi = Math.PI * 2;
  let deltaAngle = this.aEndAngle - this.aStartAngle;
  const samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI

  while (deltaAngle < 0) deltaAngle += twoPi;

  while (deltaAngle > twoPi) deltaAngle -= twoPi;

  if (deltaAngle < Number.EPSILON) {
    if (samePoints) {
      deltaAngle = 0;
    } else {
      deltaAngle = twoPi;
    }
  }

  if (this.aClockwise === true && !samePoints) {
    if (deltaAngle === twoPi) {
      deltaAngle = -twoPi;
    } else {
      deltaAngle = deltaAngle - twoPi;
    }
  }

  const angle = this.aStartAngle + t * deltaAngle;
  let x = this.aX + this.xRadius * Math.cos(angle);
  let y = this.aY + this.yRadius * Math.sin(angle);

  if (this.aRotation !== 0) {
    const cos = Math.cos(this.aRotation);
    const sin = Math.sin(this.aRotation);
    const tx = x - this.aX;
    const ty = y - this.aY; // Rotate the point about the center of the ellipse.

    x = tx * cos - ty * sin + this.aX;
    y = tx * sin + ty * cos + this.aY;
  }

  return point.set(x, y);
};

EllipseCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.aX = source.aX;
  this.aY = source.aY;
  this.xRadius = source.xRadius;
  this.yRadius = source.yRadius;
  this.aStartAngle = source.aStartAngle;
  this.aEndAngle = source.aEndAngle;
  this.aClockwise = source.aClockwise;
  this.aRotation = source.aRotation;
  return this;
};

EllipseCurve.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.aX = this.aX;
  data.aY = this.aY;
  data.xRadius = this.xRadius;
  data.yRadius = this.yRadius;
  data.aStartAngle = this.aStartAngle;
  data.aEndAngle = this.aEndAngle;
  data.aClockwise = this.aClockwise;
  data.aRotation = this.aRotation;
  return data;
};

EllipseCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.aX = json.aX;
  this.aY = json.aY;
  this.xRadius = json.xRadius;
  this.yRadius = json.yRadius;
  this.aStartAngle = json.aStartAngle;
  this.aEndAngle = json.aEndAngle;
  this.aClockwise = json.aClockwise;
  this.aRotation = json.aRotation;
  return this;
};

function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
  EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
  this.type = 'ArcCurve';
}

ArcCurve.prototype = Object.create(EllipseCurve.prototype);
ArcCurve.prototype.constructor = ArcCurve;
ArcCurve.prototype.isArcCurve = true;
/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {
  let c0 = 0,
      c1 = 0,
      c2 = 0,
      c3 = 0;
  /*
   * Compute coefficients for a cubic polynomial
   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
   * such that
   *   p(0) = x0, p(1) = x1
   *  and
   *   p'(0) = t0, p'(1) = t1.
   */

  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }

  return {
    initCatmullRom: function (x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
      // compute tangents when parameterized in [t1,t2]
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]

      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function (t) {
      const t2 = t * t;
      const t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
} //


const tmp = new Vector3();
const px = new CubicPoly(),
      py = new CubicPoly(),
      pz = new CubicPoly();

function CatmullRomCurve3(points, closed, curveType, tension) {
  Curve.call(this);
  this.type = 'CatmullRomCurve3';
  this.points = points || [];
  this.closed = closed || false;
  this.curveType = curveType || 'centripetal';
  this.tension = tension || 0.5;
}

CatmullRomCurve3.prototype = Object.create(Curve.prototype);
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

CatmullRomCurve3.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector3();
  const points = this.points;
  const l = points.length;
  const p = (l - (this.closed ? 0 : 1)) * t;
  let intPoint = Math.floor(p);
  let weight = p - intPoint;

  if (this.closed) {
    intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
  } else if (weight === 0 && intPoint === l - 1) {
    intPoint = l - 2;
    weight = 1;
  }

  let p0, p1, p2, p3; // 4 points

  if (this.closed || intPoint > 0) {
    p0 = points[(intPoint - 1) % l];
  } else {
    // extrapolate first point
    tmp.subVectors(points[0], points[1]).add(points[0]);
    p0 = tmp;
  }

  p1 = points[intPoint % l];
  p2 = points[(intPoint + 1) % l];

  if (this.closed || intPoint + 2 < l) {
    p3 = points[(intPoint + 2) % l];
  } else {
    // extrapolate last point
    tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
    p3 = tmp;
  }

  if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
    // init Centripetal / Chordal Catmull-Rom
    const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
    let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
    let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
    let dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points

    if (dt1 < 1e-4) dt1 = 1.0;
    if (dt0 < 1e-4) dt0 = dt1;
    if (dt2 < 1e-4) dt2 = dt1;
    px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
    py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
    pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
  } else if (this.curveType === 'catmullrom') {
    px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
    py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
    pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
  }

  point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
  return point;
};

CatmullRomCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.points = [];

  for (let i = 0, l = source.points.length; i < l; i++) {
    const point = source.points[i];
    this.points.push(point.clone());
  }

  this.closed = source.closed;
  this.curveType = source.curveType;
  this.tension = source.tension;
  return this;
};

CatmullRomCurve3.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.points = [];

  for (let i = 0, l = this.points.length; i < l; i++) {
    const point = this.points[i];
    data.points.push(point.toArray());
  }

  data.closed = this.closed;
  data.curveType = this.curveType;
  data.tension = this.tension;
  return data;
};

CatmullRomCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.points = [];

  for (let i = 0, l = json.points.length; i < l; i++) {
    const point = json.points[i];
    this.points.push(new Vector3().fromArray(point));
  }

  this.closed = json.closed;
  this.curveType = json.curveType;
  this.tension = json.tension;
  return this;
};
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bézier_curve
 */


function CatmullRom(t, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t2 = t * t;
  const t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
} //


function QuadraticBezierP0(t, p) {
  const k = 1 - t;
  return k * k * p;
}

function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}

function QuadraticBezierP2(t, p) {
  return t * t * p;
}

function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
} //


function CubicBezierP0(t, p) {
  const k = 1 - t;
  return k * k * k * p;
}

function CubicBezierP1(t, p) {
  const k = 1 - t;
  return 3 * k * k * t * p;
}

function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}

function CubicBezierP3(t, p) {
  return t * t * t * p;
}

function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}

function CubicBezierCurve(v0, v1, v2, v3) {
  Curve.call(this);
  this.type = 'CubicBezierCurve';
  this.v0 = v0 || new Vector2();
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
  this.v3 = v3 || new Vector2();
}

CubicBezierCurve.prototype = Object.create(Curve.prototype);
CubicBezierCurve.prototype.constructor = CubicBezierCurve;
CubicBezierCurve.prototype.isCubicBezierCurve = true;

CubicBezierCurve.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector2();
  const v0 = this.v0,
        v1 = this.v1,
        v2 = this.v2,
        v3 = this.v3;
  point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
  return point;
};

CubicBezierCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  this.v3.copy(source.v3);
  return this;
};

CubicBezierCurve.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  data.v3 = this.v3.toArray();
  return data;
};

CubicBezierCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  this.v3.fromArray(json.v3);
  return this;
};

function CubicBezierCurve3(v0, v1, v2, v3) {
  Curve.call(this);
  this.type = 'CubicBezierCurve3';
  this.v0 = v0 || new Vector3();
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
  this.v3 = v3 || new Vector3();
}

CubicBezierCurve3.prototype = Object.create(Curve.prototype);
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

CubicBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector3();
  const v0 = this.v0,
        v1 = this.v1,
        v2 = this.v2,
        v3 = this.v3;
  point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
  return point;
};

CubicBezierCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  this.v3.copy(source.v3);
  return this;
};

CubicBezierCurve3.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  data.v3 = this.v3.toArray();
  return data;
};

CubicBezierCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  this.v3.fromArray(json.v3);
  return this;
};

function LineCurve(v1, v2) {
  Curve.call(this);
  this.type = 'LineCurve';
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
}

LineCurve.prototype = Object.create(Curve.prototype);
LineCurve.prototype.constructor = LineCurve;
LineCurve.prototype.isLineCurve = true;

LineCurve.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector2();

  if (t === 1) {
    point.copy(this.v2);
  } else {
    point.copy(this.v2).sub(this.v1);
    point.multiplyScalar(t).add(this.v1);
  }

  return point;
}; // Line curve is linear, so we can overwrite default getPointAt


LineCurve.prototype.getPointAt = function (u, optionalTarget) {
  return this.getPoint(u, optionalTarget);
};

LineCurve.prototype.getTangent = function (t, optionalTarget) {
  const tangent = optionalTarget || new Vector2();
  tangent.copy(this.v2).sub(this.v1).normalize();
  return tangent;
};

LineCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};

LineCurve.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};

LineCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};

function LineCurve3(v1, v2) {
  Curve.call(this);
  this.type = 'LineCurve3';
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
}

LineCurve3.prototype = Object.create(Curve.prototype);
LineCurve3.prototype.constructor = LineCurve3;
LineCurve3.prototype.isLineCurve3 = true;

LineCurve3.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector3();

  if (t === 1) {
    point.copy(this.v2);
  } else {
    point.copy(this.v2).sub(this.v1);
    point.multiplyScalar(t).add(this.v1);
  }

  return point;
}; // Line curve is linear, so we can overwrite default getPointAt


LineCurve3.prototype.getPointAt = function (u, optionalTarget) {
  return this.getPoint(u, optionalTarget);
};

LineCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};

LineCurve3.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};

LineCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};

function QuadraticBezierCurve(v0, v1, v2) {
  Curve.call(this);
  this.type = 'QuadraticBezierCurve';
  this.v0 = v0 || new Vector2();
  this.v1 = v1 || new Vector2();
  this.v2 = v2 || new Vector2();
}

QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

QuadraticBezierCurve.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector2();
  const v0 = this.v0,
        v1 = this.v1,
        v2 = this.v2;
  point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
  return point;
};

QuadraticBezierCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};

QuadraticBezierCurve.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};

QuadraticBezierCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};

function QuadraticBezierCurve3(v0, v1, v2) {
  Curve.call(this);
  this.type = 'QuadraticBezierCurve3';
  this.v0 = v0 || new Vector3();
  this.v1 = v1 || new Vector3();
  this.v2 = v2 || new Vector3();
}

QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

QuadraticBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector3();
  const v0 = this.v0,
        v1 = this.v1,
        v2 = this.v2;
  point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
  return point;
};

QuadraticBezierCurve3.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.v0.copy(source.v0);
  this.v1.copy(source.v1);
  this.v2.copy(source.v2);
  return this;
};

QuadraticBezierCurve3.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.v0 = this.v0.toArray();
  data.v1 = this.v1.toArray();
  data.v2 = this.v2.toArray();
  return data;
};

QuadraticBezierCurve3.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.v0.fromArray(json.v0);
  this.v1.fromArray(json.v1);
  this.v2.fromArray(json.v2);
  return this;
};

function SplineCurve(points
/* array of Vector2 */
) {
  Curve.call(this);
  this.type = 'SplineCurve';
  this.points = points || [];
}

SplineCurve.prototype = Object.create(Curve.prototype);
SplineCurve.prototype.constructor = SplineCurve;
SplineCurve.prototype.isSplineCurve = true;

SplineCurve.prototype.getPoint = function (t, optionalTarget) {
  const point = optionalTarget || new Vector2();
  const points = this.points;
  const p = (points.length - 1) * t;
  const intPoint = Math.floor(p);
  const weight = p - intPoint;
  const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
  const p1 = points[intPoint];
  const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
  const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
  point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
  return point;
};

SplineCurve.prototype.copy = function (source) {
  Curve.prototype.copy.call(this, source);
  this.points = [];

  for (let i = 0, l = source.points.length; i < l; i++) {
    const point = source.points[i];
    this.points.push(point.clone());
  }

  return this;
};

SplineCurve.prototype.toJSON = function () {
  const data = Curve.prototype.toJSON.call(this);
  data.points = [];

  for (let i = 0, l = this.points.length; i < l; i++) {
    const point = this.points[i];
    data.points.push(point.toArray());
  }

  return data;
};

SplineCurve.prototype.fromJSON = function (json) {
  Curve.prototype.fromJSON.call(this, json);
  this.points = [];

  for (let i = 0, l = json.points.length; i < l; i++) {
    const point = json.points[i];
    this.points.push(new Vector2().fromArray(point));
  }

  return this;
};

var Curves = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ArcCurve: ArcCurve,
  CatmullRomCurve3: CatmullRomCurve3,
  CubicBezierCurve: CubicBezierCurve,
  CubicBezierCurve3: CubicBezierCurve3,
  EllipseCurve: EllipseCurve,
  LineCurve: LineCurve,
  LineCurve3: LineCurve3,
  QuadraticBezierCurve: QuadraticBezierCurve,
  QuadraticBezierCurve3: QuadraticBezierCurve3,
  SplineCurve: SplineCurve
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

function CurvePath() {
  Curve.call(this);
  this.type = 'CurvePath';
  this.curves = [];
  this.autoClose = false; // Automatically closes the path
}

CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
  constructor: CurvePath,
  add: function (curve) {
    this.curves.push(curve);
  },
  closePath: function () {
    // Add a line curve if start and end of lines are not connected
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);

    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  },
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint: function (t) {
    const d = t * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i = 0; // To think about boundaries points.

    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        const diff = curveLengths[i] - d;
        const curve = this.curves[i];
        const segmentLength = curve.getLength();
        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u);
      }

      i++;
    }

    return null; // loop where sum != 0, sum > d , sum+1 <d
  },
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength: function () {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  },
  // cacheLengths must be recalculated.
  updateArcLengths: function () {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  },
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths: function () {
    // We use cache values if curves and cache array are same length
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    } // Get length of sub-curve
    // Push sums into cached array


    const lengths = [];
    let sums = 0;

    for (let i = 0, l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }

    this.cacheLengths = lengths;
    return lengths;
  },
  getSpacedPoints: function (divisions) {
    if (divisions === undefined) divisions = 40;
    const points = [];

    for (let i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }

    if (this.autoClose) {
      points.push(points[0]);
    }

    return points;
  },
  getPoints: function (divisions) {
    divisions = divisions || 12;
    const points = [];
    let last;

    for (let i = 0, curves = this.curves; i < curves.length; i++) {
      const curve = curves[i];
      const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);

      for (let j = 0; j < pts.length; j++) {
        const point = pts[j];
        if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

        points.push(point);
        last = point;
      }
    }

    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }

    return points;
  },
  copy: function (source) {
    Curve.prototype.copy.call(this, source);
    this.curves = [];

    for (let i = 0, l = source.curves.length; i < l; i++) {
      const curve = source.curves[i];
      this.curves.push(curve.clone());
    }

    this.autoClose = source.autoClose;
    return this;
  },
  toJSON: function () {
    const data = Curve.prototype.toJSON.call(this);
    data.autoClose = this.autoClose;
    data.curves = [];

    for (let i = 0, l = this.curves.length; i < l; i++) {
      const curve = this.curves[i];
      data.curves.push(curve.toJSON());
    }

    return data;
  },
  fromJSON: function (json) {
    Curve.prototype.fromJSON.call(this, json);
    this.autoClose = json.autoClose;
    this.curves = [];

    for (let i = 0, l = json.curves.length; i < l; i++) {
      const curve = json.curves[i];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }

    return this;
  }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 **/

function Path(points) {
  CurvePath.call(this);
  this.type = 'Path';
  this.currentPoint = new Vector2();

  if (points) {
    this.setFromPoints(points);
  }
}

Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
  constructor: Path,
  setFromPoints: function (points) {
    this.moveTo(points[0].x, points[0].y);

    for (let i = 1, l = points.length; i < l; i++) {
      this.lineTo(points[i].x, points[i].y);
    }

    return this;
  },
  moveTo: function (x, y) {
    this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

    return this;
  },
  lineTo: function (x, y) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
    this.curves.push(curve);
    this.currentPoint.set(x, y);
    return this;
  },
  quadraticCurveTo: function (aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  },
  bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  },
  splineThru: function (pts
  /*Array of Vector*/
  ) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  },
  arc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  },
  absarc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  },
  ellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  },
  absellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

    if (this.curves.length > 0) {
      // if a previous curve is present, attempt to join
      const firstPoint = curve.getPoint(0);

      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }

    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  },
  copy: function (source) {
    CurvePath.prototype.copy.call(this, source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  },
  toJSON: function () {
    const data = CurvePath.prototype.toJSON.call(this);
    data.currentPoint = this.currentPoint.toArray();
    return data;
  },
  fromJSON: function (json) {
    CurvePath.prototype.fromJSON.call(this, json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/
// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

function Shape(points) {
  Path.call(this, points);
  this.uuid = MathUtils.generateUUID();
  this.type = 'Shape';
  this.holes = [];
}

Shape.prototype = Object.assign(Object.create(Path.prototype), {
  constructor: Shape,
  getPointsHoles: function (divisions) {
    const holesPts = [];

    for (let i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }

    return holesPts;
  },
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints: function (divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  },
  copy: function (source) {
    Path.prototype.copy.call(this, source);
    this.holes = [];

    for (let i = 0, l = source.holes.length; i < l; i++) {
      const hole = source.holes[i];
      this.holes.push(hole.clone());
    }

    return this;
  },
  toJSON: function () {
    const data = Path.prototype.toJSON.call(this);
    data.uuid = this.uuid;
    data.holes = [];

    for (let i = 0, l = this.holes.length; i < l; i++) {
      const hole = this.holes[i];
      data.holes.push(hole.toJSON());
    }

    return data;
  },
  fromJSON: function (json) {
    Path.prototype.fromJSON.call(this, json);
    this.uuid = json.uuid;
    this.holes = [];

    for (let i = 0, l = json.holes.length; i < l; i++) {
      const hole = json.holes[i];
      this.holes.push(new Path().fromJSON(hole));
    }

    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Light(color, intensity) {
  Object3D.call(this);
  this.type = 'Light';
  this.color = new Color(color);
  this.intensity = intensity !== undefined ? intensity : 1;
  this.receiveShadow = undefined;
}

Light.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Light,
  isLight: true,
  copy: function (source) {
    Object3D.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  },
  toJSON: function (meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== undefined) data.object.distance = this.distance;
    if (this.angle !== undefined) data.object.angle = this.angle;
    if (this.decay !== undefined) data.object.decay = this.decay;
    if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
    if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
    return data;
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */

function HemisphereLight(skyColor, groundColor, intensity) {
  Light.call(this, skyColor, intensity);
  this.type = 'HemisphereLight';
  this.castShadow = undefined;
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.groundColor = new Color(groundColor);
}

HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: HemisphereLight,
  isHemisphereLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.groundColor.copy(source.groundColor);
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function LightShadow(camera) {
  this.camera = camera;
  this.bias = 0;
  this.normalBias = 0;
  this.radius = 1;
  this.mapSize = new Vector2(512, 512);
  this.map = null;
  this.mapPass = null;
  this.matrix = new Matrix4();
  this.autoUpdate = true;
  this.needsUpdate = false;
  this._frustum = new Frustum();
  this._frameExtents = new Vector2(1, 1);
  this._viewportCount = 1;
  this._viewports = [new Vector4(0, 0, 1, 1)];
}

Object.assign(LightShadow.prototype, {
  _projScreenMatrix: new Matrix4(),
  _lightPositionWorld: new Vector3(),
  _lookTarget: new Vector3(),
  getViewportCount: function () {
    return this._viewportCount;
  },
  getFrustum: function () {
    return this._frustum;
  },
  updateMatrices: function (light) {
    const shadowCamera = this.camera,
          shadowMatrix = this.matrix,
          projScreenMatrix = this._projScreenMatrix,
          lookTarget = this._lookTarget,
          lightPositionWorld = this._lightPositionWorld;
    lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(lightPositionWorld);
    lookTarget.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(lookTarget);
    shadowCamera.updateMatrixWorld();
    projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);

    this._frustum.setFromProjectionMatrix(projScreenMatrix);

    shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
  },
  getViewport: function (viewportIndex) {
    return this._viewports[viewportIndex];
  },
  getFrameExtents: function () {
    return this._frameExtents;
  },
  copy: function (source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  toJSON: function () {
    const object = {};
    if (this.bias !== 0) object.bias = this.bias;
    if (this.normalBias !== 0) object.normalBias = this.normalBias;
    if (this.radius !== 1) object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function SpotLightShadow() {
  LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
}

SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: SpotLightShadow,
  isSpotLightShadow: true,
  updateMatrices: function (light) {
    const camera = this.camera;
    const fov = MathUtils.RAD2DEG * 2 * light.angle;
    const aspect = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;

    if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
      camera.fov = fov;
      camera.aspect = aspect;
      camera.far = far;
      camera.updateProjectionMatrix();
    }

    LightShadow.prototype.updateMatrices.call(this, light);
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */

function SpotLight(color, intensity, distance, angle, penumbra, decay) {
  Light.call(this, color, intensity);
  this.type = 'SpotLight';
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.target = new Object3D();
  Object.defineProperty(this, 'power', {
    get: function () {
      // intensity = power per solid angle.
      // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      return this.intensity * Math.PI;
    },
    set: function (power) {
      // intensity = power per solid angle.
      // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      this.intensity = power / Math.PI;
    }
  });
  this.distance = distance !== undefined ? distance : 0;
  this.angle = angle !== undefined ? angle : Math.PI / 3;
  this.penumbra = penumbra !== undefined ? penumbra : 0;
  this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.

  this.shadow = new SpotLightShadow();
}

SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: SpotLight,
  isSpotLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
});

function PointLightShadow() {
  LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500));
  this._frameExtents = new Vector2(4, 2);
  this._viewportCount = 6;
  this._viewports = [// These viewports map a cube-map onto a 2D texture with the
  // following orientation:
  //
  //  xzXZ
  //   y Y
  //
  // X - Positive x direction
  // x - Negative x direction
  // Y - Positive y direction
  // y - Negative y direction
  // Z - Positive z direction
  // z - Negative z direction
  // positive X
  new Vector4(2, 1, 1, 1), // negative X
  new Vector4(0, 1, 1, 1), // positive Z
  new Vector4(3, 1, 1, 1), // negative Z
  new Vector4(1, 1, 1, 1), // positive Y
  new Vector4(3, 0, 1, 1), // negative Y
  new Vector4(1, 0, 1, 1)];
  this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
  this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
}

PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: PointLightShadow,
  isPointLightShadow: true,
  updateMatrices: function (light, viewportIndex) {
    if (viewportIndex === undefined) viewportIndex = 0;
    const camera = this.camera,
          shadowMatrix = this.matrix,
          lightPositionWorld = this._lightPositionWorld,
          lookTarget = this._lookTarget,
          projScreenMatrix = this._projScreenMatrix;
    lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(lightPositionWorld);
    lookTarget.copy(camera.position);
    lookTarget.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-lightPositionWorld.x, -lightPositionWorld.y, -lightPositionWorld.z);
    projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

    this._frustum.setFromProjectionMatrix(projScreenMatrix);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function PointLight(color, intensity, distance, decay) {
  Light.call(this, color, intensity);
  this.type = 'PointLight';
  Object.defineProperty(this, 'power', {
    get: function () {
      // intensity = power per solid angle.
      // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      return this.intensity * 4 * Math.PI;
    },
    set: function (power) {
      // intensity = power per solid angle.
      // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      this.intensity = power / (4 * Math.PI);
    }
  });
  this.distance = distance !== undefined ? distance : 0;
  this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.

  this.shadow = new PointLightShadow();
}

PointLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: PointLight,
  isPointLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 * @author arose / http://github.com/arose
 */

function OrthographicCamera(left, right, top, bottom, near, far) {
  Camera.call(this);
  this.type = 'OrthographicCamera';
  this.zoom = 1;
  this.view = null;
  this.left = left !== undefined ? left : -1;
  this.right = right !== undefined ? right : 1;
  this.top = top !== undefined ? top : 1;
  this.bottom = bottom !== undefined ? bottom : -1;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;
  this.updateProjectionMatrix();
}

OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
  constructor: OrthographicCamera,
  isOrthographicCamera: true,
  copy: function (source, recursive) {
    Camera.prototype.copy.call(this, source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  },
  setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }

    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  },
  clearViewOffset: function () {
    if (this.view !== null) {
      this.view.enabled = false;
    }

    this.updateProjectionMatrix();
  },
  updateProjectionMatrix: function () {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;

    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }

    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
  },
  toJSON: function (meta) {
    const data = Object3D.prototype.toJSON.call(this, meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    return data;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectionalLightShadow() {
  LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
}

DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
  constructor: DirectionalLightShadow,
  isDirectionalLightShadow: true,
  updateMatrices: function (light) {
    LightShadow.prototype.updateMatrices.call(this, light);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function DirectionalLight(color, intensity) {
  Light.call(this, color, intensity);
  this.type = 'DirectionalLight';
  this.position.copy(Object3D.DefaultUp);
  this.updateMatrix();
  this.target = new Object3D();
  this.shadow = new DirectionalLightShadow();
}

DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: DirectionalLight,
  isDirectionalLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function AmbientLight(color, intensity) {
  Light.call(this, color, intensity);
  this.type = 'AmbientLight';
  this.castShadow = undefined;
}

AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: AmbientLight,
  isAmbientLight: true
});
/**
 * @author abelnation / http://github.com/abelnation
 */

function RectAreaLight(color, intensity, width, height) {
  Light.call(this, color, intensity);
  this.type = 'RectAreaLight';
  this.width = width !== undefined ? width : 10;
  this.height = height !== undefined ? height : 10;
}

RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: RectAreaLight,
  isRectAreaLight: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.width = source.width;
    this.height = source.height;
    return this;
  },
  toJSON: function (meta) {
    const data = Light.prototype.toJSON.call(this, meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
});
/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */
// 3-band SH defined by 9 coefficients

function SphericalHarmonics3() {
  this.coefficients = [];

  for (let i = 0; i < 9; i++) {
    this.coefficients.push(new Vector3());
  }
}

Object.assign(SphericalHarmonics3.prototype, {
  isSphericalHarmonics3: true,
  set: function (coefficients) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].copy(coefficients[i]);
    }

    return this;
  },
  zero: function () {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].set(0, 0, 0);
    }

    return this;
  },
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt: function (normal, target) {
    // normal is assumed to be unit length
    const x = normal.x,
          y = normal.y,
          z = normal.z;
    const coeff = this.coefficients; // band 0

    target.copy(coeff[0]).multiplyScalar(0.282095); // band 1

    target.addScaledVector(coeff[1], 0.488603 * y);
    target.addScaledVector(coeff[2], 0.488603 * z);
    target.addScaledVector(coeff[3], 0.488603 * x); // band 2

    target.addScaledVector(coeff[4], 1.092548 * (x * y));
    target.addScaledVector(coeff[5], 1.092548 * (y * z));
    target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
    target.addScaledVector(coeff[7], 1.092548 * (x * z));
    target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
    return target;
  },
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt: function (normal, target) {
    // normal is assumed to be unit length
    const x = normal.x,
          y = normal.y,
          z = normal.z;
    const coeff = this.coefficients; // band 0

    target.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095
    // band 1

    target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603

    target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
    target.addScaledVector(coeff[3], 2.0 * 0.511664 * x); // band 2

    target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548

    target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
    target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3

    target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
    target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274

    return target;
  },
  add: function (sh) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].add(sh.coefficients[i]);
    }

    return this;
  },
  addScaledSH: function (sh, s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].addScaledVector(sh.coefficients[i], s);
    }

    return this;
  },
  scale: function (s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].multiplyScalar(s);
    }

    return this;
  },
  lerp: function (sh, alpha) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].lerp(sh.coefficients[i], alpha);
    }

    return this;
  },
  equals: function (sh) {
    for (let i = 0; i < 9; i++) {
      if (!this.coefficients[i].equals(sh.coefficients[i])) {
        return false;
      }
    }

    return true;
  },
  copy: function (sh) {
    return this.set(sh.coefficients);
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  fromArray: function (array, offset) {
    if (offset === undefined) offset = 0;
    const coefficients = this.coefficients;

    for (let i = 0; i < 9; i++) {
      coefficients[i].fromArray(array, offset + i * 3);
    }

    return this;
  },
  toArray: function (array, offset) {
    if (array === undefined) array = [];
    if (offset === undefined) offset = 0;
    const coefficients = this.coefficients;

    for (let i = 0; i < 9; i++) {
      coefficients[i].toArray(array, offset + i * 3);
    }

    return array;
  }
});
Object.assign(SphericalHarmonics3, {
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  getBasisAt: function (normal, shBasis) {
    // normal is assumed to be unit length
    const x = normal.x,
          y = normal.y,
          z = normal.z; // band 0

    shBasis[0] = 0.282095; // band 1

    shBasis[1] = 0.488603 * y;
    shBasis[2] = 0.488603 * z;
    shBasis[3] = 0.488603 * x; // band 2

    shBasis[4] = 1.092548 * x * y;
    shBasis[5] = 1.092548 * y * z;
    shBasis[6] = 0.315392 * (3 * z * z - 1);
    shBasis[7] = 1.092548 * x * z;
    shBasis[8] = 0.546274 * (x * x - y * y);
  }
});
/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * A LightProbe is a source of indirect-diffuse light
 */

function LightProbe(sh, intensity) {
  Light.call(this, undefined, intensity);
  this.type = 'LightProbe';
  this.sh = sh !== undefined ? sh : new SphericalHarmonics3();
}

LightProbe.prototype = Object.assign(Object.create(Light.prototype), {
  constructor: LightProbe,
  isLightProbe: true,
  copy: function (source) {
    Light.prototype.copy.call(this, source);
    this.sh.copy(source.sh);
    return this;
  },
  fromJSON: function (json) {
    this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();

    this.sh.fromArray(json.sh);
    return this;
  },
  toJSON: function (meta) {
    const data = Light.prototype.toJSON.call(this, meta);
    data.object.sh = this.sh.toArray();
    return data;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function MaterialLoader(manager) {
  Loader.call(this, manager);
  this.textures = {};
}

MaterialLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: MaterialLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.load(url, function (text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }

        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  },
  parse: function (json) {
    const textures = this.textures;

    function getTexture(name) {
      if (textures[name] === undefined) {
        console.warn('THREE.MaterialLoader: Undefined texture', name);
      }

      return textures[name];
    }

    const material = new Materials[json.type]();
    if (json.uuid !== undefined) material.uuid = json.uuid;
    if (json.name !== undefined) material.name = json.name;
    if (json.color !== undefined) material.color.setHex(json.color);
    if (json.roughness !== undefined) material.roughness = json.roughness;
    if (json.metalness !== undefined) material.metalness = json.metalness;
    if (json.sheen !== undefined) material.sheen = new Color().setHex(json.sheen);
    if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
    if (json.specular !== undefined) material.specular.setHex(json.specular);
    if (json.shininess !== undefined) material.shininess = json.shininess;
    if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
    if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
    if (json.fog !== undefined) material.fog = json.fog;
    if (json.flatShading !== undefined) material.flatShading = json.flatShading;
    if (json.blending !== undefined) material.blending = json.blending;
    if (json.combine !== undefined) material.combine = json.combine;
    if (json.side !== undefined) material.side = json.side;
    if (json.opacity !== undefined) material.opacity = json.opacity;
    if (json.transparent !== undefined) material.transparent = json.transparent;
    if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
    if (json.depthTest !== undefined) material.depthTest = json.depthTest;
    if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
    if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
    if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
    if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
    if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
    if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
    if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
    if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
    if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
    if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
    if (json.wireframe !== undefined) material.wireframe = json.wireframe;
    if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
    if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
    if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
    if (json.rotation !== undefined) material.rotation = json.rotation;
    if (json.linewidth !== 1) material.linewidth = json.linewidth;
    if (json.dashSize !== undefined) material.dashSize = json.dashSize;
    if (json.gapSize !== undefined) material.gapSize = json.gapSize;
    if (json.scale !== undefined) material.scale = json.scale;
    if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
    if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
    if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
    if (json.skinning !== undefined) material.skinning = json.skinning;
    if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
    if (json.morphNormals !== undefined) material.morphNormals = json.morphNormals;
    if (json.dithering !== undefined) material.dithering = json.dithering;
    if (json.vertexTangents !== undefined) material.vertexTangents = json.vertexTangents;
    if (json.visible !== undefined) material.visible = json.visible;
    if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
    if (json.userData !== undefined) material.userData = json.userData;

    if (json.vertexColors !== undefined) {
      if (typeof json.vertexColors === 'number') {
        material.vertexColors = json.vertexColors > 0 ? true : false;
      } else {
        material.vertexColors = json.vertexColors;
      }
    } // Shader Material


    if (json.uniforms !== undefined) {
      for (const name in json.uniforms) {
        const uniform = json.uniforms[name];
        material.uniforms[name] = {};

        switch (uniform.type) {
          case 't':
            material.uniforms[name].value = getTexture(uniform.value);
            break;

          case 'c':
            material.uniforms[name].value = new Color().setHex(uniform.value);
            break;

          case 'v2':
            material.uniforms[name].value = new Vector2().fromArray(uniform.value);
            break;

          case 'v3':
            material.uniforms[name].value = new Vector3().fromArray(uniform.value);
            break;

          case 'v4':
            material.uniforms[name].value = new Vector4().fromArray(uniform.value);
            break;

          case 'm3':
            material.uniforms[name].value = new Matrix3().fromArray(uniform.value);

          case 'm4':
            material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
            break;

          default:
            material.uniforms[name].value = uniform.value;
        }
      }
    }

    if (json.defines !== undefined) material.defines = json.defines;
    if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
    if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;

    if (json.extensions !== undefined) {
      for (const key in json.extensions) {
        material.extensions[key] = json.extensions[key];
      }
    } // Deprecated


    if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
    // for PointsMaterial

    if (json.size !== undefined) material.size = json.size;
    if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation; // maps

    if (json.map !== undefined) material.map = getTexture(json.map);
    if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
    if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
    if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
    if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
    if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
    if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;

    if (json.normalScale !== undefined) {
      let normalScale = json.normalScale;

      if (Array.isArray(normalScale) === false) {
        // Blender exporter used to export a scalar. See #7459
        normalScale = [normalScale, normalScale];
      }

      material.normalScale = new Vector2().fromArray(normalScale);
    }

    if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
    if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
    if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
    if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
    if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
    if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
    if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
    if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
    if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
    if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
    if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
    if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
    if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
    if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
    if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
    if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
    if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
    if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
    if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
    if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
    if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
    return material;
  },
  setTextures: function (value) {
    this.textures = value;
    return this;
  }
});
/**
 * @author Don McCurdy / https://www.donmccurdy.com
 */

const LoaderUtils = {
  decodeText: function (array) {
    if (typeof TextDecoder !== 'undefined') {
      return new TextDecoder().decode(array);
    } // Avoid the String.fromCharCode.apply(null, array) shortcut, which
    // throws a "maximum call stack size exceeded" error for large arrays.


    let s = '';

    for (let i = 0, il = array.length; i < il; i++) {
      // Implicitly assumes little-endian.
      s += String.fromCharCode(array[i]);
    }

    try {
      // merges multi-byte utf-8 characters.
      return decodeURIComponent(escape(s));
    } catch (e) {
      // see #16358
      return s;
    }
  },
  extractUrlBase: function (url) {
    const index = url.lastIndexOf('/');
    if (index === -1) return './';
    return url.substr(0, index + 1);
  }
};
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

exports.LoaderUtils = LoaderUtils;

function InstancedBufferGeometry() {
  BufferGeometry.call(this);
  this.type = 'InstancedBufferGeometry';
  this.instanceCount = Infinity;
}

InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
  constructor: InstancedBufferGeometry,
  isInstancedBufferGeometry: true,
  copy: function (source) {
    BufferGeometry.prototype.copy.call(this, source);
    this.instanceCount = source.instanceCount;
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  toJSON: function () {
    const data = BufferGeometry.prototype.toJSON.call(this);
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
});
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
  if (typeof normalized === 'number') {
    meshPerAttribute = normalized;
    normalized = false;
    console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
  }

  BufferAttribute.call(this, array, itemSize, normalized);
  this.meshPerAttribute = meshPerAttribute || 1;
}

InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
  constructor: InstancedBufferAttribute,
  isInstancedBufferAttribute: true,
  copy: function (source) {
    BufferAttribute.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  toJSON: function () {
    const data = BufferAttribute.prototype.toJSON.call(this);
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function BufferGeometryLoader(manager) {
  Loader.call(this, manager);
}

BufferGeometryLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: BufferGeometryLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.load(url, function (text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }

        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  },
  parse: function (json) {
    const interleavedBufferMap = {};
    const arrayBufferMap = {};

    function getInterleavedBuffer(json, uuid) {
      if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
      const interleavedBuffers = json.interleavedBuffers;
      const interleavedBuffer = interleavedBuffers[uuid];
      const buffer = getArrayBuffer(json, interleavedBuffer.buffer);
      const array = new TYPED_ARRAYS[interleavedBuffer.type](buffer);
      const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
      ib.uuid = interleavedBuffer.uuid;
      interleavedBufferMap[uuid] = ib;
      return ib;
    }

    function getArrayBuffer(json, uuid) {
      if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
      const arrayBuffers = json.arrayBuffers;
      const arrayBuffer = arrayBuffers[uuid];
      const ab = new Uint32Array(arrayBuffer).buffer;
      arrayBufferMap[uuid] = ab;
      return ab;
    }

    const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
    const index = json.data.index;

    if (index !== undefined) {
      const typedArray = new TYPED_ARRAYS[index.type](index.array);
      geometry.setIndex(new BufferAttribute(typedArray, 1));
    }

    const attributes = json.data.attributes;

    for (const key in attributes) {
      const attribute = attributes[key];
      let bufferAttribute;

      if (attribute.isInterleavedBufferAttribute) {
        const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
        bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
      } else {
        const typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
        const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
        bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
      }

      if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
      geometry.setAttribute(key, bufferAttribute);
    }

    const morphAttributes = json.data.morphAttributes;

    if (morphAttributes) {
      for (const key in morphAttributes) {
        const attributeArray = morphAttributes[key];
        const array = [];

        for (let i = 0, il = attributeArray.length; i < il; i++) {
          const attribute = attributeArray[i];
          let bufferAttribute;

          if (attribute.isInterleavedBufferAttribute) {
            const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
          } else {
            const typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
            bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
          }

          if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
          array.push(bufferAttribute);
        }

        geometry.morphAttributes[key] = array;
      }
    }

    const morphTargetsRelative = json.data.morphTargetsRelative;

    if (morphTargetsRelative) {
      geometry.morphTargetsRelative = true;
    }

    const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

    if (groups !== undefined) {
      for (let i = 0, n = groups.length; i !== n; ++i) {
        const group = groups[i];
        geometry.addGroup(group.start, group.count, group.materialIndex);
      }
    }

    const boundingSphere = json.data.boundingSphere;

    if (boundingSphere !== undefined) {
      const center = new Vector3();

      if (boundingSphere.center !== undefined) {
        center.fromArray(boundingSphere.center);
      }

      geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
    }

    if (json.name) geometry.name = json.name;
    if (json.userData) geometry.userData = json.userData;
    return geometry;
  }
});
const TYPED_ARRAYS = {
  Int8Array: Int8Array,
  Uint8Array: Uint8Array,
  // Workaround for IE11 pre KB2929437. See #11440
  Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
  Int16Array: Int16Array,
  Uint16Array: Uint16Array,
  Int32Array: Int32Array,
  Uint32Array: Uint32Array,
  Float32Array: Float32Array,
  Float64Array: Float64Array
};
/**
 * @author mrdoob / http://mrdoob.com/
 */

function ObjectLoader(manager) {
  Loader.call(this, manager);
}

ObjectLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ObjectLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    const loader = new FileLoader(scope.manager);
    loader.setPath(this.path);
    loader.load(url, function (text) {
      let json = null;

      try {
        json = JSON.parse(text);
      } catch (error) {
        if (onError !== undefined) onError(error);
        console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
        return;
      }

      const metadata = json.metadata;

      if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
        console.error('THREE.ObjectLoader: Can\'t load ' + url);
        return;
      }

      scope.parse(json, onLoad);
    }, onProgress, onError);
  },
  parse: function (json, onLoad) {
    const shapes = this.parseShape(json.shapes);
    const geometries = this.parseGeometries(json.geometries, shapes);
    const images = this.parseImages(json.images, function () {
      if (onLoad !== undefined) onLoad(object);
    });
    const textures = this.parseTextures(json.textures, images);
    const materials = this.parseMaterials(json.materials, textures);
    const object = this.parseObject(json.object, geometries, materials);

    if (json.animations) {
      object.animations = this.parseAnimations(json.animations);
    }

    if (json.images === undefined || json.images.length === 0) {
      if (onLoad !== undefined) onLoad(object);
    }

    return object;
  },
  parseShape: function (json) {
    const shapes = {};

    if (json !== undefined) {
      for (let i = 0, l = json.length; i < l; i++) {
        const shape = new Shape().fromJSON(json[i]);
        shapes[shape.uuid] = shape;
      }
    }

    return shapes;
  },
  parseGeometries: function (json, shapes) {
    const geometries = {};
    let geometryShapes;

    if (json !== undefined) {
      const bufferGeometryLoader = new BufferGeometryLoader();

      for (let i = 0, l = json.length; i < l; i++) {
        let geometry;
        const data = json[i];

        switch (data.type) {
          case 'PlaneGeometry':
          case 'PlaneBufferGeometry':
            geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
            break;

          case 'BoxGeometry':
          case 'BoxBufferGeometry':
          case 'CubeGeometry':
            // backwards compatible
            geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
            break;

          case 'CircleGeometry':
          case 'CircleBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
            break;

          case 'CylinderGeometry':
          case 'CylinderBufferGeometry':
            geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            break;

          case 'ConeGeometry':
          case 'ConeBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
            break;

          case 'SphereGeometry':
          case 'SphereBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
            break;

          case 'DodecahedronGeometry':
          case 'DodecahedronBufferGeometry':
          case 'IcosahedronGeometry':
          case 'IcosahedronBufferGeometry':
          case 'OctahedronGeometry':
          case 'OctahedronBufferGeometry':
          case 'TetrahedronGeometry':
          case 'TetrahedronBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.detail);
            break;

          case 'RingGeometry':
          case 'RingBufferGeometry':
            geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
            break;

          case 'TorusGeometry':
          case 'TorusBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
            break;

          case 'TorusKnotGeometry':
          case 'TorusKnotBufferGeometry':
            geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
            break;

          case 'TubeGeometry':
          case 'TubeBufferGeometry':
            // This only works for built-in curves (e.g. CatmullRomCurve3).
            // User defined curves or instances of CurvePath will not be deserialized.
            geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
            break;

          case 'LatheGeometry':
          case 'LatheBufferGeometry':
            geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
            break;

          case 'PolyhedronGeometry':
          case 'PolyhedronBufferGeometry':
            geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
            break;

          case 'ShapeGeometry':
          case 'ShapeBufferGeometry':
            geometryShapes = [];

            for (let j = 0, jl = data.shapes.length; j < jl; j++) {
              const shape = shapes[data.shapes[j]];
              geometryShapes.push(shape);
            }

            geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
            break;

          case 'ExtrudeGeometry':
          case 'ExtrudeBufferGeometry':
            geometryShapes = [];

            for (let j = 0, jl = data.shapes.length; j < jl; j++) {
              const shape = shapes[data.shapes[j]];
              geometryShapes.push(shape);
            }

            const extrudePath = data.options.extrudePath;

            if (extrudePath !== undefined) {
              data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
            }

            geometry = new Geometries[data.type](geometryShapes, data.options);
            break;

          case 'BufferGeometry':
          case 'InstancedBufferGeometry':
            geometry = bufferGeometryLoader.parse(data);
            break;

          case 'Geometry':
            console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
            break;

          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
            continue;
        }

        geometry.uuid = data.uuid;
        if (data.name !== undefined) geometry.name = data.name;
        if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
        geometries[data.uuid] = geometry;
      }
    }

    return geometries;
  },
  parseMaterials: function (json, textures) {
    const cache = {}; // MultiMaterial

    const materials = {};

    if (json !== undefined) {
      const loader = new MaterialLoader();
      loader.setTextures(textures);

      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];

        if (data.type === 'MultiMaterial') {
          // Deprecated
          const array = [];

          for (let j = 0; j < data.materials.length; j++) {
            const material = data.materials[j];

            if (cache[material.uuid] === undefined) {
              cache[material.uuid] = loader.parse(material);
            }

            array.push(cache[material.uuid]);
          }

          materials[data.uuid] = array;
        } else {
          if (cache[data.uuid] === undefined) {
            cache[data.uuid] = loader.parse(data);
          }

          materials[data.uuid] = cache[data.uuid];
        }
      }
    }

    return materials;
  },
  parseAnimations: function (json) {
    const animations = [];

    for (let i = 0; i < json.length; i++) {
      const data = json[i];
      const clip = AnimationClip.parse(data);
      if (data.uuid !== undefined) clip.uuid = data.uuid;
      animations.push(clip);
    }

    return animations;
  },
  parseImages: function (json, onLoad) {
    const scope = this;
    const images = {};
    let loader;

    function loadImage(url) {
      scope.manager.itemStart(url);
      return loader.load(url, function () {
        scope.manager.itemEnd(url);
      }, undefined, function () {
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
    }

    if (json !== undefined && json.length > 0) {
      const manager = new LoadingManager(onLoad);
      loader = new ImageLoader(manager);
      loader.setCrossOrigin(this.crossOrigin);

      for (let i = 0, il = json.length; i < il; i++) {
        const image = json[i];
        const url = image.url;

        if (Array.isArray(url)) {
          // load array of images e.g CubeTexture
          images[image.uuid] = [];

          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j];
            const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl) ? currentUrl : scope.resourcePath + currentUrl;
            images[image.uuid].push(loadImage(path));
          }
        } else {
          // load single image
          const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.resourcePath + image.url;
          images[image.uuid] = loadImage(path);
        }
      }
    }

    return images;
  },
  parseTextures: function (json, images) {
    function parseConstant(value, type) {
      if (typeof value === 'number') return value;
      console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
      return type[value];
    }

    const textures = {};

    if (json !== undefined) {
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];

        if (data.image === undefined) {
          console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
        }

        if (images[data.image] === undefined) {
          console.warn('THREE.ObjectLoader: Undefined image', data.image);
        }

        let texture;

        if (Array.isArray(images[data.image])) {
          texture = new CubeTexture(images[data.image]);
        } else {
          texture = new Texture(images[data.image]);
        }

        texture.needsUpdate = true;
        texture.uuid = data.uuid;
        if (data.name !== undefined) texture.name = data.name;
        if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
        if (data.offset !== undefined) texture.offset.fromArray(data.offset);
        if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
        if (data.center !== undefined) texture.center.fromArray(data.center);
        if (data.rotation !== undefined) texture.rotation = data.rotation;

        if (data.wrap !== undefined) {
          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
        }

        if (data.format !== undefined) texture.format = data.format;
        if (data.type !== undefined) texture.type = data.type;
        if (data.encoding !== undefined) texture.encoding = data.encoding;
        if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
        if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
        if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
        if (data.flipY !== undefined) texture.flipY = data.flipY;
        if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
        if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
        textures[data.uuid] = texture;
      }
    }

    return textures;
  },
  parseObject: function (data, geometries, materials) {
    let object;

    function getGeometry(name) {
      if (geometries[name] === undefined) {
        console.warn('THREE.ObjectLoader: Undefined geometry', name);
      }

      return geometries[name];
    }

    function getMaterial(name) {
      if (name === undefined) return undefined;

      if (Array.isArray(name)) {
        const array = [];

        for (let i = 0, l = name.length; i < l; i++) {
          const uuid = name[i];

          if (materials[uuid] === undefined) {
            console.warn('THREE.ObjectLoader: Undefined material', uuid);
          }

          array.push(materials[uuid]);
        }

        return array;
      }

      if (materials[name] === undefined) {
        console.warn('THREE.ObjectLoader: Undefined material', name);
      }

      return materials[name];
    }

    let geometry, material;

    switch (data.type) {
      case 'Scene':
        object = new Scene();

        if (data.background !== undefined) {
          if (Number.isInteger(data.background)) {
            object.background = new Color(data.background);
          }
        }

        if (data.fog !== undefined) {
          if (data.fog.type === 'Fog') {
            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
          } else if (data.fog.type === 'FogExp2') {
            object.fog = new FogExp2(data.fog.color, data.fog.density);
          }
        }

        break;

      case 'PerspectiveCamera':
        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
        if (data.focus !== undefined) object.focus = data.focus;
        if (data.zoom !== undefined) object.zoom = data.zoom;
        if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
        if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
        if (data.view !== undefined) object.view = Object.assign({}, data.view);
        break;

      case 'OrthographicCamera':
        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
        if (data.zoom !== undefined) object.zoom = data.zoom;
        if (data.view !== undefined) object.view = Object.assign({}, data.view);
        break;

      case 'AmbientLight':
        object = new AmbientLight(data.color, data.intensity);
        break;

      case 'DirectionalLight':
        object = new DirectionalLight(data.color, data.intensity);
        break;

      case 'PointLight':
        object = new PointLight(data.color, data.intensity, data.distance, data.decay);
        break;

      case 'RectAreaLight':
        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
        break;

      case 'SpotLight':
        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
        break;

      case 'HemisphereLight':
        object = new HemisphereLight(data.color, data.groundColor, data.intensity);
        break;

      case 'LightProbe':
        object = new LightProbe().fromJSON(data);
        break;

      case 'SkinnedMesh':
        console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');

      case 'Mesh':
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new Mesh(geometry, material);
        break;

      case 'InstancedMesh':
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        const count = data.count;
        const instanceMatrix = data.instanceMatrix;
        object = new InstancedMesh(geometry, material, count);
        object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
        break;

      case 'LOD':
        object = new LOD();
        break;

      case 'Line':
        object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
        break;

      case 'LineLoop':
        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
        break;

      case 'LineSegments':
        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
        break;

      case 'PointCloud':
      case 'Points':
        object = new Points(getGeometry(data.geometry), getMaterial(data.material));
        break;

      case 'Sprite':
        object = new Sprite(getMaterial(data.material));
        break;

      case 'Group':
        object = new Group();
        break;

      default:
        object = new Object3D();
    }

    object.uuid = data.uuid;
    if (data.name !== undefined) object.name = data.name;

    if (data.matrix !== undefined) {
      object.matrix.fromArray(data.matrix);
      if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
      if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
    } else {
      if (data.position !== undefined) object.position.fromArray(data.position);
      if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
      if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
      if (data.scale !== undefined) object.scale.fromArray(data.scale);
    }

    if (data.castShadow !== undefined) object.castShadow = data.castShadow;
    if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;

    if (data.shadow) {
      if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
      if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
      if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
      if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
      if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
    }

    if (data.visible !== undefined) object.visible = data.visible;
    if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
    if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
    if (data.userData !== undefined) object.userData = data.userData;
    if (data.layers !== undefined) object.layers.mask = data.layers;

    if (data.children !== undefined) {
      const children = data.children;

      for (let i = 0; i < children.length; i++) {
        object.add(this.parseObject(children[i], geometries, materials));
      }
    }

    if (data.type === 'LOD') {
      if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
      const levels = data.levels;

      for (let l = 0; l < levels.length; l++) {
        const level = levels[l];
        const child = object.getObjectByProperty('uuid', level.object);

        if (child !== undefined) {
          object.addLevel(child, level.distance);
        }
      }
    }

    return object;
  }
});
const TEXTURE_MAPPING = {
  UVMapping: UVMapping,
  CubeReflectionMapping: CubeReflectionMapping,
  CubeRefractionMapping: CubeRefractionMapping,
  EquirectangularReflectionMapping: EquirectangularReflectionMapping,
  EquirectangularRefractionMapping: EquirectangularRefractionMapping,
  CubeUVReflectionMapping: CubeUVReflectionMapping,
  CubeUVRefractionMapping: CubeUVRefractionMapping
};
const TEXTURE_WRAPPING = {
  RepeatWrapping: RepeatWrapping,
  ClampToEdgeWrapping: ClampToEdgeWrapping,
  MirroredRepeatWrapping: MirroredRepeatWrapping
};
const TEXTURE_FILTER = {
  NearestFilter: NearestFilter,
  NearestMipmapNearestFilter: NearestMipmapNearestFilter,
  NearestMipmapLinearFilter: NearestMipmapLinearFilter,
  LinearFilter: LinearFilter,
  LinearMipmapNearestFilter: LinearMipmapNearestFilter,
  LinearMipmapLinearFilter: LinearMipmapLinearFilter
};
/**
 * @author thespite / http://clicktorelease.com/
 */

function ImageBitmapLoader(manager) {
  if (typeof createImageBitmap === 'undefined') {
    console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
  }

  if (typeof fetch === 'undefined') {
    console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
  }

  Loader.call(this, manager);
  this.options = {
    premultiplyAlpha: 'none'
  };
}

ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: ImageBitmapLoader,
  isImageBitmapLoader: true,
  setOptions: function setOptions(options) {
    this.options = options;
    return this;
  },
  load: function (url, onLoad, onProgress, onError) {
    if (url === undefined) url = '';
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);

    if (cached !== undefined) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }

    fetch(url).then(function (res) {
      return res.blob();
    }).then(function (blob) {
      return createImageBitmap(blob, scope.options);
    }).then(function (imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad) onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function (e) {
      if (onError) onError(e);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
 **/

function ShapePath() {
  this.type = 'ShapePath';
  this.color = new Color();
  this.subPaths = [];
  this.currentPath = null;
}

Object.assign(ShapePath.prototype, {
  moveTo: function (x, y) {
    this.currentPath = new Path();
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(x, y);
    return this;
  },
  lineTo: function (x, y) {
    this.currentPath.lineTo(x, y);
    return this;
  },
  quadraticCurveTo: function (aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
    return this;
  },
  bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
    return this;
  },
  splineThru: function (pts) {
    this.currentPath.splineThru(pts);
    return this;
  },
  toShapes: function (isCCW, noHoles) {
    function toShapesNoHoles(inSubpaths) {
      const shapes = [];

      for (let i = 0, l = inSubpaths.length; i < l; i++) {
        const tmpPath = inSubpaths[i];
        const tmpShape = new Shape();
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
      }

      return shapes;
    }

    function isPointInsidePolygon(inPt, inPolygon) {
      const polyLen = inPolygon.length; // inPt on polygon contour => immediate success    or
      // toggling of inside/outside at every single! intersection point of an edge
      //  with the horizontal line through inPt, left of inPt
      //  not counting lowerY endpoints of edges and whole edges on that line

      let inside = false;

      for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
        let edgeLowPt = inPolygon[p];
        let edgeHighPt = inPolygon[q];
        let edgeDx = edgeHighPt.x - edgeLowPt.x;
        let edgeDy = edgeHighPt.y - edgeLowPt.y;

        if (Math.abs(edgeDy) > Number.EPSILON) {
          // not parallel
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p];
            edgeDy = -edgeDy;
          }

          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;

          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
            // continue;				// no intersection or edgeLowPt => doesn't count !!!
          } else {
            const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0) return true; // inPt is on contour ?

            if (perpEdge < 0) continue;
            inside = !inside; // true intersection left of inPt
          }
        } else {
          // parallel or collinear
          if (inPt.y !== edgeLowPt.y) continue; // parallel
          // edge lies on the same horizontal line as inPt

          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
          // continue;
        }
      }

      return inside;
    }

    const isClockWise = ShapeUtils.isClockWise;
    const subPaths = this.subPaths;
    if (subPaths.length === 0) return [];
    if (noHoles === true) return toShapesNoHoles(subPaths);
    let solid,
        tmpPath,
        tmpShape,
        shapes = [];

    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new Shape();
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }

    let holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst; // console.log("Holes first", holesFirst);

    const betterShapeHoles = [];
    const newShapes = [];
    let newShapeHoles = [];
    let mainIdx = 0;
    let tmpPoints;
    newShapes[mainIdx] = undefined;
    newShapeHoles[mainIdx] = [];

    for (let i = 0, l = subPaths.length; i < l; i++) {
      tmpPath = subPaths[i];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;

      if (solid) {
        if (!holesFirst && newShapes[mainIdx]) mainIdx++;
        newShapes[mainIdx] = {
          s: new Shape(),
          p: tmpPoints
        };
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst) mainIdx++;
        newShapeHoles[mainIdx] = []; //console.log('cw', i);
      } else {
        newShapeHoles[mainIdx].push({
          h: tmpPath,
          p: tmpPoints[0]
        }); //console.log('ccw', i);
      }
    } // only Holes? -> probably all Shapes with wrong orientation


    if (!newShapes[0]) return toShapesNoHoles(subPaths);

    if (newShapes.length > 1) {
      let ambiguous = false;
      const toChange = [];

      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }

      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        const sho = newShapeHoles[sIdx];

        for (let hIdx = 0; hIdx < sho.length; hIdx++) {
          const ho = sho[hIdx];
          let hole_unassigned = true;

          for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx) toChange.push({
                froms: sIdx,
                tos: s2Idx,
                hole: hIdx
              });

              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }

          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      } // console.log("ambiguous: ", ambiguous);


      if (toChange.length > 0) {
        // console.log("to change: ", toChange);
        if (!ambiguous) newShapeHoles = betterShapeHoles;
      }
    }

    let tmpHoles;

    for (let i = 0, il = newShapes.length; i < il; i++) {
      tmpShape = newShapes[i].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i];

      for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
        tmpShape.holes.push(tmpHoles[j].h);
      }
    } //console.log("shape", shapes);


    return shapes;
  }
});
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author mrdoob / http://mrdoob.com/
 */

function Font(data) {
  this.type = 'Font';
  this.data = data;
}

Object.assign(Font.prototype, {
  isFont: true,
  generateShapes: function (text, size) {
    if (size === undefined) size = 100;
    const shapes = [];
    const paths = createPaths(text, size, this.data);

    for (let p = 0, pl = paths.length; p < pl; p++) {
      Array.prototype.push.apply(shapes, paths[p].toShapes());
    }

    return shapes;
  }
});

function createPaths(text, size, data) {
  const chars = Array.from ? Array.from(text) : String(text).split(''); // workaround for IE11, see #13988

  const scale = size / data.resolution;
  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
  const paths = [];
  let offsetX = 0,
      offsetY = 0;

  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];

    if (char === '\n') {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      const ret = createPath(char, scale, offsetX, offsetY, data);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }

  return paths;
}

function createPath(char, scale, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs['?'];

  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
    return;
  }

  const path = new ShapePath();
  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

    for (let i = 0, l = outline.length; i < l;) {
      const action = outline[i++];

      switch (action) {
        case 'm':
          // moveTo
          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.moveTo(x, y);
          break;

        case 'l':
          // lineTo
          x = outline[i++] * scale + offsetX;
          y = outline[i++] * scale + offsetY;
          path.lineTo(x, y);
          break;

        case 'q':
          // quadraticCurveTo
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;

        case 'b':
          // bezierCurveTo
          cpx = outline[i++] * scale + offsetX;
          cpy = outline[i++] * scale + offsetY;
          cpx1 = outline[i++] * scale + offsetX;
          cpy1 = outline[i++] * scale + offsetY;
          cpx2 = outline[i++] * scale + offsetX;
          cpy2 = outline[i++] * scale + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }

  return {
    offsetX: glyph.ha * scale,
    path: path
  };
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function FontLoader(manager) {
  Loader.call(this, manager);
}

FontLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: FontLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.load(url, function (text) {
      let json;

      try {
        json = JSON.parse(text);
      } catch (e) {
        console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
        json = JSON.parse(text.substring(65, text.length - 2));
      }

      const font = scope.parse(json);
      if (onLoad) onLoad(font);
    }, onProgress, onError);
  },
  parse: function (json) {
    return new Font(json);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

let _context;

const AudioContext = {
  getContext: function () {
    if (_context === undefined) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }

    return _context;
  },
  setContext: function (value) {
    _context = value;
  }
};
/**
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

exports.AudioContext = AudioContext;

function AudioLoader(manager) {
  Loader.call(this, manager);
}

AudioLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: AudioLoader,
  load: function (url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setResponseType('arraybuffer');
    loader.setPath(scope.path);
    loader.load(url, function (buffer) {
      try {
        // Create a copy of the buffer. The `decodeAudioData` method
        // detaches the buffer when complete, preventing reuse.
        const bufferCopy = buffer.slice(0);
        const context = AudioContext.getContext();
        context.decodeAudioData(bufferCopy, function (audioBuffer) {
          onLoad(audioBuffer);
        });
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }

        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
});
/**
 * @author WestLangley / http://github.com/WestLangley
 */

function HemisphereLightProbe(skyColor, groundColor, intensity) {
  LightProbe.call(this, undefined, intensity);
  const color1 = new Color().set(skyColor);
  const color2 = new Color().set(groundColor);
  const sky = new Vector3(color1.r, color1.g, color1.b);
  const ground = new Vector3(color2.r, color2.g, color2.b); // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );

  const c0 = Math.sqrt(Math.PI);
  const c1 = c0 * Math.sqrt(0.75);
  this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
  this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
}

HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
  constructor: HemisphereLightProbe,
  isHemisphereLightProbe: true,
  copy: function (source) {
    // modifying colors not currently supported
    LightProbe.prototype.copy.call(this, source);
    return this;
  },
  toJSON: function (meta) {
    const data = LightProbe.prototype.toJSON.call(this, meta); // data.sh = this.sh.toArray(); // todo

    return data;
  }
});
/**
 * @author WestLangley / http://github.com/WestLangley
 */

function AmbientLightProbe(color, intensity) {
  LightProbe.call(this, undefined, intensity);
  const color1 = new Color().set(color); // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );

  this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
}

AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
  constructor: AmbientLightProbe,
  isAmbientLightProbe: true,
  copy: function (source) {
    // modifying color not currently supported
    LightProbe.prototype.copy.call(this, source);
    return this;
  },
  toJSON: function (meta) {
    const data = LightProbe.prototype.toJSON.call(this, meta); // data.sh = this.sh.toArray(); // todo

    return data;
  }
});

const _eyeRight = new Matrix4();

const _eyeLeft = new Matrix4();
/**
 * @author mrdoob / http://mrdoob.com/
 */


function StereoCamera() {
  this.type = 'StereoCamera';
  this.aspect = 1;
  this.eyeSep = 0.064;
  this.cameraL = new PerspectiveCamera();
  this.cameraL.layers.enable(1);
  this.cameraL.matrixAutoUpdate = false;
  this.cameraR = new PerspectiveCamera();
  this.cameraR.layers.enable(2);
  this.cameraR.matrixAutoUpdate = false;
  this._cache = {
    focus: null,
    fov: null,
    aspect: null,
    near: null,
    far: null,
    zoom: null,
    eyeSep: null
  };
}

Object.assign(StereoCamera.prototype, {
  update: function (camera) {
    const cache = this._cache;
    const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

    if (needsUpdate) {
      cache.focus = camera.focus;
      cache.fov = camera.fov;
      cache.aspect = camera.aspect * this.aspect;
      cache.near = camera.near;
      cache.far = camera.far;
      cache.zoom = camera.zoom;
      cache.eyeSep = this.eyeSep; // Off-axis stereoscopic effect based on
      // http://paulbourke.net/stereographics/stereorender/

      const projectionMatrix = camera.projectionMatrix.clone();
      const eyeSepHalf = cache.eyeSep / 2;
      const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
      const ymax = cache.near * Math.tan(MathUtils.DEG2RAD * cache.fov * 0.5) / cache.zoom;
      let xmin, xmax; // translate xOffset

      _eyeLeft.elements[12] = -eyeSepHalf;
      _eyeRight.elements[12] = eyeSepHalf; // for left eye

      xmin = -ymax * cache.aspect + eyeSepOnProjection;
      xmax = ymax * cache.aspect + eyeSepOnProjection;
      projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraL.projectionMatrix.copy(projectionMatrix); // for right eye

      xmin = -ymax * cache.aspect - eyeSepOnProjection;
      xmax = ymax * cache.aspect - eyeSepOnProjection;
      projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraR.projectionMatrix.copy(projectionMatrix);
    }

    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */

function Clock(autoStart) {
  this.autoStart = autoStart !== undefined ? autoStart : true;
  this.startTime = 0;
  this.oldTime = 0;
  this.elapsedTime = 0;
  this.running = false;
}

Object.assign(Clock.prototype, {
  start: function () {
    this.startTime = (typeof performance === 'undefined' ? Date : performance).now(); // see #10732

    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  },
  stop: function () {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  },
  getElapsedTime: function () {
    this.getDelta();
    return this.elapsedTime;
  },
  getDelta: function () {
    let diff = 0;

    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }

    if (this.running) {
      const newTime = (typeof performance === 'undefined' ? Date : performance).now();
      diff = (newTime - this.oldTime) / 1000;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }

    return diff;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

const _position$2 = new Vector3();

const _quaternion$3 = new Quaternion();

const _scale$1 = new Vector3();

const _orientation = new Vector3();

function AudioListener() {
  Object3D.call(this);
  this.type = 'AudioListener';
  this.context = AudioContext.getContext();
  this.gain = this.context.createGain();
  this.gain.connect(this.context.destination);
  this.filter = null;
  this.timeDelta = 0; // private

  this._clock = new Clock();
}

AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: AudioListener,
  getInput: function () {
    return this.gain;
  },
  removeFilter: function () {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
      this.gain.connect(this.context.destination);
      this.filter = null;
    }

    return this;
  },
  getFilter: function () {
    return this.filter;
  },
  setFilter: function (value) {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
    } else {
      this.gain.disconnect(this.context.destination);
    }

    this.filter = value;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
    return this;
  },
  getMasterVolume: function () {
    return this.gain.gain.value;
  },
  setMasterVolume: function (value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  },
  updateMatrixWorld: function (force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    const listener = this.context.listener;
    const up = this.up;
    this.timeDelta = this._clock.getDelta();
    this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1);

    _orientation.set(0, 0, -1).applyQuaternion(_quaternion$3);

    if (listener.positionX) {
      // code path for Chrome (see #14393)
      const endTime = this.context.currentTime + this.timeDelta;
      listener.positionX.linearRampToValueAtTime(_position$2.x, endTime);
      listener.positionY.linearRampToValueAtTime(_position$2.y, endTime);
      listener.positionZ.linearRampToValueAtTime(_position$2.z, endTime);
      listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
      listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
      listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
      listener.upX.linearRampToValueAtTime(up.x, endTime);
      listener.upY.linearRampToValueAtTime(up.y, endTime);
      listener.upZ.linearRampToValueAtTime(up.z, endTime);
    } else {
      listener.setPosition(_position$2.x, _position$2.y, _position$2.z);
      listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);
    }
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

function Audio(listener) {
  Object3D.call(this);
  this.type = 'Audio';
  this.listener = listener;
  this.context = listener.context;
  this.gain = this.context.createGain();
  this.gain.connect(listener.getInput());
  this.autoplay = false;
  this.buffer = null;
  this.detune = 0;
  this.loop = false;
  this.loopStart = 0;
  this.loopEnd = 0;
  this.offset = 0;
  this.duration = undefined;
  this.playbackRate = 1;
  this.isPlaying = false;
  this.hasPlaybackControl = true;
  this.sourceType = 'empty';
  this._startedAt = 0;
  this._progress = 0;
  this.filters = [];
}

Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
  constructor: Audio,
  getOutput: function () {
    return this.gain;
  },
  setNodeSource: function (audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = 'audioNode';
    this.source = audioNode;
    this.connect();
    return this;
  },
  setMediaElementSource: function (mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = 'mediaNode';
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  },
  setMediaStreamSource: function (mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = 'mediaStreamNode';
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  },
  setBuffer: function (audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = 'buffer';
    if (this.autoplay) this.play();
    return this;
  },
  play: function (delay) {
    if (delay === undefined) delay = 0;

    if (this.isPlaying === true) {
      console.warn('THREE.Audio: Audio is already playing.');
      return;
    }

    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    this._startedAt = this.context.currentTime + delay;
    const source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.loopStart = this.loopStart;
    source.loopEnd = this.loopEnd;
    source.onended = this.onEnded.bind(this);
    source.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  },
  pause: function () {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    if (this.isPlaying === true) {
      // update current progress
      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;

      if (this.loop === true) {
        // ensure _progress does not exceed duration with looped audios
        this._progress = this._progress % (this.duration || this.buffer.duration);
      }

      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }

    return this;
  },
  stop: function () {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    this._progress = 0;
    this.source.stop();
    this.source.onended = null;
    this.isPlaying = false;
    return this;
  },
  connect: function () {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);

      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].connect(this.filters[i]);
      }

      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }

    return this;
  },
  disconnect: function () {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);

      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].disconnect(this.filters[i]);
      }

      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }

    return this;
  },
  getFilters: function () {
    return this.filters;
  },
  setFilters: function (value) {
    if (!value) value = [];

    if (this.isPlaying === true) {
      this.disconnect();
      this.filters = value;
      this.connect();
    } else {
      this.filters = value;
    }

    return this;
  },
  setDetune: function (value) {
    this.detune = value;
    if (this.source.detune === undefined) return; // only set detune when available

    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }

    return this;
  },
  getDetune: function () {
    return this.detune;
  },
  getFilter: function () {
    return this.getFilters()[0];
  },
  setFilter: function (filter) {
    return this.setFilters(filter ? [filter] : []);
  },
  setPlaybackRate: function (value) {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    this.playbackRate = value;

    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }

    return this;
  },
  getPlaybackRate: function () {
    return this.playbackRate;
  },
  onEnded: function () {
    this.isPlaying = false;
  },
  getLoop: function () {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return false;
    }

    return this.loop;
  },
  setLoop: function (value) {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.');
      return;
    }

    this.loop = value;

    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }

    return this;
  },
  setLoopStart: function (value) {
    this.loopStart = value;
    return this;
  },
  setLoopEnd: function (value) {
    this.loopEnd = value;
    return this;
  },
  getVolume: function () {
    return this.gain.gain.value;
  },
  setVolume: function (value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

const _position$3 = new Vector3();

const _quaternion$4 = new Quaternion();

const _scale$2 = new Vector3();

const _orientation$1 = new Vector3();

function PositionalAudio(listener) {
  Audio.call(this, listener);
  this.panner = this.context.createPanner();
  this.panner.panningModel = 'HRTF';
  this.panner.connect(this.gain);
}

PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
  constructor: PositionalAudio,
  getOutput: function () {
    return this.panner;
  },
  getRefDistance: function () {
    return this.panner.refDistance;
  },
  setRefDistance: function (value) {
    this.panner.refDistance = value;
    return this;
  },
  getRolloffFactor: function () {
    return this.panner.rolloffFactor;
  },
  setRolloffFactor: function (value) {
    this.panner.rolloffFactor = value;
    return this;
  },
  getDistanceModel: function () {
    return this.panner.distanceModel;
  },
  setDistanceModel: function (value) {
    this.panner.distanceModel = value;
    return this;
  },
  getMaxDistance: function () {
    return this.panner.maxDistance;
  },
  setMaxDistance: function (value) {
    this.panner.maxDistance = value;
    return this;
  },
  setDirectionalCone: function (coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.panner.coneInnerAngle = coneInnerAngle;
    this.panner.coneOuterAngle = coneOuterAngle;
    this.panner.coneOuterGain = coneOuterGain;
    return this;
  },
  updateMatrixWorld: function (force) {
    Object3D.prototype.updateMatrixWorld.call(this, force);
    if (this.hasPlaybackControl === true && this.isPlaying === false) return;
    this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2);

    _orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4);

    const panner = this.panner;

    if (panner.positionX) {
      // code path for Chrome and Firefox (see #14393)
      const endTime = this.context.currentTime + this.listener.timeDelta;
      panner.positionX.linearRampToValueAtTime(_position$3.x, endTime);
      panner.positionY.linearRampToValueAtTime(_position$3.y, endTime);
      panner.positionZ.linearRampToValueAtTime(_position$3.z, endTime);
      panner.orientationX.linearRampToValueAtTime(_orientation$1.x, endTime);
      panner.orientationY.linearRampToValueAtTime(_orientation$1.y, endTime);
      panner.orientationZ.linearRampToValueAtTime(_orientation$1.z, endTime);
    } else {
      panner.setPosition(_position$3.x, _position$3.y, _position$3.z);
      panner.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z);
    }
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function AudioAnalyser(audio, fftSize) {
  this.analyser = audio.context.createAnalyser();
  this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
  this.data = new Uint8Array(this.analyser.frequencyBinCount);
  audio.getOutput().connect(this.analyser);
}

Object.assign(AudioAnalyser.prototype, {
  getFrequencyData: function () {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  },
  getAverageFrequency: function () {
    let value = 0;
    const data = this.getFrequencyData();

    for (let i = 0; i < data.length; i++) {
      value += data[i];
    }

    return value / data.length;
  }
});
/**
 *
 * Buffered scene graph property that allows weighted accumulation.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function PropertyMixer(binding, typeName, valueSize) {
  this.binding = binding;
  this.valueSize = valueSize;
  let mixFunction, mixFunctionAdditive, setIdentity; // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
  //
  // interpolators can use .buffer as their .result
  // the data then goes to 'incoming'
  //
  // 'accu0' and 'accu1' are used frame-interleaved for
  // the cumulative result and are compared to detect
  // changes
  //
  // 'orig' stores the original state of the property
  //
  // 'add' is used for additive cumulative results
  //
  // 'work' is optional and is only present for quaternion types. It is used
  // to store intermediate quaternion multiplication results

  switch (typeName) {
    case 'quaternion':
      mixFunction = this._slerp;
      mixFunctionAdditive = this._slerpAdditive;
      setIdentity = this._setAdditiveIdentityQuaternion;
      this.buffer = new Float64Array(valueSize * 6);
      this._workIndex = 5;
      break;

    case 'string':
    case 'bool':
      mixFunction = this._select; // Use the regular mix function and for additive on these types,
      // additive is not relevant for non-numeric types

      mixFunctionAdditive = this._select;
      setIdentity = this._setAdditiveIdentityOther;
      this.buffer = new Array(valueSize * 5);
      break;

    default:
      mixFunction = this._lerp;
      mixFunctionAdditive = this._lerpAdditive;
      setIdentity = this._setAdditiveIdentityNumeric;
      this.buffer = new Float64Array(valueSize * 5);
  }

  this._mixBufferRegion = mixFunction;
  this._mixBufferRegionAdditive = mixFunctionAdditive;
  this._setIdentity = setIdentity;
  this._origIndex = 3;
  this._addIndex = 4;
  this.cumulativeWeight = 0;
  this.cumulativeWeightAdditive = 0;
  this.useCount = 0;
  this.referenceCount = 0;
}

Object.assign(PropertyMixer.prototype, {
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate: function (accuIndex, weight) {
    // note: happily accumulating nothing when weight = 0, the caller knows
    // the weight and shouldn't have made the call in the first place
    const buffer = this.buffer,
          stride = this.valueSize,
          offset = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;

    if (currentWeight === 0) {
      // accuN := incoming * weight
      for (let i = 0; i !== stride; ++i) {
        buffer[offset + i] = buffer[i];
      }

      currentWeight = weight;
    } else {
      // accuN := accuN + incoming * weight
      currentWeight += weight;
      const mix = weight / currentWeight;

      this._mixBufferRegion(buffer, offset, 0, mix, stride);
    }

    this.cumulativeWeight = currentWeight;
  },
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive: function (weight) {
    const buffer = this.buffer,
          stride = this.valueSize,
          offset = stride * this._addIndex;

    if (this.cumulativeWeightAdditive === 0) {
      // add = identity
      this._setIdentity();
    } // add := add + incoming * weight


    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);

    this.cumulativeWeightAdditive += weight;
  },
  // apply the state of 'accu<i>' to the binding when accus differ
  apply: function (accuIndex) {
    const stride = this.valueSize,
          buffer = this.buffer,
          offset = accuIndex * stride + stride,
          weight = this.cumulativeWeight,
          weightAdditive = this.cumulativeWeightAdditive,
          binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;

    if (weight < 1) {
      // accuN := accuN + original * ( 1 - cumulativeWeight )
      const originalValueOffset = stride * this._origIndex;

      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
    }

    if (weightAdditive > 0) {
      // accuN := accuN + additive accuN
      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
    }

    for (let i = stride, e = stride + stride; i !== e; ++i) {
      if (buffer[i] !== buffer[i + stride]) {
        // value has changed -> update scene graph
        binding.setValue(buffer, offset);
        break;
      }
    }
  },
  // remember the state of the bound property and copy it to both accus
  saveOriginalState: function () {
    const binding = this.binding;
    const buffer = this.buffer,
          stride = this.valueSize,
          originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original

    for (let i = stride, e = originalValueOffset; i !== e; ++i) {
      buffer[i] = buffer[originalValueOffset + i % stride];
    } // Add to identity for additive


    this._setIdentity();

    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  },
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState: function () {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  },
  _setAdditiveIdentityNumeric: function () {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;

    for (let i = startIndex; i < endIndex; i++) {
      this.buffer[i] = 0;
    }
  },
  _setAdditiveIdentityQuaternion: function () {
    this._setAdditiveIdentityNumeric();

    this.buffer[this._addIndex * 4 + 3] = 1;
  },
  _setAdditiveIdentityOther: function () {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;

    for (let i = 0; i < this.valueSize; i++) {
      this.buffer[targetIndex + i] = this.buffer[startIndex + i];
    }
  },
  // mix functions
  _select: function (buffer, dstOffset, srcOffset, t, stride) {
    if (t >= 0.5) {
      for (let i = 0; i !== stride; ++i) {
        buffer[dstOffset + i] = buffer[srcOffset + i];
      }
    }
  },
  _slerp: function (buffer, dstOffset, srcOffset, t) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
  },
  _slerpAdditive: function (buffer, dstOffset, srcOffset, t, stride) {
    const workOffset = this._workIndex * stride; // Store result in intermediate buffer offset

    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); // Slerp to the intermediate result

    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
  },
  _lerp: function (buffer, dstOffset, srcOffset, t, stride) {
    const s = 1 - t;

    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
    }
  },
  _lerpAdditive: function (buffer, dstOffset, srcOffset, t, stride) {
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
    }
  }
});
/**
 *
 * A reference to a real property in the scene graph.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */
// Characters [].:/ are reserved for track binding syntax.

const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'); // Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.


const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';

const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.


const _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.


const _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.


const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.


const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);

const _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');

const _supportedObjectNames = ['material', 'materials', 'bones'];

function Composite(targetGroup, path, optionalParsedPath) {
  const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
  this._targetGroup = targetGroup;
  this._bindings = targetGroup.subscribe_(path, parsedPath);
}

Object.assign(Composite.prototype, {
  getValue: function (array, offset) {
    this.bind(); // bind all binding

    const firstValidIndex = this._targetGroup.nCachedObjects_,
          binding = this._bindings[firstValidIndex]; // and only call .getValue on the first

    if (binding !== undefined) binding.getValue(array, offset);
  },
  setValue: function (array, offset) {
    const bindings = this._bindings;

    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].setValue(array, offset);
    }
  },
  bind: function () {
    const bindings = this._bindings;

    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].bind();
    }
  },
  unbind: function () {
    const bindings = this._bindings;

    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].unbind();
    }
  }
});

function PropertyBinding(rootNode, path, parsedPath) {
  this.path = path;
  this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
  this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
  this.rootNode = rootNode;
}

Object.assign(PropertyBinding, {
  Composite: Composite,
  create: function (root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  },

  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  sanitizeNodeName: function (name) {
    return name.replace(/\s/g, '_').replace(_reservedRe, '');
  },
  parseTrackName: function (trackName) {
    const matches = _trackRe.exec(trackName);

    if (!matches) {
      throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
    }

    const results = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      // required
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');

    if (lastDot !== undefined && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against an allowlist. Otherwise, there
      // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
      // 'bar' could be the objectName, or part of a nodeName (which can
      // include '.' characters).

      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }

    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
    }

    return results;
  },
  findNode: function (root, nodeName) {
    if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    } // search into skeleton bones.


    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);

      if (bone !== undefined) {
        return bone;
      }
    } // search into node subtree.


    if (root.children) {
      const searchNodeSubtree = function (children) {
        for (let i = 0; i < children.length; i++) {
          const childNode = children[i];

          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }

          const result = searchNodeSubtree(childNode.children);
          if (result) return result;
        }

        return null;
      };

      const subTreeNode = searchNodeSubtree(root.children);

      if (subTreeNode) {
        return subTreeNode;
      }
    }

    return null;
  }
});
Object.assign(PropertyBinding.prototype, {
  // prototype, continued
  // these are used to "bind" a nonexistent property
  _getValue_unavailable: function () {},
  _setValue_unavailable: function () {},
  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },
  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },
  GetterByBindingType: [function getValue_direct(buffer, offset) {
    buffer[offset] = this.node[this.propertyName];
  }, function getValue_array(buffer, offset) {
    const source = this.resolvedProperty;

    for (let i = 0, n = source.length; i !== n; ++i) {
      buffer[offset++] = source[i];
    }
  }, function getValue_arrayElement(buffer, offset) {
    buffer[offset] = this.resolvedProperty[this.propertyIndex];
  }, function getValue_toArray(buffer, offset) {
    this.resolvedProperty.toArray(buffer, offset);
  }],
  SetterByBindingTypeAndVersioning: [[// Direct
  function setValue_direct(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
  }, function setValue_direct_setNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }, function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }], [// EntireArray
  function setValue_array(buffer, offset) {
    const dest = this.resolvedProperty;

    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
  }, function setValue_array_setNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;

    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }

    this.targetObject.needsUpdate = true;
  }, function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;

    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }

    this.targetObject.matrixWorldNeedsUpdate = true;
  }], [// ArrayElement
  function setValue_arrayElement(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
  }, function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }, function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }], [// HasToFromArray
  function setValue_fromArray(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
  }, function setValue_fromArray_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.needsUpdate = true;
  }, function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }]],
  getValue: function getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset); // Note: This class uses a State pattern on a per-method basis:
    // 'bind' sets 'this.getValue' / 'setValue' and shadows the
    // prototype version of these methods with one that represents
    // the bound state. When the property is not found, the methods
    // become no-ops.
  },
  setValue: function getValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  },
  // create getter / setter pair for a property in the scene graph
  bind: function () {
    let targetObject = this.node,
        parsedPath = this.parsedPath,
        objectName = parsedPath.objectName,
        propertyName = parsedPath.propertyName,
        propertyIndex = parsedPath.propertyIndex;

    if (!targetObject) {
      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
      this.node = targetObject;
    } // set fail state so we can just 'return' on error


    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable; // ensure there is a value node

    if (!targetObject) {
      console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
      return;
    }

    if (objectName) {
      let objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....

      switch (objectName) {
        case 'materials':
          if (!targetObject.material) {
            console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
            return;
          }

          if (!targetObject.material.materials) {
            console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
            return;
          }

          targetObject = targetObject.material.materials;
          break;

        case 'bones':
          if (!targetObject.skeleton) {
            console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
            return;
          } // potential future optimization: skip this if propertyIndex is already an integer
          // and convert the integer string to a true integer.


          targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.

          for (let i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
              objectIndex = i;
              break;
            }
          }

          break;

        default:
          if (targetObject[objectName] === undefined) {
            console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
            return;
          }

          targetObject = targetObject[objectName];
      }

      if (objectIndex !== undefined) {
        if (targetObject[objectIndex] === undefined) {
          console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
          return;
        }

        targetObject = targetObject[objectIndex];
      }
    } // resolve property


    const nodeProperty = targetObject[propertyName];

    if (nodeProperty === undefined) {
      const nodeName = parsedPath.nodeName;
      console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
      return;
    } // determine versioning scheme


    let versioning = this.Versioning.None;
    this.targetObject = targetObject;

    if (targetObject.needsUpdate !== undefined) {
      // material
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
      // node transform
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    } // determine how the property gets bound


    let bindingType = this.BindingType.Direct;

    if (propertyIndex !== undefined) {
      // access a sub element of the property array (only primitives are supported right now)
      if (propertyName === "morphTargetInfluences") {
        // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
        // support resolving morphTarget names into indices.
        if (!targetObject.geometry) {
          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
          return;
        }

        if (targetObject.geometry.isBufferGeometry) {
          if (!targetObject.geometry.morphAttributes) {
            console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
            return;
          }

          if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
          }
        } else {
          console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
          return;
        }
      }

      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
      // must use copy for Object3D.Euler/Quaternion
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    } // select getter / setter


    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  },
  unbind: function () {
    this.node = null; // back to the prototype version of getValue / setValue
    // note: avoiding to mutate the shape of 'this' via 'delete'

    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
}); // DECLARE ALIAS AFTER assign prototype

Object.assign(PropertyBinding.prototype, {
  // initial state of these methods that calls 'bind'
  _getValue_unbound: PropertyBinding.prototype.getValue,
  _setValue_unbound: PropertyBinding.prototype.setValue
});
/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 *
 * @author tschw
 */

function AnimationObjectGroup() {
  this.uuid = MathUtils.generateUUID(); // cached objects followed by the active ones

  this._objects = Array.prototype.slice.call(arguments);
  this.nCachedObjects_ = 0; // threshold
  // note: read by PropertyBinding.Composite

  const indices = {};
  this._indicesByUUID = indices; // for bookkeeping

  for (let i = 0, n = arguments.length; i !== n; ++i) {
    indices[arguments[i].uuid] = i;
  }

  this._paths = []; // inside: string

  this._parsedPaths = []; // inside: { we don't care, here }

  this._bindings = []; // inside: Array< PropertyBinding >

  this._bindingsIndicesByPath = {}; // inside: indices in these arrays

  const scope = this;
  this.stats = {
    objects: {
      get total() {
        return scope._objects.length;
      },

      get inUse() {
        return this.total - scope.nCachedObjects_;
      }

    },

    get bindingsPerObject() {
      return scope._bindings.length;
    }

  };
}

Object.assign(AnimationObjectGroup.prototype, {
  isAnimationObjectGroup: true,
  add: function () {
    const objects = this._objects,
          indicesByUUID = this._indicesByUUID,
          paths = this._paths,
          parsedPaths = this._parsedPaths,
          bindings = this._bindings,
          nBindings = bindings.length;
    let knownObject = undefined,
        nObjects = objects.length,
        nCachedObjects = this.nCachedObjects_;

    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i],
            uuid = object.uuid;
      let index = indicesByUUID[uuid];

      if (index === undefined) {
        // unknown object -> add it to the ACTIVE region
        index = nObjects++;
        indicesByUUID[uuid] = index;
        objects.push(object); // accounting is done, now do the same for all bindings

        for (let j = 0, m = nBindings; j !== m; ++j) {
          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
        }
      } else if (index < nCachedObjects) {
        knownObject = objects[index]; // move existing object to the ACTIVE region

        const firstActiveIndex = --nCachedObjects,
              lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index;
        objects[index] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings

        for (let j = 0, m = nBindings; j !== m; ++j) {
          const bindingsForPath = bindings[j],
                lastCached = bindingsForPath[firstActiveIndex];
          let binding = bindingsForPath[index];
          bindingsForPath[index] = lastCached;

          if (binding === undefined) {
            // since we do not bother to create new bindings
            // for objects that are cached, the binding may
            // or may not exist
            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
          }

          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index] !== knownObject) {
        console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
      } // else the object is already where we want it to be

    } // for arguments


    this.nCachedObjects_ = nCachedObjects;
  },
  remove: function () {
    const objects = this._objects,
          indicesByUUID = this._indicesByUUID,
          bindings = this._bindings,
          nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_;

    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i],
            uuid = object.uuid,
            index = indicesByUUID[uuid];

      if (index !== undefined && index >= nCachedObjects) {
        // move existing object into the CACHED region
        const lastCachedIndex = nCachedObjects++,
              firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index;
        objects[index] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings

        for (let j = 0, m = nBindings; j !== m; ++j) {
          const bindingsForPath = bindings[j],
                firstActive = bindingsForPath[lastCachedIndex],
                binding = bindingsForPath[index];
          bindingsForPath[index] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    } // for arguments


    this.nCachedObjects_ = nCachedObjects;
  },
  // remove & forget
  uncache: function () {
    const objects = this._objects,
          indicesByUUID = this._indicesByUUID,
          bindings = this._bindings,
          nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_,
        nObjects = objects.length;

    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i],
            uuid = object.uuid,
            index = indicesByUUID[uuid];

      if (index !== undefined) {
        delete indicesByUUID[uuid];

        if (index < nCachedObjects) {
          // object is cached, shrink the CACHED region
          const firstActiveIndex = --nCachedObjects,
                lastCachedObject = objects[firstActiveIndex],
                lastIndex = --nObjects,
                lastObject = objects[lastIndex]; // last cached object takes this object's place

          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject; // last object goes to the activated slot and pop

          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop(); // accounting is done, now do the same for all bindings

          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j],
                  lastCached = bindingsForPath[firstActiveIndex],
                  last = bindingsForPath[lastIndex];
            bindingsForPath[index] = lastCached;
            bindingsForPath[firstActiveIndex] = last;
            bindingsForPath.pop();
          }
        } else {
          // object is active, just swap with the last and pop
          const lastIndex = --nObjects,
                lastObject = objects[lastIndex];
          indicesByUUID[lastObject.uuid] = index;
          objects[index] = lastObject;
          objects.pop(); // accounting is done, now do the same for all bindings

          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j];
            bindingsForPath[index] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        } // cached or active

      } // if object is known

    } // for arguments


    this.nCachedObjects_ = nCachedObjects;
  },
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_: function (path, parsedPath) {
    // returns an array of bindings for the given path that is changed
    // according to the contained objects in the group
    let indicesByPath = this._bindingsIndicesByPath,
        index = indicesByPath[path],
        bindings = this._bindings;
    if (index !== undefined) return bindings[index];
    const paths = this._paths,
          parsedPaths = this._parsedPaths,
          objects = this._objects,
          nObjects = objects.length,
          nCachedObjects = this.nCachedObjects_,
          bindingsForPath = new Array(nObjects);
    index = bindings.length;
    indicesByPath[path] = index;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);

    for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
      const object = objects[i];
      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
    }

    return bindingsForPath;
  },
  unsubscribe_: function (path) {
    // tells the group to forget about a property path and no longer
    // update the array previously obtained with 'subscribe_'
    const indicesByPath = this._bindingsIndicesByPath,
          index = indicesByPath[path];

    if (index !== undefined) {
      const paths = this._paths,
            parsedPaths = this._parsedPaths,
            bindings = this._bindings,
            lastBindingsIndex = bindings.length - 1,
            lastBindings = bindings[lastBindingsIndex],
            lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index;
      bindings[index] = lastBindings;
      bindings.pop();
      parsedPaths[index] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
});
/**
 *
 * Action provided by AnimationMixer for scheduling clip playback on specific
 * objects.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 *
 */

function AnimationAction(mixer, clip, localRoot, blendMode) {
  this._mixer = mixer;
  this._clip = clip;
  this._localRoot = localRoot || null;
  this.blendMode = blendMode || clip.blendMode;
  const tracks = clip.tracks,
        nTracks = tracks.length,
        interpolants = new Array(nTracks);
  const interpolantSettings = {
    endingStart: ZeroCurvatureEnding,
    endingEnd: ZeroCurvatureEnding
  };

  for (let i = 0; i !== nTracks; ++i) {
    const interpolant = tracks[i].createInterpolant(null);
    interpolants[i] = interpolant;
    interpolant.settings = interpolantSettings;
  }

  this._interpolantSettings = interpolantSettings;
  this._interpolants = interpolants; // bound by the mixer
  // inside: PropertyMixer (managed by the mixer)

  this._propertyBindings = new Array(nTracks);
  this._cacheIndex = null; // for the memory manager

  this._byClipCacheIndex = null; // for the memory manager

  this._timeScaleInterpolant = null;
  this._weightInterpolant = null;
  this.loop = LoopRepeat;
  this._loopCount = -1; // global mixer time when the action is to be started
  // it's set back to 'null' upon start of the action

  this._startTime = null; // scaled local time of the action
  // gets clamped or wrapped to 0..clip.duration according to loop

  this.time = 0;
  this.timeScale = 1;
  this._effectiveTimeScale = 1;
  this.weight = 1;
  this._effectiveWeight = 1;
  this.repetitions = Infinity; // no. of repetitions when looping

  this.paused = false; // true -> zero effective time scale

  this.enabled = true; // false -> zero effective weight

  this.clampWhenFinished = false; // keep feeding the last frame?

  this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate

  this.zeroSlopeAtEnd = true; // clips for start, loop and end
}

Object.assign(AnimationAction.prototype, {
  // State & Scheduling
  play: function () {
    this._mixer._activateAction(this);

    return this;
  },
  stop: function () {
    this._mixer._deactivateAction(this);

    return this.reset();
  },
  reset: function () {
    this.paused = false;
    this.enabled = true;
    this.time = 0; // restart clip

    this._loopCount = -1; // forget previous loops

    this._startTime = null; // forget scheduling

    return this.stopFading().stopWarping();
  },
  isRunning: function () {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  },
  // return true when play has been called
  isScheduled: function () {
    return this._mixer._isActiveAction(this);
  },
  startAt: function (time) {
    this._startTime = time;
    return this;
  },
  setLoop: function (mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  },
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight: function (weight) {
    this.weight = weight; // note: same logic as when updated at runtime

    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  },
  // return the weight considering fading and .enabled
  getEffectiveWeight: function () {
    return this._effectiveWeight;
  },
  fadeIn: function (duration) {
    return this._scheduleFading(duration, 0, 1);
  },
  fadeOut: function (duration) {
    return this._scheduleFading(duration, 1, 0);
  },
  crossFadeFrom: function (fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);

    if (warp) {
      const fadeInDuration = this._clip.duration,
            fadeOutDuration = fadeOutAction._clip.duration,
            startEndRatio = fadeOutDuration / fadeInDuration,
            endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1.0, startEndRatio, duration);
      this.warp(endStartRatio, 1.0, duration);
    }

    return this;
  },
  crossFadeTo: function (fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  },
  stopFading: function () {
    let weightInterpolant = this._weightInterpolant;

    if (weightInterpolant !== null) {
      this._weightInterpolant = null;

      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }

    return this;
  },
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale: function (timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  },
  // return the time scale considering warping and .paused
  getEffectiveTimeScale: function () {
    return this._effectiveTimeScale;
  },
  setDuration: function (duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  },
  syncWith: function (action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  },
  halt: function (duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  },
  warp: function (startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer,
          now = mixer.time,
          timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;

    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }

    const times = interpolant.parameterPositions,
          values = interpolant.sampleValues;
    times[0] = now;
    times[1] = now + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  },
  stopWarping: function () {
    let timeScaleInterpolant = this._timeScaleInterpolant;

    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;

      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }

    return this;
  },
  // Object Accessors
  getMixer: function () {
    return this._mixer;
  },
  getClip: function () {
    return this._clip;
  },
  getRoot: function () {
    return this._localRoot || this._mixer._root;
  },
  // Interna
  _update: function (time, deltaTime, timeDirection, accuIndex) {
    // called by the mixer
    if (!this.enabled) {
      // call ._updateWeight() to update ._effectiveWeight
      this._updateWeight(time);

      return;
    }

    const startTime = this._startTime;

    if (startTime !== null) {
      // check for scheduled start of action
      const timeRunning = (time - startTime) * timeDirection;

      if (timeRunning < 0 || timeDirection === 0) {
        return; // yet to come / don't decide when delta = 0
      } // start


      this._startTime = null; // unschedule

      deltaTime = timeDirection * timeRunning;
    } // apply time scale and advance time


    deltaTime *= this._updateTimeScale(time);

    const clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in
    // an effective weight of 0


    const weight = this._updateWeight(time);

    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;

      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulateAdditive(weight);
          }

          break;

        case NormalAnimationBlendMode:
        default:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulate(accuIndex, weight);
          }

      }
    }
  },
  _updateWeight: function (time) {
    let weight = 0;

    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;

      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;

        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();

          if (interpolantValue === 0) {
            // faded out, disable
            this.enabled = false;
          }
        }
      }
    }

    this._effectiveWeight = weight;
    return weight;
  },
  _updateTimeScale: function (time) {
    let timeScale = 0;

    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;

      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;

        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();

          if (timeScale === 0) {
            // motion has halted, pause
            this.paused = true;
          } else {
            // warp done - apply final time scale
            this.timeScale = timeScale;
          }
        }
      }
    }

    this._effectiveTimeScale = timeScale;
    return timeScale;
  },
  _updateTime: function (deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;

    if (deltaTime === 0) {
      if (loopCount === -1) return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }

    if (loop === LoopOnce) {
      if (loopCount === -1) {
        // just started
        this._loopCount = 0;

        this._setEndings(true, true, false);
      }

      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }

        if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
        this.time = time;

        this._mixer.dispatchEvent({
          type: 'finished',
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      // repetitive Repeat or PingPong
      if (loopCount === -1) {
        // just started
        if (deltaTime >= 0) {
          loopCount = 0;

          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          // when looping in reverse direction, the initial
          // transition through zero counts as a repetition,
          // so leave loopCount at -1
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }

      if (time >= duration || time < 0) {
        // wrap around
        const loopDelta = Math.floor(time / duration); // signed

        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;

        if (pending <= 0) {
          // have to stop (switch state, clamp time, fire event)
          if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;

          this._mixer.dispatchEvent({
            type: 'finished',
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          // keep running
          if (pending === 1) {
            // entering the last round
            const atStart = deltaTime < 0;

            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }

          this._loopCount = loopCount;
          this.time = time;

          this._mixer.dispatchEvent({
            type: 'loop',
            action: this,
            loopDelta: loopDelta
          });
        }
      } else {
        this.time = time;
      }

      if (pingPong && (loopCount & 1) === 1) {
        // invert time for the "pong round"
        return duration - time;
      }
    }

    return time;
  },
  _setEndings: function (atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;

    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      // assuming for LoopOnce atStart == atEnd == true
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }

      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  },
  _scheduleFading: function (duration, weightNow, weightThen) {
    const mixer = this._mixer,
          now = mixer.time;
    let interpolant = this._weightInterpolant;

    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }

    const times = interpolant.parameterPositions,
          values = interpolant.sampleValues;
    times[0] = now;
    values[0] = weightNow;
    times[1] = now + duration;
    values[1] = weightThen;
    return this;
  }
});
/**
 *
 * Player for AnimationClips.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function AnimationMixer(root) {
  this._root = root;

  this._initMemoryManager();

  this._accuIndex = 0;
  this.time = 0;
  this.timeScale = 1.0;
}

AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
  constructor: AnimationMixer,
  _bindAction: function (action, prototypeAction) {
    const root = action._localRoot || this._root,
          tracks = action._clip.tracks,
          nTracks = tracks.length,
          bindings = action._propertyBindings,
          interpolants = action._interpolants,
          rootUuid = root.uuid,
          bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];

    if (bindingsByName === undefined) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }

    for (let i = 0; i !== nTracks; ++i) {
      const track = tracks[i],
            trackName = track.name;
      let binding = bindingsByName[trackName];

      if (binding !== undefined) {
        bindings[i] = binding;
      } else {
        binding = bindings[i];

        if (binding !== undefined) {
          // existing binding, make sure the cache knows
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;

            this._addInactiveBinding(binding, rootUuid, trackName);
          }

          continue;
        }

        const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
        ++binding.referenceCount;

        this._addInactiveBinding(binding, rootUuid, trackName);

        bindings[i] = binding;
      }

      interpolants[i].resultBuffer = binding.buffer;
    }
  },
  _activateAction: function (action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        // this action has been forgotten by the cache, but the user
        // appears to be still using it -> rebind
        const rootUuid = (action._localRoot || this._root).uuid,
              clipUuid = action._clip.uuid,
              actionsForClip = this._actionsByClip[clipUuid];

        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);

        this._addInactiveAction(action, clipUuid, rootUuid);
      }

      const bindings = action._propertyBindings; // increment reference counts / sort out state

      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];

        if (binding.useCount++ === 0) {
          this._lendBinding(binding);

          binding.saveOriginalState();
        }
      }

      this._lendAction(action);
    }
  },
  _deactivateAction: function (action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings; // decrement reference counts / sort out state

      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];

        if (--binding.useCount === 0) {
          binding.restoreOriginalState();

          this._takeBackBinding(binding);
        }
      }

      this._takeBackAction(action);
    }
  },
  // Memory manager
  _initMemoryManager: function () {
    this._actions = []; // 'nActiveActions' followed by inactive ones

    this._nActiveActions = 0;
    this._actionsByClip = {}; // inside:
    // {
    // 	knownActions: Array< AnimationAction > - used as prototypes
    // 	actionByRoot: AnimationAction - lookup
    // }

    this._bindings = []; // 'nActiveBindings' followed by inactive ones

    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

    this._controlInterpolants = []; // same game as above

    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },

        get inUse() {
          return scope._nActiveActions;
        }

      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },

        get inUse() {
          return scope._nActiveBindings;
        }

      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },

        get inUse() {
          return scope._nActiveControlInterpolants;
        }

      }
    };
  },
  // Memory management for AnimationAction objects
  _isActiveAction: function (action) {
    const index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  },
  _addInactiveAction: function (action, clipUuid, rootUuid) {
    const actions = this._actions,
          actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];

    if (actionsForClip === undefined) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }

    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  },
  _removeInactiveAction: function (action) {
    const actions = this._actions,
          lastInactiveAction = actions[actions.length - 1],
          cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid,
          actionsByClip = this._actionsByClip,
          actionsForClip = actionsByClip[clipUuid],
          knownActionsForClip = actionsForClip.knownActions,
          lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
          byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot,
          rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];

    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }

    this._removeInactiveBindingsForAction(action);
  },
  _removeInactiveBindingsForAction: function (action) {
    const bindings = action._propertyBindings;

    for (let i = 0, n = bindings.length; i !== n; ++i) {
      const binding = bindings[i];

      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  },
  _lendAction: function (action) {
    // [ active actions |  inactive actions  ]
    // [  active actions >| inactive actions ]
    //                 s        a
    //                  <-swap->
    //                 a        s
    const actions = this._actions,
          prevIndex = action._cacheIndex,
          lastActiveIndex = this._nActiveActions++,
          firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  },
  _takeBackAction: function (action) {
    // [  active actions  | inactive actions ]
    // [ active actions |< inactive actions  ]
    //        a        s
    //         <-swap->
    //        s        a
    const actions = this._actions,
          prevIndex = action._cacheIndex,
          firstInactiveIndex = --this._nActiveActions,
          lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  },
  // Memory management for PropertyMixer objects
  _addInactiveBinding: function (binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName,
          bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];

    if (bindingByName === undefined) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }

    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  },
  _removeInactiveBinding: function (binding) {
    const bindings = this._bindings,
          propBinding = binding.binding,
          rootUuid = propBinding.rootNode.uuid,
          trackName = propBinding.path,
          bindingsByRoot = this._bindingsByRootAndName,
          bindingByName = bindingsByRoot[rootUuid],
          lastInactiveBinding = bindings[bindings.length - 1],
          cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];

    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  },
  _lendBinding: function (binding) {
    const bindings = this._bindings,
          prevIndex = binding._cacheIndex,
          lastActiveIndex = this._nActiveBindings++,
          firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  },
  _takeBackBinding: function (binding) {
    const bindings = this._bindings,
          prevIndex = binding._cacheIndex,
          firstInactiveIndex = --this._nActiveBindings,
          lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  },
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant: function () {
    const interpolants = this._controlInterpolants,
          lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];

    if (interpolant === undefined) {
      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }

    return interpolant;
  },
  _takeBackControlInterpolant: function (interpolant) {
    const interpolants = this._controlInterpolants,
          prevIndex = interpolant.__cacheIndex,
          firstInactiveIndex = --this._nActiveControlInterpolants,
          lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  },
  _controlInterpolantsResultBuffer: new Float32Array(1),
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction: function (clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root,
          rootUuid = root.uuid;
    let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    let actionsForClip = this._actionsByClip[clipUuid],
        prototypeAction = null;

    if (blendMode === undefined) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }

    if (actionsForClip !== undefined) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];

      if (existingAction !== undefined && existingAction.blendMode === blendMode) {
        return existingAction;
      } // we know the clip, so we don't have to parse all
      // the bindings again but can just copy


      prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action

      if (clipObject === null) clipObject = prototypeAction._clip;
    } // clip must be known when specified via string


    if (clipObject === null) return null; // allocate all resources required to run it

    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);

    this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager


    this._addInactiveAction(newAction, clipUuid, rootUuid);

    return newAction;
  },
  // get an existing action
  existingAction: function (clip, optionalRoot) {
    const root = optionalRoot || this._root,
          rootUuid = root.uuid,
          clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
          clipUuid = clipObject ? clipObject.uuid : clip,
          actionsForClip = this._actionsByClip[clipUuid];

    if (actionsForClip !== undefined) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }

    return null;
  },
  // deactivates all previously scheduled actions
  stopAllAction: function () {
    const actions = this._actions,
          nActions = this._nActiveActions;

    for (let i = nActions - 1; i >= 0; --i) {
      actions[i].stop();
    }

    return this;
  },
  // advance the time and update apply the animation
  update: function (deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions,
          nActions = this._nActiveActions,
          time = this.time += deltaTime,
          timeDirection = Math.sign(deltaTime),
          accuIndex = this._accuIndex ^= 1; // run active actions

    for (let i = 0; i !== nActions; ++i) {
      const action = actions[i];

      action._update(time, deltaTime, timeDirection, accuIndex);
    } // update scene graph


    const bindings = this._bindings,
          nBindings = this._nActiveBindings;

    for (let i = 0; i !== nBindings; ++i) {
      bindings[i].apply(accuIndex);
    }

    return this;
  },
  // Allows you to seek to a specific time in an animation.
  setTime: function (timeInSeconds) {
    this.time = 0; // Zero out time attribute for AnimationMixer object;

    for (let i = 0; i < this._actions.length; i++) {
      this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
    }

    return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
  },
  // return this mixer's root target object
  getRoot: function () {
    return this._root;
  },
  // free all resources specific to a particular clip
  uncacheClip: function (clip) {
    const actions = this._actions,
          clipUuid = clip.uuid,
          actionsByClip = this._actionsByClip,
          actionsForClip = actionsByClip[clipUuid];

    if (actionsForClip !== undefined) {
      // note: just calling _removeInactiveAction would mess up the
      // iteration state and also require updating the state we can
      // just throw away
      const actionsToRemove = actionsForClip.knownActions;

      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
        const action = actionsToRemove[i];

        this._deactivateAction(action);

        const cacheIndex = action._cacheIndex,
              lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();

        this._removeInactiveBindingsForAction(action);
      }

      delete actionsByClip[clipUuid];
    }
  },
  // free all resources specific to a particular root target object
  uncacheRoot: function (root) {
    const rootUuid = root.uuid,
          actionsByClip = this._actionsByClip;

    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot,
            action = actionByRoot[rootUuid];

      if (action !== undefined) {
        this._deactivateAction(action);

        this._removeInactiveAction(action);
      }
    }

    const bindingsByRoot = this._bindingsByRootAndName,
          bindingByName = bindingsByRoot[rootUuid];

    if (bindingByName !== undefined) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();

        this._removeInactiveBinding(binding);
      }
    }
  },
  // remove a targeted clip from the cache
  uncacheAction: function (clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);

    if (action !== null) {
      this._deactivateAction(action);

      this._removeInactiveAction(action);
    }
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 */

function Uniform(value) {
  if (typeof value === 'string') {
    console.warn('THREE.Uniform: Type parameter is no longer needed.');
    value = arguments[1];
  }

  this.value = value;
}

Uniform.prototype.clone = function () {
  return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
};
/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */


function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
  InterleavedBuffer.call(this, array, stride);
  this.meshPerAttribute = meshPerAttribute || 1;
}

InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
  constructor: InstancedInterleavedBuffer,
  isInstancedInterleavedBuffer: true,
  copy: function (source) {
    InterleavedBuffer.prototype.copy.call(this, source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  },
  clone: function (data) {
    const ib = InterleavedBuffer.prototype.clone.call(this, data);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  },
  toJSON: function (data) {
    const json = InterleavedBuffer.prototype.toJSON.call(this, data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

function Raycaster(origin, direction, near, far) {
  this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)

  this.near = near || 0;
  this.far = far || Infinity;
  this.camera = null;
  this.layers = new Layers();
  this.params = {
    Mesh: {},
    Line: {
      threshold: 1
    },
    LOD: {},
    Points: {
      threshold: 1
    },
    Sprite: {}
  };
  Object.defineProperties(this.params, {
    PointCloud: {
      get: function () {
        console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
        return this.Points;
      }
    }
  });
}

function ascSort(a, b) {
  return a.distance - b.distance;
}

function intersectObject(object, raycaster, intersects, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects);
  }

  if (recursive === true) {
    const children = object.children;

    for (let i = 0, l = children.length; i < l; i++) {
      intersectObject(children[i], raycaster, intersects, true);
    }
  }
}

Object.assign(Raycaster.prototype, {
  set: function (origin, direction) {
    // direction is assumed to be normalized (for accurate distance calculations)
    this.ray.set(origin, direction);
  },
  setFromCamera: function (coords, camera) {
    if (camera && camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      this.camera = camera;
    } else if (camera && camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera

      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error('THREE.Raycaster: Unsupported camera type.');
    }
  },
  intersectObject: function (object, recursive, optionalTarget) {
    const intersects = optionalTarget || [];
    intersectObject(object, this, intersects, recursive);
    intersects.sort(ascSort);
    return intersects;
  },
  intersectObjects: function (objects, recursive, optionalTarget) {
    const intersects = optionalTarget || [];

    if (Array.isArray(objects) === false) {
      console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
      return intersects;
    }

    for (let i = 0, l = objects.length; i < l; i++) {
      intersectObject(objects[i], this, intersects, recursive);
    }

    intersects.sort(ascSort);
    return intersects;
  }
});
/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */

function Spherical(radius, phi, theta) {
  this.radius = radius !== undefined ? radius : 1.0;
  this.phi = phi !== undefined ? phi : 0; // polar angle

  this.theta = theta !== undefined ? theta : 0; // azimuthal angle

  return this;
}

Object.assign(Spherical.prototype, {
  set: function (radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  },
  // restrict phi to be betwee EPS and PI-EPS
  makeSafe: function () {
    const EPS = 0.000001;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  },
  setFromVector3: function (v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  },
  setFromCartesianCoords: function (x, y, z) {
    this.radius = Math.sqrt(x * x + y * y + z * z);

    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x, z);
      this.phi = Math.acos(MathUtils.clamp(y / this.radius, -1, 1));
    }

    return this;
  }
});
/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 *
 */

function Cylindrical(radius, theta, y) {
  this.radius = radius !== undefined ? radius : 1.0; // distance from the origin to a point in the x-z plane

  this.theta = theta !== undefined ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis

  this.y = y !== undefined ? y : 0; // height above the x-z plane

  return this;
}

Object.assign(Cylindrical.prototype, {
  set: function (radius, theta, y) {
    this.radius = radius;
    this.theta = theta;
    this.y = y;
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (other) {
    this.radius = other.radius;
    this.theta = other.theta;
    this.y = other.y;
    return this;
  },
  setFromVector3: function (v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  },
  setFromCartesianCoords: function (x, y, z) {
    this.radius = Math.sqrt(x * x + z * z);
    this.theta = Math.atan2(x, z);
    this.y = y;
    return this;
  }
});
/**
 * @author bhouston / http://clara.io
 */

const _vector$7 = new Vector2();

function Box2(min, max) {
  this.min = min !== undefined ? min : new Vector2(+Infinity, +Infinity);
  this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity);
}

Object.assign(Box2.prototype, {
  set: function (min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  },
  setFromPoints: function (points) {
    this.makeEmpty();

    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }

    return this;
  },
  setFromCenterAndSize: function (center, size) {
    const halfSize = _vector$7.copy(size).multiplyScalar(0.5);

    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = +Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  },
  isEmpty: function () {
    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    return this.max.x < this.min.x || this.max.y < this.min.y;
  },
  getCenter: function (target) {
    if (target === undefined) {
      console.warn('THREE.Box2: .getCenter() target is now required');
      target = new Vector2();
    }

    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  getSize: function (target) {
    if (target === undefined) {
      console.warn('THREE.Box2: .getSize() target is now required');
      target = new Vector2();
    }

    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
  },
  expandByPoint: function (point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  },
  expandByVector: function (vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  },
  expandByScalar: function (scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  },
  containsPoint: function (point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
  },
  containsBox: function (box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
  },
  getParameter: function (point, target) {
    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.
    if (target === undefined) {
      console.warn('THREE.Box2: .getParameter() target is now required');
      target = new Vector2();
    }

    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
  },
  intersectsBox: function (box) {
    // using 4 splitting planes to rule out intersections
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
  },
  clampPoint: function (point, target) {
    if (target === undefined) {
      console.warn('THREE.Box2: .clampPoint() target is now required');
      target = new Vector2();
    }

    return target.copy(point).clamp(this.min, this.max);
  },
  distanceToPoint: function (point) {
    const clampedPoint = _vector$7.copy(point).clamp(this.min, this.max);

    return clampedPoint.sub(point).length();
  },
  intersect: function (box) {
    this.min.max(box.min);
    this.max.min(box.max);
    return this;
  },
  union: function (box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  },
  translate: function (offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  },
  equals: function (box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
});
/**
 * @author bhouston / http://clara.io
 */

const _startP = new Vector3();

const _startEnd = new Vector3();

function Line3(start, end) {
  this.start = start !== undefined ? start : new Vector3();
  this.end = end !== undefined ? end : new Vector3();
}

Object.assign(Line3.prototype, {
  set: function (start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  },
  copy: function (line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  },
  getCenter: function (target) {
    if (target === undefined) {
      console.warn('THREE.Line3: .getCenter() target is now required');
      target = new Vector3();
    }

    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  },
  delta: function (target) {
    if (target === undefined) {
      console.warn('THREE.Line3: .delta() target is now required');
      target = new Vector3();
    }

    return target.subVectors(this.end, this.start);
  },
  distanceSq: function () {
    return this.start.distanceToSquared(this.end);
  },
  distance: function () {
    return this.start.distanceTo(this.end);
  },
  at: function (t, target) {
    if (target === undefined) {
      console.warn('THREE.Line3: .at() target is now required');
      target = new Vector3();
    }

    return this.delta(target).multiplyScalar(t).add(this.start);
  },
  closestPointToPointParameter: function (point, clampToLine) {
    _startP.subVectors(point, this.start);

    _startEnd.subVectors(this.end, this.start);

    const startEnd2 = _startEnd.dot(_startEnd);

    const startEnd_startP = _startEnd.dot(_startP);

    let t = startEnd_startP / startEnd2;

    if (clampToLine) {
      t = MathUtils.clamp(t, 0, 1);
    }

    return t;
  },
  closestPointToPoint: function (point, clampToLine, target) {
    const t = this.closestPointToPointParameter(point, clampToLine);

    if (target === undefined) {
      console.warn('THREE.Line3: .closestPointToPoint() target is now required');
      target = new Vector3();
    }

    return this.delta(target).multiplyScalar(t).add(this.start);
  },
  applyMatrix4: function (matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  },
  equals: function (line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
});
/**
 * @author alteredq / http://alteredqualia.com/
 */

function ImmediateRenderObject(material) {
  Object3D.call(this);
  this.material = material;

  this.render = function ()
  /* renderCallback */
  {};

  this.hasPositions = false;
  this.hasNormals = false;
  this.hasColors = false;
  this.hasUvs = false;
  this.positionArray = null;
  this.normalArray = null;
  this.colorArray = null;
  this.uvArray = null;
  this.count = 0;
}

ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

const _vector$8 = new Vector3();

function SpotLightHelper(light, color) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.color = color;
  const geometry = new BufferGeometry();
  const positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];

  for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
    const p1 = i / l * Math.PI * 2;
    const p2 = j / l * Math.PI * 2;
    positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
  }

  geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
  const material = new LineBasicMaterial({
    fog: false,
    toneMapped: false
  });
  this.cone = new LineSegments(geometry, material);
  this.add(this.cone);
  this.update();
}

SpotLightHelper.prototype = Object.create(Object3D.prototype);
SpotLightHelper.prototype.constructor = SpotLightHelper;

SpotLightHelper.prototype.dispose = function () {
  this.cone.geometry.dispose();
  this.cone.material.dispose();
};

SpotLightHelper.prototype.update = function () {
  this.light.updateMatrixWorld();
  const coneLength = this.light.distance ? this.light.distance : 1000;
  const coneWidth = coneLength * Math.tan(this.light.angle);
  this.cone.scale.set(coneWidth, coneWidth, coneLength);

  _vector$8.setFromMatrixPosition(this.light.target.matrixWorld);

  this.cone.lookAt(_vector$8);

  if (this.color !== undefined) {
    this.cone.material.color.set(this.color);
  } else {
    this.cone.material.color.copy(this.light.color);
  }
};
/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 * @author Mugen87 / https://github.com/Mugen87
 */


const _vector$9 = new Vector3();

const _boneMatrix = new Matrix4();

const _matrixWorldInv = new Matrix4();

function getBoneList(object) {
  const boneList = [];

  if (object && object.isBone) {
    boneList.push(object);
  }

  for (let i = 0; i < object.children.length; i++) {
    boneList.push.apply(boneList, getBoneList(object.children[i]));
  }

  return boneList;
}

function SkeletonHelper(object) {
  const bones = getBoneList(object);
  const geometry = new BufferGeometry();
  const vertices = [];
  const colors = [];
  const color1 = new Color(0, 0, 1);
  const color2 = new Color(0, 1, 0);

  for (let i = 0; i < bones.length; i++) {
    const bone = bones[i];

    if (bone.parent && bone.parent.isBone) {
      vertices.push(0, 0, 0);
      vertices.push(0, 0, 0);
      colors.push(color1.r, color1.g, color1.b);
      colors.push(color2.r, color2.g, color2.b);
    }
  }

  geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
  const material = new LineBasicMaterial({
    vertexColors: true,
    depthTest: false,
    depthWrite: false,
    toneMapped: false,
    transparent: true
  });
  LineSegments.call(this, geometry, material);
  this.type = 'SkeletonHelper';
  this.root = object;
  this.bones = bones;
  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;
}

SkeletonHelper.prototype = Object.create(LineSegments.prototype);
SkeletonHelper.prototype.constructor = SkeletonHelper;
SkeletonHelper.prototype.isSkeletonHelper = true;

SkeletonHelper.prototype.updateMatrixWorld = function (force) {
  const bones = this.bones;
  const geometry = this.geometry;
  const position = geometry.getAttribute('position');

  _matrixWorldInv.getInverse(this.root.matrixWorld);

  for (let i = 0, j = 0; i < bones.length; i++) {
    const bone = bones[i];

    if (bone.parent && bone.parent.isBone) {
      _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);

      _vector$9.setFromMatrixPosition(_boneMatrix);

      position.setXYZ(j, _vector$9.x, _vector$9.y, _vector$9.z);

      _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);

      _vector$9.setFromMatrixPosition(_boneMatrix);

      position.setXYZ(j + 1, _vector$9.x, _vector$9.y, _vector$9.z);
      j += 2;
    }
  }

  geometry.getAttribute('position').needsUpdate = true;
  Object3D.prototype.updateMatrixWorld.call(this, force);
};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */


function PointLightHelper(light, sphereSize, color) {
  this.light = light;
  this.light.updateMatrixWorld();
  this.color = color;
  const geometry = new SphereBufferGeometry(sphereSize, 4, 2);
  const material = new MeshBasicMaterial({
    wireframe: true,
    fog: false,
    toneMapped: false
  });
  Mesh.call(this, geometry, material);
  this.type = 'PointLightHelper';
  this.matrix = this.light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.update();
  /*
  const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
  const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
  	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
  this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
  	const d = light.distance;
  	if ( d === 0.0 ) {
  		this.lightDistance.visible = false;
  	} else {
  		this.lightDistance.scale.set( d, d, d );
  	}
  	this.add( this.lightDistance );
  */
}

PointLightHelper.prototype = Object.create(Mesh.prototype);
PointLightHelper.prototype.constructor = PointLightHelper;

PointLightHelper.prototype.dispose = function () {
  this.geometry.dispose();
  this.material.dispose();
};

PointLightHelper.prototype.update = function () {
  if (this.color !== undefined) {
    this.material.color.set(this.color);
  } else {
    this.material.color.copy(this.light.color);
  }
  /*
  const d = this.light.distance;
  	if ( d === 0.0 ) {
  		this.lightDistance.visible = false;
  	} else {
  		this.lightDistance.visible = true;
  	this.lightDistance.scale.set( d, d, d );
  	}
  */

};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */


const _vector$a = new Vector3();

const _color1 = new Color();

const _color2 = new Color();

function HemisphereLightHelper(light, size, color) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.color = color;
  const geometry = new OctahedronBufferGeometry(size);
  geometry.rotateY(Math.PI * 0.5);
  this.material = new MeshBasicMaterial({
    wireframe: true,
    fog: false,
    toneMapped: false
  });
  if (this.color === undefined) this.material.vertexColors = true;
  const position = geometry.getAttribute('position');
  const colors = new Float32Array(position.count * 3);
  geometry.setAttribute('color', new BufferAttribute(colors, 3));
  this.add(new Mesh(geometry, this.material));
  this.update();
}

HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

HemisphereLightHelper.prototype.dispose = function () {
  this.children[0].geometry.dispose();
  this.children[0].material.dispose();
};

HemisphereLightHelper.prototype.update = function () {
  const mesh = this.children[0];

  if (this.color !== undefined) {
    this.material.color.set(this.color);
  } else {
    const colors = mesh.geometry.getAttribute('color');

    _color1.copy(this.light.color);

    _color2.copy(this.light.groundColor);

    for (let i = 0, l = colors.count; i < l; i++) {
      const color = i < l / 2 ? _color1 : _color2;
      colors.setXYZ(i, color.r, color.g, color.b);
    }

    colors.needsUpdate = true;
  }

  mesh.lookAt(_vector$a.setFromMatrixPosition(this.light.matrixWorld).negate());
};
/**
 * @author mrdoob / http://mrdoob.com/
 */


function GridHelper(size, divisions, color1, color2) {
  size = size || 10;
  divisions = divisions || 10;
  color1 = new Color(color1 !== undefined ? color1 : 0x444444);
  color2 = new Color(color2 !== undefined ? color2 : 0x888888);
  const center = divisions / 2;
  const step = size / divisions;
  const halfSize = size / 2;
  const vertices = [],
        colors = [];

  for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
    vertices.push(-halfSize, 0, k, halfSize, 0, k);
    vertices.push(k, 0, -halfSize, k, 0, halfSize);
    const color = i === center ? color1 : color2;
    color.toArray(colors, j);
    j += 3;
    color.toArray(colors, j);
    j += 3;
    color.toArray(colors, j);
    j += 3;
    color.toArray(colors, j);
    j += 3;
  }

  const geometry = new BufferGeometry();
  geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
  const material = new LineBasicMaterial({
    vertexColors: true,
    toneMapped: false
  });
  LineSegments.call(this, geometry, material);
  this.type = 'GridHelper';
}

GridHelper.prototype = Object.assign(Object.create(LineSegments.prototype), {
  constructor: GridHelper,
  copy: function (source) {
    LineSegments.prototype.copy.call(this, source);
    this.geometry.copy(source.geometry);
    this.material.copy(source.material);
    return this;
  },
  clone: function () {
    return new this.constructor().copy(this);
  }
});
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 * @author Hectate / http://www.github.com/Hectate
 */

function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
  radius = radius || 10;
  radials = radials || 16;
  circles = circles || 8;
  divisions = divisions || 64;
  color1 = new Color(color1 !== undefined ? color1 : 0x444444);
  color2 = new Color(color2 !== undefined ? color2 : 0x888888);
  const vertices = [];
  const colors = []; // create the radials

  for (let i = 0; i <= radials; i++) {
    const v = i / radials * (Math.PI * 2);
    const x = Math.sin(v) * radius;
    const z = Math.cos(v) * radius;
    vertices.push(0, 0, 0);
    vertices.push(x, 0, z);
    const color = i & 1 ? color1 : color2;
    colors.push(color.r, color.g, color.b);
    colors.push(color.r, color.g, color.b);
  } // create the circles


  for (let i = 0; i <= circles; i++) {
    const color = i & 1 ? color1 : color2;
    const r = radius - radius / circles * i;

    for (let j = 0; j < divisions; j++) {
      // first vertex
      let v = j / divisions * (Math.PI * 2);
      let x = Math.sin(v) * r;
      let z = Math.cos(v) * r;
      vertices.push(x, 0, z);
      colors.push(color.r, color.g, color.b); // second vertex

      v = (j + 1) / divisions * (Math.PI * 2);
      x = Math.sin(v) * r;
      z = Math.cos(v) * r;
      vertices.push(x, 0, z);
      colors.push(color.r, color.g, color.b);
    }
  }

  const geometry = new BufferGeometry();
  geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
  const material = new LineBasicMaterial({
    vertexColors: true,
    toneMapped: false
  });
  LineSegments.call(this, geometry, material);
  this.type = 'PolarGridHelper';
}

PolarGridHelper.prototype = Object.create(LineSegments.prototype);
PolarGridHelper.prototype.constructor = PolarGridHelper;
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

const _v1$5 = new Vector3();

const _v2$3 = new Vector3();

const _v3$1 = new Vector3();

function DirectionalLightHelper(light, size, color) {
  Object3D.call(this);
  this.light = light;
  this.light.updateMatrixWorld();
  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;
  this.color = color;
  if (size === undefined) size = 1;
  let geometry = new BufferGeometry();
  geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
  const material = new LineBasicMaterial({
    fog: false,
    toneMapped: false
  });
  this.lightPlane = new Line(geometry, material);
  this.add(this.lightPlane);
  geometry = new BufferGeometry();
  geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
  this.targetLine = new Line(geometry, material);
  this.add(this.targetLine);
  this.update();
}

DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

DirectionalLightHelper.prototype.dispose = function () {
  this.lightPlane.geometry.dispose();
  this.lightPlane.material.dispose();
  this.targetLine.geometry.dispose();
  this.targetLine.material.dispose();
};

DirectionalLightHelper.prototype.update = function () {
  _v1$5.setFromMatrixPosition(this.light.matrixWorld);

  _v2$3.setFromMatrixPosition(this.light.target.matrixWorld);

  _v3$1.subVectors(_v2$3, _v1$5);

  this.lightPlane.lookAt(_v2$3);

  if (this.color !== undefined) {
    this.lightPlane.material.color.set(this.color);
    this.targetLine.material.color.set(this.color);
  } else {
    this.lightPlane.material.color.copy(this.light.color);
    this.targetLine.material.color.copy(this.light.color);
  }

  this.targetLine.lookAt(_v2$3);
  this.targetLine.scale.z = _v3$1.length();
};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author Mugen87 / https://github.com/Mugen87
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */


const _vector$b = new Vector3();

const _camera = new Camera();

function CameraHelper(camera) {
  const geometry = new BufferGeometry();
  const material = new LineBasicMaterial({
    color: 0xffffff,
    vertexColors: true,
    toneMapped: false
  });
  const vertices = [];
  const colors = [];
  const pointMap = {}; // colors

  const colorFrustum = new Color(0xffaa00);
  const colorCone = new Color(0xff0000);
  const colorUp = new Color(0x00aaff);
  const colorTarget = new Color(0xffffff);
  const colorCross = new Color(0x333333); // near

  addLine('n1', 'n2', colorFrustum);
  addLine('n2', 'n4', colorFrustum);
  addLine('n4', 'n3', colorFrustum);
  addLine('n3', 'n1', colorFrustum); // far

  addLine('f1', 'f2', colorFrustum);
  addLine('f2', 'f4', colorFrustum);
  addLine('f4', 'f3', colorFrustum);
  addLine('f3', 'f1', colorFrustum); // sides

  addLine('n1', 'f1', colorFrustum);
  addLine('n2', 'f2', colorFrustum);
  addLine('n3', 'f3', colorFrustum);
  addLine('n4', 'f4', colorFrustum); // cone

  addLine('p', 'n1', colorCone);
  addLine('p', 'n2', colorCone);
  addLine('p', 'n3', colorCone);
  addLine('p', 'n4', colorCone); // up

  addLine('u1', 'u2', colorUp);
  addLine('u2', 'u3', colorUp);
  addLine('u3', 'u1', colorUp); // target

  addLine('c', 't', colorTarget);
  addLine('p', 'c', colorCross); // cross

  addLine('cn1', 'cn2', colorCross);
  addLine('cn3', 'cn4', colorCross);
  addLine('cf1', 'cf2', colorCross);
  addLine('cf3', 'cf4', colorCross);

  function addLine(a, b, color) {
    addPoint(a, color);
    addPoint(b, color);
  }

  function addPoint(id, color) {
    vertices.push(0, 0, 0);
    colors.push(color.r, color.g, color.b);

    if (pointMap[id] === undefined) {
      pointMap[id] = [];
    }

    pointMap[id].push(vertices.length / 3 - 1);
  }

  geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
  LineSegments.call(this, geometry, material);
  this.type = 'CameraHelper';
  this.camera = camera;
  if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
  this.matrix = camera.matrixWorld;
  this.matrixAutoUpdate = false;
  this.pointMap = pointMap;
  this.update();
}

CameraHelper.prototype = Object.create(LineSegments.prototype);
CameraHelper.prototype.constructor = CameraHelper;

CameraHelper.prototype.update = function () {
  const geometry = this.geometry;
  const pointMap = this.pointMap;
  const w = 1,
        h = 1; // we need just camera projection matrix inverse
  // world matrix must be identity

  _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); // center / target


  setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
  setPoint('t', pointMap, geometry, _camera, 0, 0, 1); // near

  setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
  setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
  setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
  setPoint('n4', pointMap, geometry, _camera, w, h, -1); // far

  setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
  setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
  setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
  setPoint('f4', pointMap, geometry, _camera, w, h, 1); // up

  setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
  setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
  setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1); // cross

  setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
  setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
  setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
  setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
  setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
  setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
  setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
  setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
  geometry.getAttribute('position').needsUpdate = true;
};

function setPoint(point, pointMap, geometry, camera, x, y, z) {
  _vector$b.set(x, y, z).unproject(camera);

  const points = pointMap[point];

  if (points !== undefined) {
    const position = geometry.getAttribute('position');

    for (let i = 0, l = points.length; i < l; i++) {
      position.setXYZ(points[i], _vector$b.x, _vector$b.y, _vector$b.z);
    }
  }
}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 */


const _box$3 = new Box3();

function BoxHelper(object, color) {
  this.object = object;
  if (color === undefined) color = 0xffff00;
  const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
  const positions = new Float32Array(8 * 3);
  const geometry = new BufferGeometry();
  geometry.setIndex(new BufferAttribute(indices, 1));
  geometry.setAttribute('position', new BufferAttribute(positions, 3));
  LineSegments.call(this, geometry, new LineBasicMaterial({
    color: color,
    toneMapped: false
  }));
  this.type = 'BoxHelper';
  this.matrixAutoUpdate = false;
  this.update();
}

BoxHelper.prototype = Object.create(LineSegments.prototype);
BoxHelper.prototype.constructor = BoxHelper;

BoxHelper.prototype.update = function (object) {
  if (object !== undefined) {
    console.warn('THREE.BoxHelper: .update() has no longer arguments.');
  }

  if (this.object !== undefined) {
    _box$3.setFromObject(this.object);
  }

  if (_box$3.isEmpty()) return;
  const min = _box$3.min;
  const max = _box$3.max;
  /*
    5____4
  1/___0/|
  | 6__|_7
  2/___3/
  	0: max.x, max.y, max.z
  1: min.x, max.y, max.z
  2: min.x, min.y, max.z
  3: max.x, min.y, max.z
  4: max.x, max.y, min.z
  5: min.x, max.y, min.z
  6: min.x, min.y, min.z
  7: max.x, min.y, min.z
  */

  const position = this.geometry.attributes.position;
  const array = position.array;
  array[0] = max.x;
  array[1] = max.y;
  array[2] = max.z;
  array[3] = min.x;
  array[4] = max.y;
  array[5] = max.z;
  array[6] = min.x;
  array[7] = min.y;
  array[8] = max.z;
  array[9] = max.x;
  array[10] = min.y;
  array[11] = max.z;
  array[12] = max.x;
  array[13] = max.y;
  array[14] = min.z;
  array[15] = min.x;
  array[16] = max.y;
  array[17] = min.z;
  array[18] = min.x;
  array[19] = min.y;
  array[20] = min.z;
  array[21] = max.x;
  array[22] = min.y;
  array[23] = min.z;
  position.needsUpdate = true;
  this.geometry.computeBoundingSphere();
};

BoxHelper.prototype.setFromObject = function (object) {
  this.object = object;
  this.update();
  return this;
};

BoxHelper.prototype.copy = function (source) {
  LineSegments.prototype.copy.call(this, source);
  this.object = source.object;
  return this;
};

BoxHelper.prototype.clone = function () {
  return new this.constructor().copy(this);
};
/**
 * @author WestLangley / http://github.com/WestLangley
 */


function Box3Helper(box, color) {
  this.type = 'Box3Helper';
  this.box = box;
  color = color || 0xffff00;
  const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
  const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
  const geometry = new BufferGeometry();
  geometry.setIndex(new BufferAttribute(indices, 1));
  geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
  LineSegments.call(this, geometry, new LineBasicMaterial({
    color: color,
    toneMapped: false
  }));
  this.type = 'Box3Helper';
  this.geometry.computeBoundingSphere();
}

Box3Helper.prototype = Object.create(LineSegments.prototype);
Box3Helper.prototype.constructor = Box3Helper;

Box3Helper.prototype.updateMatrixWorld = function (force) {
  const box = this.box;
  if (box.isEmpty()) return;
  box.getCenter(this.position);
  box.getSize(this.scale);
  this.scale.multiplyScalar(0.5);
  Object3D.prototype.updateMatrixWorld.call(this, force);
};
/**
 * @author WestLangley / http://github.com/WestLangley
 */


function PlaneHelper(plane, size, hex) {
  this.plane = plane;
  this.size = size === undefined ? 1 : size;
  const color = hex !== undefined ? hex : 0xffff00;
  const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
  const geometry = new BufferGeometry();
  geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
  geometry.computeBoundingSphere();
  Line.call(this, geometry, new LineBasicMaterial({
    color: color,
    toneMapped: false
  }));
  this.type = 'PlaneHelper'; //

  const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
  const geometry2 = new BufferGeometry();
  geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
  geometry2.computeBoundingSphere();
  this.add(new Mesh(geometry2, new MeshBasicMaterial({
    color: color,
    opacity: 0.2,
    transparent: true,
    depthWrite: false,
    toneMapped: false
  })));
}

PlaneHelper.prototype = Object.create(Line.prototype);
PlaneHelper.prototype.constructor = PlaneHelper;

PlaneHelper.prototype.updateMatrixWorld = function (force) {
  let scale = -this.plane.constant;
  if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter

  this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
  this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

  this.lookAt(this.plane.normal);
  Object3D.prototype.updateMatrixWorld.call(this, force);
};
/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */


const _axis = new Vector3();

let _lineGeometry, _coneGeometry;

function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
  // dir is assumed to be normalized
  Object3D.call(this);
  this.type = 'ArrowHelper';
  if (dir === undefined) dir = new Vector3(0, 0, 1);
  if (origin === undefined) origin = new Vector3(0, 0, 0);
  if (length === undefined) length = 1;
  if (color === undefined) color = 0xffff00;
  if (headLength === undefined) headLength = 0.2 * length;
  if (headWidth === undefined) headWidth = 0.2 * headLength;

  if (_lineGeometry === undefined) {
    _lineGeometry = new BufferGeometry();

    _lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

    _coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);

    _coneGeometry.translate(0, -0.5, 0);
  }

  this.position.copy(origin);
  this.line = new Line(_lineGeometry, new LineBasicMaterial({
    color: color,
    toneMapped: false
  }));
  this.line.matrixAutoUpdate = false;
  this.add(this.line);
  this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
    color: color,
    toneMapped: false
  }));
  this.cone.matrixAutoUpdate = false;
  this.add(this.cone);
  this.setDirection(dir);
  this.setLength(length, headLength, headWidth);
}

ArrowHelper.prototype = Object.create(Object3D.prototype);
ArrowHelper.prototype.constructor = ArrowHelper;

ArrowHelper.prototype.setDirection = function (dir) {
  // dir is assumed to be normalized
  if (dir.y > 0.99999) {
    this.quaternion.set(0, 0, 0, 1);
  } else if (dir.y < -0.99999) {
    this.quaternion.set(1, 0, 0, 0);
  } else {
    _axis.set(dir.z, 0, -dir.x).normalize();

    const radians = Math.acos(dir.y);
    this.quaternion.setFromAxisAngle(_axis, radians);
  }
};

ArrowHelper.prototype.setLength = function (length, headLength, headWidth) {
  if (headLength === undefined) headLength = 0.2 * length;
  if (headWidth === undefined) headWidth = 0.2 * headLength;
  this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458

  this.line.updateMatrix();
  this.cone.scale.set(headWidth, headLength, headWidth);
  this.cone.position.y = length;
  this.cone.updateMatrix();
};

ArrowHelper.prototype.setColor = function (color) {
  this.line.material.color.set(color);
  this.cone.material.color.set(color);
};

ArrowHelper.prototype.copy = function (source) {
  Object3D.prototype.copy.call(this, source, false);
  this.line.copy(source.line);
  this.cone.copy(source.cone);
  return this;
};

ArrowHelper.prototype.clone = function () {
  return new this.constructor().copy(this);
};
/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */


function AxesHelper(size) {
  size = size || 1;
  const vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
  const colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
  const geometry = new BufferGeometry();
  geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
  geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
  const material = new LineBasicMaterial({
    vertexColors: true,
    toneMapped: false
  });
  LineSegments.call(this, geometry, material);
  this.type = 'AxesHelper';
}

AxesHelper.prototype = Object.create(LineSegments.prototype);
AxesHelper.prototype.constructor = AxesHelper;
/**
 * @author Emmett Lalish / elalish
 *
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 */

const LOD_MIN = 4;
const LOD_MAX = 8;
const SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.

const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.

const MAX_SAMPLES = 20;
const ENCODINGS = {
  [LinearEncoding]: 0,
  [sRGBEncoding]: 1,
  [RGBEEncoding]: 2,
  [RGBM7Encoding]: 3,
  [RGBM16Encoding]: 4,
  [RGBDEncoding]: 5,
  [GammaEncoding]: 6
};

const _flatCamera = new OrthographicCamera();

const {
  _lodPlanes,
  _sizeLods,
  _sigmas
} = _createPlanes();

let _oldTarget = null; // Golden Ratio

const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.

const _axisDirections = [new Vector3(1, 1, 1), new Vector3(-1, 1, 1), new Vector3(1, 1, -1), new Vector3(-1, 1, -1), new Vector3(0, PHI, INV_PHI), new Vector3(0, PHI, -INV_PHI), new Vector3(INV_PHI, 0, PHI), new Vector3(-INV_PHI, 0, PHI), new Vector3(PHI, INV_PHI, 0), new Vector3(-PHI, INV_PHI, 0)];

function PMREMGenerator(renderer) {
  this._renderer = renderer;
  this._pingPongRenderTarget = null;
  this._blurMaterial = _getBlurShader(MAX_SAMPLES);
  this._equirectShader = null;
  this._cubemapShader = null;

  this._compileMaterial(this._blurMaterial);
}

PMREMGenerator.prototype = {
  constructor: PMREMGenerator,

  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene: function (scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();

    const cubeUVRenderTarget = this._allocateTargets();

    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);

    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }

    this._applyPMREM(cubeUVRenderTarget);

    this._cleanup(cubeUVRenderTarget);

    return cubeUVRenderTarget;
  },

  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular: function (equirectangular) {
    return this._fromTexture(equirectangular);
  },

  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap: function (cubemap) {
    return this._fromTexture(cubemap);
  },

  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader: function () {
    if (this._cubemapShader === null) {
      this._cubemapShader = _getCubemapShader();

      this._compileMaterial(this._cubemapShader);
    }
  },

  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader: function () {
    if (this._equirectShader === null) {
      this._equirectShader = _getEquirectShader();

      this._compileMaterial(this._equirectShader);
    }
  },

  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose: function () {
    this._blurMaterial.dispose();

    if (this._cubemapShader !== null) this._cubemapShader.dispose();
    if (this._equirectShader !== null) this._equirectShader.dispose();

    for (let i = 0; i < _lodPlanes.length; i++) {
      _lodPlanes[i].dispose();
    }
  },
  // private interface
  _cleanup: function (outputTarget) {
    this._pingPongRenderTarget.dispose();

    this._renderer.setRenderTarget(_oldTarget);

    outputTarget.scissorTest = false;

    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  },
  _fromTexture: function (texture) {
    _oldTarget = this._renderer.getRenderTarget();

    const cubeUVRenderTarget = this._allocateTargets(texture);

    this._textureToCubeUV(texture, cubeUVRenderTarget);

    this._applyPMREM(cubeUVRenderTarget);

    this._cleanup(cubeUVRenderTarget);

    return cubeUVRenderTarget;
  },
  _allocateTargets: function (texture) {
    // warning: null texture is valid
    const params = {
      magFilter: NearestFilter,
      minFilter: NearestFilter,
      generateMipmaps: false,
      type: UnsignedByteType,
      format: RGBEFormat,
      encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
      depthBuffer: false,
      stencilBuffer: false
    };

    const cubeUVRenderTarget = _createRenderTarget(params);

    cubeUVRenderTarget.depthBuffer = texture ? false : true;
    this._pingPongRenderTarget = _createRenderTarget(params);
    return cubeUVRenderTarget;
  },
  _compileMaterial: function (material) {
    const tmpMesh = new Mesh(_lodPlanes[0], material);

    this._renderer.compile(tmpMesh, _flatCamera);
  },
  _sceneToCubeUV: function (scene, near, far, cubeUVRenderTarget) {
    const fov = 90;
    const aspect = 1;
    const cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const outputEncoding = renderer.outputEncoding;
    const toneMapping = renderer.toneMapping;
    const clearColor = renderer.getClearColor();
    const clearAlpha = renderer.getClearAlpha();
    renderer.toneMapping = NoToneMapping;
    renderer.outputEncoding = LinearEncoding;
    let background = scene.background;

    if (background && background.isColor) {
      background.convertSRGBToLinear(); // Convert linear to RGBE

      const maxComponent = Math.max(background.r, background.g, background.b);
      const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128.0), 127.0);
      background = background.multiplyScalar(Math.pow(2.0, -fExp));
      const alpha = (fExp + 128.0) / 255.0;
      renderer.setClearColor(background, alpha);
      scene.background = null;
    }

    for (let i = 0; i < 6; i++) {
      const col = i % 3;

      if (col == 0) {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(forwardSign[i], 0, 0);
      } else if (col == 1) {
        cubeCamera.up.set(0, 0, upSign[i]);
        cubeCamera.lookAt(0, forwardSign[i], 0);
      } else {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i]);
      }

      _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);

      renderer.setRenderTarget(cubeUVRenderTarget);
      renderer.render(scene, cubeCamera);
    }

    renderer.toneMapping = toneMapping;
    renderer.outputEncoding = outputEncoding;
    renderer.setClearColor(clearColor, clearAlpha);
  },
  _textureToCubeUV: function (texture, cubeUVRenderTarget) {
    const renderer = this._renderer;

    if (texture.isCubeTexture) {
      if (this._cubemapShader == null) {
        this._cubemapShader = _getCubemapShader();
      }
    } else {
      if (this._equirectShader == null) {
        this._equirectShader = _getEquirectShader();
      }
    }

    const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
    const mesh = new Mesh(_lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms['envMap'].value = texture;

    if (!texture.isCubeTexture) {
      uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);
    }

    uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];
    uniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];

    _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);

    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  },
  _applyPMREM: function (cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;

    for (let i = 1; i < TOTAL_LODS; i++) {
      const sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);
      const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];

      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
    }

    renderer.autoClear = autoClear;
  },

  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur: function (cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;

    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);

    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
  },
  _halfBlur: function (targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;

    if (direction !== 'latitudinal' && direction !== 'longitudinal') {
      console.error('blur direction must be either latitudinal or longitudinal!');
    } // Number of standard deviations at which to cut off the discrete approximation.


    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = _sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;

    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }

    const weights = [];
    let sum = 0;

    for (let i = 0; i < MAX_SAMPLES; ++i) {
      const x = i / sigmaPixels;
      const weight = Math.exp(-x * x / 2);
      weights.push(weight);

      if (i == 0) {
        sum += weight;
      } else if (i < samples) {
        sum += 2 * weight;
      }
    }

    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / sum;
    }

    blurUniforms['envMap'].value = targetIn.texture;
    blurUniforms['samples'].value = samples;
    blurUniforms['weights'].value = weights;
    blurUniforms['latitudinal'].value = direction === 'latitudinal';

    if (poleAxis) {
      blurUniforms['poleAxis'].value = poleAxis;
    }

    blurUniforms['dTheta'].value = radiansPerPixel;
    blurUniforms['mipInt'].value = LOD_MAX - lodIn;
    blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
    blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
    const outputSize = _sizeLods[lodOut];
    const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
    const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);

    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);

    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
};

function _isLDR(texture) {
  if (texture === undefined || texture.type !== UnsignedByteType) return false;
  return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
}

function _createPlanes() {
  const _lodPlanes = [];
  const _sizeLods = [];
  const _sigmas = [];
  let lod = LOD_MAX;

  for (let i = 0; i < TOTAL_LODS; i++) {
    const sizeLod = Math.pow(2, lod);

    _sizeLods.push(sizeLod);

    let sigma = 1.0 / sizeLod;

    if (i > LOD_MAX - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];
    } else if (i == 0) {
      sigma = 0;
    }

    _sigmas.push(sigma);

    const texelSize = 1.0 / (sizeLod - 1);
    const min = -texelSize / 2;
    const max = 1 + texelSize / 2;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);

    for (let face = 0; face < cubeFaces; face++) {
      const x = face % 3 * 2 / 3 - 1;
      const y = face > 2 ? 0 : -1;
      const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }

    const planes = new BufferGeometry();
    planes.setAttribute('position', new BufferAttribute(position, positionSize));
    planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
    planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));

    _lodPlanes.push(planes);

    if (lod > LOD_MIN) {
      lod--;
    }
  }

  return {
    _lodPlanes,
    _sizeLods,
    _sigmas
  };
}

function _createRenderTarget(params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}

function _setViewport(target, x, y, width, height) {
  target.viewport.set(x, y, width, height);
  target.scissor.set(x, y, width, height);
}

function _getBlurShader(maxSamples) {
  const weights = new Float32Array(maxSamples);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new RawShaderMaterial({
    name: 'SphericalGaussianBlur',
    defines: {
      'n': maxSamples
    },
    uniforms: {
      'envMap': {
        value: null
      },
      'samples': {
        value: 1
      },
      'weights': {
        value: weights
      },
      'latitudinal': {
        value: false
      },
      'dTheta': {
        value: 0
      },
      'mipInt': {
        value: 0
      },
      'poleAxis': {
        value: poleAxis
      },
      'inputEncoding': {
        value: ENCODINGS[LinearEncoding]
      },
      'outputEncoding': {
        value: ENCODINGS[LinearEncoding]
      }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform sampler2D envMap;
uniform int samples;
uniform float weights[n];
uniform bool latitudinal;
uniform float dTheta;
uniform float mipInt;
uniform vec3 poleAxis;

${_getEncodings()}

#define ENVMAP_TYPE_CUBE_UV
#include <cube_uv_reflection_fragment>

vec3 getSample(float theta, vec3 axis) {
	float cosTheta = cos(theta);
	// Rodrigues' axis-angle rotation
	vec3 sampleDirection = vOutputDirection * cosTheta
		+ cross(axis, vOutputDirection) * sin(theta)
		+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);
	return bilinearCubeUV(envMap, sampleDirection, mipInt);
}

void main() {
	vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);
	if (all(equal(axis, vec3(0.0))))
		axis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);
	axis = normalize(axis);
	gl_FragColor = vec4(0.0);
	gl_FragColor.rgb += weights[0] * getSample(0.0, axis);
	for (int i = 1; i < n; i++) {
		if (i >= samples)
			break;
		float theta = dTheta * float(i);
		gl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);
		gl_FragColor.rgb += weights[i] * getSample(theta, axis);
	}
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}

function _getEquirectShader() {
  const texelSize = new Vector2(1, 1);
  const shaderMaterial = new RawShaderMaterial({
    name: 'EquirectangularToCubeUV',
    uniforms: {
      'envMap': {
        value: null
      },
      'texelSize': {
        value: texelSize
      },
      'inputEncoding': {
        value: ENCODINGS[LinearEncoding]
      },
      'outputEncoding': {
        value: ENCODINGS[LinearEncoding]
      }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform sampler2D envMap;
uniform vec2 texelSize;

${_getEncodings()}

#include <common>

void main() {
	gl_FragColor = vec4(0.0);
	vec3 outputDirection = normalize(vOutputDirection);
	vec2 uv = equirectUv( outputDirection );
	vec2 f = fract(uv / texelSize - 0.5);
	uv -= f * texelSize;
	vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.x += texelSize.x;
	vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.y += texelSize.y;
	vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.x -= texelSize.x;
	vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	vec3 tm = mix(tl, tr, f.x);
	vec3 bm = mix(bl, br, f.x);
	gl_FragColor.rgb = mix(tm, bm, f.y);
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}

function _getCubemapShader() {
  const shaderMaterial = new RawShaderMaterial({
    name: 'CubemapToCubeUV',
    uniforms: {
      'envMap': {
        value: null
      },
      'inputEncoding': {
        value: ENCODINGS[LinearEncoding]
      },
      'outputEncoding': {
        value: ENCODINGS[LinearEncoding]
      }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform samplerCube envMap;

${_getEncodings()}

void main() {
	gl_FragColor = vec4(0.0);
	gl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}

function _getCommonVertexShader() {
  return `
precision mediump float;
precision mediump int;
attribute vec3 position;
attribute vec2 uv;
attribute float faceIndex;
varying vec3 vOutputDirection;

// RH coordinate system; PMREM face-indexing convention
vec3 getDirection(vec2 uv, float face) {
	uv = 2.0 * uv - 1.0;
	vec3 direction = vec3(uv, 1.0);
	if (face == 0.0) {
		direction = direction.zyx; // ( 1, v, u ) pos x
	} else if (face == 1.0) {
		direction = direction.xzy;
		direction.xz *= -1.0; // ( -u, 1, -v ) pos y
	} else if (face == 2.0) {
		direction.x *= -1.0; // ( -u, v, 1 ) pos z
	} else if (face == 3.0) {
		direction = direction.zyx;
		direction.xz *= -1.0; // ( -1, v, -u ) neg x
	} else if (face == 4.0) {
		direction = direction.xzy;
		direction.xy *= -1.0; // ( -u, -1, v ) neg y
	} else if (face == 5.0) {
		direction.z *= -1.0; // ( u, v, -1 ) neg z
	}
	return direction;
}

void main() {
	vOutputDirection = getDirection(uv, faceIndex);
	gl_Position = vec4( position, 1.0 );
}
	`;
}

function _getEncodings() {
  return `
uniform int inputEncoding;
uniform int outputEncoding;

#include <encodings_pars_fragment>

vec4 inputTexelToLinear(vec4 value){
	if(inputEncoding == 0){
		return value;
	}else if(inputEncoding == 1){
		return sRGBToLinear(value);
	}else if(inputEncoding == 2){
		return RGBEToLinear(value);
	}else if(inputEncoding == 3){
		return RGBMToLinear(value, 7.0);
	}else if(inputEncoding == 4){
		return RGBMToLinear(value, 16.0);
	}else if(inputEncoding == 5){
		return RGBDToLinear(value, 256.0);
	}else{
		return GammaToLinear(value, 2.2);
	}
}

vec4 linearToOutputTexel(vec4 value){
	if(outputEncoding == 0){
		return value;
	}else if(outputEncoding == 1){
		return LinearTosRGB(value);
	}else if(outputEncoding == 2){
		return LinearToRGBE(value);
	}else if(outputEncoding == 3){
		return LinearToRGBM(value, 7.0);
	}else if(outputEncoding == 4){
		return LinearToRGBM(value, 16.0);
	}else if(outputEncoding == 5){
		return LinearToRGBD(value, 256.0);
	}else{
		return LinearToGamma(value, 2.2);
	}
}

vec4 envMapTexelToLinear(vec4 color) {
	return inputTexelToLinear(color);
}
	`;
}
/**
 * @author mrdoob / http://mrdoob.com/
 */


function Face4(a, b, c, d, normal, color, materialIndex) {
  console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
  return new Face3(a, b, c, normal, color, materialIndex);
}

const LineStrip = 0;
exports.LineStrip = LineStrip;
const LinePieces = 1;
exports.LinePieces = LinePieces;
const NoColors = 0;
exports.NoColors = NoColors;
const FaceColors = 1;
exports.FaceColors = FaceColors;
const VertexColors = 2;
exports.VertexColors = VertexColors;

function MeshFaceMaterial(materials) {
  console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
  return materials;
}

function MultiMaterial(materials) {
  if (materials === undefined) materials = [];
  console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
  materials.isMultiMaterial = true;
  materials.materials = materials;

  materials.clone = function () {
    return materials.slice();
  };

  return materials;
}

function PointCloud(geometry, material) {
  console.warn('THREE.PointCloud has been renamed to THREE.Points.');
  return new Points(geometry, material);
}

function Particle(material) {
  console.warn('THREE.Particle has been renamed to THREE.Sprite.');
  return new Sprite(material);
}

function ParticleSystem(geometry, material) {
  console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
  return new Points(geometry, material);
}

function PointCloudMaterial(parameters) {
  console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
  return new PointsMaterial(parameters);
}

function ParticleBasicMaterial(parameters) {
  console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
  return new PointsMaterial(parameters);
}

function ParticleSystemMaterial(parameters) {
  console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
  return new PointsMaterial(parameters);
}

function Vertex(x, y, z) {
  console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
  return new Vector3(x, y, z);
} //


function DynamicBufferAttribute(array, itemSize) {
  console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
  return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
}

function Int8Attribute(array, itemSize) {
  console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
  return new Int8BufferAttribute(array, itemSize);
}

function Uint8Attribute(array, itemSize) {
  console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
  return new Uint8BufferAttribute(array, itemSize);
}

function Uint8ClampedAttribute(array, itemSize) {
  console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
  return new Uint8ClampedBufferAttribute(array, itemSize);
}

function Int16Attribute(array, itemSize) {
  console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
  return new Int16BufferAttribute(array, itemSize);
}

function Uint16Attribute(array, itemSize) {
  console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
  return new Uint16BufferAttribute(array, itemSize);
}

function Int32Attribute(array, itemSize) {
  console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
  return new Int32BufferAttribute(array, itemSize);
}

function Uint32Attribute(array, itemSize) {
  console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
  return new Uint32BufferAttribute(array, itemSize);
}

function Float32Attribute(array, itemSize) {
  console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
  return new Float32BufferAttribute(array, itemSize);
}

function Float64Attribute(array, itemSize) {
  console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
  return new Float64BufferAttribute(array, itemSize);
} //


Curve.create = function (construct, getPoint) {
  console.log('THREE.Curve.create() has been deprecated');
  construct.prototype = Object.create(Curve.prototype);
  construct.prototype.constructor = construct;
  construct.prototype.getPoint = getPoint;
  return construct;
}; //


Object.assign(CurvePath.prototype, {
  createPointsGeometry: function (divisions) {
    console.warn('THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.'); // generate geometry from path points (for Line or Points objects)

    const pts = this.getPoints(divisions);
    return this.createGeometry(pts);
  },
  createSpacedPointsGeometry: function (divisions) {
    console.warn('THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.'); // generate geometry from equidistant sampling along the path

    const pts = this.getSpacedPoints(divisions);
    return this.createGeometry(pts);
  },
  createGeometry: function (points) {
    console.warn('THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');
    const geometry = new Geometry();

    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
    }

    return geometry;
  }
}); //

Object.assign(Path.prototype, {
  fromPoints: function (points) {
    console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
    return this.setFromPoints(points);
  }
}); //

function ClosedSplineCurve3(points) {
  console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
  CatmullRomCurve3.call(this, points);
  this.type = 'catmullrom';
  this.closed = true;
}

ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype); //

function SplineCurve3(points) {
  console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');
  CatmullRomCurve3.call(this, points);
  this.type = 'catmullrom';
}

SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype); //

function Spline(points) {
  console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');
  CatmullRomCurve3.call(this, points);
  this.type = 'catmullrom';
}

Spline.prototype = Object.create(CatmullRomCurve3.prototype);
Object.assign(Spline.prototype, {
  initFromArray: function ()
  /* a */
  {
    console.error('THREE.Spline: .initFromArray() has been removed.');
  },
  getControlPointsArray: function ()
  /* optionalTarget */
  {
    console.error('THREE.Spline: .getControlPointsArray() has been removed.');
  },
  reparametrizeByArcLength: function ()
  /* samplingCoef */
  {
    console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');
  }
}); //

function AxisHelper(size) {
  console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
  return new AxesHelper(size);
}

function BoundingBoxHelper(object, color) {
  console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
  return new BoxHelper(object, color);
}

function EdgesHelper(object, hex) {
  console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
  return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
    color: hex !== undefined ? hex : 0xffffff
  }));
}

GridHelper.prototype.setColors = function () {
  console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
};

SkeletonHelper.prototype.update = function () {
  console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
};

function WireframeHelper(object, hex) {
  console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
  return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
    color: hex !== undefined ? hex : 0xffffff
  }));
} //


Object.assign(Loader.prototype, {
  extractUrlBase: function (url) {
    console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
    return LoaderUtils.extractUrlBase(url);
  }
});
Loader.Handlers = {
  add: function ()
  /* regex, loader */
  {
    console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
  },
  get: function ()
  /* file */
  {
    console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
  }
};

function XHRLoader(manager) {
  console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
  return new FileLoader(manager);
}

function BinaryTextureLoader(manager) {
  console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
  return new DataTextureLoader(manager);
}

Object.assign(ObjectLoader.prototype, {
  setTexturePath: function (value) {
    console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
    return this.setResourcePath(value);
  }
}); //

Object.assign(Box2.prototype, {
  center: function (optionalTarget) {
    console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
  },
  empty: function () {
    console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
  },
  isIntersectionBox: function (box) {
    console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box);
  },
  size: function (optionalTarget) {
    console.warn('THREE.Box2: .size() has been renamed to .getSize().');
    return this.getSize(optionalTarget);
  }
});
Object.assign(Box3.prototype, {
  center: function (optionalTarget) {
    console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
    return this.getCenter(optionalTarget);
  },
  empty: function () {
    console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
  },
  isIntersectionBox: function (box) {
    console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box);
  },
  isIntersectionSphere: function (sphere) {
    console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
    return this.intersectsSphere(sphere);
  },
  size: function (optionalTarget) {
    console.warn('THREE.Box3: .size() has been renamed to .getSize().');
    return this.getSize(optionalTarget);
  }
});
Object.assign(Sphere.prototype, {
  empty: function () {
    console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');
    return this.isEmpty();
  }
});

Frustum.prototype.setFromMatrix = function (m) {
  console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
  return this.setFromProjectionMatrix(m);
};

Line3.prototype.center = function (optionalTarget) {
  console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
  return this.getCenter(optionalTarget);
};

Object.assign(MathUtils, {
  random16: function () {
    console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');
    return Math.random();
  },
  nearestPowerOfTwo: function (value) {
    console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');
    return MathUtils.floorPowerOfTwo(value);
  },
  nextPowerOfTwo: function (value) {
    console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');
    return MathUtils.ceilPowerOfTwo(value);
  }
});
Object.assign(Matrix3.prototype, {
  flattenToArrayOffset: function (array, offset) {
    console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset);
  },
  multiplyVector3: function (vector) {
    console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
    return vector.applyMatrix3(this);
  },
  multiplyVector3Array: function ()
  /* a */
  {
    console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
  },
  applyToBufferAttribute: function (attribute) {
    console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
    return attribute.applyMatrix3(this);
  },
  applyToVector3Array: function ()
  /* array, offset, length */
  {
    console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
  }
});
Object.assign(Matrix4.prototype, {
  extractPosition: function (m) {
    console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
    return this.copyPosition(m);
  },
  flattenToArrayOffset: function (array, offset) {
    console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset);
  },
  getPosition: function () {
    console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
    return new Vector3().setFromMatrixColumn(this, 3);
  },
  setRotationFromQuaternion: function (q) {
    console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
    return this.makeRotationFromQuaternion(q);
  },
  multiplyToArray: function () {
    console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
  },
  multiplyVector3: function (vector) {
    console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  multiplyVector4: function (vector) {
    console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  multiplyVector3Array: function ()
  /* a */
  {
    console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
  },
  rotateAxis: function (v) {
    console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
    v.transformDirection(this);
  },
  crossVector: function (vector) {
    console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return vector.applyMatrix4(this);
  },
  translate: function () {
    console.error('THREE.Matrix4: .translate() has been removed.');
  },
  rotateX: function () {
    console.error('THREE.Matrix4: .rotateX() has been removed.');
  },
  rotateY: function () {
    console.error('THREE.Matrix4: .rotateY() has been removed.');
  },
  rotateZ: function () {
    console.error('THREE.Matrix4: .rotateZ() has been removed.');
  },
  rotateByAxis: function () {
    console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
  },
  applyToBufferAttribute: function (attribute) {
    console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
    return attribute.applyMatrix4(this);
  },
  applyToVector3Array: function ()
  /* array, offset, length */
  {
    console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
  },
  makeFrustum: function (left, right, bottom, top, near, far) {
    console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
    return this.makePerspective(left, right, top, bottom, near, far);
  }
});

Plane.prototype.isIntersectionLine = function (line) {
  console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
  return this.intersectsLine(line);
};

Quaternion.prototype.multiplyVector3 = function (vector) {
  console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
  return vector.applyQuaternion(this);
};

Object.assign(Ray.prototype, {
  isIntersectionBox: function (box) {
    console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
    return this.intersectsBox(box);
  },
  isIntersectionPlane: function (plane) {
    console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
    return this.intersectsPlane(plane);
  },
  isIntersectionSphere: function (sphere) {
    console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
    return this.intersectsSphere(sphere);
  }
});
Object.assign(Triangle.prototype, {
  area: function () {
    console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
    return this.getArea();
  },
  barycoordFromPoint: function (point, target) {
    console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
    return this.getBarycoord(point, target);
  },
  midpoint: function (target) {
    console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
    return this.getMidpoint(target);
  },
  normal: function (target) {
    console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
    return this.getNormal(target);
  },
  plane: function (target) {
    console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
    return this.getPlane(target);
  }
});
Object.assign(Triangle, {
  barycoordFromPoint: function (point, a, b, c, target) {
    console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
    return Triangle.getBarycoord(point, a, b, c, target);
  },
  normal: function (a, b, c, target) {
    console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
    return Triangle.getNormal(a, b, c, target);
  }
});
Object.assign(Shape.prototype, {
  extractAllPoints: function (divisions) {
    console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
    return this.extractPoints(divisions);
  },
  extrude: function (options) {
    console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
    return new ExtrudeGeometry(this, options);
  },
  makeGeometry: function (options) {
    console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
    return new ShapeGeometry(this, options);
  }
});
Object.assign(Vector2.prototype, {
  fromAttribute: function (attribute, index, offset) {
    console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index, offset);
  },
  distanceToManhattan: function (v) {
    console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
    return this.manhattanDistanceTo(v);
  },
  lengthManhattan: function () {
    console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
  }
});
Object.assign(Vector3.prototype, {
  setEulerFromRotationMatrix: function () {
    console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
  },
  setEulerFromQuaternion: function () {
    console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
  },
  getPositionFromMatrix: function (m) {
    console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
    return this.setFromMatrixPosition(m);
  },
  getScaleFromMatrix: function (m) {
    console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
    return this.setFromMatrixScale(m);
  },
  getColumnFromMatrix: function (index, matrix) {
    console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
    return this.setFromMatrixColumn(matrix, index);
  },
  applyProjection: function (m) {
    console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
    return this.applyMatrix4(m);
  },
  fromAttribute: function (attribute, index, offset) {
    console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index, offset);
  },
  distanceToManhattan: function (v) {
    console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
    return this.manhattanDistanceTo(v);
  },
  lengthManhattan: function () {
    console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
  }
});
Object.assign(Vector4.prototype, {
  fromAttribute: function (attribute, index, offset) {
    console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
    return this.fromBufferAttribute(attribute, index, offset);
  },
  lengthManhattan: function () {
    console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
    return this.manhattanLength();
  }
}); //

Object.assign(Geometry.prototype, {
  computeTangents: function () {
    console.error('THREE.Geometry: .computeTangents() has been removed.');
  },
  computeLineDistances: function () {
    console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');
  },
  applyMatrix: function (matrix) {
    console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');
    return this.applyMatrix4(matrix);
  }
});
Object.assign(Object3D.prototype, {
  getChildByName: function (name) {
    console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
    return this.getObjectByName(name);
  },
  renderDepth: function () {
    console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
  },
  translate: function (distance, axis) {
    console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
    return this.translateOnAxis(axis, distance);
  },
  getWorldRotation: function () {
    console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
  },
  applyMatrix: function (matrix) {
    console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
    return this.applyMatrix4(matrix);
  }
});
Object.defineProperties(Object3D.prototype, {
  eulerOrder: {
    get: function () {
      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
      return this.rotation.order;
    },
    set: function (value) {
      console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
      this.rotation.order = value;
    }
  },
  useQuaternion: {
    get: function () {
      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
    },
    set: function () {
      console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
    }
  }
});
Object.assign(Mesh.prototype, {
  setDrawMode: function () {
    console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
  }
});
Object.defineProperties(Mesh.prototype, {
  drawMode: {
    get: function () {
      console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
      return TrianglesDrawMode;
    },
    set: function () {
      console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
    }
  }
});
Object.defineProperties(LOD.prototype, {
  objects: {
    get: function () {
      console.warn('THREE.LOD: .objects has been renamed to .levels.');
      return this.levels;
    }
  }
});
Object.defineProperty(Skeleton.prototype, 'useVertexTexture', {
  get: function () {
    console.warn('THREE.Skeleton: useVertexTexture has been removed.');
  },
  set: function () {
    console.warn('THREE.Skeleton: useVertexTexture has been removed.');
  }
});

SkinnedMesh.prototype.initBones = function () {
  console.error('THREE.SkinnedMesh: initBones() has been removed.');
};

Object.defineProperty(Curve.prototype, '__arcLengthDivisions', {
  get: function () {
    console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
    return this.arcLengthDivisions;
  },
  set: function (value) {
    console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');
    this.arcLengthDivisions = value;
  }
}); //

PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. " + "Use .setFocalLength and .filmGauge for a photographic setup.");
  if (filmGauge !== undefined) this.filmGauge = filmGauge;
  this.setFocalLength(focalLength);
}; //


Object.defineProperties(Light.prototype, {
  onlyShadow: {
    set: function () {
      console.warn('THREE.Light: .onlyShadow has been removed.');
    }
  },
  shadowCameraFov: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function (value) {
      console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function () {
      console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
    }
  },
  shadowBias: {
    set: function (value) {
      console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function () {
      console.warn('THREE.Light: .shadowDarkness has been removed.');
    }
  },
  shadowMapWidth: {
    set: function (value) {
      console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function (value) {
      console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
      this.shadow.mapSize.height = value;
    }
  }
}); //

Object.defineProperties(BufferAttribute.prototype, {
  length: {
    get: function () {
      console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
      return this.array.length;
    }
  },
  dynamic: {
    get: function () {
      console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
      return this.usage === DynamicDrawUsage;
    },
    set: function ()
    /* value */
    {
      console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
      this.setUsage(DynamicDrawUsage);
    }
  }
});
Object.assign(BufferAttribute.prototype, {
  setDynamic: function (value) {
    console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
    return this;
  },
  copyIndicesArray: function ()
  /* indices */
  {
    console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
  },
  setArray: function ()
  /* array */
  {
    console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
  }
});
Object.assign(BufferGeometry.prototype, {
  addIndex: function (index) {
    console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
    this.setIndex(index);
  },
  addAttribute: function (name, attribute) {
    console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');

    if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
      console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
      return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
    }

    if (name === 'index') {
      console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
      this.setIndex(attribute);
      return this;
    }

    return this.setAttribute(name, attribute);
  },
  addDrawCall: function (start, count, indexOffset) {
    if (indexOffset !== undefined) {
      console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
    }

    console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
    this.addGroup(start, count);
  },
  clearDrawCalls: function () {
    console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
    this.clearGroups();
  },
  computeTangents: function () {
    console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
  },
  computeOffsets: function () {
    console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
  },
  removeAttribute: function (name) {
    console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
    return this.deleteAttribute(name);
  },
  applyMatrix: function (matrix) {
    console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
    return this.applyMatrix4(matrix);
  }
});
Object.defineProperties(BufferGeometry.prototype, {
  drawcalls: {
    get: function () {
      console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
      return this.groups;
    }
  },
  offsets: {
    get: function () {
      console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
      return this.groups;
    }
  }
});
Object.defineProperties(InstancedBufferGeometry.prototype, {
  maxInstancedCount: {
    get: function () {
      console.warn('THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.');
      return this.instanceCount;
    },
    set: function (value) {
      console.warn('THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.');
      this.instanceCount = value;
    }
  }
});
Object.defineProperties(Raycaster.prototype, {
  linePrecision: {
    get: function () {
      console.warn('THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.');
      return this.params.Line.threshold;
    },
    set: function (value) {
      console.warn('THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.');
      this.params.Line.threshold = value;
    }
  }
});
Object.defineProperties(InterleavedBuffer.prototype, {
  dynamic: {
    get: function () {
      console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
      return this.usage === DynamicDrawUsage;
    },
    set: function (value) {
      console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');
      this.setUsage(value);
    }
  }
});
Object.assign(InterleavedBuffer.prototype, {
  setDynamic: function (value) {
    console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
    return this;
  },
  setArray: function ()
  /* array */
  {
    console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
  }
}); //

Object.assign(ExtrudeBufferGeometry.prototype, {
  getArrays: function () {
    console.error('THREE.ExtrudeBufferGeometry: .getArrays() has been removed.');
  },
  addShapeList: function () {
    console.error('THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.');
  },
  addShape: function () {
    console.error('THREE.ExtrudeBufferGeometry: .addShape() has been removed.');
  }
}); //

Object.defineProperties(Uniform.prototype, {
  dynamic: {
    set: function () {
      console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');
    }
  },
  onUpdate: {
    value: function () {
      console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
      return this;
    }
  }
}); //

Object.defineProperties(Material.prototype, {
  wrapAround: {
    get: function () {
      console.warn('THREE.Material: .wrapAround has been removed.');
    },
    set: function () {
      console.warn('THREE.Material: .wrapAround has been removed.');
    }
  },
  overdraw: {
    get: function () {
      console.warn('THREE.Material: .overdraw has been removed.');
    },
    set: function () {
      console.warn('THREE.Material: .overdraw has been removed.');
    }
  },
  wrapRGB: {
    get: function () {
      console.warn('THREE.Material: .wrapRGB has been removed.');
      return new Color();
    }
  },
  shading: {
    get: function () {
      console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
    },
    set: function (value) {
      console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
      this.flatShading = value === FlatShading;
    }
  },
  stencilMask: {
    get: function () {
      console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
      return this.stencilFuncMask;
    },
    set: function (value) {
      console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
      this.stencilFuncMask = value;
    }
  }
});
Object.defineProperties(MeshPhongMaterial.prototype, {
  metal: {
    get: function () {
      console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');
      return false;
    },
    set: function () {
      console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');
    }
  }
});
Object.defineProperties(ShaderMaterial.prototype, {
  derivatives: {
    get: function () {
      console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
      return this.extensions.derivatives;
    },
    set: function (value) {
      console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
      this.extensions.derivatives = value;
    }
  }
}); //

Object.assign(WebGLRenderer.prototype, {
  clearTarget: function (renderTarget, color, depth, stencil) {
    console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
    this.setRenderTarget(renderTarget);
    this.clear(color, depth, stencil);
  },
  animate: function (callback) {
    console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
    this.setAnimationLoop(callback);
  },
  getCurrentRenderTarget: function () {
    console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
    return this.getRenderTarget();
  },
  getMaxAnisotropy: function () {
    console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
    return this.capabilities.getMaxAnisotropy();
  },
  getPrecision: function () {
    console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
    return this.capabilities.precision;
  },
  resetGLState: function () {
    console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
    return this.state.reset();
  },
  supportsFloatTextures: function () {
    console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
    return this.extensions.get('OES_texture_float');
  },
  supportsHalfFloatTextures: function () {
    console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
    return this.extensions.get('OES_texture_half_float');
  },
  supportsStandardDerivatives: function () {
    console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
    return this.extensions.get('OES_standard_derivatives');
  },
  supportsCompressedTextureS3TC: function () {
    console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
    return this.extensions.get('WEBGL_compressed_texture_s3tc');
  },
  supportsCompressedTexturePVRTC: function () {
    console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
    return this.extensions.get('WEBGL_compressed_texture_pvrtc');
  },
  supportsBlendMinMax: function () {
    console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
    return this.extensions.get('EXT_blend_minmax');
  },
  supportsVertexTextures: function () {
    console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
    return this.capabilities.vertexTextures;
  },
  supportsInstancedArrays: function () {
    console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
    return this.extensions.get('ANGLE_instanced_arrays');
  },
  enableScissorTest: function (boolean) {
    console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
    this.setScissorTest(boolean);
  },
  initMaterial: function () {
    console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
  },
  addPrePlugin: function () {
    console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
  },
  addPostPlugin: function () {
    console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
  },
  updateShadowMap: function () {
    console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
  },
  setFaceCulling: function () {
    console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
  },
  allocTextureUnit: function () {
    console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
  },
  setTexture: function () {
    console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
  },
  setTexture2D: function () {
    console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
  },
  setTextureCube: function () {
    console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
  },
  getActiveMipMapLevel: function () {
    console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
    return this.getActiveMipmapLevel();
  }
});
Object.defineProperties(WebGLRenderer.prototype, {
  shadowMapEnabled: {
    get: function () {
      return this.shadowMap.enabled;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function () {
      return this.shadowMap.type;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function ()
    /* value */
    {
      console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
    }
  },
  context: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
      return this.getContext();
    }
  },
  vr: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
      return this.xr;
    }
  },
  gammaInput: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
      return false;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
    }
  },
  gammaOutput: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
      return false;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
    }
  },
  toneMappingWhitePoint: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
      return 1.0;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
    }
  }
});
Object.defineProperties(WebGLShadowMap.prototype, {
  cullFace: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function ()
    /* cullFace */
    {
      console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
    }
  },
  renderReverseSided: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
    }
  },
  renderSingleSided: {
    get: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
      return undefined;
    },
    set: function () {
      console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
    }
  }
});

function WebGLRenderTargetCube(width, height, options) {
  console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
  return new WebGLCubeRenderTarget(width, options);
} //


Object.defineProperties(WebGLRenderTarget.prototype, {
  wrapS: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
      return this.texture.wrapS;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
      return this.texture.wrapT;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
      return this.texture.magFilter;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
      return this.texture.minFilter;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
      return this.texture.anisotropy;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
      return this.texture.offset;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
      return this.texture.repeat;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
      this.texture.repeat = value;
    }
  },
  format: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
      return this.texture.format;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
      this.texture.format = value;
    }
  },
  type: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
      return this.texture.type;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function () {
      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
      return this.texture.generateMipmaps;
    },
    set: function (value) {
      console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
      this.texture.generateMipmaps = value;
    }
  }
}); //

Object.defineProperties(Audio.prototype, {
  load: {
    value: function (file) {
      console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
      const scope = this;
      const audioLoader = new AudioLoader();
      audioLoader.load(file, function (buffer) {
        scope.setBuffer(buffer);
      });
      return this;
    }
  },
  startTime: {
    set: function () {
      console.warn('THREE.Audio: .startTime is now .play( delay ).');
    }
  }
});

AudioAnalyser.prototype.getData = function () {
  console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
  return this.getFrequencyData();
}; //


CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
  console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
  return this.update(renderer, scene);
}; //


const GeometryUtils = {
  merge: function (geometry1, geometry2, materialIndexOffset) {
    console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');
    let matrix;

    if (geometry2.isMesh) {
      geometry2.matrixAutoUpdate && geometry2.updateMatrix();
      matrix = geometry2.matrix;
      geometry2 = geometry2.geometry;
    }

    geometry1.merge(geometry2, matrix, materialIndexOffset);
  },
  center: function (geometry) {
    console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');
    return geometry.center();
  }
};
exports.GeometryUtils = GeometryUtils;
ImageUtils.crossOrigin = undefined;

ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
  console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
  const loader = new TextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(url, onLoad, undefined, onError);
  if (mapping) texture.mapping = mapping;
  return texture;
};

ImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {
  console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
  const loader = new CubeTextureLoader();
  loader.setCrossOrigin(this.crossOrigin);
  const texture = loader.load(urls, onLoad, undefined, onError);
  if (mapping) texture.mapping = mapping;
  return texture;
};

ImageUtils.loadCompressedTexture = function () {
  console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
};

ImageUtils.loadCompressedTextureCube = function () {
  console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
}; //


function CanvasRenderer() {
  console.error('THREE.CanvasRenderer has been removed');
} //


function JSONLoader() {
  console.error('THREE.JSONLoader has been removed.');
} //


const SceneUtils = {
  createMultiMaterialObject: function ()
  /* geometry, materials */
  {
    console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
  },
  detach: function ()
  /* child, parent, scene */
  {
    console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
  },
  attach: function ()
  /* child, scene, parent */
  {
    console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
  }
}; //

exports.SceneUtils = SceneUtils;

function LensFlare() {
  console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');
}

if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
  /* eslint-disable no-undef */
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
    detail: {
      revision: REVISION
    }
  }));
  /* eslint-enable no-undef */

}
},{}],"src/util/patch-threejs-copy.js":[function(require,module,exports) {
"use strict";

var _three = require("three");

// Box3.prototype.expandByObject = function (object) {
//   // Computes the world-axis-aligned bounding box of an object (including its children),
// 	// accounting for both the object's, and children's, world transforms
// 	object.updateWorldMatrix( false, false );
// 	const geometry = object.geometry;
// 	if ( geometry !== undefined ) {
// 		if ( geometry.boundingBox === null ) {
// 			geometry.computeBoundingBox();
// 		}
// 		_box.copy( geometry.boundingBox );
// 		_box.applyMatrix4( object.matrixWorld );
// 		this.union( _box );
// 	}
// 	const children = object.children;
// 	for ( let i = 0, l = children.length; i < l; i ++ ) {
// 		this.expandByObject( children[ i ] );
// 	}
// 	return this;
// }
_three.Object3D.prototype.copy = function copy(source, recursive) {
  if (recursive === undefined) recursive = true;
  this.name = source.name;
  this.up.copy(source.up);
  this.position.copy(source.position);
  this.rotation.order = source.rotation.order;
  this.quaternion.copy(source.quaternion);
  this.scale.copy(source.scale);
  this.matrix.copy(source.matrix);
  this.matrixWorld.copy(source.matrixWorld);
  this.matrixAutoUpdate = source.matrixAutoUpdate;
  this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
  this.layers.mask = source.layers.mask;
  this.visible = source.visible;
  this.castShadow = source.castShadow;
  this.receiveShadow = source.receiveShadow;
  this.frustumCulled = source.frustumCulled;
  this.renderOrder = source.renderOrder;

  for (let k in this.userData) {
    // clear current
    this.userData[k] = null;
  }

  for (let k in source.userData) {
    // assign source
    this.userData[k] = source.userData[k];
  }

  if (recursive === true) {
    for (let i = 0; i < source.children.length; i++) {
      const child = source.children[i];
      this.add(child.clone());
    }
  }

  return this;
}; // Layers.prototype.test = function (layers) {
//   return (this.mask & layers.mask) !== 0;
// };
},{"three":"src/vendor/three.module.js"}],"src/polyfills.js":[function(require,module,exports) {
"use strict";

require("array-flat-polyfill");

require("./util/patch-threejs-copy");
},{"array-flat-polyfill":"node_modules/array-flat-polyfill/index.mjs","./util/patch-threejs-copy":"src/util/patch-threejs-copy.js"}],"src/util/array.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spliceOne = spliceOne;
exports.newArray = newArray;
exports.spliceObject = spliceObject;

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function newArray(n, fill = 0) {
  const array = new Array(n);

  for (let i = 0; i < n; i++) array[i] = fill;

  return array;
}

function spliceObject(list, object) {
  const idx = list.indexOf(object);
  if (idx >= 0) spliceOne(list, idx);
}
},{}],"src/util/ObjectPool.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

const ret = e => e;

const und = () => undefined;

const IS_DEV = "development" === "development";
const LOGGING = IS_DEV;
const globalPoolSet = LOGGING ? new Set() : null; // Stripped from ECSY, and modified

class ObjectPool {
  static isObjectPool = true;

  constructor(opt = {}) {
    const {
      renew = ret,
      create = und,
      release = ret,
      dispose = ret,
      initialCapacity,
      name = undefined,
      maxCapacity = Infinity
    } = opt;
    this.name = name;
    if (LOGGING) globalPoolSet.add(this);
    this._renew = renew.bind(this);
    this._create = create.bind(this);
    this._release = release.bind(this);
    this._dispose = dispose.bind(this);
    this.pool = [];
    this.capacity = 0;
    this.maxCapacity = maxCapacity;

    if (typeof initialCapacity !== "undefined") {
      this.expand(initialCapacity);
    }
  }

  next() {
    // Grow the list by 20% ish if we're out
    if (this.pool.length <= 0) {
      this.expand(Math.round(this.capacity * 0.2) + 1);
    } // reached max capacity and no more left...


    if (this.pool.length === 0) return undefined;
    const item = this.pool.pop();

    this._renew(item);

    return item;
  }

  release(item) {
    this._release(item);

    this.pool.push(item);
  }

  expand(N = 0) {
    N = Math.max(0, Math.min(N, this.maxCapacity - this.capacity));

    for (let n = 0; n < N; n++) {
      const clone = this._create();

      this.pool.push(clone);
    }

    this.capacity += N;
  }

  dispose() {
    for (let i = 0; i < this.pool.length; i++) {
      this._dispose(this.pool[i]);
    }

    this.pool.length = 0;
    this.capacity = 0;
  }

  log() {
    const name = this.name ? `${this.name} - ` : '';
    console.log(`${name}Capacity: %d, Free: %d, Used: %d`, this.totalCapacity(), this.totalFree(), this.totalUsed());
  }

  totalCapacity() {
    return this.capacity;
  }

  totalFree() {
    return this.pool.length;
  }

  totalUsed() {
    return this.capacity - this.pool.length;
  }

}

exports.default = ObjectPool;

if (LOGGING) {
  window.logPools = filter => {
    globalPoolSet.forEach(pool => {
      if (filter) {
        if (!pool.name || !pool.name.toLowerCase().includes(filter.toLowerCase())) {
          return;
        }
      }

      console.log(`Pool ${pool.name || "(Untitled)"}:`);
      console.log(`  Total Capacity:`, pool.totalCapacity());
      console.log(`  Total Free:`, pool.totalFree());
      console.log(`  Total Used:`, pool.totalUsed());
    });
  };
}
},{}],"src/alec/tag.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.copyArray = copyArray;
exports.copyObject = copyObject;
exports.copyRef = copyRef;
exports.copyInstance = copyInstance;
exports.Data = exports.Value = exports.Tag = exports.Types = exports.cloneObject = exports.cloneArray = exports.cloneRef = exports.cloneInstance = void 0;

function copyArray(src, dst) {
  if (!src) return src;
  if (!dst) return src.slice();
  dst.length = src.length;

  for (let i = 0; i < src.length; i++) {
    dst[i] = src[i];
  }

  return dst;
}

function copyObject(src, dst) {
  if (!src) return src;

  if (!dst) {
    dst = {};
  } else {
    // object exists, ensure it's empty
    for (let k in dst) {
      if (dst.hasOwnProperty(k)) delete dst[k];
    }
  } // copy over source props


  for (let k in src) {
    if (src.hasOwnProperty(k)) {
      dst[k] = src[k];
    }
  }

  return dst;
}

function copyRef(src) {
  return src;
}

function copyInstance(src, dest) {
  if (!src) return src;
  if (!dest) return src.clone();
  return dest.copy(src);
}

const cloneInstance = src => src && src.clone();

exports.cloneInstance = cloneInstance;

const cloneRef = src => src;

exports.cloneRef = cloneRef;

const cloneArray = src => src && src.slice();

exports.cloneArray = cloneArray;

const cloneObject = src => Object.assign({}, src);

exports.cloneObject = cloneObject;
const Types = {
  Object: (initial = {}) => ({
    initial,
    clone: cloneObject,
    copy: copyObject
  }),
  Array: (initial = []) => ({
    initial,
    clone: cloneArray,
    copy: copyArray
  }),
  Ref: initial => ({
    initial,
    clone: cloneRef,
    copy: copyRef
  })
};
exports.Types = Types;

class Tag {
  static isTag = true;
}

exports.Tag = Tag;

class Value extends Tag {
  static value = Types.Ref(null);
  static isValue = true;

  constructor() {
    super();
    fixSchemaProp(this.constructor, "value");
    const prop = this.constructor.value;
    this.value = prop.clone(prop.initial);
  }

  reset() {
    const prop = this.constructor.value;
    this.value = prop.copy(prop.initial, this.value);
  }

}

exports.Value = Value;

class Data extends Tag {
  static data = {};
  static isData = true;

  constructor() {
    super();
    const data = this.constructor.data;

    for (let k in data) {
      if (data.hasOwnProperty(k)) {
        fixSchemaProp(data, k);
        const prop = data[k];
        this[k] = prop.clone(prop.initial);
      }
    }
  }

  reset() {
    const data = this.constructor.data;

    for (let k in data) {
      if (data.hasOwnProperty(k)) {
        const prop = data[k];
        this[k] = prop.copy(prop.initial, this[k]);
      }
    }
  }

}

exports.Data = Data;

function fixSchemaProp(schema, k) {
  const prop = schema[k];

  if (Array.isArray(prop)) {
    schema[k] = Types.Array(schema[k]);
  } else if (typeof prop === "object" && prop) {
    if (typeof prop.copy !== "function" || typeof prop.clone !== "function") {
      throw new Error("The static schema must be a Types value, or a primitive (number, boolean, string, shallow array, null/undefined)");
    } else {// all good !
    }
  } else {
    schema[k] = Types.Ref(schema[k]);
  }
}
},{}],"src/alec/Entity.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const IS_DEV = "development" === "development";

class EntityRef {
  constructor(entity) {
    this.entity = entity;
  }

  get alive() {
    return this.entity ? this.entity.alive : false;
  }

  kill() {
    if (this.entity) this.entity.kill();
  }

}

class Entity {
  constructor(entityManager) {
    this._alive = false;
    this._enabled = true;
    this._entityManager = entityManager;
    this.system = null;
    this.name = null;
    this.Tags = new Map();
    this._queuedEvents = 0;
    this._refs = null;

    this._removeTagInstance = (instance, Tag) => {
      if (Tag.isData || Tag.isValue) {
        this._entityManager.releaseTag(Tag, instance);
      }
    };
  }

  ref() {
    const ref = new EntityRef(this);
    if (!this._refs) this._refs = [];

    this._refs.push(ref);

    return ref;
  }

  reset() {
    this.removeAll();
    this.system = null;
    this._alive = false;
    this._enabled = true;
    this.name = undefined;
    this._queuedEvents = 0;
  }

  add(Tag, values) {
    if (!Tag) throw new Error(`Must specify a Tag`);

    if (typeof Tag !== "function") {
      throw new Error(`Tags must be functions or classes`);
    } // if we already have this tag, clean up the old one


    if (this.has(Tag)) {
      this._directRemoveTag(Tag);
    }

    let tag;

    if (Tag.isData) {
      tag = this._entityManager.createTag(Tag);

      for (let k in values) {
        if (values.hasOwnProperty(k)) {
          if (Tag.data.hasOwnProperty(k)) {
            const prop = Tag.data[k];
            tag[k] = prop.copy(values[k], tag[k]);
          } else if (IS_DEV) {
            console.warn(`No property "${k}" found on the Data tag ${Tag.name}`);
          }
        }
      }
    } else if (Tag.isValue) {
      tag = this._entityManager.createTag(Tag);

      if (typeof values !== "undefined") {
        const prop = Tag.value;
        tag.value = prop.copy(values, tag.value);
      }
    } else {
      tag = Tag;
    }

    this.Tags.set(Tag, tag);

    this._tagAdded(Tag);

    return this;
  }

  set(Tag, values) {
    if (!this.has(Tag)) {
      this.add(Tag, values);
    } else if (Tag.isData) {
      const tag = this.getTag(Tag);

      for (let k in values) {
        if (values.hasOwnProperty(k)) {
          if (Tag.data.hasOwnProperty(k)) {
            const prop = Tag.data[k];
            tag[k] = prop.copy(values[k], tag[k]);
          } else if (IS_DEV) {
            console.warn(`No property "${k}" found on the Data tag ${Tag.name}`);
          }
        }
      }
    } else if (Tag.isValue && typeof values !== "undefined") {
      const tag = this.getTag(Tag);
      const prop = Tag.value;
      tag.value = prop.copy(values, tag.value);
    }

    return this;
  }

  _directRemoveTag(Tag) {
    if (Tag.isData || Tag.isValue) {
      const instance = this.Tags.get(Tag);

      this._entityManager.releaseTag(Tag, instance);
    }

    this.Tags.delete(Tag);
  }

  remove(Tag) {
    if (this.has(Tag)) {
      this._directRemoveTag(Tag);

      this._tagRemoved(Tag);
    }

    return this;
  }

  removeAll(Tags) {
    if (this.Tags.size > 0) {
      this.Tags.forEach(this._removeTagInstance);
      this.Tags.clear();

      this._update();
    }

    return this;
  }

  get(Tag) {
    const t = this.getTag(Tag);
    if (Tag.isValue) return t.value;
    return t;
  }

  getTag(Tag) {
    if (!this.has(Tag)) {
      throw new Error(`The Tag ${Tag.name} is not part of this Entity`);
    }

    return this.Tags.get(Tag);
  }

  getTagEntries() {
    return Array.from(this.Tags.entries());
  }

  has(Tag) {
    return this.Tags.has(Tag);
  }

  hasAll(Tags) {
    for (let i = 0; i < Tags.length; i++) {
      const Tag = Tags[i];
      if (!this.has(Tag)) return false;
    }

    return true;
  }

  hasAny(Tags) {
    for (let i = 0; i < Tags.length; i++) {
      const Tag = Tags[i];
      if (this.has(Tag)) return true;
    }

    return false;
  }

  get alive() {
    return this._alive;
  }

  get enabled() {
    return this._enabled;
  }

  get processed() {
    return this._queuedEvents === 0;
  } // alias to add only if tag doesn't exist


  tagOn(Tag, values) {
    if (!this.has(Tag)) this.add(Tag, values);
    return this;
  } // alias to disable only if tag exists


  tagOff(Tag) {
    this.remove(Tag);
    return this;
  }

  enable() {
    if (!this._enabled) {
      this._enabled = true;

      this._update();
    }

    return this;
  }

  disable() {
    if (this._enabled) {
      this._enabled = false;

      this._update();
    }

    return this;
  }

  unmanage() {
    if (this.system) {
      this.system._unmanage(this);

      this.system = null;
    }
  }

  kill() {
    if (this.system) this.unmanage();

    if (this._alive) {
      this._alive = false;

      this._entityManager._markEntityForRemoval(this);
    }

    if (this._refs) {
      // clear refs
      for (let i = 0; i < this._refs.length; i++) {
        this._refs[i].entity = null;
      } // de-reference the array


      this._refs = null;
    }

    return this;
  }

  _tagAdded(Tag) {
    // TODO: optimization here for add-only case
    this._update();
  }

  _tagRemoved(Tag) {
    // TODO: optimization here for remove-only case
    this._update();
  }

  _update() {
    this._entityManager._onEntityUpdated(this);
  }

}

exports.default = Entity;
},{}],"src/alec/QueryManager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _array = require("../util/array");

const getTagID = (() => {
  const map = new WeakMap();
  let id = 0;
  return function getTagID(Tag) {
    if (!map.has(Tag)) {
      map.set(Tag, id++);
    }

    return map.get(Tag);
  };
})();

class Query {
  constructor(Tags, id) {
    this.Tags = Tags;
    this.id = id;
    this._entities = [];
    this._listeners = null;
  }

  equals(other) {
    return this.id === other.id;
  }

  get entities() {
    return this._entities;
  }

  get names() {
    return this.Tags.map(Tag => Tag.name);
  }

  _addEntity(e) {
    this._entities.push(e);

    if (this._listeners) {
      this._listeners.forEach(cb => cb(e, true));
    }
  }

  _removeEntity(e) {
    const idx = this._entities.indexOf(e);

    if (idx >= 0) {
      (0, _array.spliceOne)(this._entities, idx);

      if (this._listeners) {
        this._listeners.forEach(cb => cb(e, false));
      }
    }
  }

  _addListener(cb) {
    if (!this._listeners) this._listeners = [];

    this._listeners.push(cb);
  }

  _removeListener(cb) {
    if (this._listeners) {
      (0, _array.spliceObject)(this._listeners, cb);
    }
  }

}

Query.prototype.isQuery = true;

class QueryManager {
  constructor(entityManager) {
    this._entityManager = entityManager;
    this.queries = {};
  }

  _buildQueryKey(Tags) {
    if (Array.isArray(Tags)) {
      const list = [];

      for (let i = 0; i < Tags.length; i++) {
        list.push(getTagID(Tags[i]));
      }

      list.sort();
      return list.join(":");
    } else {
      return String(getTagID(Tags));
    }
  }

  _onEntityUpdated(entity) {
    for (let k in this.queries) {
      const query = this.queries[k];

      this._updateQueryEntity(query, entity);
    }
  }

  query(Tags) {
    if (!Tags) throw new Error(`You must pass a Tag, multiple Tags, or Query object to query()`); // Fast path, we assume this has been keyed up already

    if (Tags.isQuery) return Tags;

    const id = this._buildQueryKey(Tags);

    let q = this.queries[id]; // query exists, return that

    if (q) return q; // query doesn't exist yet, create it

    const tagList = (Array.isArray(Tags) ? Tags : [Tags]).filter(Boolean);

    if (tagList.length === 0) {
      throw new Error("Must specify at least one Tag for query()");
    }

    const query = new Query(tagList, id);

    this._populateQuery(query);

    this.queries[id] = query;
    return query;
  }

  _populateQuery(query) {
    for (let i = 0; i < this._entityManager.entities.length; i++) {
      const e = this._entityManager.entities[i];

      this._updateQueryEntity(query, e);
    }
  }

  _shouldEntityExistInQuery(query, entity) {
    return entity.alive && entity.enabled && entity.hasAll(query.Tags);
  }

  _updateQueryEntity(query, entity) {
    const entityInQueryIdx = query.entities.indexOf(entity);
    const existsInQuery = entityInQueryIdx >= 0; // the entity has all those components

    let shouldExistInQuery = this._shouldEntityExistInQuery(query, entity); // needs to be added or removed


    if (existsInQuery !== shouldExistInQuery) {
      if (shouldExistInQuery) query._addEntity(entity);else query._removeEntity(entity);
    }
  }

}

exports.default = QueryManager;
},{"../util/array":"src/util/array.js"}],"src/alec/EntityManager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ObjectPool = _interopRequireDefault(require("../util/ObjectPool"));

var _Entity = _interopRequireDefault(require("./Entity"));

var _QueryManager = _interopRequireDefault(require("./QueryManager"));

var _array = require("../util/array");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class TagPool extends _ObjectPool.default {
  constructor(Tag, opt = {}) {
    super({ ...opt,
      initialCapacity: 50,
      name: `TagPool-${Tag.name}`,

      create() {
        return new Tag();
      },

      release(tag) {
        if (typeof tag.reset === "function") tag.reset();
      }

    });
  }

}

class EntityPool extends _ObjectPool.default {
  constructor(entityManager, opt = {}) {
    super({ ...opt,
      name: "Entities",

      create() {
        return new _Entity.default(entityManager);
      },

      release(e) {
        e.reset();
      }

    });
  }

}

class EntityManager {
  constructor({
    initialCapacity = 0
  } = {}) {
    this._entities = [];
    this._entitiesToRemove = [];
    this._tagPools = new Map();
    this._entityPool = new EntityPool(this, {
      initialCapacity
    });
    this._queryManager = new _QueryManager.default(this);
  }

  query(Tags) {
    return this._queryManager.query(Tags);
  }

  get entities() {
    return this._entities;
  }

  entity(name, system) {
    const e = this._entityPool.next();

    e.reset();
    e._alive = true;
    e.name = name;
    e.system = system || null;

    this._entities.push(e);

    return e;
  } // clears entities that are finished processing and have been removed


  flush() {
    const entitiesToRemove = this._entitiesToRemove;

    for (let i = entitiesToRemove.length - 1; i >= 0; i--) {
      const e = entitiesToRemove[i]; // do not remove entities that are still being processed by a system

      if (!e.processed) continue; // remove the entity from the set

      (0, _array.spliceObject)(this._entities, e); // remove all components once entity is truly killed

      e.removeAll(); // release the entity back into the pool

      this._entityPool.release(e); // splice this off the list


      (0, _array.spliceOne)(entitiesToRemove, i);
    }
  }

  createTag(Tag) {
    let pool = this.getTagPool(Tag);
    return pool.next();
  }

  getTagPool(Tag) {
    let pool = this._tagPools.get(Tag);

    if (!pool) {
      pool = new TagPool(Tag);

      this._tagPools.set(Tag, pool);
    }

    return pool;
  }

  releaseTag(Tag, tag) {
    const p = this._tagPools.get(Tag);

    if (p) p.release(tag);
  }

  _onEntityUpdated(entity) {
    this._queryManager._onEntityUpdated(entity);
  }

  _markEntityForRemoval(entity) {
    this._entitiesToRemove.push(entity);

    this._onEntityUpdated(entity);
  }

}

exports.default = EntityManager;
},{"../util/ObjectPool":"src/util/ObjectPool.js","./Entity":"src/alec/Entity.js","./QueryManager":"src/alec/QueryManager.js","../util/array":"src/util/array.js"}],"src/alec/QueryListener.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ObjectPool = _interopRequireDefault(require("../util/ObjectPool"));

var _array = require("../util/array");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class QueryEvent {
  constructor() {
    this.entity = null;
    this.active = true;
    this.added = false;
  }

  reset(entity, added) {
    this.entity = entity;
    this.added = added;
    this.active = true;
  }

  prepare() {
    this.entity._queuedEvents++;
  }

  process() {
    if (this.active) {
      this.active = false;
      this.entity._queuedEvents--;
    }
  }

}

class QueryEventPool extends _ObjectPool.default {
  constructor(opt = {}) {
    super({ ...opt,
      name: "QueryEvent",

      create() {
        return new QueryEvent();
      }

    });
  }

}

class QueryListenerState {
  constructor(query) {
    this.added = [];
    this.removing = [];
    this.changed = false;
    this.query = query;
  }

  dispose() {// overridden by World
  }

}

class QueryListener {
  constructor(query) {
    this._eventPool = new QueryEventPool();
    this._unprocessed_queue = [];
    this.state = new QueryListenerState(query);

    this._attach();
  }

  _nextQueuedMatching(entity) {
    for (let i = 0; i < this._unprocessed_queue.length; i++) {
      const ev = this._unprocessed_queue[i];
      if (ev.active && ev.entity === entity) return ev;
    }

    return null;
  }

  _attach() {
    if (this._handler) return;

    this._handler = (e, added) => {
      const ev = this._eventPool.next();

      ev.reset(e, added);
      ev.prepare();

      this._unprocessed_queue.push(ev);
    };

    this.state.query._addListener(this._handler); // initially add all the entities already matching


    for (let i = 0; i < this.state.query.entities.length; i++) {
      const e = this.state.query.entities[i];

      this._handler(e, true);
    }
  }

  detach() {
    this.poll();
    this.flush();

    if (this._handler) {
      this.state.query._removeListener(this._handler);

      this._handler = null;
    }
  }

  flush() {
    this.state.added.length = 0;
    this.state.removing.length = 0;
    this.state.changed = false;
    return this;
  }

  poll() {
    for (let i = 0; i < this._unprocessed_queue.length; i++) {
      const ev = this._unprocessed_queue[i];

      if (ev.active) {
        ev.process();
        if (ev.added) this.state.added.push(ev.entity);else this.state.removing.push(ev.entity);

        this._eventPool.release(ev);

        this.state.changed = true;
      }
    }

    this._unprocessed_queue.length = 0;
    return this;
  }

}

exports.default = QueryListener;
},{"../util/ObjectPool":"src/util/ObjectPool.js","../util/array":"src/util/array.js"}],"src/alec/World.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createWorld;
exports.Config = void 0;

var _array = require("../util/array");

var _ObjectPool = _interopRequireDefault(require("../util/ObjectPool"));

var _tag = require("./tag");

var _EntityManager = _interopRequireDefault(require("./EntityManager"));

var _QueryListener = _interopRequireDefault(require("./QueryListener"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEBUG_NAME = false;
const IS_DEV = "development" === "development";

function run(fn) {
  fn();
}

function runAll(fns) {
  fns.forEach(run);
}

function isPromise(obj) {
  return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
}

function createWorld(opt = {}) {
  return new WorldRoot(opt);
}

function queryToString(query) {
  return `[${query.names.join(",")}]`;
}

function singletonError(query, entities) {
  if (entities.length === 0) throw new Error(`No singleton by the query ${queryToString(query)}`);
  if (entities.length > 1) throw new Error(`Expected singleton, but found multiple entities by the query "${queryToString(query)}`);
}

function singletonFrom(query) {
  const entities = query.entities;
  if (entities.length !== 1) singletonError(query, entities);
  return entities[0];
}

class Config extends _tag.Data {
  static data = {
    props: _tag.Types.Ref(),
    component: _tag.Types.Ref(),
    system: _tag.Types.Ref(),
    instance: _tag.Types.Ref()
  };
}

exports.Config = Config;

class QueryView {
  constructor(query) {
    this.query = query;
    this.view = query.entities.slice();
  }

}

function fastCopy(src, dst) {
  for (let i = 0; i < src.length; i++) {
    dst[i] = src[i];
  }

  dst.length = src.length;
}

class SystemState {
  constructor(world, System) {
    this.world = world;
    this.loading = true;
    this.loaded = false;
    this.promise = undefined;
    this.enabled = true;
    this._info = {
      name: undefined
    };
    this.System = System;
    this.instance = null;
    this._children = null;
    this._listeners = null;
    this._views = null;
  }

  get name() {
    return this.info().name || this.System.name || "UntitledSystem";
  }

  info() {
    if (arguments.length === 0) return this._info;
    Object.assign(this._info, arguments[0]);
    return this;
  }

  _manage(entity) {
    if (!this._children) this._children = [];

    this._children.push(entity);
  }

  _unmanage(entity) {
    if (this._children) {
      (0, _array.spliceObject)(this._children, entity);
    }
  }

  _dispose() {
    const listeners = this._listeners;

    if (listeners) {
      for (let i = 0; i < listeners.length; i++) {
        listeners[i].detach();
      }

      listeners.length = 0;
    }

    if (this._children) {
      for (let i = this._children.length - 1; i >= 0; i--) {
        const c = this._children[i]; // first we ensure the entity is unmanaged,
        // we do it manually so that no splice is triggered

        c.system = null;
        c.kill();
      }
    }

    this._listeners = null;
    this._views = null;
    this._children = null;
  }

  _poll() {
    if (this._views) {
      for (let i = 0; i < this._views.length; i++) {
        const v = this._views[i];
        fastCopy(v.query.entities, v.view);
      }
    }

    if (this._listeners) {
      for (let i = 0; i < this._listeners.length; i++) {
        this._listeners[i].poll();
      }
    }
  }

  _flush() {
    if (this._listeners) {
      for (let i = 0; i < this._listeners.length; i++) {
        this._listeners[i].flush();
      }
    }
  }

}

class WorldFragment {
  constructor(root, systemState) {
    this.root = root;
    this._system = systemState;
  }

  subscribe(cb) {
    const subscribers = this.root._subscribers;

    let runner = () => cb(this._getSystemList());

    subscribers.push(runner);
    runner();
    return function unsubscribe() {
      if (runner) (0, _array.spliceObject)(subscribers, runner);
      runner = null;
    };
  }

  get system() {
    return this._system;
  }

  _fragment(systemState) {
    return new WorldFragment(this.root, systemState);
  }

  _getSystemList() {
    return this.root._systemList;
  }

  _getSystemMap() {
    return this.root._systemMap;
  }

  _getEntityManager() {
    return this.root._entityManager;
  }

  _getConfigurations() {
    return this.root._configurations;
  }

  view(Tags) {
    if (!this.system) throw new Error(`Must call world.view() from a world fragment passed into a System`);
    const q = this.root.query(Tags);
    const v = new QueryView(q);
    const sys = this.system;
    if (!sys._views) sys._views = [];

    sys._views.push(v);

    return v.view;
  }

  listen(Tags) {
    if (!this.system) throw new Error(`Must call world.view() from a world fragment passed into a System`);
    if (!Tags) throw new Error(`Must specify Tag, Tags, or Query object to world.listen()`);
    let query = this.root.query(Tags);
    let listener = new _QueryListener.default(query);
    const sys = this.system;
    if (!sys._listeners) sys._listeners = [];
    const listenerList = sys._listeners;
    listenerList.push(listener);
    const listenerState = listener.state;

    listenerState.dispose = () => {
      listener.detach();
      if (listenerList) (0, _array.spliceObject)(listenerList, listener);
      query = listener = null; // deref for GC
    };

    return listenerState;
  }

  tag(Tag, opts) {
    const sys = this.system;
    if (!sys) throw new Error(`Must call world.tag() from a world fragment passed into a System`);
    let name = null; // `${sys.name}:${Tag.name}`

    if (DEBUG_NAME && "development" === "development") {
      name = `DEV_${sys.name}:${Tag.name}`;
    }

    return this.entity(name, true).add(Tag, opts).get(Tag);
  }

  entity(name, managed) {
    if (this.system && managed !== false) {
      if (name == null) {
        if (DEBUG_NAME && "development" === "development") {
          name = `DEV_${this.system.name}:Entity`;
        }
      }

      const e = this._getEntityManager().entity(name, this.system);

      this.system._manage(e);

      return e;
    } else {
      return this._getEntityManager().entity(name);
    }
  }

  query(Tags) {
    return this._getEntityManager().query(Tags);
  }

  matching(Tags) {
    // maybe should remove this?
    return this.query(Tags).entities.slice();
  } // findEntity (Tags) {
  //   const q = this.query(Tags).entities;
  //   if (q.length) return q[0];
  //   else return null;
  // }
  // findTag(Tag) {
  //   const query = this.query(Tag);
  //   if (query.Tags.length !== 1) {
  //     throw new Error(
  //       `findTag() only accepts a query with one Tag, use findEntity() to match against multiple Tags`
  //     );
  //   }
  //   if (q.length) return q[0];
  //   else return null;
  // }


  findEntity(Tags) {
    const query = this.query(Tags);
    if (query.entities.length > 0) return query.entities[0];else return null;
  }

  findTag(Tag) {
    const query = this.query(Tag);

    if (query.Tags.length !== 1) {
      throw new Error(`find() only accepts a query with one Tag, use findEntity() to match against multiple Tags`);
    }

    if (query.entities.length > 0) return query.entities[0].get(query.Tags[0]);
    return null;
  }

  get entities() {
    return this._getEntityManager().entities;
  }

  hasSystem(System) {
    return this._getSystemMap().has(System);
  }

  getSystem(System) {
    return this._getSystemMap().get(System);
  }

  getAllSystems() {
    return this._getSystemList();
  }

  removeAllSystems() {
    const systemList = this._getSystemList();

    for (let i = systemList.length - 1; i >= 0; i--) {
      const System = systemList[i].System;
      this.removeSystem(System);
    }
  }

  setConfig(Tag, props = {}) {
    this._getConfigurations().set(Tag, props);
  }

  hasConfig(Tag) {
    return this._getConfigurations().has(Tag);
  }

  getConfig(Tag) {
    return this._getConfigurations().get(Tag);
  }

  removeConfig(Tag) {
    if (this.hasConfig(Tag)) this._getConfigurations().delete(Tag);
  }

  addSystem(System, attribs = {}) {
    if (typeof System !== "function") {
      throw new Error(`The first parameter of addSystem() must be a function`);
    }

    if (this.hasSystem(System)) {
      throw new Error(`The World already registered the System "${System.name}"`);
    }

    const systemList = this._getSystemList();

    const systemMap = this._getSystemMap();

    if (IS_DEV && systemList.some(sys => {
      return sys.System.name === System.name;
    })) {
      console.warn(`⚠️ You already have a different System registered by the name "${System.name}", maybe you forgot to rename it?`);
    }

    const state = new SystemState(this, System);
    systemList.push(state);
    systemMap.set(System, state);

    const fragment = this._fragment(state);

    let result = System(fragment, attribs);

    if (isPromise(result)) {
      result = result.then(instance => {
        state.instance = instance;
        state.loading = false;
        state.loaded = true;
        return state;
      });
      state.promise = result;
    } else {
      state.instance = result;
      state.promise = Promise.resolve(state);
      state.loading = false;
      state.loaded = true;
    }

    runAll(this.root._subscribers);
    return state.promise;
  }

  removeSystem(System) {
    if (typeof System !== "function") {
      throw new Error(`The first parameter of removeSystem() must be a function`);
    }

    if (!this.hasSystem(System)) {
      console.warn(`Trying to unregister the System "${System.name}" that is no longer in this World`);
      return;
    }

    const systemList = this._getSystemList();

    const systemMap = this._getSystemMap();

    const state = systemMap.get(System);
    systemMap.delete(System);
    (0, _array.spliceObject)(systemList, state);

    if (state.instance && typeof state.instance.dispose === "function") {
      state.instance.dispose();
    }

    state._dispose();

    runAll(this.root._subscribers);
  }

  process(ev) {
    const systemList = this._getSystemList();

    for (let i = 0; i < systemList.length; i++) {
      const state = systemList[i];
      const instance = state.instance;

      if (state.loaded) {
        state._poll();

        if (instance && state.enabled) {
          if (typeof instance === "function") instance(ev);else if (typeof instance.process === "function") instance.process(ev);
        }

        state._flush();
      }
    }

    this._getEntityManager().flush();
  }

}

class WorldRoot extends WorldFragment {
  constructor({
    initialCapacity = 0
  } = {}) {
    super();
    this.root = this;
    this._configurations = new Map();
    this._entityManager = new _EntityManager.default({
      initialCapacity
    });
    this._systemMap = new Map();
    this._systemList = [];
    this._subscribers = [];
  }

}
},{"../util/array":"src/util/array.js","../util/ObjectPool":"src/util/ObjectPool.js","./tag":"src/alec/tag.js","./EntityManager":"src/alec/EntityManager.js","./QueryListener":"src/alec/QueryListener.js"}],"src/alec/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "createWorld", {
  enumerable: true,
  get: function () {
    return _World.default;
  }
});
Object.defineProperty(exports, "Tag", {
  enumerable: true,
  get: function () {
    return _tag.Tag;
  }
});
Object.defineProperty(exports, "Data", {
  enumerable: true,
  get: function () {
    return _tag.Data;
  }
});
Object.defineProperty(exports, "Value", {
  enumerable: true,
  get: function () {
    return _tag.Value;
  }
});
Object.defineProperty(exports, "Types", {
  enumerable: true,
  get: function () {
    return _tag.Types;
  }
});
Object.defineProperty(exports, "copyArray", {
  enumerable: true,
  get: function () {
    return _tag.copyArray;
  }
});
Object.defineProperty(exports, "copyInstance", {
  enumerable: true,
  get: function () {
    return _tag.copyInstance;
  }
});
Object.defineProperty(exports, "copyRef", {
  enumerable: true,
  get: function () {
    return _tag.copyRef;
  }
});
Object.defineProperty(exports, "copyObject", {
  enumerable: true,
  get: function () {
    return _tag.copyObject;
  }
});
Object.defineProperty(exports, "cloneArray", {
  enumerable: true,
  get: function () {
    return _tag.cloneArray;
  }
});
Object.defineProperty(exports, "cloneInstance", {
  enumerable: true,
  get: function () {
    return _tag.cloneInstance;
  }
});
Object.defineProperty(exports, "cloneRef", {
  enumerable: true,
  get: function () {
    return _tag.cloneRef;
  }
});
Object.defineProperty(exports, "cloneObject", {
  enumerable: true,
  get: function () {
    return _tag.cloneObject;
  }
});

var _World = _interopRequireDefault(require("./World"));

var _tag = require("./tag");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./World":"src/alec/World.js","./tag":"src/alec/tag.js"}],"node_modules/svelte/internal/index.mjs":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.action_destroyer = action_destroyer;
exports.add_attribute = add_attribute;
exports.add_classes = add_classes;
exports.add_flush_callback = add_flush_callback;
exports.add_location = add_location;
exports.add_render_callback = add_render_callback;
exports.add_resize_listener = add_resize_listener;
exports.add_transform = add_transform;
exports.afterUpdate = afterUpdate;
exports.append = append;
exports.append_dev = append_dev;
exports.assign = assign;
exports.attr = attr;
exports.attr_dev = attr_dev;
exports.attribute_to_object = attribute_to_object;
exports.beforeUpdate = beforeUpdate;
exports.bind = bind;
exports.blank_object = blank_object;
exports.bubble = bubble;
exports.check_outros = check_outros;
exports.children = children;
exports.claim_component = claim_component;
exports.claim_element = claim_element;
exports.claim_space = claim_space;
exports.claim_text = claim_text;
exports.clear_loops = clear_loops;
exports.component_subscribe = component_subscribe;
exports.compute_rest_props = compute_rest_props;
exports.compute_slots = compute_slots;
exports.createEventDispatcher = createEventDispatcher;
exports.create_animation = create_animation;
exports.create_bidirectional_transition = create_bidirectional_transition;
exports.create_component = create_component;
exports.create_in_transition = create_in_transition;
exports.create_out_transition = create_out_transition;
exports.create_slot = create_slot;
exports.create_ssr_component = create_ssr_component;
exports.custom_event = custom_event;
exports.dataset_dev = dataset_dev;
exports.debug = debug;
exports.destroy_block = destroy_block;
exports.destroy_component = destroy_component;
exports.destroy_each = destroy_each;
exports.detach = detach;
exports.detach_after_dev = detach_after_dev;
exports.detach_before_dev = detach_before_dev;
exports.detach_between_dev = detach_between_dev;
exports.detach_dev = detach_dev;
exports.dispatch_dev = dispatch_dev;
exports.each = each;
exports.element = element;
exports.element_is = element_is;
exports.empty = empty;
exports.escape = escape;
exports.exclude_internal_props = exclude_internal_props;
exports.fix_and_destroy_block = fix_and_destroy_block;
exports.fix_and_outro_and_destroy_block = fix_and_outro_and_destroy_block;
exports.fix_position = fix_position;
exports.flush = flush;
exports.getContext = getContext;
exports.get_binding_group_value = get_binding_group_value;
exports.get_current_component = get_current_component;
exports.get_custom_elements_slots = get_custom_elements_slots;
exports.get_slot_changes = get_slot_changes;
exports.get_slot_context = get_slot_context;
exports.get_spread_object = get_spread_object;
exports.get_spread_update = get_spread_update;
exports.get_store_value = get_store_value;
exports.group_outros = group_outros;
exports.handle_promise = handle_promise;
exports.hasContext = hasContext;
exports.init = init;
exports.insert = insert;
exports.insert_dev = insert_dev;
exports.is_crossorigin = is_crossorigin;
exports.is_empty = is_empty;
exports.is_function = is_function;
exports.is_promise = is_promise;
exports.listen = listen;
exports.listen_dev = listen_dev;
exports.loop = loop;
exports.loop_guard = loop_guard;
exports.mount_component = mount_component;
exports.noop = noop;
exports.not_equal = not_equal;
exports.null_to_empty = null_to_empty;
exports.object_without_properties = object_without_properties;
exports.onDestroy = onDestroy;
exports.onMount = onMount;
exports.once = once;
exports.outro_and_destroy_block = outro_and_destroy_block;
exports.prevent_default = prevent_default;
exports.prop_dev = prop_dev;
exports.query_selector_all = query_selector_all;
exports.run = run;
exports.run_all = run_all;
exports.safe_not_equal = safe_not_equal;
exports.schedule_update = schedule_update;
exports.select_multiple_value = select_multiple_value;
exports.select_option = select_option;
exports.select_options = select_options;
exports.select_value = select_value;
exports.self = self;
exports.setContext = setContext;
exports.set_attributes = set_attributes;
exports.set_current_component = set_current_component;
exports.set_custom_element_data = set_custom_element_data;
exports.set_data = set_data;
exports.set_data_dev = set_data_dev;
exports.set_input_type = set_input_type;
exports.set_input_value = set_input_value;
exports.set_now = set_now;
exports.set_raf = set_raf;
exports.set_store_value = set_store_value;
exports.set_style = set_style;
exports.set_svg_attributes = set_svg_attributes;
exports.space = space;
exports.spread = spread;
exports.stop_propagation = stop_propagation;
exports.subscribe = subscribe;
exports.svg_element = svg_element;
exports.text = text;
exports.tick = tick;
exports.time_ranges_to_array = time_ranges_to_array;
exports.to_number = to_number;
exports.toggle_class = toggle_class;
exports.transition_in = transition_in;
exports.transition_out = transition_out;
exports.update_keyed_each = update_keyed_each;
exports.update_slot = update_slot;
exports.update_slot_spread = update_slot_spread;
exports.validate_component = validate_component;
exports.validate_each_argument = validate_each_argument;
exports.validate_each_keys = validate_each_keys;
exports.validate_slots = validate_slots;
exports.validate_store = validate_store;
exports.xlink_attr = xlink_attr;
exports.raf = exports.now = exports.missing_component = exports.is_client = exports.invalid_attribute_name_character = exports.intros = exports.identity = exports.has_prop = exports.globals = exports.escaped = exports.dirty_components = exports.current_component = exports.binding_callbacks = exports.SvelteElement = exports.SvelteComponentTyped = exports.SvelteComponentDev = exports.SvelteComponent = exports.HtmlTag = void 0;

function noop() {}

const identity = x => x;

exports.identity = identity;

function assign(tar, src) {
  // @ts-ignore
  for (const k in src) tar[k] = src[k];

  return tar;
}

function is_promise(value) {
  return value && typeof value === 'object' && typeof value.then === 'function';
}

function add_location(element, file, line, column, char) {
  element.__svelte_meta = {
    loc: {
      file,
      line,
      column,
      char
    }
  };
}

function run(fn) {
  return fn();
}

function blank_object() {
  return Object.create(null);
}

function run_all(fns) {
  fns.forEach(run);
}

function is_function(thing) {
  return typeof thing === 'function';
}

function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === 'object' || typeof a === 'function';
}

function not_equal(a, b) {
  return a != a ? b == b : a !== b;
}

function is_empty(obj) {
  return Object.keys(obj).length === 0;
}

function validate_store(store, name) {
  if (store != null && typeof store.subscribe !== 'function') {
    throw new Error(`'${name}' is not a store with a 'subscribe' method`);
  }
}

function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }

  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}

function get_store_value(store) {
  let value;
  subscribe(store, _ => value = _)();
  return value;
}

function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}

function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}

function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}

function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));

    if ($$scope.dirty === undefined) {
      return lets;
    }

    if (typeof lets === 'object') {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);

      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }

      return merged;
    }

    return $$scope.dirty | lets;
  }

  return $$scope.dirty;
}

function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
  const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);

  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}

function update_slot_spread(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_spread_changes_fn, get_slot_context_fn) {
  const slot_changes = get_slot_spread_changes_fn(dirty) | get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);

  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}

function exclude_internal_props(props) {
  const result = {};

  for (const k in props) if (k[0] !== '$') result[k] = props[k];

  return result;
}

function compute_rest_props(props, keys) {
  const rest = {};
  keys = new Set(keys);

  for (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];

  return rest;
}

function compute_slots(slots) {
  const result = {};

  for (const key in slots) {
    result[key] = true;
  }

  return result;
}

function once(fn) {
  let ran = false;
  return function (...args) {
    if (ran) return;
    ran = true;
    fn.call(this, ...args);
  };
}

function null_to_empty(value) {
  return value == null ? '' : value;
}

function set_store_value(store, ret, value = ret) {
  store.set(value);
  return ret;
}

const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);

exports.has_prop = has_prop;

function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

const is_client = typeof window !== 'undefined';
exports.is_client = is_client;
let now = is_client ? () => window.performance.now() : () => Date.now();
exports.now = now;
let raf = is_client ? cb => requestAnimationFrame(cb) : noop; // used internally for testing

exports.raf = raf;

function set_now(fn) {
  exports.now = now = fn;
}

function set_raf(fn) {
  exports.raf = raf = fn;
}

const tasks = new Set();

function run_tasks(now) {
  tasks.forEach(task => {
    if (!task.c(now)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0) raf(run_tasks);
}
/**
 * For testing purposes only!
 */


function clear_loops() {
  tasks.clear();
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */


function loop(callback) {
  let task;
  if (tasks.size === 0) raf(run_tasks);
  return {
    promise: new Promise(fulfill => {
      tasks.add(task = {
        c: callback,
        f: fulfill
      });
    }),

    abort() {
      tasks.delete(task);
    }

  };
}

function append(target, node) {
  target.appendChild(node);
}

function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}

function detach(node) {
  node.parentNode.removeChild(node);
}

function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i]) iterations[i].d(detaching);
  }
}

function element(name) {
  return document.createElement(name);
}

function element_is(name, is) {
  return document.createElement(name, {
    is
  });
}

function object_without_properties(obj, exclude) {
  const target = {};

  for (const k in obj) {
    if (has_prop(obj, k) // @ts-ignore
    && exclude.indexOf(k) === -1) {
      // @ts-ignore
      target[k] = obj[k];
    }
  }

  return target;
}

function svg_element(name) {
  return document.createElementNS('http://www.w3.org/2000/svg', name);
}

function text(data) {
  return document.createTextNode(data);
}

function space() {
  return text(' ');
}

function empty() {
  return text('');
}

function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}

function prevent_default(fn) {
  return function (event) {
    event.preventDefault(); // @ts-ignore

    return fn.call(this, event);
  };
}

function stop_propagation(fn) {
  return function (event) {
    event.stopPropagation(); // @ts-ignore

    return fn.call(this, event);
  };
}

function self(fn) {
  return function (event) {
    // @ts-ignore
    if (event.target === this) fn.call(this, event);
  };
}

function attr(node, attribute, value) {
  if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
}

function set_attributes(node, attributes) {
  // @ts-ignore
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);

  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === 'style') {
      node.style.cssText = attributes[key];
    } else if (key === '__value') {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}

function set_svg_attributes(node, attributes) {
  for (const key in attributes) {
    attr(node, key, attributes[key]);
  }
}

function set_custom_element_data(node, prop, value) {
  if (prop in node) {
    node[prop] = value;
  } else {
    attr(node, prop, value);
  }
}

function xlink_attr(node, attribute, value) {
  node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
}

function get_binding_group_value(group, __value, checked) {
  const value = new Set();

  for (let i = 0; i < group.length; i += 1) {
    if (group[i].checked) value.add(group[i].__value);
  }

  if (!checked) {
    value.delete(__value);
  }

  return Array.from(value);
}

function to_number(value) {
  return value === '' ? null : +value;
}

function time_ranges_to_array(ranges) {
  const array = [];

  for (let i = 0; i < ranges.length; i += 1) {
    array.push({
      start: ranges.start(i),
      end: ranges.end(i)
    });
  }

  return array;
}

function children(element) {
  return Array.from(element.childNodes);
}

function claim_element(nodes, name, attributes, svg) {
  for (let i = 0; i < nodes.length; i += 1) {
    const node = nodes[i];

    if (node.nodeName === name) {
      let j = 0;
      const remove = [];

      while (j < node.attributes.length) {
        const attribute = node.attributes[j++];

        if (!attributes[attribute.name]) {
          remove.push(attribute.name);
        }
      }

      for (let k = 0; k < remove.length; k++) {
        node.removeAttribute(remove[k]);
      }

      return nodes.splice(i, 1)[0];
    }
  }

  return svg ? svg_element(name) : element(name);
}

function claim_text(nodes, data) {
  for (let i = 0; i < nodes.length; i += 1) {
    const node = nodes[i];

    if (node.nodeType === 3) {
      node.data = '' + data;
      return nodes.splice(i, 1)[0];
    }
  }

  return text(data);
}

function claim_space(nodes) {
  return claim_text(nodes, ' ');
}

function set_data(text, data) {
  data = '' + data;
  if (text.wholeText !== data) text.data = data;
}

function set_input_value(input, value) {
  input.value = value == null ? '' : value;
}

function set_input_type(input, type) {
  try {
    input.type = type;
  } catch (e) {// do nothing
  }
}

function set_style(node, key, value, important) {
  node.style.setProperty(key, value, important ? 'important' : '');
}

function select_option(select, value) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];

    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
}

function select_options(select, value) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    option.selected = ~value.indexOf(option.__value);
  }
}

function select_value(select) {
  const selected_option = select.querySelector(':checked') || select.options[0];
  return selected_option && selected_option.__value;
}

function select_multiple_value(select) {
  return [].map.call(select.querySelectorAll(':checked'), option => option.__value);
} // unfortunately this can't be a constant as that wouldn't be tree-shakeable
// so we cache the result instead


let crossorigin;

function is_crossorigin() {
  if (crossorigin === undefined) {
    crossorigin = false;

    try {
      if (typeof window !== 'undefined' && window.parent) {
        void window.parent.document;
      }
    } catch (error) {
      crossorigin = true;
    }
  }

  return crossorigin;
}

function add_resize_listener(node, fn) {
  const computed_style = getComputedStyle(node);
  const z_index = (parseInt(computed_style.zIndex) || 0) - 1;

  if (computed_style.position === 'static') {
    node.style.position = 'relative';
  }

  const iframe = element('iframe');
  iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' + `overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: ${z_index};`);
  iframe.setAttribute('aria-hidden', 'true');
  iframe.tabIndex = -1;
  const crossorigin = is_crossorigin();
  let unsubscribe;

  if (crossorigin) {
    iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
    unsubscribe = listen(window, 'message', event => {
      if (event.source === iframe.contentWindow) fn();
    });
  } else {
    iframe.src = 'about:blank';

    iframe.onload = () => {
      unsubscribe = listen(iframe.contentWindow, 'resize', fn);
    };
  }

  append(node, iframe);
  return () => {
    if (crossorigin) {
      unsubscribe();
    } else if (unsubscribe && iframe.contentWindow) {
      unsubscribe();
    }

    detach(iframe);
  };
}

function toggle_class(element, name, toggle) {
  element.classList[toggle ? 'add' : 'remove'](name);
}

function custom_event(type, detail) {
  const e = document.createEvent('CustomEvent');
  e.initCustomEvent(type, false, false, detail);
  return e;
}

function query_selector_all(selector, parent = document.body) {
  return Array.from(parent.querySelectorAll(selector));
}

class HtmlTag {
  constructor(anchor = null) {
    this.a = anchor;
    this.e = this.n = null;
  }

  m(html, target, anchor = null) {
    if (!this.e) {
      this.e = element(target.nodeName);
      this.t = target;
      this.h(html);
    }

    this.i(anchor);
  }

  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(this.e.childNodes);
  }

  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }

  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }

  d() {
    this.n.forEach(detach);
  }

}

exports.HtmlTag = HtmlTag;

function attribute_to_object(attributes) {
  const result = {};

  for (const attribute of attributes) {
    result[attribute.name] = attribute.value;
  }

  return result;
}

function get_custom_elements_slots(element) {
  const result = {};
  element.childNodes.forEach(node => {
    result[node.slot || 'default'] = true;
  });
  return result;
}

const active_docs = new Set();
let active = 0; // https://github.com/darkskyapp/string-hash/blob/master/index.js

function hash(str) {
  let hash = 5381;
  let i = str.length;

  while (i--) hash = (hash << 5) - hash ^ str.charCodeAt(i);

  return hash >>> 0;
}

function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = '{\n';

  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
  }

  const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = node.ownerDocument;
  active_docs.add(doc);
  const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
  const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});

  if (!current_rules[name]) {
    current_rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }

  const animation = node.style.animation || '';
  node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}

function delete_rule(node, name) {
  const previous = (node.style.animation || '').split(', ');
  const next = previous.filter(name ? anim => anim.indexOf(name) < 0 // remove specific animation
  : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
  );
  const deleted = previous.length - next.length;

  if (deleted) {
    node.style.animation = next.join(', ');
    active -= deleted;
    if (!active) clear_rules();
  }
}

function clear_rules() {
  raf(() => {
    if (active) return;
    active_docs.forEach(doc => {
      const stylesheet = doc.__svelte_stylesheet;
      let i = stylesheet.cssRules.length;

      while (i--) stylesheet.deleteRule(i);

      doc.__svelte_rules = {};
    });
    active_docs.clear();
  });
}

function create_animation(node, from, fn, params) {
  if (!from) return noop;
  const to = node.getBoundingClientRect();
  if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom) return noop;
  const {
    delay = 0,
    duration = 300,
    easing = identity,
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: start_time = now() + delay,
    // @ts-ignore todo:
    end = start_time + duration,
    tick = noop,
    css
  } = fn(node, {
    from,
    to
  }, params);
  let running = true;
  let started = false;
  let name;

  function start() {
    if (css) {
      name = create_rule(node, 0, 1, duration, delay, easing, css);
    }

    if (!delay) {
      started = true;
    }
  }

  function stop() {
    if (css) delete_rule(node, name);
    running = false;
  }

  loop(now => {
    if (!started && now >= start_time) {
      started = true;
    }

    if (started && now >= end) {
      tick(1, 0);
      stop();
    }

    if (!running) {
      return false;
    }

    if (started) {
      const p = now - start_time;
      const t = 0 + 1 * easing(p / duration);
      tick(t, 1 - t);
    }

    return true;
  });
  start();
  tick(0, 1);
  return stop;
}

function fix_position(node) {
  const style = getComputedStyle(node);

  if (style.position !== 'absolute' && style.position !== 'fixed') {
    const {
      width,
      height
    } = style;
    const a = node.getBoundingClientRect();
    node.style.position = 'absolute';
    node.style.width = width;
    node.style.height = height;
    add_transform(node, a);
  }
}

function add_transform(node, a) {
  const b = node.getBoundingClientRect();

  if (a.left !== b.left || a.top !== b.top) {
    const style = getComputedStyle(node);
    const transform = style.transform === 'none' ? '' : style.transform;
    node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
  }
}

let current_component;
exports.current_component = current_component;

function set_current_component(component) {
  exports.current_component = current_component = component;
}

function get_current_component() {
  if (!current_component) throw new Error('Function called outside component initialization');
  return current_component;
}

function beforeUpdate(fn) {
  get_current_component().$$.before_update.push(fn);
}

function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}

function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}

function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}

function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail) => {
    const callbacks = component.$$.callbacks[type];

    if (callbacks) {
      // TODO are there situations where events could be dispatched
      // in a server (non-DOM) environment?
      const event = custom_event(type, detail);
      callbacks.slice().forEach(fn => {
        fn.call(component, event);
      });
    }
  };
}

function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}

function getContext(key) {
  return get_current_component().$$.context.get(key);
}

function hasContext(key) {
  return get_current_component().$$.context.has(key);
} // TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism


function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];

  if (callbacks) {
    callbacks.slice().forEach(fn => fn(event));
  }
}

const dirty_components = [];
exports.dirty_components = dirty_components;
const intros = {
  enabled: false
};
exports.intros = intros;
const binding_callbacks = [];
exports.binding_callbacks = binding_callbacks;
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;

function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}

function tick() {
  schedule_update();
  return resolved_promise;
}

function add_render_callback(fn) {
  render_callbacks.push(fn);
}

function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}

let flushing = false;
const seen_callbacks = new Set();

function flush() {
  if (flushing) return;
  flushing = true;

  do {
    // first, call beforeUpdate functions
    // and update components
    for (let i = 0; i < dirty_components.length; i += 1) {
      const component = dirty_components[i];
      set_current_component(component);
      update(component.$$);
    }

    set_current_component(null);
    dirty_components.length = 0;

    while (binding_callbacks.length) binding_callbacks.pop()(); // then, once components are updated, call
    // afterUpdate functions. This may cause
    // subsequent updates...


    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];

      if (!seen_callbacks.has(callback)) {
        // ...so guard against infinite loops
        seen_callbacks.add(callback);
        callback();
      }
    }

    render_callbacks.length = 0;
  } while (dirty_components.length);

  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }

  update_scheduled = false;
  flushing = false;
  seen_callbacks.clear();
}

function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}

let promise;

function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }

  return promise;
}

function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}

const outroing = new Set();
let outros;

function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros // parent group

  };
}

function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }

  outros = outros.p;
}

function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}

function transition_out(block, local, detach, callback) {
  if (block && block.o) {
    if (outroing.has(block)) return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);

      if (callback) {
        if (detach) block.d(1);
        callback();
      }
    });
    block.o(local);
  }
}

const null_transition = {
  duration: 0
};

function create_in_transition(node, fn, params) {
  let config = fn(node, params);
  let running = false;
  let animation_name;
  let task;
  let uid = 0;

  function cleanup() {
    if (animation_name) delete_rule(node, animation_name);
  }

  function go() {
    const {
      delay = 0,
      duration = 300,
      easing = identity,
      tick = noop,
      css
    } = config || null_transition;
    if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
    tick(0, 1);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    if (task) task.abort();
    running = true;
    add_render_callback(() => dispatch(node, true, 'start'));
    task = loop(now => {
      if (running) {
        if (now >= end_time) {
          tick(1, 0);
          dispatch(node, true, 'end');
          cleanup();
          return running = false;
        }

        if (now >= start_time) {
          const t = easing((now - start_time) / duration);
          tick(t, 1 - t);
        }
      }

      return running;
    });
  }

  let started = false;
  return {
    start() {
      if (started) return;
      delete_rule(node);

      if (is_function(config)) {
        config = config();
        wait().then(go);
      } else {
        go();
      }
    },

    invalidate() {
      started = false;
    },

    end() {
      if (running) {
        cleanup();
        running = false;
      }
    }

  };
}

function create_out_transition(node, fn, params) {
  let config = fn(node, params);
  let running = true;
  let animation_name;
  const group = outros;
  group.r += 1;

  function go() {
    const {
      delay = 0,
      duration = 300,
      easing = identity,
      tick = noop,
      css
    } = config || null_transition;
    if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    add_render_callback(() => dispatch(node, false, 'start'));
    loop(now => {
      if (running) {
        if (now >= end_time) {
          tick(0, 1);
          dispatch(node, false, 'end');

          if (! --group.r) {
            // this will result in `end()` being called,
            // so we don't need to clean up here
            run_all(group.c);
          }

          return false;
        }

        if (now >= start_time) {
          const t = easing((now - start_time) / duration);
          tick(1 - t, t);
        }
      }

      return running;
    });
  }

  if (is_function(config)) {
    wait().then(() => {
      // @ts-ignore
      config = config();
      go();
    });
  } else {
    go();
  }

  return {
    end(reset) {
      if (reset && config.tick) {
        config.tick(1, 0);
      }

      if (running) {
        if (animation_name) delete_rule(node, animation_name);
        running = false;
      }
    }

  };
}

function create_bidirectional_transition(node, fn, params, intro) {
  let config = fn(node, params);
  let t = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;

  function clear_animation() {
    if (animation_name) delete_rule(node, animation_name);
  }

  function init(program, duration) {
    const d = program.b - t;
    duration *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }

  function go(b) {
    const {
      delay = 0,
      duration = 300,
      easing = identity,
      tick = noop,
      css
    } = config || null_transition;
    const program = {
      start: now() + delay,
      b
    };

    if (!b) {
      // @ts-ignore todo: improve typings
      program.group = outros;
      outros.r += 1;
    }

    if (running_program || pending_program) {
      pending_program = program;
    } else {
      // if this is an intro, and there's a delay, we need to do
      // an initial tick and/or apply CSS animation immediately
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay, easing, css);
      }

      if (b) tick(0, 1);
      running_program = init(program, duration);
      add_render_callback(() => dispatch(node, b, 'start'));
      loop(now => {
        if (pending_program && now > pending_program.start) {
          running_program = init(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, 'start');

          if (css) {
            clear_animation();
            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
          }
        }

        if (running_program) {
          if (now >= running_program.end) {
            tick(t = running_program.b, 1 - t);
            dispatch(node, running_program.b, 'end');

            if (!pending_program) {
              // we're done
              if (running_program.b) {
                // intro — we can tidy up immediately
                clear_animation();
              } else {
                // outro — needs to be coordinated
                if (! --running_program.group.r) run_all(running_program.group.c);
              }
            }

            running_program = null;
          } else if (now >= running_program.start) {
            const p = now - running_program.start;
            t = running_program.a + running_program.d * easing(p / running_program.duration);
            tick(t, 1 - t);
          }
        }

        return !!(running_program || pending_program);
      });
    }
  }

  return {
    run(b) {
      if (is_function(config)) {
        wait().then(() => {
          // @ts-ignore
          config = config();
          go(b);
        });
      } else {
        go(b);
      }
    },

    end() {
      clear_animation();
      running_program = pending_program = null;
    }

  };
}

function handle_promise(promise, info) {
  const token = info.token = {};

  function update(type, index, key, value) {
    if (info.token !== token) return;
    info.resolved = value;
    let child_ctx = info.ctx;

    if (key !== undefined) {
      child_ctx = child_ctx.slice();
      child_ctx[key] = value;
    }

    const block = type && (info.current = type)(child_ctx);
    let needs_flush = false;

    if (info.block) {
      if (info.blocks) {
        info.blocks.forEach((block, i) => {
          if (i !== index && block) {
            group_outros();
            transition_out(block, 1, 1, () => {
              info.blocks[i] = null;
            });
            check_outros();
          }
        });
      } else {
        info.block.d(1);
      }

      block.c();
      transition_in(block, 1);
      block.m(info.mount(), info.anchor);
      needs_flush = true;
    }

    info.block = block;
    if (info.blocks) info.blocks[index] = block;

    if (needs_flush) {
      flush();
    }
  }

  if (is_promise(promise)) {
    const current_component = get_current_component();
    promise.then(value => {
      set_current_component(current_component);
      update(info.then, 1, info.value, value);
      set_current_component(null);
    }, error => {
      set_current_component(current_component);
      update(info.catch, 2, info.error, error);
      set_current_component(null);

      if (!info.hasCatch) {
        throw error;
      }
    }); // if we previously had a then/catch block, destroy it

    if (info.current !== info.pending) {
      update(info.pending, 0);
      return true;
    }
  } else {
    if (info.current !== info.then) {
      update(info.then, 1, info.value, promise);
      return true;
    }

    info.resolved = promise;
  }
}

const globals = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : global;
exports.globals = globals;

function destroy_block(block, lookup) {
  block.d(1);
  lookup.delete(block.key);
}

function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}

function fix_and_destroy_block(block, lookup) {
  block.f();
  destroy_block(block, lookup);
}

function fix_and_outro_and_destroy_block(block, lookup) {
  block.f();
  outro_and_destroy_block(block, lookup);
}

function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};

  while (i--) old_indexes[old_blocks[i].key] = i;

  const new_blocks = [];
  const new_lookup = new Map();
  const deltas = new Map();
  i = n;

  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);

    if (!block) {
      block = create_each_block(key, child_ctx);
      block.c();
    } else if (dynamic) {
      block.p(child_ctx, dirty);
    }

    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
  }

  const will_move = new Set();
  const did_move = new Set();

  function insert(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }

  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;

    if (new_block === old_block) {
      // do nothing
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      // remove old block
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }

  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
  }

  while (n) insert(new_blocks[n - 1]);

  return new_blocks;
}

function validate_each_keys(ctx, list, get_context, get_key) {
  const keys = new Set();

  for (let i = 0; i < list.length; i++) {
    const key = get_key(get_context(ctx, list, i));

    if (keys.has(key)) {
      throw new Error('Cannot have duplicate keys in a keyed each');
    }

    keys.add(key);
  }
}

function get_spread_update(levels, updates) {
  const update = {};
  const to_null_out = {};
  const accounted_for = {
    $$scope: 1
  };
  let i = levels.length;

  while (i--) {
    const o = levels[i];
    const n = updates[i];

    if (n) {
      for (const key in o) {
        if (!(key in n)) to_null_out[key] = 1;
      }

      for (const key in n) {
        if (!accounted_for[key]) {
          update[key] = n[key];
          accounted_for[key] = 1;
        }
      }

      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }

  for (const key in to_null_out) {
    if (!(key in update)) update[key] = undefined;
  }

  return update;
}

function get_spread_object(spread_props) {
  return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
} // source: https://html.spec.whatwg.org/multipage/indices.html


const boolean_attributes = new Set(['allowfullscreen', 'allowpaymentrequest', 'async', 'autofocus', 'autoplay', 'checked', 'controls', 'default', 'defer', 'disabled', 'formnovalidate', 'hidden', 'ismap', 'loop', 'multiple', 'muted', 'nomodule', 'novalidate', 'open', 'playsinline', 'readonly', 'required', 'reversed', 'selected']);
const invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u; // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
// https://infra.spec.whatwg.org/#noncharacter

exports.invalid_attribute_name_character = invalid_attribute_name_character;

function spread(args, classes_to_add) {
  const attributes = Object.assign({}, ...args);

  if (classes_to_add) {
    if (attributes.class == null) {
      attributes.class = classes_to_add;
    } else {
      attributes.class += ' ' + classes_to_add;
    }
  }

  let str = '';
  Object.keys(attributes).forEach(name => {
    if (invalid_attribute_name_character.test(name)) return;
    const value = attributes[name];
    if (value === true) str += ' ' + name;else if (boolean_attributes.has(name.toLowerCase())) {
      if (value) str += ' ' + name;
    } else if (value != null) {
      str += ` ${name}="${String(value).replace(/"/g, '&#34;').replace(/'/g, '&#39;')}"`;
    }
  });
  return str;
}

const escaped = {
  '"': '&quot;',
  "'": '&#39;',
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;'
};
exports.escaped = escaped;

function escape(html) {
  return String(html).replace(/["'&<>]/g, match => escaped[match]);
}

function each(items, fn) {
  let str = '';

  for (let i = 0; i < items.length; i += 1) {
    str += fn(items[i], i);
  }

  return str;
}

const missing_component = {
  $$render: () => ''
};
exports.missing_component = missing_component;

function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === 'svelte:component') name += ' this={...}';
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }

  return component;
}

function debug(file, line, column, values) {
  console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console

  console.log(values); // eslint-disable-line no-console

  return '';
}

let on_destroy;

function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(parent_component ? parent_component.$$.context : []),
      // these will be immediately discarded
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({
      $$
    });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }

  return {
    render: (props = {}, options = {}) => {
      on_destroy = [];
      const result = {
        title: '',
        head: '',
        css: new Set()
      };
      const html = $$render(result, props, {}, options);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map(css => css.code).join('\n'),
          map: null // TODO

        },
        head: result.title + result.head
      };
    },
    $$render
  };
}

function add_attribute(name, value, boolean) {
  if (value == null || boolean && !value) return '';
  return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `"${value}"`}`}`;
}

function add_classes(classes) {
  return classes ? ` class="${classes}"` : '';
}

function bind(component, name, callback) {
  const index = component.$$.props[name];

  if (index !== undefined) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}

function create_component(block) {
  block && block.c();
}

function claim_component(block, parent_nodes) {
  block && block.l(parent_nodes);
}

function mount_component(component, target, anchor) {
  const {
    fragment,
    on_mount,
    on_destroy,
    after_update
  } = component.$$;
  fragment && fragment.m(target, anchor); // onMount happens before the initial afterUpdate

  add_render_callback(() => {
    const new_on_destroy = on_mount.map(run).filter(is_function);

    if (on_destroy) {
      on_destroy.push(...new_on_destroy);
    } else {
      // Edge case - component was destroyed immediately,
      // most likely as a result of a binding initialising
      run_all(new_on_destroy);
    }

    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}

function destroy_component(component, detaching) {
  const $$ = component.$$;

  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to
    // preserve final state?)

    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}

function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }

  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}

function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const prop_values = options.props || {};
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    before_update: [],
    after_update: [],
    context: new Map(parent_component ? parent_component.$$.context : []),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false
  };
  let ready = false;
  $$.ctx = instance ? instance(component, prop_values, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;

    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
      if (ready) make_dirty(component, i);
    }

    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update); // `false` as a special case of no DOM component

  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;

  if (options.target) {
    if (options.hydrate) {
      const nodes = children(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      $$.fragment && $$.fragment.c();
    }

    if (options.intro) transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    flush();
  }

  set_current_component(parent_component);
}

let SvelteElement;
exports.SvelteElement = SvelteElement;

if (typeof HTMLElement === 'function') {
  exports.SvelteElement = SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({
        mode: 'open'
      });
    }

    connectedCallback() {
      // @ts-ignore todo: improve typings
      for (const key in this.$$.slotted) {
        // @ts-ignore todo: improve typings
        this.appendChild(this.$$.slotted[key]);
      }
    }

    attributeChangedCallback(attr, _oldValue, newValue) {
      this[attr] = newValue;
    }

    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }

    $on(type, callback) {
      // TODO should this delegate to addEventListener?
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1) callbacks.splice(index, 1);
      };
    }

    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }

  };
}
/**
 * Base class for Svelte components. Used when dev=false.
 */


class SvelteComponent {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }

  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1) callbacks.splice(index, 1);
    };
  }

  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }

}

exports.SvelteComponent = SvelteComponent;

function dispatch_dev(type, detail) {
  document.dispatchEvent(custom_event(type, Object.assign({
    version: '3.31.0'
  }, detail)));
}

function append_dev(target, node) {
  dispatch_dev('SvelteDOMInsert', {
    target,
    node
  });
  append(target, node);
}

function insert_dev(target, node, anchor) {
  dispatch_dev('SvelteDOMInsert', {
    target,
    node,
    anchor
  });
  insert(target, node, anchor);
}

function detach_dev(node) {
  dispatch_dev('SvelteDOMRemove', {
    node
  });
  detach(node);
}

function detach_between_dev(before, after) {
  while (before.nextSibling && before.nextSibling !== after) {
    detach_dev(before.nextSibling);
  }
}

function detach_before_dev(after) {
  while (after.previousSibling) {
    detach_dev(after.previousSibling);
  }
}

function detach_after_dev(before) {
  while (before.nextSibling) {
    detach_dev(before.nextSibling);
  }
}

function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
  const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
  if (has_prevent_default) modifiers.push('preventDefault');
  if (has_stop_propagation) modifiers.push('stopPropagation');
  dispatch_dev('SvelteDOMAddEventListener', {
    node,
    event,
    handler,
    modifiers
  });
  const dispose = listen(node, event, handler, options);
  return () => {
    dispatch_dev('SvelteDOMRemoveEventListener', {
      node,
      event,
      handler,
      modifiers
    });
    dispose();
  };
}

function attr_dev(node, attribute, value) {
  attr(node, attribute, value);
  if (value == null) dispatch_dev('SvelteDOMRemoveAttribute', {
    node,
    attribute
  });else dispatch_dev('SvelteDOMSetAttribute', {
    node,
    attribute,
    value
  });
}

function prop_dev(node, property, value) {
  node[property] = value;
  dispatch_dev('SvelteDOMSetProperty', {
    node,
    property,
    value
  });
}

function dataset_dev(node, property, value) {
  node.dataset[property] = value;
  dispatch_dev('SvelteDOMSetDataset', {
    node,
    property,
    value
  });
}

function set_data_dev(text, data) {
  data = '' + data;
  if (text.wholeText === data) return;
  dispatch_dev('SvelteDOMSetData', {
    node: text,
    data
  });
  text.data = data;
}

function validate_each_argument(arg) {
  if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
    let msg = '{#each} only iterates over array-like objects.';

    if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
      msg += ' You can use a spread to convert this iterable into an array.';
    }

    throw new Error(msg);
  }
}

function validate_slots(name, slot, keys) {
  for (const slot_key of Object.keys(slot)) {
    if (!~keys.indexOf(slot_key)) {
      console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
    }
  }
}
/**
 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
 */


class SvelteComponentDev extends SvelteComponent {
  constructor(options) {
    if (!options || !options.target && !options.$$inline) {
      throw new Error("'target' is a required option");
    }

    super();
  }

  $destroy() {
    super.$destroy();

    this.$destroy = () => {
      console.warn('Component was already destroyed'); // eslint-disable-line no-console
    };
  }

  $capture_state() {}

  $inject_state() {}

}
/**
 * Base class to create strongly typed Svelte components.
 * This only exists for typing purposes and should be used in `.d.ts` files.
 *
 * ### Example:
 *
 * You have component library on npm called `component-library`, from which
 * you export a component called `MyComponent`. For Svelte+TypeScript users,
 * you want to provide typings. Therefore you create a `index.d.ts`:
 * ```ts
 * import { SvelteComponentTyped } from "svelte";
 * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}
 * ```
 * Typing this makes it possible for IDEs like VS Code with the Svelte extension
 * to provide intellisense and to use the component like this in a Svelte file
 * with TypeScript:
 * ```svelte
 * <script lang="ts">
 * 	import { MyComponent } from "component-library";
 * </script>
 * <MyComponent foo={'bar'} />
 * ```
 *
 * #### Why not make this part of `SvelteComponent(Dev)`?
 * Because
 * ```ts
 * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}
 * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;
 * ```
 * will throw a type error, so we need to seperate the more strictly typed class.
 */


exports.SvelteComponentDev = SvelteComponentDev;

class SvelteComponentTyped extends SvelteComponentDev {
  constructor(options) {
    super(options);
  }

}

exports.SvelteComponentTyped = SvelteComponentTyped;

function loop_guard(timeout) {
  const start = Date.now();
  return () => {
    if (Date.now() - start > timeout) {
      throw new Error('Infinite loop detected');
    }
  };
}
},{}],"node_modules/svelte/store/index.mjs":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.derived = derived;
exports.readable = readable;
exports.writable = writable;
Object.defineProperty(exports, "get", {
  enumerable: true,
  get: function () {
    return _index.get_store_value;
  }
});

var _index = require("../internal/index.mjs");

const subscriber_queue = [];
/**
 * Creates a `Readable` store that allows reading by subscription.
 * @param value initial value
 * @param {StartStopNotifier}start start and stop notifications for subscriptions
 */

function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */


function writable(value, start = _index.noop) {
  let stop;
  const subscribers = [];

  function set(new_value) {
    if ((0, _index.safe_not_equal)(value, new_value)) {
      value = new_value;

      if (stop) {
        // store is ready
        const run_queue = !subscriber_queue.length;

        for (let i = 0; i < subscribers.length; i += 1) {
          const s = subscribers[i];
          s[1]();
          subscriber_queue.push(s, value);
        }

        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }

          subscriber_queue.length = 0;
        }
      }
    }
  }

  function update(fn) {
    set(fn(value));
  }

  function subscribe(run, invalidate = _index.noop) {
    const subscriber = [run, invalidate];
    subscribers.push(subscriber);

    if (subscribers.length === 1) {
      stop = start(set) || _index.noop;
    }

    run(value);
    return () => {
      const index = subscribers.indexOf(subscriber);

      if (index !== -1) {
        subscribers.splice(index, 1);
      }

      if (subscribers.length === 0) {
        stop();
        stop = null;
      }
    };
  }

  return {
    set,
    update,
    subscribe
  };
}

function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto = fn.length < 2;
  return readable(initial_value, set => {
    let inited = false;
    const values = [];
    let pending = 0;
    let cleanup = _index.noop;

    const sync = () => {
      if (pending) {
        return;
      }

      cleanup();
      const result = fn(single ? values[0] : values, set);

      if (auto) {
        set(result);
      } else {
        cleanup = (0, _index.is_function)(result) ? result : _index.noop;
      }
    };

    const unsubscribers = stores_array.map((store, i) => (0, _index.subscribe)(store, value => {
      values[i] = value;
      pending &= ~(1 << i);

      if (inited) {
        sync();
      }
    }, () => {
      pending |= 1 << i;
    }));
    inited = true;
    sync();
    return function stop() {
      (0, _index.run_all)(unsubscribers);
      cleanup();
    };
  });
}
},{"../internal/index.mjs":"node_modules/svelte/internal/index.mjs"}],"node_modules/svelte/index.mjs":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "SvelteComponent", {
  enumerable: true,
  get: function () {
    return _index.SvelteComponentDev;
  }
});
Object.defineProperty(exports, "SvelteComponentTyped", {
  enumerable: true,
  get: function () {
    return _index.SvelteComponentTyped;
  }
});
Object.defineProperty(exports, "afterUpdate", {
  enumerable: true,
  get: function () {
    return _index.afterUpdate;
  }
});
Object.defineProperty(exports, "beforeUpdate", {
  enumerable: true,
  get: function () {
    return _index.beforeUpdate;
  }
});
Object.defineProperty(exports, "createEventDispatcher", {
  enumerable: true,
  get: function () {
    return _index.createEventDispatcher;
  }
});
Object.defineProperty(exports, "getContext", {
  enumerable: true,
  get: function () {
    return _index.getContext;
  }
});
Object.defineProperty(exports, "hasContext", {
  enumerable: true,
  get: function () {
    return _index.hasContext;
  }
});
Object.defineProperty(exports, "onDestroy", {
  enumerable: true,
  get: function () {
    return _index.onDestroy;
  }
});
Object.defineProperty(exports, "onMount", {
  enumerable: true,
  get: function () {
    return _index.onMount;
  }
});
Object.defineProperty(exports, "setContext", {
  enumerable: true,
  get: function () {
    return _index.setContext;
  }
});
Object.defineProperty(exports, "tick", {
  enumerable: true,
  get: function () {
    return _index.tick;
  }
});

var _index = require("./internal/index.mjs");
},{"./internal/index.mjs":"node_modules/svelte/internal/index.mjs"}],"node_modules/right-now/browser.js":[function(require,module,exports) {
var global = arguments[3];
module.exports =
  global.performance &&
  global.performance.now ? function now() {
    return performance.now()
  } : Date.now || function now() {
    return +new Date
  }

},{}],"node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"src/alec-svelte/index.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRootWorld = createRootWorld;
exports.context = context;
exports.AutoReleasingTrigger = exports.TagPropUpdate = exports.MarkConfigChanged = exports.Config = exports.ViewLayerNeedsUpdate = exports.ViewLayer = exports.CONTEXT_KEY_NODE = void 0;

var _alec = require("../alec");

var _store = require("svelte/store");

var _svelte = require("svelte");

var _rightNow = _interopRequireDefault(require("right-now"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const CONTEXT_KEY_NODE = {};
exports.CONTEXT_KEY_NODE = CONTEXT_KEY_NODE;

class ViewLayer extends _alec.Data {
  static data = {
    id: _alec.Types.Ref(""),
    component: _alec.Types.Ref(),
    props: _alec.Types.Object()
  };
}

exports.ViewLayer = ViewLayer;

class ViewLayerNeedsUpdate extends _alec.Tag {}

exports.ViewLayerNeedsUpdate = ViewLayerNeedsUpdate;

class Config extends _alec.Data {
  static data = {
    name: _alec.Types.Ref(""),
    component: _alec.Types.Ref(),
    props: _alec.Types.Object(),
    triggers: _alec.Types.Object(),
    changed: _alec.Types.Ref(false),
    sync: _alec.Types.Ref(false),
    instance: _alec.Types.Ref()
  };

  update() {
    this.changed = true;
    this.sync = true;
  }

}

exports.Config = Config;

class MarkConfigChanged extends _alec.Tag {}

exports.MarkConfigChanged = MarkConfigChanged;

class TagPropUpdate extends _alec.Value {}

exports.TagPropUpdate = TagPropUpdate;

class AutoReleasingTrigger extends _alec.Data {
  static data = {
    target: _alec.Types.Ref(),
    key: _alec.Types.Ref(),
    value: _alec.Types.Ref()
  };
}

exports.AutoReleasingTrigger = AutoReleasingTrigger;

function ViewLayerSystem(world, {
  store
}) {
  world.system.info({
    hidden: true
  });
  const entities = world.view(ViewLayer);
  const events = world.listen(ViewLayer);
  const updates = world.view([ViewLayer, ViewLayerNeedsUpdate]);
  return () => {
    let needsUpdate = false;
    let didUpdate = false;

    if (events.changed) {
      const layers = entities.slice();
      if (store) store.update(() => layers);
      didUpdate = true;
    }

    updates.forEach(e => {
      e.remove(ViewLayerNeedsUpdate);
      needsUpdate = true;
    });

    if (!didUpdate && needsUpdate && store) {
      const layers = entities.slice();
      store.update(() => layers);
    }
  };
}

function ConfigSystem(world, {
  store
}) {
  world.system.info({
    hidden: true
  });
  const configs = world.view(Config);
  const events = world.listen(Config);
  const triggers = world.view(AutoReleasingTrigger);
  const triggerEvents = world.listen(AutoReleasingTrigger);
  const tagUpdates = world.view(TagPropUpdate);
  const updateFps = 10;
  let fpsInterval = 1 / updateFps;
  let fpsElapsed = 0;
  let lastFrameTime = (0, _rightNow.default)();
  return {
    process
  };

  function process(dt) {
    // first, if any configs have been added / removed, we
    // will trigger a full update on the store
    if (events.changed) {
      if (store) {
        const list = configs.slice();
        store.update(d => list);
      } // newly added configs will also receive a ConfigHasChanged tag


      events.added.forEach(e => {
        e.add(MarkConfigChanged);
      });
      events.removing.forEach(e => {
        if (e.has(MarkConfigChanged)) e.remove(MarkConfigChanged);
      });
    } // next, we cycle through all current configs and mark change flags


    configs.forEach(e => {
      const config = e.get(Config);
      const hasChangeMarker = e.has(MarkConfigChanged);
      config.changed = hasChangeMarker; // remove the tag as we've now set the change flag

      if (hasChangeMarker) e.remove(MarkConfigChanged);

      if (config.instance && config.sync) {
        // config.instance.$set(config.props);
        config.instance.sync();
        config.sync = false;
      }
    }); // go through any triggers that are being killed

    triggerEvents.removing.forEach(e => {
      // release the trigger, which forces a change flag
      const trigger = e.get(AutoReleasingTrigger); // trigger.target.changed = true;
      // and delete the trigger prop

      delete trigger.target.triggers[trigger.key];
    }); // this view is into the not-yet-killed triggers

    triggers.forEach(e => {
      // mark the change flag and set trigger to new value
      const trigger = e.get(AutoReleasingTrigger); // trigger.target.changed = true;

      trigger.target.triggers[trigger.key] = trigger.value; // mark entity for deletion, next time we process it will get
      // picked up by triggerEvents.removing

      e.kill();
    });
    fpsElapsed += dt;

    if (fpsElapsed >= fpsInterval) {
      fpsElapsed %= fpsInterval;
      const now = (0, _rightNow.default)();
      tagUpdates.forEach(e => {
        const f = e.get(TagPropUpdate);
        if (typeof f === "function") f();
      });
      lastFrameTime = now;
    }
  }
}

function createRootWorld(opt = {}) {
  const {
    useEditorConfig = false
  } = opt;
  const world = (0, _alec.createWorld)({
    initialCapacity: 400
  });
  const viewLayerStore = (0, _store.writable)([]);
  world.addSystem(ViewLayerSystem, {
    store: viewLayerStore
  });
  const configEntityStore = useEditorConfig ? (0, _store.writable)([]) : null; // if (useEditorConfig) {

  world.addSystem(ConfigSystem, {
    store: configEntityStore
  }); // }

  return {
    configEntityStore,
    viewLayerStore,
    world
  };
}

function context() {
  const ctx = (0, _svelte.getContext)(CONTEXT_KEY_NODE);
  if (ctx == null) throw new Error(`Must call context() from within a Svelte component`);
  return ctx;
}
},{"../alec":"src/alec/index.js","svelte/store":"node_modules/svelte/store/index.mjs","svelte":"node_modules/svelte/index.mjs","right-now":"node_modules/right-now/browser.js","process":"node_modules/process/browser.js"}],"src/tags/tags.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "ViewLayer", {
  enumerable: true,
  get: function () {
    return _alecSvelte.ViewLayer;
  }
});
Object.defineProperty(exports, "ViewLayerNeedsUpdate", {
  enumerable: true,
  get: function () {
    return _alecSvelte.ViewLayerNeedsUpdate;
  }
});
Object.defineProperty(exports, "Config", {
  enumerable: true,
  get: function () {
    return _alecSvelte.Config;
  }
});
Object.defineProperty(exports, "MarkConfigChanged", {
  enumerable: true,
  get: function () {
    return _alecSvelte.MarkConfigChanged;
  }
});
Object.defineProperty(exports, "Data", {
  enumerable: true,
  get: function () {
    return _alec.Data;
  }
});
Object.defineProperty(exports, "Value", {
  enumerable: true,
  get: function () {
    return _alec.Value;
  }
});
Object.defineProperty(exports, "Tag", {
  enumerable: true,
  get: function () {
    return _alec.Tag;
  }
});
exports.DebugRenderTarget = exports.UserFirstVisitedWorldIndex = exports.GroundDataRenderTarget = exports.GroundFogRenderTarget = exports.AudioMeta = exports.SolvingDecayArea = exports.HasVisitedFinalPortal = exports.WaitingToVisitFinalPortal = exports.WorldDecayTweens = exports.WorldTweens = exports.ActiveWorldIndex = exports.WaitingForTokenPaper = exports.HaikuInInventory = exports.HaikuAddingToInventory = exports.FinishedPoem = exports.CollectedToken = exports.GroundToken = exports.UserLine = exports.KillWritingIgnore = exports.UserWritingState = exports.GroundSpawnDecayTag = exports.GroundSpawnTokenTag = exports.GroundSpawnPosition2D = exports.PoemLineVertex = exports.PoemFinishing = exports.PoemLineText = exports.PoemInProgress = exports.PoemWriting = exports.IntroLayer = exports.HasLoaded = exports.HasShownElementalOverlay = exports.NearestEnvironmentCell = exports.CanShowCompass = exports.PoemRemaining = exports.PoemTextFragment = exports.GroundPoemFragmentSprite = exports.PoemLineMesh = exports.TickerTimeline = exports.PoemLineWithinRange = exports.GroundMeshWithPoem = exports.PoemLineTrigger = exports.PoemLine = exports.SpriteBlobShadowView = exports.SpriteBlobShadow = exports.GroundAssetSpriteType = exports.GroundAssetCellSampleToHide = exports.GroundAssetCellSampleToGrow = exports.GroundAssetCellSampleWithFeature = exports.GroundAssetCellSampleInstance = exports.GroundAssetCellSample = exports.GroundPlaneLayer = exports.GrassPlaneView = exports.GroundPlaneView = exports.GroundSpawningDot = exports.GroundSpawningGrass = exports.GroundSpawningLeaf = exports.GroundPatchInstance = exports.EnvironmentCell = exports.ActiveEnvironmentState = exports.EnvironmentState = exports.GroundPhysicsBody = exports.EnvironmentUnderPlayerState = exports.TextSprite3D = exports.MoveUserTo = exports.CinematicCameraMoment = exports.UserCompletingPoem = exports.UserInPoemArea = exports.PoemLineActivated = exports.PoemLineTriggerActivated = exports.TriggerDelayedPoemOverlay = exports.TriggerPoemComplete = exports.TweenCopyTargetKeyToVectorScalar = exports.TargetKeyTween = exports.Sequence = exports.MovementBoost = exports.ShaderUniformUserCharacterPosition = exports.ShaderUniformUserTargetPosition = exports.ShaderUniformResolution = exports.ShaderUniformTime = exports.EnvironmentMap = exports.IsGameUIActive = exports.ModalStoppingUserMovement = exports.CameraStopUserMovement = exports.UserFollow = exports.UserZoom = exports.DebugState = exports.UserTarget = exports.UserCharacter = exports.AppState = exports.UserInitiatedGesture = exports.InputState = exports.TriggerMovementGesture = exports.InputGestureEmitter = exports.Renderer = exports.Canvas = exports.MainScene = exports.MainCamera = exports.Object3DKeepAlive = exports.Object3D = exports.Types = void 0;
exports.UserHasHit = exports.WaterFishPlaceholderTag = exports.FoxHm = exports.FoxPurring = exports.FoxSpriteTag = exports.GameFinished = exports.TutorialMessage = exports.FloatingEndLine = exports.TokenForCompass = exports.AnimateOutCharacter = exports.AnimateInCharacter = exports.Animal = exports.AnimalSpawn = exports.LastWalkedLake = exports.Raining = exports.RainDropSplatter = exports.RainDrop = exports.WindLine = exports.HintOrb = exports.ObjectiveText = exports.CanSetIntroTags = exports.BlockTokenCollection = exports.UserForceApplied = exports.TutorialBarrenGround = exports.TutorialTextHint = exports.TutorialState = exports.HideHUD = exports.HideCharacter = exports.BlockUserMove = exports.HaikuCardSaved = exports.HaikuCardShown = exports.KillTextHint = exports.TextHint = exports.ScreenFade = exports.LetterboxBars = exports.CameraZoomOut = exports.GameLandingCameraDrift = exports.OriginTreeIntroSequenceStarted = exports.OriginTreeIntroSequence = exports.MoveUserToOrigin = exports.HatTipWindLineSound = exports.HatTipWindLineTag = exports.HatTipPoint = exports.WaterFollowParticle = exports.UserCarryingTokenCollectionFeature = exports.GLTFSpawnItemsMap = exports.FloatingTokenShouldTargetTree = exports.FloatingTokenTargetUser = exports.FloatingToken = exports.GlowingHaikuCard = exports.CameraFocusOnTarget = exports.SpriteAnimationOriginTreeTag = exports.GameStarted = exports.ButtonClick = exports.ButtonHover = exports.PauseOpen = exports.JournalOpen = exports.SpriteAnimationLazyLoadSheet = exports.SpriteAnimation = exports.SpawnedFlora = exports.StanzaLineSpawningAsset = exports.WrittenStanzaLineActive = exports.WrittenStanzaLine = exports.TokensDiscoveredSet = exports.GroundAssetToken = exports.BoxHelper = exports.SafeToSwapBiomes = exports.TransitionToNextBiome = exports.EndGameState = exports.FinalBiomeResolutionLines = exports.FinalBiomeResolution = exports.ShowBiomeResolution = exports.WaitingForBiomeResolution = exports.DirectUserToOrigin = exports.GameUIStore = exports.TestLoadRef = exports.IsInFrustum = exports.GLTFRefAssetLoaded = exports.GLTFRefAsset = exports.AssetCache = exports.BloomObject = exports.ShadowCaster = exports.RenderLayers = exports.GrassEditableData = exports.GroundMeshEditableData = exports.Atmospherics = exports.PostProcessEnabled = exports.GroundAsset3DAsync = exports.GroundAssetInsideFrustum = exports.MainCameraFrustum = exports.GroundAssetData = exports.GroundAsset = exports.WillTriggerAudio = exports.UserHitAudioTrigger = exports.ShowUserTokenInventory = exports.ShowUserCollectHint = exports.ShowUserWriteHint = exports.WaitingForUserWrite = exports.BlockUserWrite = exports.GroundDataParticle = void 0;
exports.TriggerTreeTransitionAudio = exports.OutroFinished = exports.MusicalOrb = exports.ParticleEmit = exports.AutoRemoveCapeMagicalEffect = exports.CapeMagicalEffect = exports.FlashSound = exports.AnimalSound = exports.ClearInputPress = exports.GIFRecord = exports.CollectTokenOrb = exports.TokenChildren = exports.TriggerTokenLine = exports.TokenIsCollecting = exports.ResetToCameraDrift = exports.Snowflake = exports.CompassVisible = void 0;

var THREE = _interopRequireWildcard(require("three"));

var _alecSvelte = require("../alec-svelte");

var _alec = require("../alec");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// re-export some Svelte-specific tags
const Types = { ..._alec.Types,
  Vector2: (x = 0, y = 0) => ({
    initial: new THREE.Vector2(x, y),
    copy: _alec.copyInstance,
    clone: _alec.cloneInstance
  }),
  Vector3: (x = 0, y = 0, z = 0) => ({
    initial: new THREE.Vector3(x, y, z),
    copy: _alec.copyInstance,
    clone: _alec.cloneInstance
  }),
  Vector4: (x = 0, y = 0, z = 0, w = 0) => ({
    initial: new THREE.Vector4(x, y, z, w),
    copy: _alec.copyInstance,
    clone: _alec.cloneInstance
  }),
  Quaternion: (x = 0, y = 0, z = 0, w = 0) => ({
    initial: new THREE.Quaternion(x, y, z, w),
    copy: _alec.copyInstance,
    clone: _alec.cloneInstance
  }),
  Euler: (x = 0, y = 0, z = 0, order = "XYZ") => ({
    initial: new THREE.Euler(x, y, z, order),
    copy: _alec.copyInstance,
    clone: _alec.cloneInstance
  }),
  Color: (r = 0, g = 0, b = 0) => ({
    initial: new THREE.Color(r, g, b),
    copy: _alec.copyInstance,
    clone: _alec.cloneInstance
  })
};
exports.Types = Types;

class Object3D extends _alec.Value {
  static edit = {
    visible: false
  };
}

exports.Object3D = Object3D;

class Object3DKeepAlive extends _alec.Tag {}

exports.Object3DKeepAlive = Object3DKeepAlive;

class MainCamera extends _alec.Value {}

exports.MainCamera = MainCamera;

class MainScene extends _alec.Value {}

exports.MainScene = MainScene;

class Canvas extends _alec.Value {}

exports.Canvas = Canvas;

class Renderer extends _alec.Value {}

exports.Renderer = Renderer;

class InputGestureEmitter extends _alec.Value {}

exports.InputGestureEmitter = InputGestureEmitter;

class TriggerMovementGesture extends _alec.Value {}

exports.TriggerMovementGesture = TriggerMovementGesture;

class InputState extends _alec.Data {
  static data = {
    multitouch: Types.Ref(null),
    position: Types.Vector2(),
    positionNormalized: Types.Vector2(),
    // dragging: false,
    // inside: false,
    interacted: false,
    pressed: false,
    metaKey: false,
    ctrlKey: false,
    shiftKey: false
  };
}

exports.InputState = InputState;

class UserInitiatedGesture extends _alec.Tag {}

exports.UserInitiatedGesture = UserInitiatedGesture;

class AppState extends _alec.Data {
  static data = {
    ready: Types.Ref(false),
    running: Types.Ref(true),
    rendering: Types.Ref(true),
    pixelRatio: Types.Ref(1),
    width: Types.Ref(1),
    height: Types.Ref(1),
    canvasWidth: Types.Ref(1),
    canvasHeight: Types.Ref(1)
  };
} // In some special cases, such as starting audio,
// we require a 'tap' event. In these cases you
// can get this handler from the world and assign
// events during system init
// export class InputEmitter extends Value {
//   static edit = { visible: false };
// }


exports.AppState = AppState;

class UserCharacter extends _alec.Data {
  static data = {
    direction: Types.Vector3(),
    position: Types.Vector3(),
    target: Types.Vector3(),
    velocity: Types.Vector3(),
    yOffset: Types.Ref(0),
    magicalEffect: Types.Ref(0),
    glowIntensity: Types.Ref(1),
    glowIntensity2: Types.Ref(1),
    capeSpeed: Types.Ref(1)
  };
}

exports.UserCharacter = UserCharacter;

class UserTarget extends _alec.Data {
  static data = {
    direction: Types.Vector3(),
    position: Types.Vector3(),
    forceApplied: false,
    speedAlpha: 0,
    totalBoost: 0,
    boostAlpha: 0,
    totalSpeedAlpha: 0,
    inputPositionOnPlane: Types.Vector3(),
    inputHitPlane: false
  };
}

exports.UserTarget = UserTarget;

class DebugState extends _alec.Data {
  static data = {
    mouseOnPlaneHitPoint: Types.Vector3()
  };
}

exports.DebugState = DebugState;

class UserZoom extends _alec.Data {
  static data = {
    allowMouseZoom: false,
    distance: 15,
    defaultDistance: 15,
    minDistance: 2,
    maxDistance: 50,
    currentWheelOffset: 0,
    zoomPowFactor: 1.25,
    zoomPowTarget: 5,
    zoomPixelsToWorld: 0.001
  };
}

exports.UserZoom = UserZoom;

class UserFollow extends _alec.Data {
  static data = {
    currentTarget: Types.Vector3(),
    currentPosition: Types.Vector3(),
    currentDistance: 12,
    distanceSpring: 5,
    minSpeedZoomDistance: 0,
    maxSpeedZoomDistance: 1,
    speedZoomDistance: 0,
    speedZoomSpringIn: 0.25,
    speedZoomSpringOut: 4,
    shake: 0,
    shakeSpeed: 1,
    shakeTime: 0
  };
}

exports.UserFollow = UserFollow;

class CameraStopUserMovement extends _alec.Tag {}

exports.CameraStopUserMovement = CameraStopUserMovement;

class ModalStoppingUserMovement extends _alec.Tag {}

exports.ModalStoppingUserMovement = ModalStoppingUserMovement;

class IsGameUIActive extends _alec.Tag {}

exports.IsGameUIActive = IsGameUIActive;

class EnvironmentMap extends _alec.Data {
  static data = {
    image: null
  };
}

exports.EnvironmentMap = EnvironmentMap;

class ShaderUniformTime extends _alec.Data {
  static data = {
    uniform: Types.Ref(),
    elapsed: Types.Ref(0)
  };
  static edit = {
    visible: false
  };
}

exports.ShaderUniformTime = ShaderUniformTime;

class ShaderUniformResolution extends _alec.Data {
  static data = {
    uniform: Types.Ref()
  };
  static edit = {
    visible: false
  };
}

exports.ShaderUniformResolution = ShaderUniformResolution;

class ShaderUniformUserTargetPosition extends _alec.Data {
  static data = {
    uniform: Types.Ref()
  };
  static edit = {
    visible: false
  };
}

exports.ShaderUniformUserTargetPosition = ShaderUniformUserTargetPosition;

class ShaderUniformUserCharacterPosition extends _alec.Data {
  static data = {
    uniform: Types.Ref()
  };
  static edit = {
    visible: false
  };
}

exports.ShaderUniformUserCharacterPosition = ShaderUniformUserCharacterPosition;

class MovementBoost extends _alec.Data {
  static data = {
    frictionPower: Types.Ref(1),
    value: Types.Ref(2),
    duration: Types.Ref(4),
    elapsed: Types.Ref(0)
  };
}

exports.MovementBoost = MovementBoost;

class Sequence {
  static data = {
    curve: Types.Ref(),
    stanza: Types.Ref(0)
  };
}

exports.Sequence = Sequence;

class TargetKeyTween extends _alec.Data {
  static data = {
    pauseOnModal: Types.Ref(false),
    started: Types.Ref(false),
    duration: Types.Ref(1),
    elapsed: Types.Ref(0),
    ease: Types.Ref("linear"),
    delay: Types.Ref(0),
    from: Types.Ref(0),
    to: Types.Ref(1),
    active: Types.Ref(true),
    finished: Types.Ref(false),
    killEntityOnFinish: Types.Ref(false),
    assignFromOnStart: Types.Ref(false),
    target: Types.Ref(null),
    key: Types.Ref(""),
    // kinda hate ECS for animation !
    // must be a better way than callbacks
    callbackOnStart: Types.Ref(null),
    callbackOnFinish: Types.Ref(null)
  };
}

exports.TargetKeyTween = TargetKeyTween;

class TweenCopyTargetKeyToVectorScalar extends _alec.Value {} // export class StartTween extends Tag {}
// export class CopyTweenValueToVector extends Value {}


exports.TweenCopyTargetKeyToVectorScalar = TweenCopyTargetKeyToVectorScalar;

class TriggerPoemComplete extends _alec.Value {
  static value = Types.Ref(null);
}

exports.TriggerPoemComplete = TriggerPoemComplete;

class TriggerDelayedPoemOverlay extends _alec.Data {
  static data = {
    root: Types.Ref(null),
    delay: Types.Ref(1),
    elapsed: Types.Ref(0),
    spawned: Types.Ref(false)
  };
}

exports.TriggerDelayedPoemOverlay = TriggerDelayedPoemOverlay;

class PoemLineTriggerActivated extends _alec.Tag {}

exports.PoemLineTriggerActivated = PoemLineTriggerActivated;

class PoemLineActivated extends _alec.Data {
  static data = {
    root: Types.Ref(null),
    node: Types.Ref(null)
  };
}

exports.PoemLineActivated = PoemLineActivated;

class UserInPoemArea extends _alec.Tag {}

exports.UserInPoemArea = UserInPoemArea;

class UserCompletingPoem extends _alec.Tag {}

exports.UserCompletingPoem = UserCompletingPoem;

class CinematicCameraMoment extends _alec.Data {
  static data = {
    copyStart: Types.Ref(false),
    target: Types.Vector3()
  };
}

exports.CinematicCameraMoment = CinematicCameraMoment;

class MoveUserTo extends _alec.Data {
  static data = {
    target: Types.Vector3()
  };
}

exports.MoveUserTo = MoveUserTo;

class TextSprite3D extends _alec.Data {
  static data = {
    text: Types.Ref(""),
    color: Types.Color(1, 1, 1),
    culling: Types.Ref(true),
    depth: Types.Ref(true),
    x: Types.Ref(0),
    y: Types.Ref(0),
    sprite: Types.Ref(null),
    opacity: Types.Ref(1),
    fontStyle: Types.Ref("normal"),
    fontSize: Types.Ref(14),
    parent: Types.Ref(null)
  };
}

exports.TextSprite3D = TextSprite3D;

class EnvironmentUnderPlayerState extends _alec.Data {
  static data = {
    lake: Types.Ref(null),
    water: Types.Ref(false)
  };
}

exports.EnvironmentUnderPlayerState = EnvironmentUnderPlayerState;

class GroundPhysicsBody extends _alec.Data {
  static data = {
    position: Types.Vector3(0, 0, 0),
    velocity: Types.Vector3(0, 0, 0),
    speed: Types.Ref(1),
    scale: Types.Ref(1),
    timeScale: Types.Ref(1),
    currentRotation: Types.Quaternion(0, 0, 0, 0),
    spinRotation: Types.Quaternion(0, 0, 0, 0),
    targetRotation: Types.Quaternion(0, 0, 0, 0),
    flatRotation: Types.Quaternion(0, 0, 0, 0),
    rotationAxis: Types.Vector3(0, 0, 0),
    rotationSpeed: Types.Ref(1),
    rotationAngleOffset: Types.Ref(0)
  };
}

exports.GroundPhysicsBody = GroundPhysicsBody;

class EnvironmentState extends _alec.Data {
  static data = {
    name: Types.Ref(""),
    grassInstanceCount: Types.Ref(1),
    grassScale: Types.Ref(1),
    grassTipFactor: Types.Ref(1),
    haikusTotal: Types.Ref(5),
    waterMeshes: Types.Array([]),
    tokens: Types.Array([]),
    solved: Types.Ref(0),
    group: Types.Ref(null),
    lakes: Types.Ref(null),
    data: Types.Ref(null),
    grid: Types.Ref(null),
    samples: Types.Ref(null),
    waterSamples: Types.Ref(null),
    waterColors: Types.Ref(null),
    seed: Types.Ref(null),
    waterId: Types.Ref(null),
    hasLakes: Types.Ref(null),
    idleViewPoint: Types.Vector3(),
    cells: Types.Ref(null),
    colors: Types.Ref(null),
    textures: Types.Array([]),
    patches: Types.Array([]),
    waterMap: Types.Ref(null),
    overlayOpacity: Types.Ref(1)
  };
  static edit = {};
}

exports.EnvironmentState = EnvironmentState;

class ActiveEnvironmentState extends _alec.Tag {}

exports.ActiveEnvironmentState = ActiveEnvironmentState;

class EnvironmentCell extends _alec.Data {
  static data = {
    environmentState: Types.Ref(null),
    cell: Types.Ref(null),
    random: Types.Ref(null),
    children: Types.Array([])
  };
}

exports.EnvironmentCell = EnvironmentCell;

class GroundPatchInstance extends _alec.Value {
  static value = null;
}

exports.GroundPatchInstance = GroundPatchInstance;

class GroundSpawningLeaf extends _alec.Tag {}

exports.GroundSpawningLeaf = GroundSpawningLeaf;

class GroundSpawningGrass extends _alec.Tag {}

exports.GroundSpawningGrass = GroundSpawningGrass;

class GroundSpawningDot extends _alec.Tag {}

exports.GroundSpawningDot = GroundSpawningDot;

class GroundPlaneView extends _alec.Data {
  static data = {
    camera: null,
    target: null,
    projectionMatrix: null,
    layer: 5
  };
}

exports.GroundPlaneView = GroundPlaneView;

class GrassPlaneView extends _alec.Data {
  static data = {
    layer: Types.Ref(7)
  };
}

exports.GrassPlaneView = GrassPlaneView;

class GroundPlaneLayer extends _alec.Value {
  static value = null;
}

exports.GroundPlaneLayer = GroundPlaneLayer;

class GroundAssetCellSample extends _alec.Data {
  static data = {
    x: Types.Ref(0),
    y: Types.Ref(0),
    random: Types.Ref(null),
    cell: Types.Ref(null),
    type: Types.Ref(null),
    children: Types.Array([])
  };
}

exports.GroundAssetCellSample = GroundAssetCellSample;

class GroundAssetCellSampleInstance extends _alec.Data {
  static data = {
    worldIndex: Types.Ref(0),
    feature: Types.Ref(false),
    data: Types.Ref(null)
  };
}

exports.GroundAssetCellSampleInstance = GroundAssetCellSampleInstance;

class GroundAssetCellSampleWithFeature extends _alec.Value {}

exports.GroundAssetCellSampleWithFeature = GroundAssetCellSampleWithFeature;

class GroundAssetCellSampleToGrow extends _alec.Tag {}

exports.GroundAssetCellSampleToGrow = GroundAssetCellSampleToGrow;

class GroundAssetCellSampleToHide extends _alec.Tag {}

exports.GroundAssetCellSampleToHide = GroundAssetCellSampleToHide;

class GroundAssetSpriteType extends _alec.Value {}

exports.GroundAssetSpriteType = GroundAssetSpriteType;

class SpriteBlobShadow extends _alec.Data {
  static data = {
    size: Types.Ref(1),
    scale: Types.Ref(1),
    offsetX: Types.Ref(0),
    offsetY: Types.Ref(0),
    mesh: Types.Ref(null)
  };
}

exports.SpriteBlobShadow = SpriteBlobShadow;

class SpriteBlobShadowView extends _alec.Data {
  static data = {
    target: Types.Ref(null),
    layer: Types.Ref(6)
  };
}

exports.SpriteBlobShadowView = SpriteBlobShadowView;

class PoemLine extends _alec.Data {
  static data = {
    node: Types.Ref(null),
    root: Types.Ref(null),
    nearby: Types.Ref(false),
    boundingCenter: Types.Array([]),
    boundingRadius: Types.Ref(1),
    curve: Types.Ref(null),
    triggers: Types.Array([]),
    activated: Types.Ref(false),
    yOffset: Types.Ref(0.5)
  };
}

exports.PoemLine = PoemLine;

class PoemLineTrigger extends _alec.Data {
  static data = {
    root: Types.Ref(null),
    ready: Types.Ref(false),
    activated: Types.Ref(false),
    progress: Types.Ref(0),
    fragment: Types.Ref(""),
    previous: Types.Ref(null),
    next: Types.Ref(null),
    parent: Types.Ref(null),
    position: Types.Vector3()
  };
}

exports.PoemLineTrigger = PoemLineTrigger;

class GroundMeshWithPoem extends _alec.Data {
  static data = {
    mesh: Types.Ref(null),
    id: Types.Ref("")
  };
}

exports.GroundMeshWithPoem = GroundMeshWithPoem;

class PoemLineWithinRange extends _alec.Tag {} // export class KillEntityAfterTweens extends Tag {}
// export class Complete extends Value {}
// export class TriggerPoemFragment extends Value {}


exports.PoemLineWithinRange = PoemLineWithinRange;

class TickerTimeline extends _alec.Value {}

exports.TickerTimeline = TickerTimeline;

class PoemLineMesh extends _alec.Data {
  static data = {
    mesh: Types.Ref(null),
    timeline: Types.Ref(null),
    parent: Types.Ref(null)
  };
} // export class TriggerPoemLineHide extends Tag {}


exports.PoemLineMesh = PoemLineMesh;

class GroundPoemFragmentSprite extends _alec.Tag {}

exports.GroundPoemFragmentSprite = GroundPoemFragmentSprite;

class PoemTextFragment extends _alec.Data {
  static data = {
    root: Types.Ref(null),
    mesh: Types.Ref(null)
  };
}

exports.PoemTextFragment = PoemTextFragment;

class PoemRemaining extends _alec.Value {}

exports.PoemRemaining = PoemRemaining;

class CanShowCompass extends _alec.Tag {}

exports.CanShowCompass = CanShowCompass;

class NearestEnvironmentCell extends _alec.Value {}

exports.NearestEnvironmentCell = NearestEnvironmentCell;

class HasShownElementalOverlay extends _alec.Tag {} // export class FadeFromBlack extends Tag {}


exports.HasShownElementalOverlay = HasShownElementalOverlay;

class HasLoaded extends _alec.Tag {}

exports.HasLoaded = HasLoaded;

class IntroLayer extends _alec.Tag {}

exports.IntroLayer = IntroLayer;

class PoemWriting extends _alec.Tag {}

exports.PoemWriting = PoemWriting;

class PoemInProgress extends _alec.Tag {}

exports.PoemInProgress = PoemInProgress;

class PoemLineText extends _alec.Tag {}

exports.PoemLineText = PoemLineText;

class PoemFinishing extends _alec.Data {
  static data = {
    elapsed: Types.Ref(0),
    delay: Types.Ref(3)
  };
}

exports.PoemFinishing = PoemFinishing;

class PoemLineVertex extends _alec.Data {
  static data = {
    position: Types.Vector3()
  };
}

exports.PoemLineVertex = PoemLineVertex;

class GroundSpawnPosition2D extends _alec.Value {
  static value = Types.Array([]);
}

exports.GroundSpawnPosition2D = GroundSpawnPosition2D;

class GroundSpawnTokenTag extends _alec.Tag {}

exports.GroundSpawnTokenTag = GroundSpawnTokenTag;

class GroundSpawnDecayTag extends _alec.Tag {}

exports.GroundSpawnDecayTag = GroundSpawnDecayTag;

class UserWritingState extends _alec.Data {
  static data = {
    writing: Types.Ref(false),
    force: Types.Ref(false),
    ignore: Types.Ref(false)
  };
}

exports.UserWritingState = UserWritingState;

class KillWritingIgnore extends _alec.Data {
  static data = {
    elapsed: Types.Ref(0),
    duration: Types.Ref(0.5)
  };
}

exports.KillWritingIgnore = KillWritingIgnore;

class UserLine extends _alec.Data {
  static data = {
    distance: Types.Ref(0),
    writing: Types.Ref(false),
    changed: Types.Ref(false),
    active: Types.Ref(false),
    line: Types.Ref(null),
    elapsed: Types.Ref(0),
    duration: Types.Ref(1)
  };
}

exports.UserLine = UserLine;

class GroundToken extends _alec.Data {
  static data = {
    type: Types.Ref(""),
    position: Types.Vector3(0, 0, 0),
    collected: Types.Ref(false)
  };
}

exports.GroundToken = GroundToken;

class CollectedToken extends _alec.Data {
  static data = {
    type: Types.Ref(""),
    stanza: Types.Ref(null),
    stanzaIndex: Types.Ref(0),
    x: Types.Ref(0),
    z: Types.Ref(0) // writing: Types.Ref(false),
    // idleTime: Types.Ref(0),
    // killAfterIdleDuration: Types.Ref(2),
    // linkedEntity: Types.Ref(null),

  };
} // export class CurrentWritingToken extends Data {
//   static data = {
//     stanza: Types.Ref(0),
//     fragments: Types.Ref(null),
//     text: Types.Ref(""),
//     tokenType: Types.Ref(""),
//     token: Types.Ref(null),
//     index: Types.Ref(0),
//   };
// }
// export class CurrentWritingTokenFading extends Data {
//   static data = {
//     ref: Types.Ref(null),
//     children: Types.Array([]),
//     elapsed: Types.Ref(0),
//     duration: Types.Ref(2),
//   };
// }
// export class FinishedStanza extends Data {
//   static data = {
//     text: Types.Ref(""),
//     stanza: Types.Ref(0),
//     token: Types.Ref(""),
//   };
// }


exports.CollectedToken = CollectedToken;

class FinishedPoem extends _alec.Data {
  static data = {
    tokens: Types.Array([]),
    lines: Types.Array([])
  };
}

exports.FinishedPoem = FinishedPoem;

class HaikuAddingToInventory extends _alec.Data {
  static data = {
    time: Types.Ref(0),
    delay: Types.Ref(0.25)
  };
}

exports.HaikuAddingToInventory = HaikuAddingToInventory;

class HaikuInInventory extends _alec.Tag {}

exports.HaikuInInventory = HaikuInInventory;

class WaitingForTokenPaper extends _alec.Tag {} // export class FinishedPoemHasElemental extends Tag {}
// export class Portal extends Data {
//   static data = {
//     visited: Types.Ref(false),
//     position: Types.Vector3(),
//     textEntity: Types.Ref(null),
//     tween: Types.Ref(1),
//     symbol: Types.Ref(null),
//     showing: Types.Ref(false),
//     opening: Types.Ref(null),
//     index: Types.Ref(0),
//     open: Types.Ref(false),
//     discovered: Types.Ref(false), // if you've captured it
//     active: Types.Ref(false), // if you are currently in that biome
//   };
// }
// export class PortalLine extends Data {
//   static data = {
//     line: Types.Ref(null),
//     from: Types.Ref(null),
//     to: Types.Ref(null),
//   };
// }


exports.WaitingForTokenPaper = WaitingForTokenPaper;

class ActiveWorldIndex extends _alec.Value {
  static value = Types.Ref(0);
}

exports.ActiveWorldIndex = ActiveWorldIndex;

class WorldTweens extends _alec.Value {
  static value = Types.Array([]);
}

exports.WorldTweens = WorldTweens;

class WorldDecayTweens extends _alec.Value {
  static value = Types.Array([]);
}

exports.WorldDecayTweens = WorldDecayTweens;

class WaitingToVisitFinalPortal extends _alec.Tag {}

exports.WaitingToVisitFinalPortal = WaitingToVisitFinalPortal;

class HasVisitedFinalPortal extends _alec.Tag {}

exports.HasVisitedFinalPortal = HasVisitedFinalPortal;

class SolvingDecayArea extends _alec.Data {
  static data = {
    index: Types.Ref(0),
    tween: Types.Ref(0)
  };
}

exports.SolvingDecayArea = SolvingDecayArea;

class AudioMeta extends _alec.Data {
  static data = {
    names: Types.Array([]),
    paths: Types.Array([])
  };
}

exports.AudioMeta = AudioMeta;

class GroundFogRenderTarget extends _alec.Data {
  static data = {
    projection: Types.Ref(null),
    target: Types.Ref(null)
  };
}

exports.GroundFogRenderTarget = GroundFogRenderTarget;

class GroundDataRenderTarget extends _alec.Data {
  static data = {
    projection: Types.Ref(null),
    view: Types.Ref(null),
    target: Types.Ref(null)
  };
}

exports.GroundDataRenderTarget = GroundDataRenderTarget;

class UserFirstVisitedWorldIndex extends _alec.Value {
  static value = Types.Ref(0);
}

exports.UserFirstVisitedWorldIndex = UserFirstVisitedWorldIndex;

class DebugRenderTarget extends _alec.Data {
  static data = {
    visible: Types.Ref(true),
    target: Types.Ref(null)
  };
}

exports.DebugRenderTarget = DebugRenderTarget;

class GroundDataParticle extends _alec.Data {
  static value = Types.Ref(null);
}

exports.GroundDataParticle = GroundDataParticle;

class BlockUserWrite extends _alec.Tag {}

exports.BlockUserWrite = BlockUserWrite;

class WaitingForUserWrite extends _alec.Tag {}

exports.WaitingForUserWrite = WaitingForUserWrite;

class ShowUserWriteHint extends _alec.Tag {}

exports.ShowUserWriteHint = ShowUserWriteHint;

class ShowUserCollectHint extends _alec.Tag {}

exports.ShowUserCollectHint = ShowUserCollectHint;

class ShowUserTokenInventory extends _alec.Tag {} // export class HintSpaceBar extends Tag {}


exports.ShowUserTokenInventory = ShowUserTokenInventory;

class UserHitAudioTrigger extends _alec.Data {
  static data = {
    type: Types.Ref("")
  };
}

exports.UserHitAudioTrigger = UserHitAudioTrigger;

class WillTriggerAudio extends _alec.Tag {}

exports.WillTriggerAudio = WillTriggerAudio;

class GroundAsset extends _alec.Data {
  static data = {
    x: Types.Ref(0),
    z: Types.Ref(0),
    cellEntity: Types.Ref(null)
  };
}

exports.GroundAsset = GroundAsset;

class GroundAssetData extends _alec.Data {
  static data = {
    instance: Types.Ref(null),
    key: Types.Ref(""),
    audio: Types.Ref(false),
    type: Types.Ref("sprite"),
    useMapDiscard: Types.Ref(false),
    ignoreFlip: Types.Ref(false),
    // height: Types.Ref(null),
    rotation: Types.Ref(0),
    // varianceMean: Types.Ref(null),
    // varianceStd: Types.Ref(null),
    // minSize: Types.Ref(null),
    // maxSize: Types.Ref(null),
    flip: Types.Ref(false),
    scale: Types.Vector3(1, 1, 1),
    sizeFactor: Types.Ref(1),
    variance: Types.Ref(0)
  };
}

exports.GroundAssetData = GroundAssetData;

class MainCameraFrustum extends _alec.Value {}

exports.MainCameraFrustum = MainCameraFrustum;

class GroundAssetInsideFrustum extends _alec.Data {}

exports.GroundAssetInsideFrustum = GroundAssetInsideFrustum;

class GroundAsset3DAsync extends _alec.Data {
  static data = {
    url: Types.Ref("")
  };
}

exports.GroundAsset3DAsync = GroundAsset3DAsync;

class PostProcessEnabled extends _alec.Value {
  static value = Types.Ref(true);
}

exports.PostProcessEnabled = PostProcessEnabled;

class Atmospherics extends _alec.Data {
  static data = {
    camera: Types.Ref(null),
    scene: Types.Ref(null)
  };
}

exports.Atmospherics = Atmospherics;

class GroundMeshEditableData extends _alec.Data {
  static data = {
    uvRepeatScale: Types.Ref(1),
    overrideMap: Types.Ref(null),
    overrideColor: Types.Ref("#ffffff"),
    useOverrideMap: Types.Ref(false),
    useOverrideColor: Types.Ref(false),
    useOverrideWater: Types.Ref(false),
    overrideWater: Types.Ref(null),
    useOverrideWaterColor: Types.Ref(false),
    overrideWaterColorA: Types.Ref("#0000ff"),
    overrideWaterColorB: Types.Ref("#0000ff"),
    useCustomLUT: Types.Ref(false),
    lutMap: Types.Ref(null)
  };
}

exports.GroundMeshEditableData = GroundMeshEditableData;

class GrassEditableData extends _alec.Data {
  static data = {
    useCustomGrass: Types.Ref(false),
    customGrassMap: Types.Ref(null),
    grassScale: Types.Ref(1)
  };
}

exports.GrassEditableData = GrassEditableData;

class RenderLayers extends _alec.Data {
  static data = {
    groundDepth: Types.Ref(4),
    ground: Types.Ref(5),
    water: Types.Ref(6),
    grass: Types.Ref(10),
    // elements: Types.Ref(12),
    shadow: Types.Ref(15),
    atmospherics: Types.Ref(25)
  };
} // export class RenderPass extends Data {
//   static data = {
//     ground: Types.Ref(null),
//   };
// }
// export class AddToRenderScene extends Value {
//   static value = Types.Ref(null);
// }


exports.RenderLayers = RenderLayers;

class ShadowCaster extends _alec.Data {
  static data = {
    sprite: Types.Ref(false)
  };
}

exports.ShadowCaster = ShadowCaster;

class BloomObject extends _alec.Data {
  static data = {
    color: Types.Color(1, 1, 1)
  };
}

exports.BloomObject = BloomObject;

class AssetCache extends _alec.Value {}

exports.AssetCache = AssetCache;

class GLTFRefAsset extends _alec.Data {
  static data = {
    position: Types.Array(),
    boundsMin: Types.Vector3(),
    boundsMax: Types.Vector3(),
    boundsSet: Types.Ref(false),
    name: Types.Ref(""),
    biome: Types.Ref(""),
    group: Types.Ref(null),
    promise: Types.Ref(null)
  };
}

exports.GLTFRefAsset = GLTFRefAsset;

class GLTFRefAssetLoaded extends _alec.Data {
  static data = {
    mesh: Types.Ref(null)
  };
}

exports.GLTFRefAssetLoaded = GLTFRefAssetLoaded;

class IsInFrustum extends _alec.Tag {}

exports.IsInFrustum = IsInFrustum;

class TestLoadRef extends _alec.Data {
  static data = {
    position: Types.Array(),
    name: Types.Ref("")
  };
}

exports.TestLoadRef = TestLoadRef;

class GameUIStore extends _alec.Value {}

exports.GameUIStore = GameUIStore;

class DirectUserToOrigin extends _alec.Tag {}

exports.DirectUserToOrigin = DirectUserToOrigin;

class WaitingForBiomeResolution extends _alec.Tag {}

exports.WaitingForBiomeResolution = WaitingForBiomeResolution;

class ShowBiomeResolution extends _alec.Tag {}

exports.ShowBiomeResolution = ShowBiomeResolution;

class FinalBiomeResolution extends _alec.Tag {}

exports.FinalBiomeResolution = FinalBiomeResolution;

class FinalBiomeResolutionLines extends _alec.Tag {}

exports.FinalBiomeResolutionLines = FinalBiomeResolutionLines;

class EndGameState extends _alec.Tag {}

exports.EndGameState = EndGameState;

class TransitionToNextBiome extends _alec.Tag {}

exports.TransitionToNextBiome = TransitionToNextBiome;

class SafeToSwapBiomes extends _alec.Tag {}

exports.SafeToSwapBiomes = SafeToSwapBiomes;

class BoxHelper extends _alec.Data {
  static data = {
    entity: Types.Ref(null),
    box: Types.Ref(null)
  };
}

exports.BoxHelper = BoxHelper;

class GroundAssetToken extends _alec.Data {
  static data = {
    type: Types.Ref("")
  };
}

exports.GroundAssetToken = GroundAssetToken;

class TokensDiscoveredSet extends _alec.Value {} // collecting a token makes a line drawn onto the world


exports.TokensDiscoveredSet = TokensDiscoveredSet;

class WrittenStanzaLine extends _alec.Data {
  static data = {
    started: Types.Ref(false),
    // only start writing once we move away from token
    elapsed: Types.Ref(0),
    startDelay: Types.Ref(0.33),
    text: Types.Ref(""),
    line: Types.Array([]),
    // array of Line3D data
    type: Types.Ref(""),
    // token type
    inputs: Types.Array([]),
    // array of text chunks
    fragments: Types.Array([]),
    // array of output word fragments
    originPosition2D: Types.Vector2(),
    // where line originated from (token pos)
    lastPosition2D: Types.Vector2(),
    // last user pos
    active: Types.Ref(false),
    // whether user is drawing this out
    initial: Types.Ref(true),
    // only true on first place
    distance: Types.Ref(0),
    // total distance of line so far
    changed: Types.Ref(false),
    // whether Line3D needs updating
    children: Types.Array([]) // array of child text entities

  };
}

exports.WrittenStanzaLine = WrittenStanzaLine;

class WrittenStanzaLineActive extends _alec.Tag {}

exports.WrittenStanzaLineActive = WrittenStanzaLineActive;

class StanzaLineSpawningAsset extends _alec.Data {
  static data = {
    x: Types.Ref(0),
    z: Types.Ref(0),
    biome: Types.Ref("")
  };
}

exports.StanzaLineSpawningAsset = StanzaLineSpawningAsset;

class SpawnedFlora extends _alec.Data {
  static data = {
    height: Types.Ref(1),
    time: Types.Ref(0),
    aspect: Types.Ref(1),
    spawnTime: Types.Ref(0),
    delay: Types.Ref(0),
    duration: Types.Ref(5),
    animateDuration: Types.Ref(0.75)
  };
}

exports.SpawnedFlora = SpawnedFlora;

class SpriteAnimation extends _alec.Data {
  static data = {
    key: Types.Ref(""),
    delay: Types.Ref(0),
    playing: Types.Ref(false),
    finished: Types.Ref(false),
    currentLoop: Types.Ref(0),
    looping: Types.Ref(false),
    // key: Types.Ref(""),
    elapsed: Types.Ref(0),
    // frames: Types.Array([]),
    frame: Types.Ref(0),
    sheet: Types.Ref(null),
    lastFrame: Types.Ref(null),
    dirty: Types.Ref(true),
    fixSpriteAspect: Types.Ref(true),
    speed: Types.Ref(1),
    loopStart: Types.Ref(null),
    loopEnd: Types.Ref(null),
    onLoopEnd: Types.Ref(null)
  };

  reset() {
    super.reset();
    this.playing = false;
    this.delay = 0;
    this.elapsed = 0;
    this.finished = false;
    this.frame = 0;
    this.dirty = true;
    this.lastFrame = null;
    this.currentLoop = 0;
    if (this.loopStart != null && this.looping) this.frame = this.loopStart;
  }

  start() {
    this.playing = true;
    this.elapsed = 0;
    this.frame = 0;
    this.finished = false;
    this.delay = 0;
    this.dirty = true;
    this.lastFrame = null;
    this.currentLoop = 0;
    if (this.loopStart != null && this.looping) this.frame = this.loopStart;
  }

}

exports.SpriteAnimation = SpriteAnimation;

class SpriteAnimationLazyLoadSheet extends _alec.Data {
  static data = {
    id: Types.Ref(""),
    playOnLoad: Types.Ref(true),
    fixSpriteAspectOnLoad: Types.Ref(true)
  };
} // Audio trigger tags


exports.SpriteAnimationLazyLoadSheet = SpriteAnimationLazyLoadSheet;

class JournalOpen extends _alec.Tag {}

exports.JournalOpen = JournalOpen;

class PauseOpen extends _alec.Tag {}

exports.PauseOpen = PauseOpen;

class ButtonHover extends _alec.Tag {}

exports.ButtonHover = ButtonHover;

class ButtonClick extends _alec.Tag {}

exports.ButtonClick = ButtonClick;

class GameStarted extends _alec.Tag {}

exports.GameStarted = GameStarted;

class SpriteAnimationOriginTreeTag extends _alec.Tag {}

exports.SpriteAnimationOriginTreeTag = SpriteAnimationOriginTreeTag;

class CameraFocusOnTarget extends _alec.Data {
  static data = {
    target: Types.Vector3()
  };
}

exports.CameraFocusOnTarget = CameraFocusOnTarget;

class GlowingHaikuCard extends _alec.Data {
  static data = {
    angle: Types.Ref(0),
    radius: Types.Ref(1),
    y: Types.Ref(0),
    speed: Types.Ref(1),
    driftPhase: Types.Ref(0),
    driftAmplitude: Types.Ref(1),
    driftFrequency: Types.Ref(1),
    time: Types.Ref(0),
    opacity: Types.Ref(1),
    rgbOpaque: Types.Color(),
    rgbTransparent: Types.Color()
  };
}

exports.GlowingHaikuCard = GlowingHaikuCard;

class FloatingToken extends _alec.Data {
  static data = {
    type: Types.Ref(""),
    map: Types.Ref(null),
    velocity2D: Types.Vector2(0, 0),
    position2D: Types.Vector2(0, 0),
    offset3D: Types.Vector3(0, 0, 0),
    offsetHeight: Types.Ref(2),
    offsetY: Types.Ref(0),
    animateToTreeTime: Types.Ref(0),
    animateToTreeDelay: Types.Ref(0),
    animateToTreeDuration: Types.Ref(2),
    rotationSpeed: Types.Ref(1),
    rotationAngleOffset: Types.Ref(1),
    rotationAxis: Types.Vector3(0, 0, 0),
    scale: Types.Ref(1),
    time: Types.Ref(0),
    started: Types.Ref(false),
    speed: Types.Ref(1)
  };
}

exports.FloatingToken = FloatingToken;

class FloatingTokenTargetUser extends _alec.Tag {}

exports.FloatingTokenTargetUser = FloatingTokenTargetUser;

class FloatingTokenShouldTargetTree extends _alec.Tag {}

exports.FloatingTokenShouldTargetTree = FloatingTokenShouldTargetTree;

class GLTFSpawnItemsMap extends _alec.Value {}

exports.GLTFSpawnItemsMap = GLTFSpawnItemsMap;

class UserCarryingTokenCollectionFeature extends _alec.Tag {}

exports.UserCarryingTokenCollectionFeature = UserCarryingTokenCollectionFeature;

class WaterFollowParticle extends _alec.Tag {}

exports.WaterFollowParticle = WaterFollowParticle;

class HatTipPoint extends _alec.Value {
  static value = Types.Vector3(0, 0, 0);
}

exports.HatTipPoint = HatTipPoint;

class HatTipWindLineTag extends _alec.Tag {}

exports.HatTipWindLineTag = HatTipWindLineTag;

class HatTipWindLineSound extends _alec.Value {
  static value = Types.Ref("");
}

exports.HatTipWindLineSound = HatTipWindLineSound;

class MoveUserToOrigin extends _alec.Tag {}

exports.MoveUserToOrigin = MoveUserToOrigin;

class OriginTreeIntroSequence extends _alec.Tag {}

exports.OriginTreeIntroSequence = OriginTreeIntroSequence;

class OriginTreeIntroSequenceStarted extends _alec.Tag {}

exports.OriginTreeIntroSequenceStarted = OriginTreeIntroSequenceStarted;

class GameLandingCameraDrift extends _alec.Data {
  static data = {
    fixed: Types.Ref(null)
  };
}

exports.GameLandingCameraDrift = GameLandingCameraDrift;

class CameraZoomOut extends _alec.Tag {}

exports.CameraZoomOut = CameraZoomOut;

class LetterboxBars extends _alec.Tag {}

exports.LetterboxBars = LetterboxBars;

class ScreenFade extends _alec.Data {
  static data = {
    from: Types.Ref(0),
    to: Types.Ref(1),
    duration: Types.Ref(1),
    delay: Types.Ref(0),
    ease: Types.Ref("sineIn"),
    callbackOnStart: Types.Ref(null),
    callbackOnFinish: Types.Ref(null)
  };
}

exports.ScreenFade = ScreenFade;

class TextHint extends _alec.Data {
  static data = {
    text: Types.Ref(""),
    delay: Types.Ref(0),
    position: Types.Vector3(0, 0, 0),
    fontSize: Types.Ref(32),
    time: Types.Ref(0),
    duration: Types.Ref(2),
    killing: Types.Ref(false)
  };
}

exports.TextHint = TextHint;

class KillTextHint extends _alec.Tag {}

exports.KillTextHint = KillTextHint;

class HaikuCardShown extends _alec.Tag {}

exports.HaikuCardShown = HaikuCardShown;

class HaikuCardSaved extends _alec.Tag {}

exports.HaikuCardSaved = HaikuCardSaved;

class BlockUserMove extends _alec.Tag {}

exports.BlockUserMove = BlockUserMove;

class HideCharacter extends _alec.Tag {}

exports.HideCharacter = HideCharacter;

class HideHUD extends _alec.Tag {}

exports.HideHUD = HideHUD;

class TutorialState extends _alec.Tag {}

exports.TutorialState = TutorialState;

class TutorialTextHint extends _alec.Tag {}

exports.TutorialTextHint = TutorialTextHint;

class TutorialBarrenGround extends _alec.Tag {}

exports.TutorialBarrenGround = TutorialBarrenGround;

class UserForceApplied extends _alec.Tag {}

exports.UserForceApplied = UserForceApplied;

class BlockTokenCollection extends _alec.Tag {}

exports.BlockTokenCollection = BlockTokenCollection;

class CanSetIntroTags extends _alec.Tag {}

exports.CanSetIntroTags = CanSetIntroTags;

class ObjectiveText extends _alec.Data {
  static data = {
    text: Types.Ref(""),
    delay: Types.Ref(0)
  };
}

exports.ObjectiveText = ObjectiveText;

class HintOrb extends _alec.Data {
  static data = {
    origin: Types.Vector3(),
    scale: Types.Ref(1),
    time: Types.Ref(0),
    triggered: Types.Ref(false),
    trigger: Types.Ref(null),
    scaleFactor: Types.Ref(1),
    line: Types.Ref(null)
  };
}

exports.HintOrb = HintOrb;

class WindLine extends _alec.Data {
  static data = {
    time: Types.Ref(0),
    animateDuration: Types.Ref(0.25),
    duration: Types.Ref(4)
  };
}

exports.WindLine = WindLine;

class RainDrop extends _alec.Data {
  static data = {
    splat: Types.Ref(false),
    time: Types.Ref(0),
    speed: Types.Ref(5),
    animateDuration: Types.Ref(0.25),
    splatterSpawnPosition: Types.Vector3(0, 0, 0)
  };
}

exports.RainDrop = RainDrop;

class RainDropSplatter extends _alec.Data {
  static data = {
    time: Types.Ref(0),
    animateDuration: Types.Ref(0.25),
    duration: Types.Ref(1)
  };
}

exports.RainDropSplatter = RainDropSplatter;

class Raining extends _alec.Tag {}

exports.Raining = Raining;

class LastWalkedLake extends _alec.Tag {}

exports.LastWalkedLake = LastWalkedLake;

class AnimalSpawn extends _alec.Data {
  static data = {
    biome: Types.Ref(""),
    animal: Types.Ref(""),
    position: Types.Vector3(0, 0, 0),
    lake: Types.Ref(false),
    // these are auto-killed after 1 second or so
    // assumes systems will spawn new entities
    time: Types.Ref(0),
    duration: Types.Ref(1)
  };
}

exports.AnimalSpawn = AnimalSpawn;

class Animal extends _alec.Tag {}

exports.Animal = Animal;

class AnimateInCharacter extends _alec.Tag {}

exports.AnimateInCharacter = AnimateInCharacter;

class AnimateOutCharacter extends _alec.Tag {}

exports.AnimateOutCharacter = AnimateOutCharacter;

class TokenForCompass extends _alec.Data {
  static data = {
    distanceSq: Types.Ref(0)
  };
}

exports.TokenForCompass = TokenForCompass;

class FloatingEndLine extends _alec.Data {
  static data = {
    time: Types.Ref(0),
    speed: Types.Ref(0.5),
    animateDuration: Types.Ref(0.25),
    duration: Types.Ref(1),
    delay: Types.Ref(0)
  };
}

exports.FloatingEndLine = FloatingEndLine;

class TutorialMessage extends _alec.Data {
  static data = {
    id: Types.Ref(""),
    iconMode: Types.Ref(false),
    token: Types.Ref(""),
    message: Types.Ref(""),
    duration: Types.Ref(4),
    time: Types.Ref(0),
    delay: Types.Ref(0)
  };
}

exports.TutorialMessage = TutorialMessage;

class GameFinished extends _alec.Tag {}

exports.GameFinished = GameFinished;

class FoxSpriteTag extends _alec.Tag {}

exports.FoxSpriteTag = FoxSpriteTag;

class FoxPurring extends _alec.Tag {}

exports.FoxPurring = FoxPurring;

class FoxHm extends _alec.Tag {}

exports.FoxHm = FoxHm;

class WaterFishPlaceholderTag extends _alec.Tag {}

exports.WaterFishPlaceholderTag = WaterFishPlaceholderTag;

class UserHasHit extends _alec.Tag {}

exports.UserHasHit = UserHasHit;

class CompassVisible extends _alec.Data {
  static data = {
    position: Types.Vector3(0, 0, 0)
  };
}

exports.CompassVisible = CompassVisible;

class Snowflake extends _alec.Data {
  static data = {
    position: Types.Vector3(0, 0, 0),
    velocity: Types.Vector3(0, 0, 0),
    size: Types.Ref(0.1),
    time: Types.Ref(0),
    duration: Types.Ref(5),
    animateDuration: Types.Ref(0.2),
    delay: Types.Ref(0)
  };
}

exports.Snowflake = Snowflake;

class ResetToCameraDrift extends _alec.Tag {}

exports.ResetToCameraDrift = ResetToCameraDrift;

class TokenIsCollecting extends _alec.Tag {}

exports.TokenIsCollecting = TokenIsCollecting;

class TriggerTokenLine extends _alec.Tag {}

exports.TriggerTokenLine = TriggerTokenLine;

class TokenChildren extends _alec.Data {
  static data = {
    complete: Types.Ref(false),
    line: Types.Ref(null),
    radius: Types.Ref(null),
    center: Types.Ref(null),
    markers: Types.Array([]),
    group: Types.Ref(null),
    removing: Types.Ref(false),
    removeTime: Types.Ref(0),
    removeDelay: Types.Ref(1),
    killing: Types.Ref(false),
    stanza: Types.Ref(null),
    type: Types.Ref(""),
    shadow: Types.Ref(null),
    x: Types.Ref(0),
    z: Types.Ref(0),
    stanzaIndex: Types.Ref(0)
  };
}

exports.TokenChildren = TokenChildren;

class CollectTokenOrb extends _alec.Tag {}

exports.CollectTokenOrb = CollectTokenOrb;

class GIFRecord extends _alec.Data {
  static data = {
    encoder: Types.Ref(null),
    frame: Types.Ref(0),
    started: Types.Ref(false),
    duration: Types.Ref(5),
    width: Types.Ref(512),
    height: Types.Ref(512),
    maxColors: Types.Ref(256),
    format: Types.Ref("rgb565")
  };
}

exports.GIFRecord = GIFRecord;

class ClearInputPress extends _alec.Tag {}

exports.ClearInputPress = ClearInputPress;

class AnimalSound extends _alec.Value {
  static value = Types.Ref("");
}

exports.AnimalSound = AnimalSound;

class FlashSound extends _alec.Value {
  static value = Types.Ref("");
}

exports.FlashSound = FlashSound;

class CapeMagicalEffect extends _alec.Tag {}

exports.CapeMagicalEffect = CapeMagicalEffect;

class AutoRemoveCapeMagicalEffect extends _alec.Data {
  static data = {
    elapsed: Types.Ref(0),
    delay: Types.Ref(2)
  };
}

exports.AutoRemoveCapeMagicalEffect = AutoRemoveCapeMagicalEffect;

class ParticleEmit extends _alec.Data {
  static data = {
    position: Types.Vector3(0, 0, 0),
    elapsed: Types.Ref(0),
    duration: Types.Ref(1)
  };
}

exports.ParticleEmit = ParticleEmit;

class MusicalOrb extends _alec.Data {
  static data = {
    elapsed: Types.Ref(0),
    duration: Types.Ref(4),
    killing: Types.Ref(false),
    hit: Types.Ref(false)
  };
}

exports.MusicalOrb = MusicalOrb;

class OutroFinished extends _alec.Tag {}

exports.OutroFinished = OutroFinished;

class TriggerTreeTransitionAudio extends _alec.Tag {}

exports.TriggerTreeTransitionAudio = TriggerTreeTransitionAudio;
},{"three":"src/vendor/three.module.js","../alec-svelte":"src/alec-svelte/index.js","../alec":"src/alec/index.js"}],"src/tags/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _tags = require("./tags");

Object.keys(_tags).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _tags[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _tags[key];
    }
  });
});
},{"./tags":"src/tags/tags.js"}],"node_modules/strict-uri-encode/index.js":[function(require,module,exports) {
'use strict';

module.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
},{}],"node_modules/decode-uri-component/index.js":[function(require,module,exports) {
'use strict';

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp(token, 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');

function decodeComponents(components, split) {
  try {
    // Try to decode the entire string first
    return decodeURIComponent(components.join(''));
  } catch (err) {// Do nothing
  }

  if (components.length === 1) {
    return components;
  }

  split = split || 1; // Split the array in 2 parts

  var left = components.slice(0, split);
  var right = components.slice(split);
  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode(input) {
  try {
    return decodeURIComponent(input);
  } catch (err) {
    var tokens = input.match(singleMatcher);

    for (var i = 1; i < tokens.length; i++) {
      input = decodeComponents(tokens, i).join('');
      tokens = input.match(singleMatcher);
    }

    return input;
  }
}

function customDecodeURIComponent(input) {
  // Keep track of all the replacements and prefill the map with the `BOM`
  var replaceMap = {
    '%FE%FF': '\uFFFD\uFFFD',
    '%FF%FE': '\uFFFD\uFFFD'
  };
  var match = multiMatcher.exec(input);

  while (match) {
    try {
      // Decode as big chunks as possible
      replaceMap[match[0]] = decodeURIComponent(match[0]);
    } catch (err) {
      var result = decode(match[0]);

      if (result !== match[0]) {
        replaceMap[match[0]] = result;
      }
    }

    match = multiMatcher.exec(input);
  } // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else


  replaceMap['%C2'] = '\uFFFD';
  var entries = Object.keys(replaceMap);

  for (var i = 0; i < entries.length; i++) {
    // Replace all decoded components
    var key = entries[i];
    input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
  }

  return input;
}

module.exports = function (encodedURI) {
  if (typeof encodedURI !== 'string') {
    throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
  }

  try {
    encodedURI = encodedURI.replace(/\+/g, ' '); // Try the built in decoder first

    return decodeURIComponent(encodedURI);
  } catch (err) {
    // Fallback to a more advanced decoder
    return customDecodeURIComponent(encodedURI);
  }
};
},{}],"node_modules/split-on-first/index.js":[function(require,module,exports) {
'use strict';

module.exports = (string, separator) => {
  if (!(typeof string === 'string' && typeof separator === 'string')) {
    throw new TypeError('Expected the arguments to be of type `string`');
  }

  if (separator === '') {
    return [string];
  }

  const separatorIndex = string.indexOf(separator);

  if (separatorIndex === -1) {
    return [string];
  }

  return [string.slice(0, separatorIndex), string.slice(separatorIndex + separator.length)];
};
},{}],"node_modules/filter-obj/index.js":[function(require,module,exports) {
'use strict';

module.exports = function (obj, predicate) {
  var ret = {};
  var keys = Object.keys(obj);
  var isArr = Array.isArray(predicate);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var val = obj[key];

    if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
      ret[key] = val;
    }
  }

  return ret;
};
},{}],"node_modules/query-string/index.js":[function(require,module,exports) {
'use strict';

const strictUriEncode = require('strict-uri-encode');

const decodeComponent = require('decode-uri-component');

const splitOnFirst = require('split-on-first');

const filterObject = require('filter-obj');

const isNullOrUndefined = value => value === null || value === undefined;

const encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');

function encoderForArrayFormat(options) {
  switch (options.arrayFormat) {
    case 'index':
      return key => (result, value) => {
        const index = result.length;

        if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
          return result;
        }

        if (value === null) {
          return [...result, [encode(key, options), '[', index, ']'].join('')];
        }

        return [...result, [encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')];
      };

    case 'bracket':
      return key => (result, value) => {
        if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
          return result;
        }

        if (value === null) {
          return [...result, [encode(key, options), '[]'].join('')];
        }

        return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
      };

    case 'comma':
    case 'separator':
    case 'bracket-separator':
      {
        const keyValueSep = options.arrayFormat === 'bracket-separator' ? '[]=' : '=';
        return key => (result, value) => {
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          } // Translate null to an empty string so that it doesn't serialize as 'null'


          value = value === null ? '' : value;

          if (result.length === 0) {
            return [[encode(key, options), keyValueSep, encode(value, options)].join('')];
          }

          return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
        };
      }

    default:
      return key => (result, value) => {
        if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
          return result;
        }

        if (value === null) {
          return [...result, encode(key, options)];
        }

        return [...result, [encode(key, options), '=', encode(value, options)].join('')];
      };
  }
}

function parserForArrayFormat(options) {
  let result;

  switch (options.arrayFormat) {
    case 'index':
      return (key, value, accumulator) => {
        result = /\[(\d*)\]$/.exec(key);
        key = key.replace(/\[\d*\]$/, '');

        if (!result) {
          accumulator[key] = value;
          return;
        }

        if (accumulator[key] === undefined) {
          accumulator[key] = {};
        }

        accumulator[key][result[1]] = value;
      };

    case 'bracket':
      return (key, value, accumulator) => {
        result = /(\[\])$/.exec(key);
        key = key.replace(/\[\]$/, '');

        if (!result) {
          accumulator[key] = value;
          return;
        }

        if (accumulator[key] === undefined) {
          accumulator[key] = [value];
          return;
        }

        accumulator[key] = [].concat(accumulator[key], value);
      };

    case 'comma':
    case 'separator':
      return (key, value, accumulator) => {
        const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
        const isEncodedArray = typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
        value = isEncodedArray ? decode(value, options) : value;
        const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
        accumulator[key] = newValue;
      };

    case 'bracket-separator':
      return (key, value, accumulator) => {
        const isArray = /(\[\])$/.test(key);
        key = key.replace(/\[\]$/, '');

        if (!isArray) {
          accumulator[key] = value ? decode(value, options) : value;
          return;
        }

        const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map(item => decode(item, options));

        if (accumulator[key] === undefined) {
          accumulator[key] = arrayValue;
          return;
        }

        accumulator[key] = [].concat(accumulator[key], arrayValue);
      };

    default:
      return (key, value, accumulator) => {
        if (accumulator[key] === undefined) {
          accumulator[key] = value;
          return;
        }

        accumulator[key] = [].concat(accumulator[key], value);
      };
  }
}

function validateArrayFormatSeparator(value) {
  if (typeof value !== 'string' || value.length !== 1) {
    throw new TypeError('arrayFormatSeparator must be single character string');
  }
}

function encode(value, options) {
  if (options.encode) {
    return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
  }

  return value;
}

function decode(value, options) {
  if (options.decode) {
    return decodeComponent(value);
  }

  return value;
}

function keysSorter(input) {
  if (Array.isArray(input)) {
    return input.sort();
  }

  if (typeof input === 'object') {
    return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map(key => input[key]);
  }

  return input;
}

function removeHash(input) {
  const hashStart = input.indexOf('#');

  if (hashStart !== -1) {
    input = input.slice(0, hashStart);
  }

  return input;
}

function getHash(url) {
  let hash = '';
  const hashStart = url.indexOf('#');

  if (hashStart !== -1) {
    hash = url.slice(hashStart);
  }

  return hash;
}

function extract(input) {
  input = removeHash(input);
  const queryStart = input.indexOf('?');

  if (queryStart === -1) {
    return '';
  }

  return input.slice(queryStart + 1);
}

function parseValue(value, options) {
  if (options.parseNumbers && !Number.isNaN(Number(value)) && typeof value === 'string' && value.trim() !== '') {
    value = Number(value);
  } else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
    value = value.toLowerCase() === 'true';
  }

  return value;
}

function parse(query, options) {
  options = Object.assign({
    decode: true,
    sort: true,
    arrayFormat: 'none',
    arrayFormatSeparator: ',',
    parseNumbers: false,
    parseBooleans: false
  }, options);
  validateArrayFormatSeparator(options.arrayFormatSeparator);
  const formatter = parserForArrayFormat(options); // Create an object with no prototype

  const ret = Object.create(null);

  if (typeof query !== 'string') {
    return ret;
  }

  query = query.trim().replace(/^[?#&]/, '');

  if (!query) {
    return ret;
  }

  for (const param of query.split('&')) {
    if (param === '') {
      continue;
    }

    let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '='); // Missing `=` should be `null`:
    // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters

    value = value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options);
    formatter(decode(key, options), value, ret);
  }

  for (const key of Object.keys(ret)) {
    const value = ret[key];

    if (typeof value === 'object' && value !== null) {
      for (const k of Object.keys(value)) {
        value[k] = parseValue(value[k], options);
      }
    } else {
      ret[key] = parseValue(value, options);
    }
  }

  if (options.sort === false) {
    return ret;
  }

  return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
    const value = ret[key];

    if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
      // Sort object keys, not values
      result[key] = keysSorter(value);
    } else {
      result[key] = value;
    }

    return result;
  }, Object.create(null));
}

exports.extract = extract;
exports.parse = parse;

exports.stringify = (object, options) => {
  if (!object) {
    return '';
  }

  options = Object.assign({
    encode: true,
    strict: true,
    arrayFormat: 'none',
    arrayFormatSeparator: ','
  }, options);
  validateArrayFormatSeparator(options.arrayFormatSeparator);

  const shouldFilter = key => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === '';

  const formatter = encoderForArrayFormat(options);
  const objectCopy = {};

  for (const key of Object.keys(object)) {
    if (!shouldFilter(key)) {
      objectCopy[key] = object[key];
    }
  }

  const keys = Object.keys(objectCopy);

  if (options.sort !== false) {
    keys.sort(options.sort);
  }

  return keys.map(key => {
    const value = object[key];

    if (value === undefined) {
      return '';
    }

    if (value === null) {
      return encode(key, options);
    }

    if (Array.isArray(value)) {
      if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
        return encode(key, options) + '[]';
      }

      return value.reduce(formatter(key), []).join('&');
    }

    return encode(key, options) + '=' + encode(value, options);
  }).filter(x => x.length > 0).join('&');
};

exports.parseUrl = (url, options) => {
  options = Object.assign({
    decode: true
  }, options);
  const [url_, hash] = splitOnFirst(url, '#');
  return Object.assign({
    url: url_.split('?')[0] || '',
    query: parse(extract(url), options)
  }, options && options.parseFragmentIdentifier && hash ? {
    fragmentIdentifier: decode(hash, options)
  } : {});
};

exports.stringifyUrl = (object, options) => {
  options = Object.assign({
    encode: true,
    strict: true,
    [encodeFragmentIdentifier]: true
  }, options);
  const url = removeHash(object.url).split('?')[0] || '';
  const queryFromUrl = exports.extract(object.url);
  const parsedQueryFromUrl = exports.parse(queryFromUrl, {
    sort: false
  });
  const query = Object.assign(parsedQueryFromUrl, object.query);
  let queryString = exports.stringify(query, options);

  if (queryString) {
    queryString = `?${queryString}`;
  }

  let hash = getHash(object.url);

  if (object.fragmentIdentifier) {
    hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
  }

  return `${url}${queryString}${hash}`;
};

exports.pick = (input, filter, options) => {
  options = Object.assign({
    parseFragmentIdentifier: true,
    [encodeFragmentIdentifier]: false
  }, options);
  const {
    url,
    query,
    fragmentIdentifier
  } = exports.parseUrl(input, options);
  return exports.stringifyUrl({
    url,
    query: filterObject(query, filter),
    fragmentIdentifier
  }, options);
};

exports.exclude = (input, filter, options) => {
  const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);
  return exports.pick(input, exclusionFilter, options);
};
},{"strict-uri-encode":"node_modules/strict-uri-encode/index.js","decode-uri-component":"node_modules/decode-uri-component/index.js","split-on-first":"node_modules/split-on-first/index.js","filter-obj":"node_modules/filter-obj/index.js"}],"src/util/query-string.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseQuery = parseQuery;
exports.default = void 0;

var _queryString = _interopRequireDefault(require("query-string"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parseQuery() {
  if (typeof window === "undefined") return {};

  const parsed = _queryString.default.parse(window.location.search);

  Object.keys(parsed).forEach(key => {
    if (parsed[key] === null) parsed[key] = true;
    if (parsed[key] === "false") parsed[key] = false;
    if (parsed[key] === "true") parsed[key] = true;

    if (isNumber(parsed[key])) {
      parsed[key] = Number(parsed[key]);
    }
  });
  return parsed;
}

function isNumber(x) {
  if (typeof x === "number") return true;
  if (/^0x[0-9a-f]+$/i.test(x)) return true;
  return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}

var _default = parseQuery();

exports.default = _default;
},{"query-string":"node_modules/query-string/index.js"}],"src/config.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getConfig;
exports.hideLoader = hideLoader;
const IS_WEBGL2 = true;

function getConfig() {
  const sym = Symbol.for("wayfinder.config");
  let config;

  if (sym in window) {
    config = window[sym];
  } else {
    window[sym] = {};
    config = window[sym];
  }

  if (!config.context && !config.contextLoaded) {
    config.contextLoaded = true;
    config.context = getContext();
    config.context.canvas.style.display = "none";
  }

  config.haikusPerBiome = 2;
  return config;
}

function hideLoader() {
  // After we add those systems we can hide the loader as it will be replaced
  // by the svelte UI
  const loader = document.querySelector(".loader");
  if (loader) loader.style.display = "none";
}

function getContext() {
  const config = getConfig();
  const canvas = config.canvas || document.createElement("canvas");
  return findContext(canvas, IS_WEBGL2 ? "webgl2" : "webgl", {
    alpha: false,
    antialias: false,
    stencil: false,
    depth: true,
    powerPreference: "high-performance",
    failIfMajorPerformanceCaveat: true,
    // desynchronized: false,
    premultipliedAlpha: true,
    preserveDrawingBuffer: false
  });

  function findContext(canvas, type, opts) {
    const contextNames = [];
    if (type === "webgl2") contextNames.push("webgl2");
    contextNames.push("webgl", "experimental-webgl");
    let context;

    for (let i = 0; i < contextNames.length; i++) {
      try {
        context = canvas.getContext(contextNames[i], opts);
        if (context != null) return context;
      } catch (err) {// pass
      }
    }

    return null;
  }
}
},{}],"src/util/defined.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = defined;

function defined(a, b) {
  return typeof a === "undefined" ? b : a;
}
},{}],"src/util/prng-pcg.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRandomState = getRandomState;
exports.default = PCGR;

function getRandomState() {
  const state = new Uint16Array(4);

  for (let i = 0; i < state.length; i++) {
    state[i] = Math.random() * 0x10000;
  }

  return state;
}

function PCGR(initialState) {
  // Note that the index order [0, 1, 2, 3] is little-endian
  const eps = Math.pow(2, -32),
        m0 = 0x7f2d,
        m1 = 0x4c95,
        m2 = 0xf42d,
        m3 = 0x5851,
        // 6364136223846793005
  a0 = 0x814f,
        a1 = 0xf767,
        a2 = 0x7b7e,
        a3 = 0x1405; // 1442695040888963407

  let state = new Uint16Array(4);
  seed(initialState);
  return {
    seed,

    next() {
      // Advance internal state
      const s0 = state[0],
            s1 = state[1],
            s2 = state[2],
            s3 = state[3],
            new0 = a0 + m0 * s0 | 0,
            new1 = a1 + m0 * s1 + (m1 * s0 + (new0 >>> 16)) | 0,
            new2 = a2 + m0 * s2 + m1 * s1 + (m2 * s0 + (new1 >>> 16)) | 0,
            new3 = a3 + m0 * s3 + (m1 * s2 + m2 * s1) + (m3 * s0 + (new2 >>> 16));
      state[0] = new0, state[1] = new1, state[2] = new2;
      state[3] = new3; // Calculate output function (XSH RR), uses old state

      const xorshifted = (s3 << 21) + ((s3 >> 2 ^ s2) << 5) + ((s2 >> 2 ^ s1) >> 11),
            out_int32 = xorshifted >>> (s3 >> 11) | xorshifted << (-(s3 >> 11) & 31);
      return eps * (out_int32 >>> 0);
    }

  };

  function seed(newState) {
    if (!newState) {
      newState = getRandomState();
    }

    for (let i = 0; i < state.length; i++) {
      state[i] = newState[i];
    }
  }
}
},{}],"src/util/Random.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Random;

var _config = _interopRequireDefault(require("../config"));

var _defined = _interopRequireDefault(require("./defined"));

var _prngPcg = _interopRequireWildcard(require("./prng-pcg"));

var _queryString = _interopRequireDefault(require("./query-string"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import PRNG from "./prng-mersenne";
const embed = (0, _config.default)().embed; //[39783, 27946, 21768, 27541]
// 9103, 33041, 40850, 9357
// We can use a single fixed state to generate
// all the random numbers in the game.

const TRUE_RANDOM = !embed && !_queryString.default.deterministic;
const SEED_STATE = new Uint16Array(embed ? [39783, 27946, 21768, 27541] : [9697, 37140, 38490, 15272]);
console.log("Random Seed:", [...SEED_STATE]);
const SEED_PCG = (0, _prngPcg.default)(SEED_STATE);

function Random() {
  let seed = null; // console.log("GOT RANDOM", seed);

  if (seed == null) seed = Random.nextSeed();
  const prng = (0, _prngPcg.default)(seed);
  let _nextGaussian = null;
  let _hasNextGaussian = false;
  return {
    seed(v) {
      prng.seed(v);
      _nextGaussian = null;
      _hasNextGaussian = false;
    },

    value,
    valueNonZero: valueNonZero,
    sign: sign,
    boolean: boolean,
    chance: chance,
    range: range,
    rangeFloor: rangeFloor,
    pick: pick,
    shuffle: shuffle,
    onCircle: onCircle,
    insideCircle: insideCircle,
    onSphere: onSphere,
    insideSphere: insideSphere,
    quaternion: quaternion,
    weighted: weighted,
    weightedSet: weightedSet,
    weightedSetIndex: weightedSetIndex,
    deck,
    gaussian: gaussian
  };

  function value() {
    return prng.next();
  }

  function valueNonZero() {
    var u = 0;

    while (u === 0) u = value();

    return u;
  }

  function sign() {
    return boolean() ? 1 : -1;
  }

  function boolean() {
    return value() > 0.5;
  }

  function chance(n) {
    n = (0, _defined.default)(n, 0.5);
    if (typeof n !== "number") throw new TypeError("expected n to be a number");
    return value() < n;
  }

  function range(min, max) {
    if (max === undefined) {
      max = min;
      min = 0;
    }

    if (typeof min !== "number" || typeof max !== "number") {
      throw new TypeError("Expected all arguments to be numbers");
    }

    return value() * (max - min) + min;
  }

  function rangeFloor(min, max) {
    if (max === undefined) {
      max = min;
      min = 0;
    }

    if (typeof min !== "number" || typeof max !== "number") {
      throw new TypeError("Expected all arguments to be numbers");
    }

    return Math.floor(range(min, max));
  }

  function pick(array) {
    if (array.length === 0) return undefined;
    return array[rangeFloor(0, array.length)];
  }

  function shuffle(arr) {
    if (!Array.isArray(arr)) {
      throw new TypeError("Expected Array, got " + typeof arr);
    }

    var rand;
    var tmp;
    var len = arr.length;
    var ret = arr.slice();

    while (len) {
      rand = Math.floor(value() * len--);
      tmp = ret[len];
      ret[len] = ret[rand];
      ret[rand] = tmp;
    }

    return ret;
  }

  function onCircle(radius, out) {
    radius = (0, _defined.default)(radius, 1);
    out = out || [];
    var theta = value() * 2.0 * Math.PI;
    out[0] = radius * Math.cos(theta);
    out[1] = radius * Math.sin(theta);
    return out;
  }

  function insideCircle(radius, out) {
    radius = (0, _defined.default)(radius, 1);
    out = out || [];
    onCircle(1, out);
    var r = radius * Math.sqrt(value());
    out[0] *= r;
    out[1] *= r;
    return out;
  }

  function onSphere(radius, out) {
    radius = (0, _defined.default)(radius, 1);
    out = out || [];
    var u = value() * Math.PI * 2;
    var v = value() * 2 - 1;
    var phi = u;
    var theta = Math.acos(v);
    out[0] = radius * Math.sin(theta) * Math.cos(phi);
    out[1] = radius * Math.sin(theta) * Math.sin(phi);
    out[2] = radius * Math.cos(theta);
    return out;
  }

  function insideSphere(radius, out) {
    radius = (0, _defined.default)(radius, 1);
    out = out || [];
    var u = value() * Math.PI * 2;
    var v = value() * 2 - 1;
    var k = value();
    var phi = u;
    var theta = Math.acos(v);
    var r = radius * Math.cbrt(k);
    out[0] = r * Math.sin(theta) * Math.cos(phi);
    out[1] = r * Math.sin(theta) * Math.sin(phi);
    out[2] = r * Math.cos(theta);
    return out;
  }

  function quaternion(out) {
    out = out || [];
    var u1 = value();
    var u2 = value();
    var u3 = value();
    var sq1 = Math.sqrt(1 - u1);
    var sq2 = Math.sqrt(u1);
    var theta1 = Math.PI * 2 * u2;
    var theta2 = Math.PI * 2 * u3;
    var x = Math.sin(theta1) * sq1;
    var y = Math.cos(theta1) * sq1;
    var z = Math.sin(theta2) * sq2;
    var w = Math.cos(theta2) * sq2;
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
  }

  function weightedSet(set) {
    set = set || [];
    if (set.length === 0) return null;
    return set[weightedSetIndex(set)].value;
  }

  function weightedSetIndex(set) {
    set = set || [];
    if (set.length === 0) return -1;
    return weighted(set.map(function (s) {
      return s.weight;
    }));
  }

  function weighted(weights) {
    weights = weights || [];
    if (weights.length === 0) return -1;
    var totalWeight = 0;
    var i;

    for (i = 0; i < weights.length; i++) {
      totalWeight += weights[i];
    }

    if (totalWeight <= 0) throw new Error("Weights must sum to > 0");
    var random = value() * totalWeight;

    for (i = 0; i < weights.length; i++) {
      if (random < weights[i]) {
        return i;
      }

      random -= weights[i];
    }

    return 0;
  }

  function gaussian(mean, standardDerivation) {
    mean = (0, _defined.default)(mean, 0);
    standardDerivation = (0, _defined.default)(standardDerivation, 1); // https://github.com/openjdk-mirror/jdk7u-jdk/blob/f4d80957e89a19a29bb9f9807d2a28351ed7f7df/src/share/classes/java/util/Random.java#L496

    if (_hasNextGaussian) {
      _hasNextGaussian = false;
      var result = _nextGaussian;
      _nextGaussian = null;
      return mean + standardDerivation * result;
    } else {
      var v1 = 0;
      var v2 = 0;
      var s = 0;

      do {
        v1 = value() * 2 - 1; // between -1 and 1

        v2 = value() * 2 - 1; // between -1 and 1

        s = v1 * v1 + v2 * v2;
      } while (s >= 1 || s === 0);

      var multiplier = Math.sqrt(-2 * Math.log(s) / s);
      _nextGaussian = v2 * multiplier;
      _hasNextGaussian = true;
      return mean + standardDerivation * (v1 * multiplier);
    }
  }

  function deck(array) {
    array = shuffle(array);
    let index = 0;
    return {
      get array() {
        return array;
      },

      get index() {
        return index;
      },

      get current() {
        return array[index];
      },

      reset() {
        this.shuffle();
        index = 0;
      },

      next() {
        let cur = this.current;
        index++;

        if (index > array.length - 1) {
          this.shuffle();
          index = 0;
        }

        return cur;
      },

      nextIndex() {
        let cur = index;
        index++;

        if (index > array.length - 1) {
          this.shuffle();
          index = 0;
        }

        return cur;
      },

      shuffle() {
        array = shuffle(array);
      }

    };
  }
}

Random.nextSeed = function nextSeed(out = new Uint16Array(4)) {
  for (let i = 0; i < 4; i++) {
    out[i] = TRUE_RANDOM ? Math.random() * 0x10000 : SEED_PCG.next() * 0x10000;
  }

  return out;
};

Random.getRandomState = _prngPcg.getRandomState;
},{"../config":"src/config.js","./defined":"src/util/defined.js","./prng-pcg":"src/util/prng-pcg.js","./query-string":"src/util/query-string.js"}],"node_modules/defined/index.js":[function(require,module,exports) {
module.exports = function () {
    for (var i = 0; i < arguments.length; i++) {
        if (arguments[i] !== undefined) return arguments[i];
    }
};

},{}],"node_modules/canvas-sketch-util/lib/wrap.js":[function(require,module,exports) {
module.exports = wrap;
function wrap (value, from, to) {
  if (typeof from !== 'number' || typeof to !== 'number') {
    throw new TypeError('Must specify "to" and "from" arguments as numbers');
  }
  // algorithm from http://stackoverflow.com/a/5852628/599884
  if (from > to) {
    var t = from;
    from = to;
    to = t;
  }
  var cycle = to - from;
  if (cycle === 0) {
    return to;
  }
  return value - cycle * Math.floor((value - from) / cycle);
}

},{}],"node_modules/canvas-sketch-util/math.js":[function(require,module,exports) {
var defined = require('defined');
var wrap = require('./lib/wrap');
var EPSILON = Number.EPSILON;

function clamp (value, min, max) {
  return min < max
    ? (value < min ? min : value > max ? max : value)
    : (value < max ? max : value > min ? min : value);
}

function clamp01 (v) {
  return clamp(v, 0, 1);
}

function lerp (min, max, t) {
  return min * (1 - t) + max * t;
}

function inverseLerp (min, max, t) {
  if (Math.abs(min - max) < EPSILON) return 0;
  else return (t - min) / (max - min);
}

function smoothstep (min, max, t) {
  var x = clamp(inverseLerp(min, max, t), 0, 1);
  return x * x * (3 - 2 * x);
}

function toFinite (n, defaultValue) {
  defaultValue = defined(defaultValue, 0);
  return typeof n === 'number' && isFinite(n) ? n : defaultValue;
}

function expandVector (dims) {
  if (typeof dims !== 'number') throw new TypeError('Expected dims argument');
  return function (p, defaultValue) {
    defaultValue = defined(defaultValue, 0);
    var scalar;
    if (p == null) {
      // No vector, create a default one
      scalar = defaultValue;
    } else if (typeof p === 'number' && isFinite(p)) {
      // Expand single channel to multiple vector
      scalar = p;
    }

    var out = [];
    var i;
    if (scalar == null) {
      for (i = 0; i < dims; i++) {
        out[i] = toFinite(p[i], defaultValue);
      }
    } else {
      for (i = 0; i < dims; i++) {
        out[i] = scalar;
      }
    }
    return out;
  };
}

function lerpArray (min, max, t, out) {
  out = out || [];
  if (min.length !== max.length) {
    throw new TypeError('min and max array are expected to have the same length');
  }
  for (var i = 0; i < min.length; i++) {
    out[i] = lerp(min[i], max[i], t);
  }
  return out;
}

function newArray (n, initialValue) {
  n = defined(n, 0);
  if (typeof n !== 'number') throw new TypeError('Expected n argument to be a number');
  var out = [];
  for (var i = 0; i < n; i++) out.push(initialValue);
  return out;
}

function linspace (n, opts) {
  n = defined(n, 0);
  if (typeof n !== 'number') throw new TypeError('Expected n argument to be a number');
  opts = opts || {};
  if (typeof opts === 'boolean') {
    opts = { endpoint: true };
  }
  var offset = defined(opts.offset, 0);
  if (opts.endpoint) {
    return newArray(n).map(function (_, i) {
      return n <= 1 ? 0 : ((i + offset) / (n - 1));
    });
  } else {
    return newArray(n).map(function (_, i) {
      return (i + offset) / n;
    });
  }
}

function lerpFrames (values, t, out) {
  t = clamp(t, 0, 1);

  var len = values.length - 1;
  var whole = t * len;
  var frame = Math.floor(whole);
  var fract = whole - frame;

  var nextFrame = Math.min(frame + 1, len);
  var a = values[frame % values.length];
  var b = values[nextFrame % values.length];
  if (typeof a === 'number' && typeof b === 'number') {
    return lerp(a, b, fract);
  } else if (Array.isArray(a) && Array.isArray(b)) {
    return lerpArray(a, b, fract, out);
  } else {
    throw new TypeError('Mismatch in value type of two array elements: ' + frame + ' and ' + nextFrame);
  }
}

function mod (a, b) {
  return ((a % b) + b) % b;
}

function degToRad (n) {
  return n * Math.PI / 180;
}

function radToDeg (n) {
  return n * 180 / Math.PI;
}

function fract (n) {
  return n - Math.floor(n);
}

function sign (n) {
  if (n > 0) return 1;
  else if (n < 0) return -1;
  else return 0;
}

// Specific function from Unity / ofMath, not sure its needed?
// function lerpWrap (a, b, t, min, max) {
//   return wrap(a + wrap(b - a, min, max) * t, min, max)
// }

function pingPong (t, length) {
  t = mod(t, length * 2);
  return length - Math.abs(t - length);
}

function damp (a, b, lambda, dt) {
  return lerp(a, b, 1 - Math.exp(-lambda * dt));
}

function dampArray (a, b, lambda, dt, out) {
  out = out || [];
  for (var i = 0; i < a.length; i++) {
    out[i] = damp(a[i], b[i], lambda, dt);
  }
  return out;
}

function mapRange (value, inputMin, inputMax, outputMin, outputMax, clamp) {
  // Reference:
  // https://openframeworks.cc/documentation/math/ofMath/
  if (Math.abs(inputMin - inputMax) < EPSILON) {
    return outputMin;
  } else {
    var outVal = ((value - inputMin) / (inputMax - inputMin) * (outputMax - outputMin) + outputMin);
    if (clamp) {
      if (outputMax < outputMin) {
        if (outVal < outputMax) outVal = outputMax;
        else if (outVal > outputMin) outVal = outputMin;
      } else {
        if (outVal > outputMax) outVal = outputMax;
        else if (outVal < outputMin) outVal = outputMin;
      }
    }
    return outVal;
  }
}

module.exports = {
  mod: mod,
  fract: fract,
  sign: sign,
  degToRad: degToRad,
  radToDeg: radToDeg,
  wrap: wrap,
  pingPong: pingPong,
  linspace: linspace,
  lerp: lerp,
  lerpArray: lerpArray,
  inverseLerp: inverseLerp,
  lerpFrames: lerpFrames,
  clamp: clamp,
  clamp01: clamp01,
  smoothstep: smoothstep,
  damp: damp,
  dampArray: dampArray,
  mapRange: mapRange,
  expand2D: expandVector(2),
  expand3D: expandVector(3),
  expand4D: expandVector(4)
};

},{"defined":"node_modules/defined/index.js","./lib/wrap":"node_modules/canvas-sketch-util/lib/wrap.js"}],"src/util/math.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  dampVector: true,
  sign: true,
  moveTowardVector: true,
  moveToward: true,
  repeat: true,
  deltaAngle: true,
  wrapAngle: true,
  lerpAngle: true,
  dampAngle: true,
  getDistSq2D: true,
  quaternionFromNormal: true,
  sphericalToCartesian: true,
  getScreenSpaceCameraUp: true,
  getScreenSpaceCameraRight: true,
  addScreenSpaceUV: true,
  map: true
};
exports.dampVector = dampVector;
exports.sign = sign;
exports.moveTowardVector = moveTowardVector;
exports.moveToward = moveToward;
exports.repeat = repeat;
exports.deltaAngle = deltaAngle;
exports.wrapAngle = wrapAngle;
exports.lerpAngle = lerpAngle;
exports.dampAngle = dampAngle;
exports.getDistSq2D = getDistSq2D;
exports.quaternionFromNormal = quaternionFromNormal;
exports.sphericalToCartesian = sphericalToCartesian;
exports.getScreenSpaceCameraUp = getScreenSpaceCameraUp;
exports.getScreenSpaceCameraRight = getScreenSpaceCameraRight;
exports.addScreenSpaceUV = addScreenSpaceUV;
exports.map = map;

var _math = require("canvas-sketch-util/math");

Object.keys(_math).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _math[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _math[key];
    }
  });
});

var THREE = _interopRequireWildcard(require("three"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const tmpUp = new THREE.Vector3();
const tmpRight = new THREE.Vector3();
const axis = new THREE.Vector3();
const norm = new THREE.Vector3();

function dampVector(a, b, power, dt, output = a) {
  output.x = (0, _math.damp)(a.x, b.x, power, dt);
  output.y = (0, _math.damp)(a.y, b.y, power, dt);
  output.z = (0, _math.damp)(a.z, b.z, power, dt);
  return output;
}

function sign(f) {
  return f >= 0.0 ? 1 : -1;
}

function moveTowardVector(a, b, speed, dt, output = a) {
  norm.copy(b).sub(a);
  const dist = norm.length();
  if (dist !== 0) norm.divideScalar(dist);
  const maxDelta = speed * dt;
  if (dist <= maxDelta) return output.copy(b);
  output.addScaledVector(norm, maxDelta);
  return output; // output.x = moveToward(a.x, b.x, speed, dt);
  // output.y = moveToward(a.y, b.y, speed, dt);
  // output.z = moveToward(a.z, b.z, speed, dt);
  // return output;
}

function moveToward(current, target, speed, dt) {
  const maxDelta = speed * dt;
  if (Math.abs(target - current) <= maxDelta) return target;
  return current + sign(target - current) * maxDelta;
}

function repeat(t, length) {
  return t - Math.floor(t / length) * length;
}

function deltaAngle(current, target) {
  let num = repeat(target - current, Math.PI * 2);
  if (num > Math.PI) num -= Math.PI * 2;
  return num;
}

function wrapAngle(angle) {
  let n = repeat(angle, Math.PI * 2);
  if (n > Math.PI) n -= Math.PI * 2;
  return n;
}

function lerpAngle(a, b, t) {
  let delta = repeat(b - a, Math.PI * 2);
  if (delta > Math.PI) delta -= Math.PI * 2;
  return a + delta * (0, _math.clamp01)(t);
}

function dampAngle(a, b, lambda, dt) {
  const delta = deltaAngle(a, b);
  const t = 1 - Math.exp(-lambda * dt);
  return a + delta * t;
}

function getDistSq2D(a, b) {
  const dx = b.x - a.x;
  const dy = b.z - a.z;
  return dx * dx + dy * dy;
}

function quaternionFromNormal(normal, quaternion) {
  quaternion = quaternion || new THREE.Quaternion(); // vector is assumed to be normalized

  if (normal.y > 0.99999) {
    quaternion.set(0, 0, 0, 1);
  } else if (normal.y < -0.99999) {
    quaternion.set(1, 0, 0, 0);
  } else {
    axis.set(normal.z, 0, -normal.x).normalize();
    var radians = Math.acos(normal.y);
    quaternion.setFromAxisAngle(axis, radians);
  }

  return quaternion;
}

function sphericalToCartesian(latitude, longitude, out = new THREE.Vector3()) {
  //flips the Y axis
  latitude = Math.PI / 2 - latitude; //distribute to sphere

  out.set(Math.sin(latitude) * Math.sin(longitude), Math.cos(latitude), Math.sin(latitude) * Math.cos(longitude));
  return out;
}

function getScreenSpaceCameraUp(camera, vec = new THREE.Vector3()) {
  const upX = camera.matrixWorldInverse.elements[4];
  const upY = camera.matrixWorldInverse.elements[5];
  const upZ = camera.matrixWorldInverse.elements[6];
  vec.set(upX, upY, upZ);
  return vec;
}

function getScreenSpaceCameraRight(camera, vec = new THREE.Vector3()) {
  const rightX = camera.matrixWorldInverse.elements[0];
  const rightY = camera.matrixWorldInverse.elements[1];
  const rightZ = camera.matrixWorldInverse.elements[2];
  vec.set(rightX, rightY, rightZ);
  return vec;
}

function addScreenSpaceUV(camera, position, u, v) {
  const up = getScreenSpaceCameraUp(camera, tmpUp);
  const right = getScreenSpaceCameraRight(camera, tmpRight);
  position.addScaledVector(right, u);
  position.addScaledVector(up, v);
  return position;
}

function map(value, low1, high1, low2, high2) {
  return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
}
},{"canvas-sketch-util/math":"node_modules/canvas-sketch-util/math.js","three":"src/vendor/three.module.js"}],"node_modules/eases/back-in-out.js":[function(require,module,exports) {
function backInOut(t) {
  var s = 1.70158 * 1.525
  if ((t *= 2) < 1)
    return 0.5 * (t * t * ((s + 1) * t - s))
  return 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2)
}

module.exports = backInOut
},{}],"node_modules/eases/back-in.js":[function(require,module,exports) {
function backIn(t) {
  var s = 1.70158
  return t * t * ((s + 1) * t - s)
}

module.exports = backIn
},{}],"node_modules/eases/back-out.js":[function(require,module,exports) {
function backOut(t) {
  var s = 1.70158
  return --t * t * ((s + 1) * t + s) + 1
}

module.exports = backOut
},{}],"node_modules/eases/bounce-out.js":[function(require,module,exports) {
function bounceOut(t) {
  var a = 4.0 / 11.0
  var b = 8.0 / 11.0
  var c = 9.0 / 10.0

  var ca = 4356.0 / 361.0
  var cb = 35442.0 / 1805.0
  var cc = 16061.0 / 1805.0

  var t2 = t * t

  return t < a
    ? 7.5625 * t2
    : t < b
      ? 9.075 * t2 - 9.9 * t + 3.4
      : t < c
        ? ca * t2 - cb * t + cc
        : 10.8 * t * t - 20.52 * t + 10.72
}

module.exports = bounceOut
},{}],"node_modules/eases/bounce-in-out.js":[function(require,module,exports) {
var bounceOut = require('./bounce-out')

function bounceInOut(t) {
  return t < 0.5
    ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))
    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5
}

module.exports = bounceInOut
},{"./bounce-out":"node_modules/eases/bounce-out.js"}],"node_modules/eases/bounce-in.js":[function(require,module,exports) {
var bounceOut = require('./bounce-out')

function bounceIn(t) {
  return 1.0 - bounceOut(1.0 - t)
}

module.exports = bounceIn
},{"./bounce-out":"node_modules/eases/bounce-out.js"}],"node_modules/eases/circ-in-out.js":[function(require,module,exports) {
function circInOut(t) {
  if ((t *= 2) < 1) return -0.5 * (Math.sqrt(1 - t * t) - 1)
  return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
}

module.exports = circInOut
},{}],"node_modules/eases/circ-in.js":[function(require,module,exports) {
function circIn(t) {
  return 1.0 - Math.sqrt(1.0 - t * t)
}

module.exports = circIn
},{}],"node_modules/eases/circ-out.js":[function(require,module,exports) {
function circOut(t) {
  return Math.sqrt(1 - ( --t * t ))
}

module.exports = circOut
},{}],"node_modules/eases/cubic-in-out.js":[function(require,module,exports) {
function cubicInOut(t) {
  return t < 0.5
    ? 4.0 * t * t * t
    : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0
}

module.exports = cubicInOut
},{}],"node_modules/eases/cubic-in.js":[function(require,module,exports) {
function cubicIn(t) {
  return t * t * t
}

module.exports = cubicIn
},{}],"node_modules/eases/cubic-out.js":[function(require,module,exports) {
function cubicOut(t) {
  var f = t - 1.0
  return f * f * f + 1.0
}

module.exports = cubicOut
},{}],"node_modules/eases/elastic-in-out.js":[function(require,module,exports) {
function elasticInOut(t) {
  return t < 0.5
    ? 0.5 * Math.sin(+13.0 * Math.PI/2 * 2.0 * t) * Math.pow(2.0, 10.0 * (2.0 * t - 1.0))
    : 0.5 * Math.sin(-13.0 * Math.PI/2 * ((2.0 * t - 1.0) + 1.0)) * Math.pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0
}

module.exports = elasticInOut
},{}],"node_modules/eases/elastic-in.js":[function(require,module,exports) {
function elasticIn(t) {
  return Math.sin(13.0 * t * Math.PI/2) * Math.pow(2.0, 10.0 * (t - 1.0))
}

module.exports = elasticIn
},{}],"node_modules/eases/elastic-out.js":[function(require,module,exports) {
function elasticOut(t) {
  return Math.sin(-13.0 * (t + 1.0) * Math.PI/2) * Math.pow(2.0, -10.0 * t) + 1.0
}

module.exports = elasticOut
},{}],"node_modules/eases/expo-in-out.js":[function(require,module,exports) {
function expoInOut(t) {
  return (t === 0.0 || t === 1.0)
    ? t
    : t < 0.5
      ? +0.5 * Math.pow(2.0, (20.0 * t) - 10.0)
      : -0.5 * Math.pow(2.0, 10.0 - (t * 20.0)) + 1.0
}

module.exports = expoInOut
},{}],"node_modules/eases/expo-in.js":[function(require,module,exports) {
function expoIn(t) {
  return t === 0.0 ? t : Math.pow(2.0, 10.0 * (t - 1.0))
}

module.exports = expoIn
},{}],"node_modules/eases/expo-out.js":[function(require,module,exports) {
function expoOut(t) {
  return t === 1.0 ? t : 1.0 - Math.pow(2.0, -10.0 * t)
}

module.exports = expoOut
},{}],"node_modules/eases/linear.js":[function(require,module,exports) {
function linear(t) {
  return t
}

module.exports = linear
},{}],"node_modules/eases/quad-in-out.js":[function(require,module,exports) {
function quadInOut(t) {
    t /= 0.5
    if (t < 1) return 0.5*t*t
    t--
    return -0.5 * (t*(t-2) - 1)
}

module.exports = quadInOut
},{}],"node_modules/eases/quad-in.js":[function(require,module,exports) {
function quadIn(t) {
  return t * t
}

module.exports = quadIn
},{}],"node_modules/eases/quad-out.js":[function(require,module,exports) {
function quadOut(t) {
  return -t * (t - 2.0)
}

module.exports = quadOut
},{}],"node_modules/eases/quart-in-out.js":[function(require,module,exports) {
function quarticInOut(t) {
  return t < 0.5
    ? +8.0 * Math.pow(t, 4.0)
    : -8.0 * Math.pow(t - 1.0, 4.0) + 1.0
}

module.exports = quarticInOut
},{}],"node_modules/eases/quart-in.js":[function(require,module,exports) {
function quarticIn(t) {
  return Math.pow(t, 4.0)
}

module.exports = quarticIn
},{}],"node_modules/eases/quart-out.js":[function(require,module,exports) {
function quarticOut(t) {
  return Math.pow(t - 1.0, 3.0) * (1.0 - t) + 1.0
}

module.exports = quarticOut
},{}],"node_modules/eases/quint-in-out.js":[function(require,module,exports) {
function qinticInOut(t) {
    if ( ( t *= 2 ) < 1 ) return 0.5 * t * t * t * t * t
    return 0.5 * ( ( t -= 2 ) * t * t * t * t + 2 )
}

module.exports = qinticInOut
},{}],"node_modules/eases/quint-in.js":[function(require,module,exports) {
function qinticIn(t) {
  return t * t * t * t * t
}

module.exports = qinticIn
},{}],"node_modules/eases/quint-out.js":[function(require,module,exports) {
function qinticOut(t) {
  return --t * t * t * t * t + 1
}

module.exports = qinticOut
},{}],"node_modules/eases/sine-in-out.js":[function(require,module,exports) {
function sineInOut(t) {
  return -0.5 * (Math.cos(Math.PI*t) - 1)
}

module.exports = sineInOut
},{}],"node_modules/eases/sine-in.js":[function(require,module,exports) {
function sineIn (t) {
  var v = Math.cos(t * Math.PI * 0.5)
  if (Math.abs(v) < 1e-14) return 1
  else return 1 - v
}

module.exports = sineIn

},{}],"node_modules/eases/sine-out.js":[function(require,module,exports) {
function sineOut(t) {
  return Math.sin(t * Math.PI/2)
}

module.exports = sineOut
},{}],"node_modules/eases/index.js":[function(require,module,exports) {
module.exports = {
	'backInOut': require('./back-in-out'),
	'backIn': require('./back-in'),
	'backOut': require('./back-out'),
	'bounceInOut': require('./bounce-in-out'),
	'bounceIn': require('./bounce-in'),
	'bounceOut': require('./bounce-out'),
	'circInOut': require('./circ-in-out'),
	'circIn': require('./circ-in'),
	'circOut': require('./circ-out'),
	'cubicInOut': require('./cubic-in-out'),
	'cubicIn': require('./cubic-in'),
	'cubicOut': require('./cubic-out'),
	'elasticInOut': require('./elastic-in-out'),
	'elasticIn': require('./elastic-in'),
	'elasticOut': require('./elastic-out'),
	'expoInOut': require('./expo-in-out'),
	'expoIn': require('./expo-in'),
	'expoOut': require('./expo-out'),
	'linear': require('./linear'),
	'quadInOut': require('./quad-in-out'),
	'quadIn': require('./quad-in'),
	'quadOut': require('./quad-out'),
	'quartInOut': require('./quart-in-out'),
	'quartIn': require('./quart-in'),
	'quartOut': require('./quart-out'),
	'quintInOut': require('./quint-in-out'),
	'quintIn': require('./quint-in'),
	'quintOut': require('./quint-out'),
	'sineInOut': require('./sine-in-out'),
	'sineIn': require('./sine-in'),
	'sineOut': require('./sine-out')
}
},{"./back-in-out":"node_modules/eases/back-in-out.js","./back-in":"node_modules/eases/back-in.js","./back-out":"node_modules/eases/back-out.js","./bounce-in-out":"node_modules/eases/bounce-in-out.js","./bounce-in":"node_modules/eases/bounce-in.js","./bounce-out":"node_modules/eases/bounce-out.js","./circ-in-out":"node_modules/eases/circ-in-out.js","./circ-in":"node_modules/eases/circ-in.js","./circ-out":"node_modules/eases/circ-out.js","./cubic-in-out":"node_modules/eases/cubic-in-out.js","./cubic-in":"node_modules/eases/cubic-in.js","./cubic-out":"node_modules/eases/cubic-out.js","./elastic-in-out":"node_modules/eases/elastic-in-out.js","./elastic-in":"node_modules/eases/elastic-in.js","./elastic-out":"node_modules/eases/elastic-out.js","./expo-in-out":"node_modules/eases/expo-in-out.js","./expo-in":"node_modules/eases/expo-in.js","./expo-out":"node_modules/eases/expo-out.js","./linear":"node_modules/eases/linear.js","./quad-in-out":"node_modules/eases/quad-in-out.js","./quad-in":"node_modules/eases/quad-in.js","./quad-out":"node_modules/eases/quad-out.js","./quart-in-out":"node_modules/eases/quart-in-out.js","./quart-in":"node_modules/eases/quart-in.js","./quart-out":"node_modules/eases/quart-out.js","./quint-in-out":"node_modules/eases/quint-in-out.js","./quint-in":"node_modules/eases/quint-in.js","./quint-out":"node_modules/eases/quint-out.js","./sine-in-out":"node_modules/eases/sine-in-out.js","./sine-in":"node_modules/eases/sine-in.js","./sine-out":"node_modules/eases/sine-out.js"}],"src/systems/AnimationSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tweenTo = tweenTo;
exports.createTimerTween = createTimerTween;
exports.tweenFromTo = tweenFromTo;
exports.setEntityTweenFromTo = setEntityTweenFromTo;
exports.default = AnimationSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var eases = _interopRequireWildcard(require("eases"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function tweenTo(world, target, key, to, duration, ease, delay) {
  const e = world.entity();
  setEntityTweenFromTo(e, target, key, target[key], to, duration, ease, delay);
  e.get(Tags.TargetKeyTween).assignFromOnStart = true;
  return e;
}

function createTimerTween(world, duration, delay, onStart, onFinish) {
  const e = world.entity();
  setEntityTweenFromTo(e, null, null, 0, 1, duration, null, delay);
  return e;
}

function tweenFromTo(world, target, key, from, to, duration, ease, delay) {
  const e = world.entity();
  setEntityTweenFromTo(e, target, key, from, to, duration, ease, delay);
  return e;
}

function setEntityTweenFromTo(entity, target, key, from, to, duration, ease, delay) {
  entity.add(Tags.TargetKeyTween);
  const t = entity.get(Tags.TargetKeyTween);
  t.duration = duration != null ? duration : 1;
  t.ease = ease || "linear";
  t.target = target;
  t.key = key;
  t.from = from;
  t.to = to;
  t.delay = delay || 0;
  t.elapsed = 0;
  t.finished = false;
  t.active = true;
  t.started = false;
  t.killEntityOnFinish = true;
  t.assignFromOnStart = false;
}

function AnimationSystem(world) {
  const tweens = world.view(Tags.TargetKeyTween);
  const copyScalar = world.view([Tags.TargetKeyTween, Tags.TweenCopyTargetKeyToVectorScalar]); // const killables = world.view(Tags.KillEntityAfterTweens);
  // const copyVector = world.view([Tags.CopyTweenValueToVector, Tags.Tween]);

  return function animationSystem(dt) {
    const isModalStopping = Boolean(world.findTag(Tags.ModalStoppingUserMovement));
    tweens.forEach(e => {
      const d = e.get(Tags.TargetKeyTween);
      if (!d.active) return;
      if (d.pauseOnModal && isModalStopping) return;

      if (!d.finished) {
        if (d.elapsed >= d.delay) {
          let t = Math.min(1, Math.max(0, d.elapsed - d.delay) / d.duration);

          if (typeof d.ease === "string" && d.ease && d.ease in eases) {
            t = eases[d.ease](t);
          } else if (typeof d.ease === "function") {
            t = d.ease(t);
          }

          if (!d.started) {
            if (d.assignFromOnStart) {
              if (d.target) d.from = d.target[d.key];
            }

            d.started = true;

            if (d.callbackOnStart && typeof d.callbackOnStart === "function") {
              d.callbackOnStart(e);
            }
          }

          if (d.target) d.target[d.key] = MathUtil.lerp(d.from, d.to, t);
        }

        d.elapsed += dt;

        if (d.elapsed - d.delay > d.duration) {
          d.finished = true;
          if (d.target) d.target[d.key] = d.to;

          if (d.callbackOnFinish && typeof d.callbackOnFinish === "function") {
            d.callbackOnFinish(e);
          }
        }
      }

      if (d.finished && d.killEntityOnFinish) {
        e.kill();
      }
    });
    copyScalar.forEach(e => {
      const d = e.get(Tags.TargetKeyTween);
      if (!d.active) return;
      const vec = e.get(Tags.TweenCopyTargetKeyToVectorScalar);

      if (d.started && d.target && d.key) {
        const s = d.target[d.key];
        if (vec) vec.setScalar(s);
      }
    }); // killables.forEach((e) => {
    //   // find all tweens associated with this entity
    //   if (!hasActiveTweenMatching(e)) {
    //     console.log("killing entity");
    //     e.kill();
    //   }
    // });
  }; // function hasActiveTweenMatching(entity) {
  //   for (let i = 0; i < tweens.length; i++) {
  //     const e = tweens[i];
  //     if (!e.alive || !e.has(Tags.TargetKeyTween)) continue;
  //     const d = e.get(Tags.TargetKeyTween);
  //     if (!d.finished && ) return true;
  //   }
  //   return false;
  // }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/math":"src/util/math.js","eases":"node_modules/eases/index.js"}],"src/systems/SnowAtmosphereSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SnowAtmosphereSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _ObjectPool = _interopRequireDefault(require("../util/ObjectPool"));

var _AnimationSystem = require("./AnimationSystem");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function SnowAtmosphereSystem(world) {
  const dummyGeometry = new THREE.IcosahedronGeometry(1, 0);
  const pool = new _ObjectPool.default({
    maxCapacity: 50,
    initialCapacity: 50,

    create() {
      const mesh = new THREE.Mesh(dummyGeometry, new THREE.MeshBasicMaterial({
        name: "snow" // transparent: true,
        // opacity: 0.5,

      })); // mesh.matrixAutoUpdate = false;

      mesh.userData._entity = null;
      mesh.frustumCulled = false;
      mesh.visible = false;
      return mesh;
    },

    release(m) {}

  });
  let time = 0;
  let duration = 0.1;
  const random = (0, _Random.default)();
  const randomPos = new THREE.Vector3();
  const tmp2D = [0, 0];
  const userTarget = world.findTag(Tags.UserTarget);
  const flakes = world.view([Tags.Snowflake, Tags.Object3D]);
  const env = world.view([Tags.EnvironmentState, Tags.ActiveEnvironmentState]);
  let globalScaleTween = {
    value: 1
  };
  const finished = world.listen(Tags.FinalBiomeResolution);
  return function SnowAtmosphereSystemDT(dt) {
    const name = env.length ? env[0].get(Tags.EnvironmentState).name : null;
    if (name !== "tundra") return;

    if (finished.changed && finished.added.length > 0) {
      (0, _AnimationSystem.tweenTo)(world, globalScaleTween, "value", 0, 2, "sineOut");
    } else if (finished.changed && finished.removing.length > 0) {
      (0, _AnimationSystem.tweenTo)(world, globalScaleTween, "value", 1, 2, "sineOut");
    }

    time += dt;

    if (time >= duration) {
      time %= duration;
      randomPos.copy(userTarget.position);
      random.insideCircle(20, tmp2D);
      randomPos.x += tmp2D[0];
      randomPos.z += tmp2D[1];
      randomPos.y += random.range(4, 20);
      if (globalScaleTween.value > 0) spawn(randomPos);
    }

    flakes.forEach(e => {
      const snow = e.get(Tags.Snowflake);
      snow.velocity.x = Math.sin(snow.time * 2) * 0.5;
      snow.velocity.z = Math.sin(snow.time * 1) * 0.25;
      snow.position.addScaledVector(snow.velocity, dt * 1);
      const obj = e.get(Tags.Object3D);
      obj.visible = true;
      obj.position.copy(snow.position);
      snow.time += dt;
      const t = animate(snow.time, snow.duration, snow.animateDuration, snow.delay);
      const s = snow.size * t * globalScaleTween.value;
      obj.scale.setScalar(s);
      const a = 1;
      const bloom = 0.75;
      obj.material.color.setRGB(a + bloom, a + bloom, a + bloom);

      if (snow.time >= snow.duration || snow.position.y < 0) {
        pool.release(obj);
        obj.userData._entity = null;
        e.kill();
      }
    });
  };

  function spawn(position) {
    const m = pool.next();
    if (!m) return;
    m.userData._entity = world.entity().add(Tags.Snowflake).add(Tags.Object3D, m);

    const snow = m.userData._entity.get(Tags.Snowflake);

    m.scale.setScalar(0.05);
    snow.size = 0.05;
    snow.position.copy(position);
    snow.velocity.set(0, -1, 0);
    m.visible = false;
  }

  function animate(time, duration, animateDuration, ease = linear) {
    let anim = 0;

    if (time <= animateDuration) {
      anim = time / animateDuration;
    } else if (time >= duration - animateDuration) {
      const el = Math.max(0, time - (duration - animateDuration));
      const t = el / animateDuration;
      anim = 1 - t;
    } else {
      anim = 1;
    } // anim = ease(anim);


    return anim;
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/Random":"src/util/Random.js","../util/ObjectPool":"src/util/ObjectPool.js","./AnimationSystem":"src/systems/AnimationSystem.js"}],"src/assets/font/SilkaMono/silkamono-regularitalic-webfont.woff2":[function(require,module,exports) {
module.exports = "/silkamono-regularitalic-webfont.aa275850.woff2";
},{}],"src/util/ShaderManager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.push = push;
exports.initialize = initialize;

var THREE = _interopRequireWildcard(require("three"));

var _ObjectPool = _interopRequireDefault(require("./ObjectPool"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const materialsToBeInit = [];
const boxMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial());
boxMesh.name = "shader-manager-box";
const boxScene = new THREE.Scene();
const boxCamera = new THREE.OrthographicCamera(-1, 1, -1, 1, -10, 10);
const boxes = [];
const boxPool = new _ObjectPool.default({
  create() {
    const box = boxMesh.clone();
    boxScene.add(box); // box.userData.wasVisible = false;

    return box;
  },

  release(m) {
    if (m.parent) {
      m.parent.remove(m);
    }
  }

});

function create(opts) {
  const material = new THREE.ShaderMaterial(opts);
  materialsToBeInit.push(material);

  if (!opts.name) {
    console.error("Must specify name for ShaderMaterial");
  }

  return material;
}

function push(shader) {
  materialsToBeInit.push(shader);
}

function initialize(renderer, max = Infinity) {
  if (materialsToBeInit.length <= 0) return;
  const len = Math.min(max, materialsToBeInit.length);
  boxes.length = len;

  for (let i = 0; i < len; i++) {
    boxes[i] = boxPool.next();
    boxes[i].material = materialsToBeInit[i]; // boxes[i].material.needsUpdate = true;
    // boxes[i].material.version++;
  }

  renderer.render(boxScene, boxCamera);

  for (let i = 0; i < len; i++) {
    const box = boxes[i]; // box.material.needsUpdate = true;

    box.material = null;
    boxPool.release(box);
  }

  boxes.length = 0; // console.log("Init", len, "materials");

  materialsToBeInit.length = materialsToBeInit.length - len;
}
},{"three":"src/vendor/three.module.js","./ObjectPool":"src/util/ObjectPool.js"}],"src/util/createPlaneSprite.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createSprite;

var THREE = _interopRequireWildcard(require("three"));

var ShaderManager = _interopRequireWildcard(require("./ShaderManager"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let planeGeo;

function createSprite(opts = {}) {
  const {
    map = new THREE.Texture(),
    scale = 1,
    opacity = 1,
    color = "white"
  } = opts;
  let planeGeo = opts.geometry;

  if (!planeGeo) {
    planeGeo = new THREE.PlaneGeometry(1, 1, 1, 1);
    planeGeo.translate(0, 0.5, 0);
  }

  const isMultiply = opts.blending === THREE.MultiplyBlending;
  const rgba = opts.rgba;
  const isGroundMap = opts.groundMap != null && opts.groundProjectionMatrix != null;
  const matOpts = { ...opts
  };
  delete matOpts.geometry;
  delete matOpts.groundMap;
  delete matOpts.groundProjectionMatrix;
  delete matOpts.color;
  delete matOpts.rgba;
  delete matOpts.opacity;
  delete matOpts.map;
  delete matOpts.scale;
  const material = ShaderManager.create({
    name: "createPlaneSprite",
    // extensions: {
    //   derivatives: true,
    // },
    ...matOpts,
    defines: {
      IS_RGBA: rgba,
      IS_MULTIPLY: isMultiply,
      IS_GROUND_MAP: isGroundMap
    },
    fragmentShader:
    /* glsl */
    `
      varying vec2 vUv;
      uniform sampler2D map;
      uniform vec3 color;
      uniform float opacity;
      #ifdef IS_GROUND_MAP
      uniform sampler2D groundMap;
      varying vec3 vGroundColor;
      varying vec2 vGroundUv;
      varying float vGroundY;
      #endif
      void main () {
        vec4 tcol = texture2D(map, vUv);
        #if defined(IS_RGBA)
        gl_FragColor.rgba = tcol;
        gl_FragColor.rgb *= color;
        gl_FragColor.a *= opacity;
        #elif defined(IS_MULTIPLY)
        gl_FragColor.rgb = mix(vec3(1.0), tcol.rgb * color, tcol.a * opacity);
        gl_FragColor.a = 1.0;
        #else
        gl_FragColor.rgba = tcol;
        gl_FragColor.rgb *= color;
        gl_FragColor.a *= opacity;
        #endif
        #ifdef IS_GROUND_MAP
        // vec3 vGroundColor = texture2D(groundMap, vGroundUv).rgb;
        gl_FragColor.rgb = mix(vGroundColor, gl_FragColor.rgb, vGroundY);
        gl_FragColor.a = tcol.a * opacity;
        #endif

      }
    `,
    vertexShader:
    /* glsl */
    `
      #include <common>
      uniform float rotation;
      uniform vec2 repeat;
      uniform vec2 offset;
      uniform float globalScale;
      uniform float flip;
      uniform vec2 translate;
      varying vec3 vObjectCoord;
      varying vec2 vScreenScale;
      varying vec2 vUv;
      #ifdef IS_GROUND_MAP
      varying float vGroundY;
      uniform mat4 groundProjectionMatrix;
      uniform sampler2D groundMap;
      varying vec3 vGroundColor;
      varying vec2 vGroundUv;
      uniform float groundYDistance;
      #endif
      void main () {
        vUv = uv;
        vUv *= repeat;
        vUv += offset;
        
        vec3 centerWorldPos = (modelMatrix * vec4(vec3(0.0), 1.0)).xyz;
        vec3 camRightWorld = vec3(viewMatrix[0].x, viewMatrix[1].x, viewMatrix[2].x);
        vec3 camUpWorld = vec3(viewMatrix[0].y, viewMatrix[1].y, viewMatrix[2].y);

        vec2 scale;
        scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
        scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
        scale.x *= flip;
        scale *= globalScale;
        vScreenScale = scale.xy;

        vec3 vertexWorldPos = centerWorldPos
          + camRightWorld * position.x * scale.x
          + camUpWorld * position.y * scale.y;

        #ifdef IS_GROUND_MAP
          vec3 vertexCenterWorldPos = centerWorldPos;
          vec4 baseClipPos = groundProjectionMatrix * viewMatrix * vec4(vertexCenterWorldPos, 1.0);
          vGroundUv = baseClipPos.xy / baseClipPos.w * 0.5 + 0.5;
          vGroundColor = texture2D(groundMap, vGroundUv).rgb;
          vGroundY = vertexWorldPos.y / groundYDistance;
        #endif

        vertexWorldPos += camRightWorld * translate.x * scale.x;
        vertexWorldPos += camUpWorld * translate.y * scale.y;

        gl_Position = projectionMatrix * viewMatrix * vec4(vertexWorldPos, 1.0);
        vObjectCoord = vec3(position.xy, 0.0);
      }
    `,
    uniforms: {
      map: {
        value: map || new THREE.Texture()
      },
      groundMap: {
        value: opts.groundMap || new THREE.Texture()
      },
      groundProjectionMatrix: {
        value: opts.groundProjectionMatrix || new THREE.Matrix4()
      },
      groundYDistance: {
        value: 0.5
      },
      flip: {
        value: 1
      },
      globalScale: {
        value: scale
      },
      color: {
        value: new THREE.Color(color)
      },
      translate: {
        value: new THREE.Vector2(0, 0)
      },
      repeat: {
        value: new THREE.Vector2(1, 1)
      },
      offset: {
        value: new THREE.Vector2(0, 0)
      },
      opacity: {
        value: opacity
      }
    }
  });
  return new THREE.Mesh(planeGeo, material);
}
},{"three":"src/vendor/three.module.js","./ShaderManager":"src/util/ShaderManager.js"}],"src/util/three-util.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.detachObject = detachObject;
exports.addObject = addObject;
exports.removeFromObject = removeFromObject;
exports.clearGroup = clearGroup;
exports.copyTextureHandle = copyTextureHandle;
exports.pruneUserData = pruneUserData;
exports.disposeTree = disposeTree;
exports.setPointsToBufferPosition = setPointsToBufferPosition;
exports.shareAtlasTexture = shareAtlasTexture;
exports.fastCopyCameraData = fastCopyCameraData;
exports.cloneMaterial = cloneMaterial;

var THREE = _interopRequireWildcard(require("three"));

var _array = require("./array");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const _addedEvent = {
  type: "added"
};
const _removedEvent = {
  type: "removed"
};

function detachObject(object) {
  if (object.parent) {
    removeFromObject(object.parent, object);
  }
}

function addObject(object, child) {
  detachObject(child);
  child.parent = object;
  object.children.push(child);
  object.dispatchEvent(_addedEvent);
}

function removeFromObject(object, child) {
  const idx = object.children.indexOf(child);

  if (idx >= 0) {
    (0, _array.spliceOne)(object.children, idx);
    child.parent = null;
    child.dispatchEvent(_removedEvent);
  }
}

function clearGroup(g) {
  for (let i = 0; i < g.children.length; i++) {
    const child = g.children[i];
    child.parent = null;
    child.dispatchEvent(_removedEvent);
  }

  g.children.length = 0;
}

function copyTextureHandle(renderer, textureInstance, textureAtlas) {
  if (textureAtlas.image && !textureInstance.__hasFixedTexture) {
    const atlas = renderer.properties.get(textureAtlas);

    if (!atlas.__webglTexture) {
      console.warn("Re-uploading texture data");
      renderer.initTexture(textureAtlas);
    }

    const data = renderer.properties.get(textureInstance);
    Object.assign(data, atlas);
    textureInstance.__hasFixedTexture = true;
  }
}

function pruneUserData(obj) {
  const userData = obj.userData;
  Object.keys(userData).forEach(k => {
    if (k.startsWith("_")) {
      delete userData[k];
    } else if (k === "name" && userData.name === obj.name) {
      delete userData[k];
    }
  });
}

function disposeTree(obj, {
  textures = false
} = {}) {
  obj.traverse(t => {
    if (t.__hasDisposedAlready) return;

    if (typeof t.dispose === "function") {
      t.dispose();
      t.__hasDisposedAlready = true;
    }

    if (t.geometry && typeof t.geometry.dispose === "function" && !t.geometry.__hasDisposedAlready) {
      t.geometry.dispose();
      t.geometry.__hasDisposedAlready = true;
    }

    if (t.material && typeof t.material.dispose === "function" && !t.material.__hasDisposedAlready) {
      t.material.dispose();
      t.material.__hasDisposedAlready = true;
    }

    if (t.material && textures) {
      const m = t.material;
      Object.keys(m).forEach(key => {
        if (m[key] && m[key].isTexture) {
          m[key].dispose();
        }
      });

      if (m.uniforms) {
        Object.keys(m.uniforms).forEach(key => {
          if (m[key] && m[key].value && m[key].value.isTexture) {
            m[key].value.dispose();
          }
        });
      }
    }
  });
  clearGroup(obj);
}

function setPointsToBufferPosition(geometry, points) {
  const vertices = points.map(p => {
    if (Array.isArray(p)) return p;
    return p.toArray();
  }).flat();
  geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
}

function shareAtlasTexture(renderer, atlasTexture, spriteTexture) {
  if (atlasTexture.image && spriteTexture.__hasFixedTexture !== atlasTexture) {
    spriteTexture.__hasFixedTexture = atlasTexture; // console.log("Fixing WebGL Image");

    const atlas = renderer.properties.get(atlasTexture);

    if (!atlas.__webglTexture) {
      // console.warn("WARN: Re-uploading texture data for sprite atlas.");
      // console.log("[tex-upload]", atlasTexture.name || atlasTexture.image.src);
      renderer.initTexture(atlasTexture);
    }

    const data = renderer.properties.get(spriteTexture);
    Object.assign(data, atlas);
  }
}

function fastCopyCameraData(cameraSrc, cameraDst) {
  THREE.Camera.prototype.copy.call(cameraDst, cameraSrc);
  cameraDst.fov = cameraSrc.fov;
  cameraDst.zoom = cameraSrc.zoom;
  cameraDst.near = cameraSrc.near;
  cameraDst.far = cameraSrc.far;
  cameraDst.focus = cameraSrc.focus;
  cameraDst.aspect = cameraSrc.aspect;
  cameraDst.filmGauge = cameraSrc.filmGauge;
  cameraDst.filmOffset = cameraSrc.filmOffset;
}

function cloneMaterial(c) {
  const oldMat = c.material;
  c.material = oldMat.clone();
  c.material.uniforms = Object.assign({}, oldMat.uniforms);

  for (let p in oldMat.uniforms) {
    const oldV = oldMat.uniforms[p].value;

    if (oldV.isColor || oldV.isMatrix3 || oldV.isMatrix4 || oldV.isVector2 || oldV.isVector3 || oldV.isVector4) {
      c.material.uniforms[p] = Object.assign({}, c.material.uniforms[p], {
        value: oldV.clone()
      });
    } else if (Array.isArray(oldV)) {
      c.material.uniforms[p] = Object.assign({}, c.material.uniforms[p], {
        value: oldV.slice()
      });
    } else {
      c.material.uniforms[p] = Object.assign({}, c.material.uniforms[p], {
        value: oldV
      });
    }
  }
}
},{"three":"src/vendor/three.module.js","./array":"src/util/array.js"}],"node_modules/gl-vec4/transformMat4.js":[function(require,module,exports) {
module.exports = transformMat4

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
function transformMat4 (out, a, m) {
  var x = a[0], y = a[1], z = a[2], w = a[3]
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w
  return out
}

},{}],"node_modules/gl-vec4/set.js":[function(require,module,exports) {
module.exports = set

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
function set (out, x, y, z, w) {
  out[0] = x
  out[1] = y
  out[2] = z
  out[3] = w
  return out
}

},{}],"node_modules/camera-project/index.js":[function(require,module,exports) {
var transformMat4 = require('gl-vec4/transformMat4')
var set = require('gl-vec4/set')

var NEAR_RANGE = 0
var FAR_RANGE = 1
var tmp4 = [0, 0, 0, 0]

module.exports = cameraProject
function cameraProject (out, vec, viewport, combinedProjView) {
  var vX = viewport[0],
    vY = viewport[1],
    vWidth = viewport[2],
    vHeight = viewport[3],
    n = NEAR_RANGE,
    f = FAR_RANGE

  // convert: clip space -> NDC -> window coords
  // implicit 1.0 for w component
  set(tmp4, vec[0], vec[1], vec[2], 1.0)

  // transform into clip space
  transformMat4(tmp4, tmp4, combinedProjView)

  // now transform into NDC
  var w = tmp4[3]
  if (w !== 0) { // how to handle infinity here?
    tmp4[0] = tmp4[0] / w
    tmp4[1] = tmp4[1] / w
    tmp4[2] = tmp4[2] / w
  }

  // and finally into window coordinates
  // the foruth component is (1/clip.w)
  // which is the same as gl_FragCoord.w
  out[0] = vX + vWidth / 2 * tmp4[0] + (0 + vWidth / 2)
  out[1] = vY + vHeight / 2 * tmp4[1] + (0 + vHeight / 2)
  out[2] = (f - n) / 2 * tmp4[2] + (f + n) / 2
  out[3] = w === 0 ? 0 : 1 / w
  return out
}

},{"gl-vec4/transformMat4":"node_modules/gl-vec4/transformMat4.js","gl-vec4/set":"node_modules/gl-vec4/set.js"}],"src/util/addFrameTasks.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addFrameTask = addFrameTask;
exports.nextFrameTask = nextFrameTask;
exports.addPostRenderCallback = addPostRenderCallback;
exports.addPreRenderCallback = addPreRenderCallback;
exports.preRender = preRender;
exports.postRender = postRender;
const tasks = [];
const postRenderCallbacks = [];
const preRenderCallbacks = [];

function addFrameTask(cb) {
  tasks.push(cb);
}

function nextFrameTask() {
  if (!tasks.length) return null;
  return tasks.shift();
}

function addPostRenderCallback(cb) {
  postRenderCallbacks.push(cb);
}

function addPreRenderCallback(cb) {
  preRenderCallbacks.push(cb);
}

function preRender() {
  preRenderCallbacks.forEach(fn => fn());
}

function postRender() {
  postRenderCallbacks.forEach(fn => fn());
}
},{}],"src/overlays/Text3DOverlay.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var THREE = _interopRequireWildcard(require("three"));

var Tags = _interopRequireWildcard(require("../tags"));

var _svelte = require("svelte");

var _ObjectPool = _interopRequireDefault(require("../util/ObjectPool"));

var _cameraProject = _interopRequireDefault(require("camera-project"));

var _addFrameTasks = require("../util/addFrameTasks");

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _eases = _interopRequireDefault(require("eases"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* overlays/Text3DOverlay.svelte generated by Svelte v3.31.0 */
function create_fragment(ctx) {
  let div;
  return {
    c() {
      div = (0, _internal.element)("div");
      (0, _internal.attr)(div, "class", "container svelte-1bz0ho2");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      /*div_binding*/

      ctx[3](div);
    },

    p: _internal.noop,
    i: _internal.noop,
    o: _internal.noop,

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      /*div_binding*/

      ctx[3](null);
    }

  };
}

function buildChildTexts(container, text) {
  text.split("").forEach(letter => {
    const span = document.createElement("span");
    span.textContent = letter;
    container.appendChild(span);
  });
}

function clearChildren(node) {
  while (node.lastElementChild) {
    node.removeChild(node.lastElementChild);
  }
}

function instance($$self, $$props, $$invalidate) {
  let {
    world
  } = $$props;
  let {
    state
  } = $$props;
  const viewport = [0, 0, 0, 0];
  const upVector = new THREE.Vector3(0, 1, 0);
  const vec3 = new THREE.Vector3();
  const arr4D = [0, 0, 0, 0];
  const inArr3 = [0, 0, 0];

  class TextNode {
    constructor() {
      this.inner = document.createElement("div");
      this.inner.className = "text-sprite-3d";
      this.element = document.createElement("div");
      this.element.appendChild(this.inner);
      this.element.className = "text-sprite-3d-container";
      this.reset();
    }

    reset() {
      this._splitText = false;
      this._visible = false;
      this._text = "";
      this._x = null;
      this._y = null;
      this._scale = null;
      this._opacity = null;
      this._fontSize = null;
      this._fontStyle = null;
      this.element.style.opacity = "1";
      this.element.style.display = "none";
      this.setTransform(0, 0, 1);
      this.setOpacity(1);
      this.setFont(16, "normal");
    } // clearChildren(this.inner);


    setFont(size, style) {
      let oldSize = this._fontSize;
      let oldStyle = this._fontStyle;
      this._fontSize = size;
      this._fontStyle = style;

      if (oldStyle !== this._fontStyle) {
        this.element.style.fontStyle = this._fontStyle;
      }

      if (oldSize !== this._fontSize) {
        this.element.style.fontSize = `${this._fontSize}px`;
        this.element.style.top = `${-this._fontSize}px`;
      }
    }

    appendTo(parent) {
      if (this.element) parent.appendChild(this.element);
    }

    detach() {
      if (this.element && this.element.parentElement) {
        this.element.parentElement.removeChild(this.element);
      }
    }

    dispose() {
      this.detach();
      this.element = null;
      this.container = null;
    }

    setOpacity(o) {
      const eps = 0.01;

      if (Math.abs(this._opacity - o) >= eps || o >= 1 || o <= 0) {
        this._opacity = o;
        if (this.element) this.element.style.opacity = o;

        if (this.inner) {
          const v = _eases.default.quadInOut(o);
        } // this.inner.style.clipPath = `inset(-20px ${((1 - v) * 100).toFixed(
        //   5

      } // )}% -20px -20px)`;

    }

    setVisible(v) {
      if (this._visible !== v) {
        this._visible = v;
        if (this.element) this.element.style.display = this._visible ? "" : "none";
      }
    }

    setTransform(x, y, scale = 1) {
      const eps = 0.001;

      if (Math.abs(this._x - x) >= eps || Math.abs(this._y - y) >= eps || Math.abs(this._scale - scale) >= eps) {
        this._x = x;
        this._y = y;
        this._scale = scale;

        if (this.element) {
          // scale(${scale}, ${scale})
          this.element.style.transform = `translate(${x}px, ${y}px)`;
        }

        if (this.inner) {
          this.inner.style.transform = `scale(${scale}, ${scale})`;
        }
      }
    }

    setText(text) {
      if (this._text !== text) {
        this._text = text;

        if (this.inner) {
          this.inner.textContent = text;
        } // clearChildren(this.inner);
        // this._splitText = true;

      } // buildChildTexts(this.inner, text);

    }

  }

  const elementPool = new _ObjectPool.default({
    create() {
      return new TextNode();
    },

    release(e) {
      e.reset();
    }

  });
  const projectionMatrix = new THREE.Matrix4();
  let container;
  let nodes = [];
  let wasVisible = null;
  let currentElements = [];
  (0, _addFrameTasks.addPostRenderCallback)(() => {
    if (!nodes) return;
    const camera = world.findTag(Tags.MainCamera);
    const appState = world.findTag(Tags.AppState);
    viewport[2] = appState.width;
    viewport[3] = appState.height;
    projectionMatrix.copy(camera.projectionMatrix).multiply(camera.matrixWorldInverse); // nodes = v;

    updated(container, nodes);
  });
  state.subscribe(v => {
    nodes = v;
  }); // $: updated(container, nodes);

  function updated(container, nodes) {
    if (!container) return; // first we adjust arrays to be aligned

    if (currentElements.length !== nodes.length) {
      // fill buffer to match
      for (let i = 0; i < nodes.length; i++) {
        if (!currentElements[i]) {
          // get from pool
          currentElements[i] = elementPool.next(); // add to container

          currentElements[i].appendTo(container);
        }
      } // fix any overflow


      if (currentElements.length > nodes.length) {
        for (let j = nodes.length; j < currentElements.length; j++) {
          if (currentElements[j]) {
            const e = currentElements[j];
            e.detach();
            elementPool.release(e);
            currentElements[j] = null;
          }
        }
      }

      currentElements.length = nodes.length;
    }

    let hasVisible = false;

    for (let i = 0; i < currentElements.length; i++) {
      const el = currentElements[i];
      const entity = nodes[i];
      const sprite = entity.get(Tags.TextSprite3D);
      let visible = false;

      if (sprite && sprite.parent) {
        visible = true;
        sprite.parent.getWorldPosition(vec3);
        vec3.toArray(inArr3);
        (0, _cameraProject.default)(arr4D, inArr3, viewport, projectionMatrix.elements);
        const x = arr4D[0];
        const y = viewport[3] - arr4D[1];
        const xpad = 80;
        const ypad = 20;
        const inside = x >= -xpad && y >= -ypad && x <= viewport[2] + xpad && y <= viewport[3] + ypad;

        if (inside || !sprite.culling) {
          const ySize = 1;
          vec3.addScaledVector(upVector, ySize);
          vec3.toArray(inArr3);
          (0, _cameraProject.default)(arr4D, inArr3, viewport, projectionMatrix.elements);
          const y2 = viewport[3] - arr4D[1]; // Here's how I got this:
          // First, set window to any size (e.g. 534px high)
          // Then check the view units coming from the difference (~23.31 px)
          // between the two projected vectors, and scale that by
          // the height factor so that we get the size at that 534px high view
          // and divide by the target size to get a scaling factor

          const heightFactor = viewport[3] / 534;
          const sizeAtHeight = 23.31024;
          let size = Math.abs(y2 - y) / heightFactor / sizeAtHeight; // size = MathUtil.clamp(size, 0.25, 2);

          size = viewport[3] / 500;
          el.setTransform(x, y, size);
          hasVisible = true;
        } else {
          visible = false;
        }

        if (visible) {
          el.setText(sprite.text);
          el.setOpacity(sprite.opacity);
          el.setFont(sprite.fontSize, sprite.fontStyle);
        }
      }

      el.setVisible(visible);
    }

    const oldVisible = wasVisible;
    wasVisible = hasVisible;

    if (oldVisible !== hasVisible) {
      container.style.display = hasVisible ? "" : "none";
    }
  }

  function div_binding($$value) {
    _internal.binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(0, container);
    });
  }

  $$self.$$set = $$props => {
    if ("world" in $$props) $$invalidate(1, world = $$props.world);
    if ("state" in $$props) $$invalidate(2, state = $$props.state);
  };

  return [container, world, state, div_binding];
}

class Text3DOverlay extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      world: 1,
      state: 2
    });
  }

}

var _default = Text3DOverlay;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","three":"src/vendor/three.module.js","../tags":"src/tags/index.js","svelte":"node_modules/svelte/index.mjs","../util/ObjectPool":"src/util/ObjectPool.js","camera-project":"node_modules/camera-project/index.js","../util/addFrameTasks":"src/util/addFrameTasks.js","../util/math":"src/util/math.js","eases":"node_modules/eases/index.js"}],"src/systems/DOMTextSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = DOMTextSystem;

var _silkamonoRegularitalicWebfont = _interopRequireDefault(require("../assets/font/SilkaMono/silkamono-regularitalic-webfont.woff2"));

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _createPlaneSprite = _interopRequireDefault(require("../util/createPlaneSprite"));

var _threeUtil = require("../util/three-util");

var _Text3DOverlay = _interopRequireDefault(require("../overlays/Text3DOverlay.svelte"));

var _store = require("svelte/store");

var _ObjectPool = _interopRequireDefault(require("../util/ObjectPool"));

var _AnimationSystem = require("./AnimationSystem");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function DOMTextSystem(world) {
  world.system.info({
    hidden: true
  });
  const events = world.listen(Tags.TextSprite3D);
  const sprites = world.view(Tags.TextSprite3D);
  const hintEvents = world.listen(Tags.TextHint);
  const hintKillEvents = world.listen([Tags.KillTextHint, Tags.TextHint, Tags.Object3D]);
  const hintView = world.view(Tags.TextHint);
  const state = (0, _store.writable)(sprites);
  world.entity().add(Tags.ViewLayer, {
    id: "text-3d-overlay",
    component: _Text3DOverlay.default,
    props: {
      world,
      state
    }
  }); // const textGroup = new THREE.Group();
  // const textEntity = world
  //   .entity()
  //   .add(Tags.TextSprite3D)
  //   .add(Tags.Object3D, textGroup);
  // const textData = textEntity.get(Tags.TextSprite3D);
  // textData.text = "hihihi";
  // textData.parent = textGroup;
  // textData.fontSize = 18;
  // textData.opacity = 1;
  // const sphere = new THREE.Mesh(
  //   new THREE.SphereGeometry(0.1, 32, 32),
  //   new THREE.MeshBasicMaterial({ color: "pink" })
  // );
  // world.entity().add(Tags.Object3D, sphere);

  const objectPool = new _ObjectPool.default({
    create() {
      return new THREE.Group();
    }

  });
  return function textSystem(dt) {
    // const user = world.findTag(Tags.UserCharacter).position;
    // textGroup.position.copy(user);
    // textGroup.position.y += 2;
    // sphere.position.copy(textGroup.position);
    hintEvents.added.forEach(e => {
      const group = objectPool.next();
      e.add(Tags.Object3D, group);
      const hint = e.get(Tags.TextHint);
      const startY = hint.position.y - 0.5;
      const endY = hint.position.y;
      const endZ = hint.position.z;
      const startZ = hint.position.z - 1;
      group.position.copy(hint.position);
      group.position.y = startY;
      group.position.z = startZ; // const planeMat = new THREE.MeshBasicMaterial({ color: "red" });
      // const mesh = new THREE.Mesh(plane, planeMat);
      // mesh.position.copy(group.position);
      // world.entity().add(Tags.Object3D, mesh);

      e.add(Tags.TextSprite3D);
      const textData = e.get(Tags.TextSprite3D);
      textData.text = hint.text;
      textData.depth = false;
      textData.fontStyle = "italic";
      textData.fontSize = 14;
      textData.parent = group;
      textData.opacity = 0;
      textData.culling = false;
      const delay = hint.delay;
      (0, _AnimationSystem.tweenTo)(world, group.position, "y", endY, 1.5, "sineOut", delay);
      (0, _AnimationSystem.tweenTo)(world, group.position, "z", endZ, 1.5, "sineOut", delay);
      (0, _AnimationSystem.tweenTo)(world, textData, "opacity", 1, 2, "linear", delay);
    });
    hintKillEvents.added.forEach(e => {
      const hint = e.get(Tags.TextHint);
      const textData = e.get(Tags.TextSprite3D);
      const startY = hint.position.y - 0.5;
      const endY = hint.position.y;
      const group = e.get(Tags.Object3D);
      (0, _AnimationSystem.tweenTo)(world, group.position, "y", startY, 1, "sineOut", 0);
      (0, _AnimationSystem.setEntityTweenFromTo)(e, textData, "opacity", 1, 0, 1, "quadOut", 0);
      const t = e.get(Tags.TargetKeyTween);
      t.killEntityOnFinish = true;
      t.assignFromOnStart = true;
    });
    hintView.forEach(e => {
      const hint = e.get(Tags.TextHint);

      if (hint.killing && !e.has(Tags.KillTextHint)) {
        hint.time += dt;

        if (hint.time - hint.delay >= hint.duration) {
          e.add(Tags.KillTextHint);
        }
      }
    });
    hintEvents.removing.forEach(e => {
      const obj = e.get(Tags.Object3D);
      (0, _threeUtil.detachObject)(obj);
      e.remove(Tags.Object3D);
      objectPool.release(obj);
    }); // trigger UI update each frame
    // if (events.changed || sprites.length > 0) {
    //   state.update((d) => d);
    // }
    // view.map()
    // events.added.forEach((e) => {
    //   const opt = e.get(Tags.TextSprite3D);
    // });
    // events.removing.forEach((e) => {
    //   // const opt = e.get(Tags.TextSprite3D);
    //   // if (opt.sprite && opt.sprite.parent) detachObject(opt.sprite);
    // });
    // sprites.forEach((e) => {
    // const data = e.get(Tags.TextSprite3D);
    // if (data.sprite) {
    //   data.sprite.material.uniforms.opacity.value = data.opacity;
    //   data.sprite.material.uniforms.color.value.copy(data.color);
    // }
    // });
  };
}
},{"../assets/font/SilkaMono/silkamono-regularitalic-webfont.woff2":"src/assets/font/SilkaMono/silkamono-regularitalic-webfont.woff2","../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/createPlaneSprite":"src/util/createPlaneSprite.js","../util/three-util":"src/util/three-util.js","../overlays/Text3DOverlay.svelte":"src/overlays/Text3DOverlay.svelte.js","svelte/store":"node_modules/svelte/store/index.mjs","../util/ObjectPool":"src/util/ObjectPool.js","./AnimationSystem":"src/systems/AnimationSystem.js"}],"src/assets/image/ui/ico_resume.png":[function(require,module,exports) {
module.exports = "/ico_resume.45a633f9.png";
},{}],"src/assets/image/ui/btn_restart.png":[function(require,module,exports) {
module.exports = "/btn_restart.b94d37f8.png";
},{}],"src/assets/image/ui/btn_about.png":[function(require,module,exports) {
module.exports = "/btn_about.824b4f41.png";
},{}],"src/assets/image/ui/btn_about_long.png":[function(require,module,exports) {
module.exports = "/btn_about_long.09ddd1cf.png";
},{}],"src/assets/image/ui/btn_start.png":[function(require,module,exports) {
module.exports = "/btn_start.96477592.png";
},{}],"src/animations/transitions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transition = transition;
exports.emptyTransition = emptyTransition;
exports.fadeOpacityTransition = fadeOpacityTransition;
exports.fadeInTransition = fadeInTransition;
exports.fadeTransition = fadeTransition;
exports.fadeOutTransition = fadeOutTransition;

var eases = _interopRequireWildcard(require("eases"));

var _math = require("../util/math");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function transition(fn, opts = {}) {
  return (node, args = {}) => {
    return fn(node, { ...args,
      ...opts
    });
  };
}

function emptyTransition(node, opts = {}) {
  // const o = +getComputedStyle(node).opacity;
  // delay = delay + stagger * index;
  return {
    delay: 0,
    duration: 0,
    css: t => ""
  };
}

function fadeOpacityTransition(node, {
  index = 0,
  opacity = 0,
  stagger = 200,
  delay = 0,
  duration = 350,
  reverse = false
} = {}) {
  const o = +getComputedStyle(node).opacity;
  delay = delay + stagger * index;
  return {
    delay,
    duration,

    tick(t) {
      let b = eases.sineIn(t);
      if (reverse) b = 1 - b;
      node.style.opacity = (0, _math.lerp)(opacity, o, b);
    }

  };
}

function fadeInTransition(node, {
  x = 0,
  y = -10,
  endX = 0,
  endY = 0,
  endAngle = 0,
  angle = 0,
  opacity = 0,
  index = 0,
  stagger = 200,
  delay = 0,
  duration = 1000,
  reverse = false
} = {}) {
  const o = +getComputedStyle(node).opacity;
  delay = delay + stagger * index;
  return {
    delay,
    duration,

    tick(t) {
      let a = eases.quartOut(t);
      let b = eases.sineIn(t);

      if (reverse) {
        a = 1 - a;
        b = 1 - b;
      }

      const px = (0, _math.lerp)(x, endX, a);
      const py = (0, _math.lerp)(y, endY, a);
      const pangle = (0, _math.lerpAngle)(angle, endAngle, b);
      node.style.transformOrigin = "50% 50%";
      node.style.transform = `translate(${px}px, ${py}px) rotateZ(${pangle}rad)`;
      node.style.opacity = (0, _math.lerp)(opacity, o, b);
    } // css(t) {
    //   const a = eases.quartOut(t);
    //   const b = eases.sineIn(t);
    //   const py = lerp(y, 0, a);
    //   return `
    //     transform: translate(0px, ${py}px);
    //     opacity: ${lerp(opacity, o, b)};
    //   `;
    // },


  };
}

function fadeTransition(node, opts = {}) {
  return fadeInTransition(node, opts);
}

function fadeOutTransition(node, opts = {}) {
  return fadeInTransition(node, opts);
}
},{"eases":"node_modules/eases/index.js","../util/math":"src/util/math.js"}],"src/components/ImageButton.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _btn_restart = _interopRequireDefault(require("../assets/image/ui/btn_restart.png"));

var _btn_about = _interopRequireDefault(require("../assets/image/ui/btn_about.png"));

var _btn_about_long = _interopRequireDefault(require("../assets/image/ui/btn_about_long.png"));

var _btn_start = _interopRequireDefault(require("../assets/image/ui/btn_start.png"));

var _svelte = require("svelte");

var _transitions = require("../animations/transitions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* components/ImageButton.svelte generated by Svelte v3.31.0 */
// import AlertButtonIdle from "../assets/image/ui/btn_restart_top.png";
// import NormalButtonIdle from "../assets/image/ui/btn_start_top.png";
function create_if_block_1(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = (0, _internal.element)("img");
      (0, _internal.attr)(img, "class", "icon svelte-1j4vnox");
      if (img.src !== (img_src_value =
      /*icon*/
      ctx[0])) (0, _internal.attr)(img, "src", img_src_value);
      (0, _internal.attr)(img, "alt", "");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, img, anchor);
    },

    p(ctx, dirty) {
      if (dirty &
      /*icon*/
      1 && img.src !== (img_src_value =
      /*icon*/
      ctx[0])) {
        (0, _internal.attr)(img, "src", img_src_value);
      }
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(img);
    }

  };
} // (106:4) {#if text}


function create_if_block(ctx) {
  let div;
  let t;
  return {
    c() {
      div = (0, _internal.element)("div");
      t = (0, _internal.text)(
      /*text*/
      ctx[2]);
      (0, _internal.attr)(div, "class", "text svelte-1j4vnox");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.append)(div, t);
    },

    p(ctx, dirty) {
      if (dirty &
      /*text*/
      4) (0, _internal.set_data)(t,
      /*text*/
      ctx[2]);
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
    }

  };
}

function create_fragment(ctx) {
  let div2;
  let div0;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let div1;
  let t1;
  let div2_intro;
  let div2_outro;
  let current;
  let mounted;
  let dispose;
  let if_block0 =
  /*icon*/
  ctx[0] && create_if_block_1(ctx);
  let if_block1 =
  /*text*/
  ctx[2] && create_if_block(ctx);
  return {
    c() {
      div2 = (0, _internal.element)("div");
      div0 = (0, _internal.element)("div");
      img = (0, _internal.element)("img");
      t0 = (0, _internal.space)();
      div1 = (0, _internal.element)("div");
      if (if_block0) if_block0.c();
      t1 = (0, _internal.space)();
      if (if_block1) if_block1.c();
      if (img.src !== (img_src_value =
      /*image*/
      ctx[7])) (0, _internal.attr)(img, "src", img_src_value);
      (0, _internal.attr)(img, "alt", img_alt_value =
      /*alt*/
      ctx[3] ||
      /*text*/
      ctx[2]);
      (0, _internal.attr)(img, "class", "svelte-1j4vnox");
      (0, _internal.attr)(div0, "class", "image-container svelte-1j4vnox");
      (0, _internal.attr)(div1, "class", "content-container svelte-1j4vnox");
      (0, _internal.toggle_class)(div1, "offset",
      /*offset*/
      ctx[8]);
      (0, _internal.attr)(div2, "class", "container svelte-1j4vnox");
      (0, _internal.toggle_class)(div2, "invert",
      /*mode*/
      ctx[1] === "dark" ||
      /*mode*/
      ctx[1] === "dark_long");
      (0, _internal.toggle_class)(div2, "smaller",
      /*smaller*/
      ctx[9]);
      (0, _internal.toggle_class)(div2, "longer",
      /*longer*/
      ctx[10]);
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div2, anchor);
      (0, _internal.append)(div2, div0);
      (0, _internal.append)(div0, img);
      (0, _internal.append)(div2, t0);
      (0, _internal.append)(div2, div1);
      if (if_block0) if_block0.m(div1, null);
      (0, _internal.append)(div1, t1);
      if (if_block1) if_block1.m(div1, null);
      current = true;

      if (!mounted) {
        dispose = [(0, _internal.listen)(div2, "introend",
        /*introend_handler*/
        ctx[12]), (0, _internal.listen)(div2, "introstart",
        /*introstart_handler*/
        ctx[13]), (0, _internal.listen)(div2, "outroend",
        /*outroend_handler*/
        ctx[14]), (0, _internal.listen)(div2, "outrostart",
        /*outrostart_handler*/
        ctx[15]), (0, _internal.listen)(div2, "click",
        /*click_handler*/
        ctx[16]), (0, _internal.listen)(div2, "mouseenter",
        /*mouseenter_handler*/
        ctx[17]), (0, _internal.listen)(div2, "mouseleave",
        /*mouseleave_handler*/
        ctx[18])];
        mounted = true;
      }
    },

    p(ctx, [dirty]) {
      if (!current || dirty &
      /*image*/
      128 && img.src !== (img_src_value =
      /*image*/
      ctx[7])) {
        (0, _internal.attr)(img, "src", img_src_value);
      }

      if (!current || dirty &
      /*alt, text*/
      12 && img_alt_value !== (img_alt_value =
      /*alt*/
      ctx[3] ||
      /*text*/
      ctx[2])) {
        (0, _internal.attr)(img, "alt", img_alt_value);
      }

      if (
      /*icon*/
      ctx[0]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_1(ctx);
          if_block0.c();
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }

      if (
      /*text*/
      ctx[2]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block(ctx);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }

      if (dirty &
      /*offset*/
      256) {
        (0, _internal.toggle_class)(div1, "offset",
        /*offset*/
        ctx[8]);
      }

      if (dirty &
      /*mode*/
      2) {
        (0, _internal.toggle_class)(div2, "invert",
        /*mode*/
        ctx[1] === "dark" ||
        /*mode*/
        ctx[1] === "dark_long");
      }

      if (dirty &
      /*smaller*/
      512) {
        (0, _internal.toggle_class)(div2, "smaller",
        /*smaller*/
        ctx[9]);
      }

      if (dirty &
      /*longer*/
      1024) {
        (0, _internal.toggle_class)(div2, "longer",
        /*longer*/
        ctx[10]);
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.add_render_callback)(() => {
        if (div2_outro) div2_outro.end(1);
        if (!div2_intro) div2_intro = (0, _internal.create_in_transition)(div2,
        /*inTransition*/
        ctx[4], {});
        div2_intro.start();
      });
      current = true;
    },

    o(local) {
      if (div2_intro) div2_intro.invalidate();
      div2_outro = (0, _internal.create_out_transition)(div2,
      /*outTransition*/
      ctx[5], {});
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div2);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (detaching && div2_outro) div2_outro.end();
      mounted = false;
      (0, _internal.run_all)(dispose);
    }

  };
}

function instance($$self, $$props, $$invalidate) {
  const dispatcher = (0, _svelte.createEventDispatcher)(); // We have a few different types of idle/hover images, depending on mode

  const modes = {
    normal: {
      idle: _btn_start.default,
      hover: _btn_start.default,
      offset: true
    },
    normal_small: {
      idle: _btn_start.default,
      hover: _btn_start.default,
      offset: true,
      smaller: true
    },
    alert: {
      idle: _btn_restart.default,
      hover: _btn_restart.default,
      offset: true
    },
    dark: {
      idle: _btn_about.default,
      hover: _btn_about.default,
      smaller: true
    },
    dark_long: {
      idle: _btn_about_long.default,
      hover: _btn_about_long.default,
      smaller: true,
      longer: true
    }
  };
  let {
    icon = ""
  } = $$props;
  let {
    mode = "normal"
  } = $$props;
  let {
    text = ""
  } = $$props;
  let {
    alt = ""
  } = $$props;
  let {
    inTransition = _transitions.emptyTransition
  } = $$props;
  let {
    outTransition = _transitions.emptyTransition
  } = $$props; // local props

  let state;
  let image;
  let offset = false;
  let hover = false;
  let smaller = false;
  let longer = false;

  function introend_handler(event) {
    (0, _internal.bubble)($$self, event);
  }

  function introstart_handler(event) {
    (0, _internal.bubble)($$self, event);
  }

  function outroend_handler(event) {
    (0, _internal.bubble)($$self, event);
  }

  function outrostart_handler(event) {
    (0, _internal.bubble)($$self, event);
  }

  function click_handler(event) {
    (0, _internal.bubble)($$self, event);
  }

  const mouseenter_handler = () => {
    $$invalidate(6, hover = true);
  }; // dispatcher("triggerHoverSound");


  const mouseleave_handler = () => {
    $$invalidate(6, hover = false);
  }; // dispatcher("unmountTriggerHoverSound");


  $$self.$$set = $$props => {
    if ("icon" in $$props) $$invalidate(0, icon = $$props.icon);
    if ("mode" in $$props) $$invalidate(1, mode = $$props.mode);
    if ("text" in $$props) $$invalidate(2, text = $$props.text);
    if ("alt" in $$props) $$invalidate(3, alt = $$props.alt);
    if ("inTransition" in $$props) $$invalidate(4, inTransition = $$props.inTransition);
    if ("outTransition" in $$props) $$invalidate(5, outTransition = $$props.outTransition);
  };

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*mode, state, hover*/
    2114) {
      // svelte reactive statement
      $: {
        // when mode changes, get a new state
        $$invalidate(11, state = modes[mode]); // whether to offset text a bit due to button shadow

        $$invalidate(8, offset = Boolean(state.offset)); // whether to make button a bit smaller

        $$invalidate(9, smaller = Boolean(state.smaller)); // Bit longer?

        $$invalidate(10, longer = Boolean(state.longer)); // when hover changes, update image

        $$invalidate(7, image = hover ? state.hover : state.idle);
      }
    }
  };

  return [icon, mode, text, alt, inTransition, outTransition, hover, image, offset, smaller, longer, state, introend_handler, introstart_handler, outroend_handler, outrostart_handler, click_handler, mouseenter_handler, mouseleave_handler];
}

class ImageButton extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      icon: 0,
      mode: 1,
      text: 2,
      alt: 3,
      inTransition: 4,
      outTransition: 5
    });
  }

}

var _default = ImageButton;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","../assets/image/ui/btn_restart.png":"src/assets/image/ui/btn_restart.png","../assets/image/ui/btn_about.png":"src/assets/image/ui/btn_about.png","../assets/image/ui/btn_about_long.png":"src/assets/image/ui/btn_about_long.png","../assets/image/ui/btn_start.png":"src/assets/image/ui/btn_start.png","svelte":"node_modules/svelte/index.mjs","../animations/transitions":"src/animations/transitions.js"}],"src/assets/image/data/bluenoise-0.png":[function(require,module,exports) {
module.exports = "/bluenoise-0.c477167f.png";
},{}],"src/assets/image/data/bluenoise-1.png":[function(require,module,exports) {
module.exports = "/bluenoise-1.1f73f24f.png";
},{}],"src/assets/image/data/bluenoise-2.png":[function(require,module,exports) {
module.exports = "/bluenoise-2.43118496.png";
},{}],"src/assets/image/data/bluenoise-3.png":[function(require,module,exports) {
module.exports = "/bluenoise-3.8db09f99.png";
},{}],"src/assets/image/data/compass-arrow.png":[function(require,module,exports) {
module.exports = "/compass-arrow.4472bc30.png";
},{}],"src/assets/image/data/cape-texture-landscape-1024.png":[function(require,module,exports) {
module.exports = "/cape-texture-landscape-1024.9e6756f9.png";
},{}],"src/assets/image/data/compass-arrow2.png":[function(require,module,exports) {
module.exports = "/compass-arrow2.71a2ead3.png";
},{}],"src/assets/image/data/compass-dot.png":[function(require,module,exports) {
module.exports = "/compass-dot.3306061f.png";
},{}],"src/assets/image/data/compass-arrow3.png":[function(require,module,exports) {
module.exports = "/compass-arrow3.e43968b0.png";
},{}],"src/assets/image/data/compass-ring.png":[function(require,module,exports) {
module.exports = "/compass-ring.ff01a164.png";
},{}],"src/assets/image/data/floating-paper-lines.png":[function(require,module,exports) {
module.exports = "/floating-paper-lines.67bae230.png";
},{}],"src/assets/image/data/floating-paper.png":[function(require,module,exports) {
module.exports = "/floating-paper.685fe73f.png";
},{}],"src/assets/image/data/grass-1.png":[function(require,module,exports) {
module.exports = "/grass-1.06ba9c96.png";
},{}],"src/assets/image/data/grass-temp.png":[function(require,module,exports) {
module.exports = "/grass-temp.2bf1260b.png";
},{}],"src/assets/image/data/grass-temp2.png":[function(require,module,exports) {
module.exports = "/grass-temp2.88878112.png";
},{}],"src/assets/image/data/grass-thin.png":[function(require,module,exports) {
module.exports = "/grass-thin.4c284b20.png";
},{}],"src/assets/image/data/ground-spawn-grasslands.png":[function(require,module,exports) {
module.exports = "/ground-spawn-grasslands.9718a156.png";
},{}],"src/assets/image/data/ground-spawn-forest.png":[function(require,module,exports) {
module.exports = "/ground-spawn-forest.dd4b42b8.png";
},{}],"src/assets/image/data/ground-spawn-tundra.png":[function(require,module,exports) {
module.exports = "/ground-spawn-tundra.32a2927f.png";
},{}],"src/assets/image/data/hard-circle.png":[function(require,module,exports) {
module.exports = "/hard-circle.fe9d970d.png";
},{}],"src/assets/image/data/ico_about.png":[function(require,module,exports) {
module.exports = "/ico_about.4a325dba.png";
},{}],"src/assets/image/data/lightray.png":[function(require,module,exports) {
module.exports = "/lightray.6171c8d6.png";
},{}],"src/assets/image/data/lut-forest.png":[function(require,module,exports) {
module.exports = "/lut-forest.a3ffb341.png";
},{}],"src/assets/image/data/lut-grasslands.png":[function(require,module,exports) {
module.exports = "/lut-grasslands.b52ea89a.png";
},{}],"src/assets/image/data/lut-raw-no-post.png":[function(require,module,exports) {
module.exports = "/lut-raw-no-post.ee6b2ad5.png";
},{}],"src/assets/image/data/lut-tundra5.png":[function(require,module,exports) {
module.exports = "/lut-tundra5.a29b4d95.png";
},{}],"src/assets/image/data/lut-tundra6.png":[function(require,module,exports) {
module.exports = "/lut-tundra6.466bedff.png";
},{}],"src/assets/image/data/lut-tundra.png":[function(require,module,exports) {
module.exports = "/lut-tundra.94fae02b.png";
},{}],"src/assets/image/data/soft-circle.png":[function(require,module,exports) {
module.exports = "/soft-circle.e889c1fe.png";
},{}],"src/assets/image/data/water-distort.png":[function(require,module,exports) {
module.exports = "/water-distort.dc1a8094.png";
},{}],"src/assets/image/data/water-noise.png":[function(require,module,exports) {
module.exports = "/water-noise.1e7e1977.png";
},{}],"src/assets/image/opaque/floor-overlay.jpg":[function(require,module,exports) {
module.exports = "/floor-overlay.0cb23327.jpg";
},{}],"src/assets/image/opaque/floor-tundra.jpg":[function(require,module,exports) {
module.exports = "/floor-tundra.ff74d2b1.jpg";
},{}],"src/assets/image/opaque/floor-path.jpg":[function(require,module,exports) {
module.exports = "/floor-path.50242089.jpg";
},{}],"src/assets/image/opaque/floor.jpg":[function(require,module,exports) {
module.exports = "/floor.b85bebb9.jpg";
},{}],"src/assets/image/opaque/ice.jpg":[function(require,module,exports) {
module.exports = "/ice.c9094bfb.jpg";
},{}],"src/assets/image/svg/MAP.svg":[function(require,module,exports) {
module.exports = "/MAP.435279cc.svg";
},{}],"src/assets/image/svg/back.svg":[function(require,module,exports) {
module.exports = "/back.7c7bb610.svg";
},{}],"src/assets/image/svg/circle-24px.svg":[function(require,module,exports) {
module.exports = "/circle-24px.ecf25bd3.svg";
},{}],"src/assets/image/svg/code-24px.svg":[function(require,module,exports) {
module.exports = "/code-24px.7443add3.svg";
},{}],"src/assets/image/svg/compass.svg":[function(require,module,exports) {
module.exports = "/compass.91c4b887.svg";
},{}],"src/assets/image/svg/create-24px.svg":[function(require,module,exports) {
module.exports = "/create-24px.cf0486ca.svg";
},{}],"src/assets/image/svg/down-arrow.svg":[function(require,module,exports) {
module.exports = "/down-arrow.511eede1.svg";
},{}],"src/assets/image/svg/exit.svg":[function(require,module,exports) {
module.exports = "/exit.c6442c7b.svg";
},{}],"src/assets/image/svg/eye-24px.svg":[function(require,module,exports) {
module.exports = "/eye-24px.97026c9d.svg";
},{}],"src/assets/image/svg/ico_NFBONF.svg":[function(require,module,exports) {
module.exports = "/ico_NFBONF.e4f084d8.svg";
},{}],"src/assets/image/svg/eye-off-24px.svg":[function(require,module,exports) {
module.exports = "/eye-off-24px.f23c8aba.svg";
},{}],"src/assets/image/svg/icon-biome-forest.svg":[function(require,module,exports) {
module.exports = "/icon-biome-forest.9b83bebd.svg";
},{}],"src/assets/image/svg/icon-audio.svg":[function(require,module,exports) {
module.exports = "/icon-audio.b6e7108f.svg";
},{}],"src/assets/image/svg/icon-biome-grasslands.svg":[function(require,module,exports) {
module.exports = "/icon-biome-grasslands.d5072470.svg";
},{}],"src/assets/image/svg/icon-biome-group.svg":[function(require,module,exports) {
module.exports = "/icon-biome-group.562dbb8d.svg";
},{}],"src/assets/image/svg/icon-biome-tundra.svg":[function(require,module,exports) {
module.exports = "/icon-biome-tundra.60e4f515.svg";
},{}],"src/assets/image/svg/icon-compass.svg":[function(require,module,exports) {
module.exports = "/icon-compass.fd40e924.svg";
},{}],"src/assets/image/svg/icon-leaf-menu.svg":[function(require,module,exports) {
module.exports = "/icon-leaf-menu.dcfc0951.svg";
},{}],"src/assets/image/svg/icon-leaf.svg":[function(require,module,exports) {
module.exports = "/icon-leaf.ae221fd8.svg";
},{}],"src/assets/image/svg/icon-touch.svg":[function(require,module,exports) {
module.exports = "/icon-touch.f0677b06.svg";
},{}],"src/assets/image/svg/journal.svg":[function(require,module,exports) {
module.exports = "/journal.8defcf90.svg";
},{}],"src/assets/image/svg/keyboard_arrow_down-24px.svg":[function(require,module,exports) {
module.exports = "/keyboard_arrow_down-24px.9883ec65.svg";
},{}],"src/assets/image/svg/keyboard_arrow_right-24px.svg":[function(require,module,exports) {
module.exports = "/keyboard_arrow_right-24px.784f3314.svg";
},{}],"src/assets/image/svg/loupe-24px.svg":[function(require,module,exports) {
module.exports = "/loupe-24px.f639f6ff.svg";
},{}],"src/assets/image/svg/map-trail.svg":[function(require,module,exports) {
module.exports = "/map-trail.9d988a35.svg";
},{}],"src/assets/image/svg/menu.svg":[function(require,module,exports) {
module.exports = "/menu.a6dda947.svg";
},{}],"src/assets/image/svg/nfblogo.svg":[function(require,module,exports) {
module.exports = "/nfblogo.a0332e51.svg";
},{}],"src/assets/image/svg/rotate-smartphone.svg":[function(require,module,exports) {
module.exports = "/rotate-smartphone.373429b9.svg";
},{}],"src/assets/image/svg/sound.svg":[function(require,module,exports) {
module.exports = "/sound.50dce035.svg";
},{}],"src/assets/image/svg/title.svg":[function(require,module,exports) {
module.exports = "/title.8ad233a8.svg";
},{}],"src/assets/image/tokens/ico_feather.png":[function(require,module,exports) {
module.exports = "/ico_feather.c6145313.png";
},{}],"src/assets/image/tokens/ico_animal.png":[function(require,module,exports) {
module.exports = "/ico_animal.48734dff.png";
},{}],"src/assets/image/tokens/ico_fish.png":[function(require,module,exports) {
module.exports = "/ico_fish.a1c52121.png";
},{}],"src/assets/image/tokens/ico_flower.png":[function(require,module,exports) {
module.exports = "/ico_flower.ee2b6371.png";
},{}],"src/assets/image/tokens/ico_grass.png":[function(require,module,exports) {
module.exports = "/ico_grass.9f2ab0cf.png";
},{}],"src/assets/image/tokens/ico_leaf.png":[function(require,module,exports) {
module.exports = "/ico_leaf.49467633.png";
},{}],"src/assets/image/tokens/ico_mist.png":[function(require,module,exports) {
module.exports = "/ico_mist.98a687f7.png";
},{}],"src/assets/image/tokens/ico_insect.png":[function(require,module,exports) {
module.exports = "/ico_insect.3e38b4a3.png";
},{}],"src/assets/image/tokens/ico_moon.png":[function(require,module,exports) {
module.exports = "/ico_moon.9d5a0a34.png";
},{}],"src/assets/image/tokens/ico_rain..png":[function(require,module,exports) {
module.exports = "/ico_rain..67b649cf.png";
},{}],"src/assets/image/tokens/ico_stars.png":[function(require,module,exports) {
module.exports = "/ico_stars.bfbdb20c.png";
},{}],"src/assets/image/tokens/ico_snow.png":[function(require,module,exports) {
module.exports = "/ico_snow.b6fe126f.png";
},{}],"src/assets/image/tokens/ico_storm.png":[function(require,module,exports) {
module.exports = "/ico_storm.7f0f76d2.png";
},{}],"src/assets/image/tokens/ico_sun.png":[function(require,module,exports) {
module.exports = "/ico_sun.87d52164.png";
},{}],"src/assets/image/tokens/ico_tree.png":[function(require,module,exports) {
module.exports = "/ico_tree.4b0fac16.png";
},{}],"src/assets/image/tokens/ico_wind.png":[function(require,module,exports) {
module.exports = "/ico_wind.de106b5f.png";
},{}],"src/assets/image/tokens-collected/animal.png":[function(require,module,exports) {
module.exports = "/animal.b370a8bf.png";
},{}],"src/assets/image/tokens-collected/fish.png":[function(require,module,exports) {
module.exports = "/fish.e7e16b3a.png";
},{}],"src/assets/image/tokens-collected/feather.png":[function(require,module,exports) {
module.exports = "/feather.842f4677.png";
},{}],"src/assets/image/tokens-collected/flower.png":[function(require,module,exports) {
module.exports = "/flower.9f0e8987.png";
},{}],"src/assets/image/tokens-collected/grass.png":[function(require,module,exports) {
module.exports = "/grass.e214070d.png";
},{}],"src/assets/image/tokens-collected/insect.png":[function(require,module,exports) {
module.exports = "/insect.c24390d7.png";
},{}],"src/assets/image/tokens-collected/mist.png":[function(require,module,exports) {
module.exports = "/mist.b9020bfa.png";
},{}],"src/assets/image/tokens-collected/leaf.png":[function(require,module,exports) {
module.exports = "/leaf.87cee7c7.png";
},{}],"src/assets/image/tokens-collected/moon.png":[function(require,module,exports) {
module.exports = "/moon.6948726c.png";
},{}],"src/assets/image/tokens-collected/stars.png":[function(require,module,exports) {
module.exports = "/stars.cf9a660c.png";
},{}],"src/assets/image/tokens-collected/rain.png":[function(require,module,exports) {
module.exports = "/rain.168a71c9.png";
},{}],"src/assets/image/tokens-collected/snow.png":[function(require,module,exports) {
module.exports = "/snow.e989dfbd.png";
},{}],"src/assets/image/tokens-collected/storm.png":[function(require,module,exports) {
module.exports = "/storm.36b5c835.png";
},{}],"src/assets/image/tokens-collected/tree.png":[function(require,module,exports) {
module.exports = "/tree.34143e5f.png";
},{}],"src/assets/image/tokens-collected/sun.png":[function(require,module,exports) {
module.exports = "/sun.ac560817.png";
},{}],"src/assets/image/tokens-collected/wind.png":[function(require,module,exports) {
module.exports = "/wind.329723e8.png";
},{}],"src/assets/image/tokens-inverted/ico_feather.png":[function(require,module,exports) {
module.exports = "/ico_feather.bcdb806c.png";
},{}],"src/assets/image/tokens-inverted/ico_animal.png":[function(require,module,exports) {
module.exports = "/ico_animal.6fe82a35.png";
},{}],"src/assets/image/tokens-inverted/ico_flower.png":[function(require,module,exports) {
module.exports = "/ico_flower.330d0134.png";
},{}],"src/assets/image/tokens-inverted/ico_fish.png":[function(require,module,exports) {
module.exports = "/ico_fish.1d500da1.png";
},{}],"src/assets/image/tokens-inverted/ico_grass.png":[function(require,module,exports) {
module.exports = "/ico_grass.29affbab.png";
},{}],"src/assets/image/tokens-inverted/ico_insect..png":[function(require,module,exports) {
module.exports = "/ico_insect..4781ff9a.png";
},{}],"src/assets/image/tokens-inverted/ico_leaf.png":[function(require,module,exports) {
module.exports = "/ico_leaf.29ff08f6.png";
},{}],"src/assets/image/tokens-inverted/ico_mist.png":[function(require,module,exports) {
module.exports = "/ico_mist.41eeafd6.png";
},{}],"src/assets/image/tokens-inverted/ico_moon.png":[function(require,module,exports) {
module.exports = "/ico_moon.1d866bd1.png";
},{}],"src/assets/image/tokens-inverted/ico_rain.png":[function(require,module,exports) {
module.exports = "/ico_rain.53ed9c3a.png";
},{}],"src/assets/image/tokens-inverted/ico_snow.png":[function(require,module,exports) {
module.exports = "/ico_snow.a367247d.png";
},{}],"src/assets/image/tokens-inverted/ico_storm.png":[function(require,module,exports) {
module.exports = "/ico_storm.b9df3d44.png";
},{}],"src/assets/image/tokens-inverted/ico_stars.png":[function(require,module,exports) {
module.exports = "/ico_stars.1cfa5190.png";
},{}],"src/assets/image/tokens-inverted/ico_sun.png":[function(require,module,exports) {
module.exports = "/ico_sun.67c2061f.png";
},{}],"src/assets/image/tokens-inverted/ico_wind.png":[function(require,module,exports) {
module.exports = "/ico_wind.51c6a713.png";
},{}],"src/assets/image/tokens-inverted/ico_tree.png":[function(require,module,exports) {
module.exports = "/ico_tree.c19f27dc.png";
},{}],"src/assets/image/ui/biomeforest-alt.png":[function(require,module,exports) {
module.exports = "/biomeforest-alt.666b0bf6.png";
},{}],"src/assets/image/ui/biomeforest.png":[function(require,module,exports) {
module.exports = "/biomeforest.bcacccf7.png";
},{}],"src/assets/image/ui/biomegrass-alt.png":[function(require,module,exports) {
module.exports = "/biomegrass-alt.6b18ea76.png";
},{}],"src/assets/image/ui/biomegrass.png":[function(require,module,exports) {
module.exports = "/biomegrass.a2b632cf.png";
},{}],"src/assets/image/ui/biometundra-alt.png":[function(require,module,exports) {
module.exports = "/biometundra-alt.e0cf58f4.png";
},{}],"src/assets/image/ui/biometundra.png":[function(require,module,exports) {
module.exports = "/biometundra.61d9b92b.png";
},{}],"src/assets/image/ui/bird.png":[function(require,module,exports) {
module.exports = "/bird.8edc6573.png";
},{}],"src/assets/image/ui/btn_pause.png":[function(require,module,exports) {
module.exports = "/btn_pause.50f5c5f6.png";
},{}],"src/assets/image/ui/btn_restart_shadow.png":[function(require,module,exports) {
module.exports = "/btn_restart_shadow.45bdc4e2.png";
},{}],"src/assets/image/ui/btn_restart_top.png":[function(require,module,exports) {
module.exports = "/btn_restart_top.d2453a3c.png";
},{}],"src/assets/image/ui/btn_start_shadow.png":[function(require,module,exports) {
module.exports = "/btn_start_shadow.b7072322.png";
},{}],"src/assets/image/ui/close-button.png":[function(require,module,exports) {
module.exports = "/close-button.eba160d5.png";
},{}],"src/assets/image/ui/btn_start_top.png":[function(require,module,exports) {
module.exports = "/btn_start_top.5eddec0a.png";
},{}],"src/assets/image/ui/compass1.png":[function(require,module,exports) {
module.exports = "/compass1.0a35b69b.png";
},{}],"src/assets/image/ui/compass2.png":[function(require,module,exports) {
module.exports = "/compass2.061d6a3d.png";
},{}],"src/assets/image/ui/compass3.png":[function(require,module,exports) {
module.exports = "/compass3.941ed345.png";
},{}],"src/assets/image/ui/compass4.png":[function(require,module,exports) {
module.exports = "/compass4.a8c1c4a3.png";
},{}],"src/assets/image/ui/empty_box.png":[function(require,module,exports) {
module.exports = "/empty_box.8112b50b.png";
},{}],"src/assets/image/ui/filled_box.png":[function(require,module,exports) {
module.exports = "/filled_box.02dba145.png";
},{}],"src/assets/image/ui/finger-inv.png":[function(require,module,exports) {
module.exports = "/finger-inv.52c84c89.png";
},{}],"src/assets/image/ui/hint-card-left.png":[function(require,module,exports) {
module.exports = "/hint-card-left.aa1c0649.png";
},{}],"src/assets/image/ui/finger.png":[function(require,module,exports) {
module.exports = "/finger.56d70c4c.png";
},{}],"src/assets/image/ui/hint-card-middle.png":[function(require,module,exports) {
module.exports = "/hint-card-middle.251798d8.png";
},{}],"src/assets/image/ui/ico_NFBONF.png":[function(require,module,exports) {
module.exports = "/ico_NFBONF.0a82dd27.png";
},{}],"src/assets/image/ui/hint-card-right.png":[function(require,module,exports) {
module.exports = "/hint-card-right.1ad52a86.png";
},{}],"src/assets/image/ui/ico_XcloseJournal.png":[function(require,module,exports) {
module.exports = "/ico_XcloseJournal.85c230c6.png";
},{}],"src/assets/image/ui/ico_about_orange.png":[function(require,module,exports) {
module.exports = "/ico_about_orange.eef1ea78.png";
},{}],"src/assets/image/ui/ico_about.png":[function(require,module,exports) {
module.exports = "/ico_about.ac608152.png";
},{}],"src/assets/image/ui/ico_closeJournal.png":[function(require,module,exports) {
module.exports = "/ico_closeJournal.d39508cb.png";
},{}],"src/assets/image/ui/ico_completedHaiku.png":[function(require,module,exports) {
module.exports = "/ico_completedHaiku.3a3ecc6e.png";
},{}],"src/assets/image/ui/ico_emptyHaiku.png":[function(require,module,exports) {
module.exports = "/ico_emptyHaiku.e7103347.png";
},{}],"src/assets/image/ui/ico_expand.png":[function(require,module,exports) {
module.exports = "/ico_expand.9750c355.png";
},{}],"src/assets/image/ui/ico_emptytoken.png":[function(require,module,exports) {
module.exports = "/ico_emptytoken.2a58d56a.png";
},{}],"src/assets/image/ui/ico_haiku.png":[function(require,module,exports) {
module.exports = "/ico_haiku.9818a6c9.png";
},{}],"src/assets/image/ui/ico_haiku_leaf.png":[function(require,module,exports) {
module.exports = "/ico_haiku_leaf.55c197e2.png";
},{}],"src/assets/image/ui/ico_journal.png":[function(require,module,exports) {
module.exports = "/ico_journal.00403c08.png";
},{}],"src/assets/image/ui/ico_languageSelect.png":[function(require,module,exports) {
module.exports = "/ico_languageSelect.780f8eaa.png";
},{}],"src/assets/image/ui/ico_openjournal.png":[function(require,module,exports) {
module.exports = "/ico_openjournal.cb89f53c.png";
},{}],"src/assets/image/ui/ico_paperJournal1-rotated.png":[function(require,module,exports) {
module.exports = "/ico_paperJournal1-rotated.efca2540.png";
},{}],"src/assets/image/ui/ico_paperJournal1.png":[function(require,module,exports) {
module.exports = "/ico_paperJournal1.c8be65b2.png";
},{}],"src/assets/image/ui/ico_paperJournal2-rotated.png":[function(require,module,exports) {
module.exports = "/ico_paperJournal2-rotated.811488b6.png";
},{}],"src/assets/image/ui/ico_paperJournal2.png":[function(require,module,exports) {
module.exports = "/ico_paperJournal2.51459bce.png";
},{}],"src/assets/image/ui/ico_popupHaiku-straight.png":[function(require,module,exports) {
module.exports = "/ico_popupHaiku-straight.a9937f7c.png";
},{}],"src/assets/image/ui/ico_popupHaiku.png":[function(require,module,exports) {
module.exports = "/ico_popupHaiku.60e073dc.png";
},{}],"src/assets/image/ui/ico_restart.png":[function(require,module,exports) {
module.exports = "/ico_restart.d9d38ff4.png";
},{}],"src/assets/image/ui/ico_scrollbar.png":[function(require,module,exports) {
module.exports = "/ico_scrollbar.82fe6a15.png";
},{}],"src/assets/image/ui/ico_toggle.png":[function(require,module,exports) {
module.exports = "/ico_toggle.a611d81e.png";
},{}],"src/assets/image/ui/ico_volume.png":[function(require,module,exports) {
module.exports = "/ico_volume.eba9fc65.png";
},{}],"src/assets/image/ui/ico_volume_bar.png":[function(require,module,exports) {
module.exports = "/ico_volume_bar.62724a59.png";
},{}],"src/assets/image/ui/ico_volume_gauge.png":[function(require,module,exports) {
module.exports = "/ico_volume_gauge.e775c134.png";
},{}],"src/assets/image/ui/ico_volume_toggle.png":[function(require,module,exports) {
module.exports = "/ico_volume_toggle.e1c933ac.png";
},{}],"src/assets/image/ui/title2_en.png":[function(require,module,exports) {
module.exports = "/title2_en.f2b6d10e.png";
},{}],"src/assets/image/ui/title2_fr.png":[function(require,module,exports) {
module.exports = "/title2_fr.61ccba7a.png";
},{}],"src/assets/image/ui/title2_en_leaf.png":[function(require,module,exports) {
module.exports = "/title2_en_leaf.bf6f5f46.png";
},{}],"src/assets/image/ui/title2_fr_leaf.png":[function(require,module,exports) {
module.exports = "/title2_fr_leaf.8f66da22.png";
},{}],"src/assets/image/ui/touch-inv.png":[function(require,module,exports) {
module.exports = "/touch-inv.d9d136bf.png";
},{}],"src/assets/image/ui/touch.png":[function(require,module,exports) {
module.exports = "/touch.6a7242ef.png";
},{}],"src/assets/image/ui/tree-inv.png":[function(require,module,exports) {
module.exports = "/tree-inv.ee45f035.png";
},{}],"src/assets/image/ui/tree.png":[function(require,module,exports) {
module.exports = "/tree.bb7fa072.png";
},{}],"src/assets/image/ui/vertical-rule.png":[function(require,module,exports) {
module.exports = "/vertical-rule.bcf68d7b.png";
},{}],"src/assets/image/ui/wayfinder_placeholder.png":[function(require,module,exports) {
module.exports = "/wayfinder_placeholder.c35739a2.png";
},{}],"src/assets/image/**/*.{png,jpeg,jpg,svg}":[function(require,module,exports) {
module.exports = {
  "data": {
    "bluenoise-0": {
      "png": require("./../data/bluenoise-0.png")
    },
    "bluenoise-1": {
      "png": require("./../data/bluenoise-1.png")
    },
    "bluenoise-2": {
      "png": require("./../data/bluenoise-2.png")
    },
    "bluenoise-3": {
      "png": require("./../data/bluenoise-3.png")
    },
    "compass-arrow": {
      "png": require("./../data/compass-arrow.png")
    },
    "cape-texture-landscape-1024": {
      "png": require("./../data/cape-texture-landscape-1024.png")
    },
    "compass-arrow2": {
      "png": require("./../data/compass-arrow2.png")
    },
    "compass-dot": {
      "png": require("./../data/compass-dot.png")
    },
    "compass-arrow3": {
      "png": require("./../data/compass-arrow3.png")
    },
    "compass-ring": {
      "png": require("./../data/compass-ring.png")
    },
    "floating-paper-lines": {
      "png": require("./../data/floating-paper-lines.png")
    },
    "floating-paper": {
      "png": require("./../data/floating-paper.png")
    },
    "grass-1": {
      "png": require("./../data/grass-1.png")
    },
    "grass-temp": {
      "png": require("./../data/grass-temp.png")
    },
    "grass-temp2": {
      "png": require("./../data/grass-temp2.png")
    },
    "grass-thin": {
      "png": require("./../data/grass-thin.png")
    },
    "ground-spawn-grasslands": {
      "png": require("./../data/ground-spawn-grasslands.png")
    },
    "ground-spawn-forest": {
      "png": require("./../data/ground-spawn-forest.png")
    },
    "ground-spawn-tundra": {
      "png": require("./../data/ground-spawn-tundra.png")
    },
    "hard-circle": {
      "png": require("./../data/hard-circle.png")
    },
    "ico_about": {
      "png": require("./../data/ico_about.png")
    },
    "lightray": {
      "png": require("./../data/lightray.png")
    },
    "lut-forest": {
      "png": require("./../data/lut-forest.png")
    },
    "lut-grasslands": {
      "png": require("./../data/lut-grasslands.png")
    },
    "lut-raw-no-post": {
      "png": require("./../data/lut-raw-no-post.png")
    },
    "lut-tundra5": {
      "png": require("./../data/lut-tundra5.png")
    },
    "lut-tundra6": {
      "png": require("./../data/lut-tundra6.png")
    },
    "lut-tundra": {
      "png": require("./../data/lut-tundra.png")
    },
    "soft-circle": {
      "png": require("./../data/soft-circle.png")
    },
    "water-distort": {
      "png": require("./../data/water-distort.png")
    },
    "water-noise": {
      "png": require("./../data/water-noise.png")
    }
  },
  "opaque": {
    "floor-overlay": {
      "jpg": require("./../opaque/floor-overlay.jpg")
    },
    "floor-tundra": {
      "jpg": require("./../opaque/floor-tundra.jpg")
    },
    "floor-path": {
      "jpg": require("./../opaque/floor-path.jpg")
    },
    "floor": {
      "jpg": require("./../opaque/floor.jpg")
    },
    "ice": {
      "jpg": require("./../opaque/ice.jpg")
    }
  },
  "svg": {
    "MAP": {
      "svg": require("./../svg/MAP.svg")
    },
    "back": {
      "svg": require("./../svg/back.svg")
    },
    "circle-24px": {
      "svg": require("./../svg/circle-24px.svg")
    },
    "code-24px": {
      "svg": require("./../svg/code-24px.svg")
    },
    "compass": {
      "svg": require("./../svg/compass.svg")
    },
    "create-24px": {
      "svg": require("./../svg/create-24px.svg")
    },
    "down-arrow": {
      "svg": require("./../svg/down-arrow.svg")
    },
    "exit": {
      "svg": require("./../svg/exit.svg")
    },
    "eye-24px": {
      "svg": require("./../svg/eye-24px.svg")
    },
    "ico_NFBONF": {
      "svg": require("./../svg/ico_NFBONF.svg")
    },
    "eye-off-24px": {
      "svg": require("./../svg/eye-off-24px.svg")
    },
    "icon-biome-forest": {
      "svg": require("./../svg/icon-biome-forest.svg")
    },
    "icon-audio": {
      "svg": require("./../svg/icon-audio.svg")
    },
    "icon-biome-grasslands": {
      "svg": require("./../svg/icon-biome-grasslands.svg")
    },
    "icon-biome-group": {
      "svg": require("./../svg/icon-biome-group.svg")
    },
    "icon-biome-tundra": {
      "svg": require("./../svg/icon-biome-tundra.svg")
    },
    "icon-compass": {
      "svg": require("./../svg/icon-compass.svg")
    },
    "icon-leaf-menu": {
      "svg": require("./../svg/icon-leaf-menu.svg")
    },
    "icon-leaf": {
      "svg": require("./../svg/icon-leaf.svg")
    },
    "icon-touch": {
      "svg": require("./../svg/icon-touch.svg")
    },
    "journal": {
      "svg": require("./../svg/journal.svg")
    },
    "keyboard_arrow_down-24px": {
      "svg": require("./../svg/keyboard_arrow_down-24px.svg")
    },
    "keyboard_arrow_right-24px": {
      "svg": require("./../svg/keyboard_arrow_right-24px.svg")
    },
    "loupe-24px": {
      "svg": require("./../svg/loupe-24px.svg")
    },
    "map-trail": {
      "svg": require("./../svg/map-trail.svg")
    },
    "menu": {
      "svg": require("./../svg/menu.svg")
    },
    "nfblogo": {
      "svg": require("./../svg/nfblogo.svg")
    },
    "rotate-smartphone": {
      "svg": require("./../svg/rotate-smartphone.svg")
    },
    "sound": {
      "svg": require("./../svg/sound.svg")
    },
    "title": {
      "svg": require("./../svg/title.svg")
    }
  },
  "tokens": {
    "ico_feather": {
      "png": require("./../tokens/ico_feather.png")
    },
    "ico_animal": {
      "png": require("./../tokens/ico_animal.png")
    },
    "ico_fish": {
      "png": require("./../tokens/ico_fish.png")
    },
    "ico_flower": {
      "png": require("./../tokens/ico_flower.png")
    },
    "ico_grass": {
      "png": require("./../tokens/ico_grass.png")
    },
    "ico_leaf": {
      "png": require("./../tokens/ico_leaf.png")
    },
    "ico_mist": {
      "png": require("./../tokens/ico_mist.png")
    },
    "ico_insect": {
      "png": require("./../tokens/ico_insect.png")
    },
    "ico_moon": {
      "png": require("./../tokens/ico_moon.png")
    },
    "ico_rain.": {
      "png": require("./../tokens/ico_rain..png")
    },
    "ico_stars": {
      "png": require("./../tokens/ico_stars.png")
    },
    "ico_snow": {
      "png": require("./../tokens/ico_snow.png")
    },
    "ico_storm": {
      "png": require("./../tokens/ico_storm.png")
    },
    "ico_sun": {
      "png": require("./../tokens/ico_sun.png")
    },
    "ico_tree": {
      "png": require("./../tokens/ico_tree.png")
    },
    "ico_wind": {
      "png": require("./../tokens/ico_wind.png")
    }
  },
  "tokens-collected": {
    "animal": {
      "png": require("./../tokens-collected/animal.png")
    },
    "fish": {
      "png": require("./../tokens-collected/fish.png")
    },
    "feather": {
      "png": require("./../tokens-collected/feather.png")
    },
    "flower": {
      "png": require("./../tokens-collected/flower.png")
    },
    "grass": {
      "png": require("./../tokens-collected/grass.png")
    },
    "insect": {
      "png": require("./../tokens-collected/insect.png")
    },
    "mist": {
      "png": require("./../tokens-collected/mist.png")
    },
    "leaf": {
      "png": require("./../tokens-collected/leaf.png")
    },
    "moon": {
      "png": require("./../tokens-collected/moon.png")
    },
    "stars": {
      "png": require("./../tokens-collected/stars.png")
    },
    "rain": {
      "png": require("./../tokens-collected/rain.png")
    },
    "snow": {
      "png": require("./../tokens-collected/snow.png")
    },
    "storm": {
      "png": require("./../tokens-collected/storm.png")
    },
    "tree": {
      "png": require("./../tokens-collected/tree.png")
    },
    "sun": {
      "png": require("./../tokens-collected/sun.png")
    },
    "wind": {
      "png": require("./../tokens-collected/wind.png")
    }
  },
  "tokens-inverted": {
    "ico_feather": {
      "png": require("./../tokens-inverted/ico_feather.png")
    },
    "ico_animal": {
      "png": require("./../tokens-inverted/ico_animal.png")
    },
    "ico_flower": {
      "png": require("./../tokens-inverted/ico_flower.png")
    },
    "ico_fish": {
      "png": require("./../tokens-inverted/ico_fish.png")
    },
    "ico_grass": {
      "png": require("./../tokens-inverted/ico_grass.png")
    },
    "ico_insect.": {
      "png": require("./../tokens-inverted/ico_insect..png")
    },
    "ico_leaf": {
      "png": require("./../tokens-inverted/ico_leaf.png")
    },
    "ico_mist": {
      "png": require("./../tokens-inverted/ico_mist.png")
    },
    "ico_moon": {
      "png": require("./../tokens-inverted/ico_moon.png")
    },
    "ico_rain": {
      "png": require("./../tokens-inverted/ico_rain.png")
    },
    "ico_snow": {
      "png": require("./../tokens-inverted/ico_snow.png")
    },
    "ico_storm": {
      "png": require("./../tokens-inverted/ico_storm.png")
    },
    "ico_stars": {
      "png": require("./../tokens-inverted/ico_stars.png")
    },
    "ico_sun": {
      "png": require("./../tokens-inverted/ico_sun.png")
    },
    "ico_wind": {
      "png": require("./../tokens-inverted/ico_wind.png")
    },
    "ico_tree": {
      "png": require("./../tokens-inverted/ico_tree.png")
    }
  },
  "ui": {
    "biomeforest-alt": {
      "png": require("./../ui/biomeforest-alt.png")
    },
    "biomeforest": {
      "png": require("./../ui/biomeforest.png")
    },
    "biomegrass-alt": {
      "png": require("./../ui/biomegrass-alt.png")
    },
    "biomegrass": {
      "png": require("./../ui/biomegrass.png")
    },
    "biometundra-alt": {
      "png": require("./../ui/biometundra-alt.png")
    },
    "biometundra": {
      "png": require("./../ui/biometundra.png")
    },
    "bird": {
      "png": require("./../ui/bird.png")
    },
    "btn_about": {
      "png": require("./../ui/btn_about.png")
    },
    "btn_about_long": {
      "png": require("./../ui/btn_about_long.png")
    },
    "btn_pause": {
      "png": require("./../ui/btn_pause.png")
    },
    "btn_restart": {
      "png": require("./../ui/btn_restart.png")
    },
    "btn_restart_shadow": {
      "png": require("./../ui/btn_restart_shadow.png")
    },
    "btn_restart_top": {
      "png": require("./../ui/btn_restart_top.png")
    },
    "btn_start": {
      "png": require("./../ui/btn_start.png")
    },
    "btn_start_shadow": {
      "png": require("./../ui/btn_start_shadow.png")
    },
    "close-button": {
      "png": require("./../ui/close-button.png")
    },
    "btn_start_top": {
      "png": require("./../ui/btn_start_top.png")
    },
    "compass1": {
      "png": require("./../ui/compass1.png")
    },
    "compass2": {
      "png": require("./../ui/compass2.png")
    },
    "compass3": {
      "png": require("./../ui/compass3.png")
    },
    "compass4": {
      "png": require("./../ui/compass4.png")
    },
    "empty_box": {
      "png": require("./../ui/empty_box.png")
    },
    "filled_box": {
      "png": require("./../ui/filled_box.png")
    },
    "finger-inv": {
      "png": require("./../ui/finger-inv.png")
    },
    "hint-card-left": {
      "png": require("./../ui/hint-card-left.png")
    },
    "finger": {
      "png": require("./../ui/finger.png")
    },
    "hint-card-middle": {
      "png": require("./../ui/hint-card-middle.png")
    },
    "ico_NFBONF": {
      "png": require("./../ui/ico_NFBONF.png")
    },
    "hint-card-right": {
      "png": require("./../ui/hint-card-right.png")
    },
    "ico_XcloseJournal": {
      "png": require("./../ui/ico_XcloseJournal.png")
    },
    "ico_about_orange": {
      "png": require("./../ui/ico_about_orange.png")
    },
    "ico_about": {
      "png": require("./../ui/ico_about.png")
    },
    "ico_closeJournal": {
      "png": require("./../ui/ico_closeJournal.png")
    },
    "ico_completedHaiku": {
      "png": require("./../ui/ico_completedHaiku.png")
    },
    "ico_emptyHaiku": {
      "png": require("./../ui/ico_emptyHaiku.png")
    },
    "ico_expand": {
      "png": require("./../ui/ico_expand.png")
    },
    "ico_emptytoken": {
      "png": require("./../ui/ico_emptytoken.png")
    },
    "ico_haiku": {
      "png": require("./../ui/ico_haiku.png")
    },
    "ico_haiku_leaf": {
      "png": require("./../ui/ico_haiku_leaf.png")
    },
    "ico_journal": {
      "png": require("./../ui/ico_journal.png")
    },
    "ico_languageSelect": {
      "png": require("./../ui/ico_languageSelect.png")
    },
    "ico_openjournal": {
      "png": require("./../ui/ico_openjournal.png")
    },
    "ico_paperJournal1-rotated": {
      "png": require("./../ui/ico_paperJournal1-rotated.png")
    },
    "ico_paperJournal1": {
      "png": require("./../ui/ico_paperJournal1.png")
    },
    "ico_paperJournal2-rotated": {
      "png": require("./../ui/ico_paperJournal2-rotated.png")
    },
    "ico_paperJournal2": {
      "png": require("./../ui/ico_paperJournal2.png")
    },
    "ico_popupHaiku-straight": {
      "png": require("./../ui/ico_popupHaiku-straight.png")
    },
    "ico_popupHaiku": {
      "png": require("./../ui/ico_popupHaiku.png")
    },
    "ico_restart": {
      "png": require("./../ui/ico_restart.png")
    },
    "ico_resume": {
      "png": require("./../ui/ico_resume.png")
    },
    "ico_scrollbar": {
      "png": require("./../ui/ico_scrollbar.png")
    },
    "ico_toggle": {
      "png": require("./../ui/ico_toggle.png")
    },
    "ico_volume": {
      "png": require("./../ui/ico_volume.png")
    },
    "ico_volume_bar": {
      "png": require("./../ui/ico_volume_bar.png")
    },
    "ico_volume_gauge": {
      "png": require("./../ui/ico_volume_gauge.png")
    },
    "ico_volume_toggle": {
      "png": require("./../ui/ico_volume_toggle.png")
    },
    "title2_en": {
      "png": require("./../ui/title2_en.png")
    },
    "title2_fr": {
      "png": require("./../ui/title2_fr.png")
    },
    "title2_en_leaf": {
      "png": require("./../ui/title2_en_leaf.png")
    },
    "title2_fr_leaf": {
      "png": require("./../ui/title2_fr_leaf.png")
    },
    "touch-inv": {
      "png": require("./../ui/touch-inv.png")
    },
    "touch": {
      "png": require("./../ui/touch.png")
    },
    "tree-inv": {
      "png": require("./../ui/tree-inv.png")
    },
    "tree": {
      "png": require("./../ui/tree.png")
    },
    "vertical-rule": {
      "png": require("./../ui/vertical-rule.png")
    },
    "wayfinder_placeholder": {
      "png": require("./../ui/wayfinder_placeholder.png")
    }
  }
};
},{"./../data/bluenoise-0.png":"src/assets/image/data/bluenoise-0.png","./../data/bluenoise-1.png":"src/assets/image/data/bluenoise-1.png","./../data/bluenoise-2.png":"src/assets/image/data/bluenoise-2.png","./../data/bluenoise-3.png":"src/assets/image/data/bluenoise-3.png","./../data/compass-arrow.png":"src/assets/image/data/compass-arrow.png","./../data/cape-texture-landscape-1024.png":"src/assets/image/data/cape-texture-landscape-1024.png","./../data/compass-arrow2.png":"src/assets/image/data/compass-arrow2.png","./../data/compass-dot.png":"src/assets/image/data/compass-dot.png","./../data/compass-arrow3.png":"src/assets/image/data/compass-arrow3.png","./../data/compass-ring.png":"src/assets/image/data/compass-ring.png","./../data/floating-paper-lines.png":"src/assets/image/data/floating-paper-lines.png","./../data/floating-paper.png":"src/assets/image/data/floating-paper.png","./../data/grass-1.png":"src/assets/image/data/grass-1.png","./../data/grass-temp.png":"src/assets/image/data/grass-temp.png","./../data/grass-temp2.png":"src/assets/image/data/grass-temp2.png","./../data/grass-thin.png":"src/assets/image/data/grass-thin.png","./../data/ground-spawn-grasslands.png":"src/assets/image/data/ground-spawn-grasslands.png","./../data/ground-spawn-forest.png":"src/assets/image/data/ground-spawn-forest.png","./../data/ground-spawn-tundra.png":"src/assets/image/data/ground-spawn-tundra.png","./../data/hard-circle.png":"src/assets/image/data/hard-circle.png","./../data/ico_about.png":"src/assets/image/data/ico_about.png","./../data/lightray.png":"src/assets/image/data/lightray.png","./../data/lut-forest.png":"src/assets/image/data/lut-forest.png","./../data/lut-grasslands.png":"src/assets/image/data/lut-grasslands.png","./../data/lut-raw-no-post.png":"src/assets/image/data/lut-raw-no-post.png","./../data/lut-tundra5.png":"src/assets/image/data/lut-tundra5.png","./../data/lut-tundra6.png":"src/assets/image/data/lut-tundra6.png","./../data/lut-tundra.png":"src/assets/image/data/lut-tundra.png","./../data/soft-circle.png":"src/assets/image/data/soft-circle.png","./../data/water-distort.png":"src/assets/image/data/water-distort.png","./../data/water-noise.png":"src/assets/image/data/water-noise.png","./../opaque/floor-overlay.jpg":"src/assets/image/opaque/floor-overlay.jpg","./../opaque/floor-tundra.jpg":"src/assets/image/opaque/floor-tundra.jpg","./../opaque/floor-path.jpg":"src/assets/image/opaque/floor-path.jpg","./../opaque/floor.jpg":"src/assets/image/opaque/floor.jpg","./../opaque/ice.jpg":"src/assets/image/opaque/ice.jpg","./../svg/MAP.svg":"src/assets/image/svg/MAP.svg","./../svg/back.svg":"src/assets/image/svg/back.svg","./../svg/circle-24px.svg":"src/assets/image/svg/circle-24px.svg","./../svg/code-24px.svg":"src/assets/image/svg/code-24px.svg","./../svg/compass.svg":"src/assets/image/svg/compass.svg","./../svg/create-24px.svg":"src/assets/image/svg/create-24px.svg","./../svg/down-arrow.svg":"src/assets/image/svg/down-arrow.svg","./../svg/exit.svg":"src/assets/image/svg/exit.svg","./../svg/eye-24px.svg":"src/assets/image/svg/eye-24px.svg","./../svg/ico_NFBONF.svg":"src/assets/image/svg/ico_NFBONF.svg","./../svg/eye-off-24px.svg":"src/assets/image/svg/eye-off-24px.svg","./../svg/icon-biome-forest.svg":"src/assets/image/svg/icon-biome-forest.svg","./../svg/icon-audio.svg":"src/assets/image/svg/icon-audio.svg","./../svg/icon-biome-grasslands.svg":"src/assets/image/svg/icon-biome-grasslands.svg","./../svg/icon-biome-group.svg":"src/assets/image/svg/icon-biome-group.svg","./../svg/icon-biome-tundra.svg":"src/assets/image/svg/icon-biome-tundra.svg","./../svg/icon-compass.svg":"src/assets/image/svg/icon-compass.svg","./../svg/icon-leaf-menu.svg":"src/assets/image/svg/icon-leaf-menu.svg","./../svg/icon-leaf.svg":"src/assets/image/svg/icon-leaf.svg","./../svg/icon-touch.svg":"src/assets/image/svg/icon-touch.svg","./../svg/journal.svg":"src/assets/image/svg/journal.svg","./../svg/keyboard_arrow_down-24px.svg":"src/assets/image/svg/keyboard_arrow_down-24px.svg","./../svg/keyboard_arrow_right-24px.svg":"src/assets/image/svg/keyboard_arrow_right-24px.svg","./../svg/loupe-24px.svg":"src/assets/image/svg/loupe-24px.svg","./../svg/map-trail.svg":"src/assets/image/svg/map-trail.svg","./../svg/menu.svg":"src/assets/image/svg/menu.svg","./../svg/nfblogo.svg":"src/assets/image/svg/nfblogo.svg","./../svg/rotate-smartphone.svg":"src/assets/image/svg/rotate-smartphone.svg","./../svg/sound.svg":"src/assets/image/svg/sound.svg","./../svg/title.svg":"src/assets/image/svg/title.svg","./../tokens/ico_feather.png":"src/assets/image/tokens/ico_feather.png","./../tokens/ico_animal.png":"src/assets/image/tokens/ico_animal.png","./../tokens/ico_fish.png":"src/assets/image/tokens/ico_fish.png","./../tokens/ico_flower.png":"src/assets/image/tokens/ico_flower.png","./../tokens/ico_grass.png":"src/assets/image/tokens/ico_grass.png","./../tokens/ico_leaf.png":"src/assets/image/tokens/ico_leaf.png","./../tokens/ico_mist.png":"src/assets/image/tokens/ico_mist.png","./../tokens/ico_insect.png":"src/assets/image/tokens/ico_insect.png","./../tokens/ico_moon.png":"src/assets/image/tokens/ico_moon.png","./../tokens/ico_rain..png":"src/assets/image/tokens/ico_rain..png","./../tokens/ico_stars.png":"src/assets/image/tokens/ico_stars.png","./../tokens/ico_snow.png":"src/assets/image/tokens/ico_snow.png","./../tokens/ico_storm.png":"src/assets/image/tokens/ico_storm.png","./../tokens/ico_sun.png":"src/assets/image/tokens/ico_sun.png","./../tokens/ico_tree.png":"src/assets/image/tokens/ico_tree.png","./../tokens/ico_wind.png":"src/assets/image/tokens/ico_wind.png","./../tokens-collected/animal.png":"src/assets/image/tokens-collected/animal.png","./../tokens-collected/fish.png":"src/assets/image/tokens-collected/fish.png","./../tokens-collected/feather.png":"src/assets/image/tokens-collected/feather.png","./../tokens-collected/flower.png":"src/assets/image/tokens-collected/flower.png","./../tokens-collected/grass.png":"src/assets/image/tokens-collected/grass.png","./../tokens-collected/insect.png":"src/assets/image/tokens-collected/insect.png","./../tokens-collected/mist.png":"src/assets/image/tokens-collected/mist.png","./../tokens-collected/leaf.png":"src/assets/image/tokens-collected/leaf.png","./../tokens-collected/moon.png":"src/assets/image/tokens-collected/moon.png","./../tokens-collected/stars.png":"src/assets/image/tokens-collected/stars.png","./../tokens-collected/rain.png":"src/assets/image/tokens-collected/rain.png","./../tokens-collected/snow.png":"src/assets/image/tokens-collected/snow.png","./../tokens-collected/storm.png":"src/assets/image/tokens-collected/storm.png","./../tokens-collected/tree.png":"src/assets/image/tokens-collected/tree.png","./../tokens-collected/sun.png":"src/assets/image/tokens-collected/sun.png","./../tokens-collected/wind.png":"src/assets/image/tokens-collected/wind.png","./../tokens-inverted/ico_feather.png":"src/assets/image/tokens-inverted/ico_feather.png","./../tokens-inverted/ico_animal.png":"src/assets/image/tokens-inverted/ico_animal.png","./../tokens-inverted/ico_flower.png":"src/assets/image/tokens-inverted/ico_flower.png","./../tokens-inverted/ico_fish.png":"src/assets/image/tokens-inverted/ico_fish.png","./../tokens-inverted/ico_grass.png":"src/assets/image/tokens-inverted/ico_grass.png","./../tokens-inverted/ico_insect..png":"src/assets/image/tokens-inverted/ico_insect..png","./../tokens-inverted/ico_leaf.png":"src/assets/image/tokens-inverted/ico_leaf.png","./../tokens-inverted/ico_mist.png":"src/assets/image/tokens-inverted/ico_mist.png","./../tokens-inverted/ico_moon.png":"src/assets/image/tokens-inverted/ico_moon.png","./../tokens-inverted/ico_rain.png":"src/assets/image/tokens-inverted/ico_rain.png","./../tokens-inverted/ico_snow.png":"src/assets/image/tokens-inverted/ico_snow.png","./../tokens-inverted/ico_storm.png":"src/assets/image/tokens-inverted/ico_storm.png","./../tokens-inverted/ico_stars.png":"src/assets/image/tokens-inverted/ico_stars.png","./../tokens-inverted/ico_sun.png":"src/assets/image/tokens-inverted/ico_sun.png","./../tokens-inverted/ico_wind.png":"src/assets/image/tokens-inverted/ico_wind.png","./../tokens-inverted/ico_tree.png":"src/assets/image/tokens-inverted/ico_tree.png","./../ui/biomeforest-alt.png":"src/assets/image/ui/biomeforest-alt.png","./../ui/biomeforest.png":"src/assets/image/ui/biomeforest.png","./../ui/biomegrass-alt.png":"src/assets/image/ui/biomegrass-alt.png","./../ui/biomegrass.png":"src/assets/image/ui/biomegrass.png","./../ui/biometundra-alt.png":"src/assets/image/ui/biometundra-alt.png","./../ui/biometundra.png":"src/assets/image/ui/biometundra.png","./../ui/bird.png":"src/assets/image/ui/bird.png","./../ui/btn_about.png":"src/assets/image/ui/btn_about.png","./../ui/btn_about_long.png":"src/assets/image/ui/btn_about_long.png","./../ui/btn_pause.png":"src/assets/image/ui/btn_pause.png","./../ui/btn_restart.png":"src/assets/image/ui/btn_restart.png","./../ui/btn_restart_shadow.png":"src/assets/image/ui/btn_restart_shadow.png","./../ui/btn_restart_top.png":"src/assets/image/ui/btn_restart_top.png","./../ui/btn_start.png":"src/assets/image/ui/btn_start.png","./../ui/btn_start_shadow.png":"src/assets/image/ui/btn_start_shadow.png","./../ui/close-button.png":"src/assets/image/ui/close-button.png","./../ui/btn_start_top.png":"src/assets/image/ui/btn_start_top.png","./../ui/compass1.png":"src/assets/image/ui/compass1.png","./../ui/compass2.png":"src/assets/image/ui/compass2.png","./../ui/compass3.png":"src/assets/image/ui/compass3.png","./../ui/compass4.png":"src/assets/image/ui/compass4.png","./../ui/empty_box.png":"src/assets/image/ui/empty_box.png","./../ui/filled_box.png":"src/assets/image/ui/filled_box.png","./../ui/finger-inv.png":"src/assets/image/ui/finger-inv.png","./../ui/hint-card-left.png":"src/assets/image/ui/hint-card-left.png","./../ui/finger.png":"src/assets/image/ui/finger.png","./../ui/hint-card-middle.png":"src/assets/image/ui/hint-card-middle.png","./../ui/ico_NFBONF.png":"src/assets/image/ui/ico_NFBONF.png","./../ui/hint-card-right.png":"src/assets/image/ui/hint-card-right.png","./../ui/ico_XcloseJournal.png":"src/assets/image/ui/ico_XcloseJournal.png","./../ui/ico_about_orange.png":"src/assets/image/ui/ico_about_orange.png","./../ui/ico_about.png":"src/assets/image/ui/ico_about.png","./../ui/ico_closeJournal.png":"src/assets/image/ui/ico_closeJournal.png","./../ui/ico_completedHaiku.png":"src/assets/image/ui/ico_completedHaiku.png","./../ui/ico_emptyHaiku.png":"src/assets/image/ui/ico_emptyHaiku.png","./../ui/ico_expand.png":"src/assets/image/ui/ico_expand.png","./../ui/ico_emptytoken.png":"src/assets/image/ui/ico_emptytoken.png","./../ui/ico_haiku.png":"src/assets/image/ui/ico_haiku.png","./../ui/ico_haiku_leaf.png":"src/assets/image/ui/ico_haiku_leaf.png","./../ui/ico_journal.png":"src/assets/image/ui/ico_journal.png","./../ui/ico_languageSelect.png":"src/assets/image/ui/ico_languageSelect.png","./../ui/ico_openjournal.png":"src/assets/image/ui/ico_openjournal.png","./../ui/ico_paperJournal1-rotated.png":"src/assets/image/ui/ico_paperJournal1-rotated.png","./../ui/ico_paperJournal1.png":"src/assets/image/ui/ico_paperJournal1.png","./../ui/ico_paperJournal2-rotated.png":"src/assets/image/ui/ico_paperJournal2-rotated.png","./../ui/ico_paperJournal2.png":"src/assets/image/ui/ico_paperJournal2.png","./../ui/ico_popupHaiku-straight.png":"src/assets/image/ui/ico_popupHaiku-straight.png","./../ui/ico_popupHaiku.png":"src/assets/image/ui/ico_popupHaiku.png","./../ui/ico_restart.png":"src/assets/image/ui/ico_restart.png","./../ui/ico_resume.png":"src/assets/image/ui/ico_resume.png","./../ui/ico_scrollbar.png":"src/assets/image/ui/ico_scrollbar.png","./../ui/ico_toggle.png":"src/assets/image/ui/ico_toggle.png","./../ui/ico_volume.png":"src/assets/image/ui/ico_volume.png","./../ui/ico_volume_bar.png":"src/assets/image/ui/ico_volume_bar.png","./../ui/ico_volume_gauge.png":"src/assets/image/ui/ico_volume_gauge.png","./../ui/ico_volume_toggle.png":"src/assets/image/ui/ico_volume_toggle.png","./../ui/title2_en.png":"src/assets/image/ui/title2_en.png","./../ui/title2_fr.png":"src/assets/image/ui/title2_fr.png","./../ui/title2_en_leaf.png":"src/assets/image/ui/title2_en_leaf.png","./../ui/title2_fr_leaf.png":"src/assets/image/ui/title2_fr_leaf.png","./../ui/touch-inv.png":"src/assets/image/ui/touch-inv.png","./../ui/touch.png":"src/assets/image/ui/touch.png","./../ui/tree-inv.png":"src/assets/image/ui/tree-inv.png","./../ui/tree.png":"src/assets/image/ui/tree.png","./../ui/vertical-rule.png":"src/assets/image/ui/vertical-rule.png","./../ui/wayfinder_placeholder.png":"src/assets/image/ui/wayfinder_placeholder.png"}],"src/assets/spritesheets/bird_fly.png":[function(require,module,exports) {
module.exports = "/bird_fly.5dfd20d3.png";
},{}],"src/assets/spritesheets/bird_still.png":[function(require,module,exports) {
module.exports = "/bird_still.f67fb49b.png";
},{}],"src/assets/spritesheets/butterfly.png":[function(require,module,exports) {
module.exports = "/butterfly.eb0b666b.png";
},{}],"src/assets/spritesheets/butterfly.sheet":[function(require,module,exports) {
module.exports = "/butterfly.a0f2292e.sheet";
},{}],"src/assets/spritesheets/fish.png":[function(require,module,exports) {
module.exports = "/fish.287efbe4.png";
},{}],"src/assets/spritesheets/fish.sheet":[function(require,module,exports) {
module.exports = "/fish.313f4586.sheet";
},{}],"src/assets/spritesheets/fox.png":[function(require,module,exports) {
module.exports = "/fox.9b8e29b6.png";
},{}],"src/assets/spritesheets/fox.sheet":[function(require,module,exports) {
module.exports = "/fox.d5dc78c8.sheet";
},{}],"src/assets/spritesheets/fox_sleep.png":[function(require,module,exports) {
module.exports = "/fox_sleep.73ae7da9.png";
},{}],"src/assets/spritesheets/fox_sleep.sheet":[function(require,module,exports) {
module.exports = "/fox_sleep.598ef84c.sheet";
},{}],"src/assets/spritesheets/fox_wakesup.png":[function(require,module,exports) {
module.exports = "/fox_wakesup.2e5e79a2.png";
},{}],"src/assets/spritesheets/fox_wakesup.sheet":[function(require,module,exports) {
module.exports = "/fox_wakesup.37119a25.sheet";
},{}],"src/assets/spritesheets/ground-flowers.png":[function(require,module,exports) {
module.exports = "/ground-flowers.f2d2bf1f.png";
},{}],"src/assets/spritesheets/ground-flowers.sheet":[function(require,module,exports) {
module.exports = "/ground-flowers.9e712464.sheet";
},{}],"src/assets/spritesheets/jumpingrabbit.png":[function(require,module,exports) {
module.exports = "/jumpingrabbit.2c1a3757.png";
},{}],"src/assets/spritesheets/jumpingrabbit.sheet":[function(require,module,exports) {
module.exports = "/jumpingrabbit.422ece05.sheet";
},{}],"src/assets/spritesheets/owl.png":[function(require,module,exports) {
module.exports = "/owl.db5dba82.png";
},{}],"src/assets/spritesheets/owl_sleep.png":[function(require,module,exports) {
module.exports = "/owl_sleep.b3e802fd.png";
},{}],"src/assets/spritesheets/owl_wakeup.png":[function(require,module,exports) {
module.exports = "/owl_wakeup.5cd3f99d.png";
},{}],"src/assets/spritesheets/rabbit.png":[function(require,module,exports) {
module.exports = "/rabbit.c6e297d9.png";
},{}],"src/assets/spritesheets/seal.png":[function(require,module,exports) {
module.exports = "/seal.1c2a3530.png";
},{}],"src/assets/spritesheets/temp_grass_sprites.png":[function(require,module,exports) {
module.exports = "/temp_grass_sprites.e65f38f9.png";
},{}],"src/assets/spritesheets/temp_grass_sprites.sheet":[function(require,module,exports) {
module.exports = "/temp_grass_sprites.9ea244d0.sheet";
},{}],"src/assets/spritesheets/temp_sprites-0.png":[function(require,module,exports) {
module.exports = "/temp_sprites-0.9c001956.png";
},{}],"src/assets/spritesheets/temp_sprites-0.sheet":[function(require,module,exports) {
module.exports = "/temp_sprites-0.96ee59ae.sheet";
},{}],"src/assets/spritesheets/temp_sprites-1.png":[function(require,module,exports) {
module.exports = "/temp_sprites-1.86e1f92b.png";
},{}],"src/assets/spritesheets/temp_sprites-1.sheet":[function(require,module,exports) {
module.exports = "/temp_sprites-1.b6d75478.sheet";
},{}],"src/assets/spritesheets/temp_sprites-2.png":[function(require,module,exports) {
module.exports = "/temp_sprites-2.64f0141a.png";
},{}],"src/assets/spritesheets/temp_sprites-2.sheet":[function(require,module,exports) {
module.exports = "/temp_sprites-2.0025142b.sheet";
},{}],"src/assets/spritesheets/tokens.png":[function(require,module,exports) {
module.exports = "/tokens.adf8cbff.png";
},{}],"src/assets/spritesheets/tokens.sheet":[function(require,module,exports) {
module.exports = "/tokens.d1e04ac0.sheet";
},{}],"src/assets/spritesheets/tree-anim-a.png":[function(require,module,exports) {
module.exports = "/tree-anim-a.dc4a8091.png";
},{}],"src/assets/spritesheets/tree-anim-a.sheet":[function(require,module,exports) {
module.exports = "/tree-anim-a.cec80452.sheet";
},{}],"src/assets/spritesheets/tree-anim-b.png":[function(require,module,exports) {
module.exports = "/tree-anim-b.239632e2.png";
},{}],"src/assets/spritesheets/tree-anim-b.sheet":[function(require,module,exports) {
module.exports = "/tree-anim-b.c84b5aca.sheet";
},{}],"src/assets/spritesheets/tree-anim-c.png":[function(require,module,exports) {
module.exports = "/tree-anim-c.a8cbbfc0.png";
},{}],"src/assets/spritesheets/tree-anim-c.sheet":[function(require,module,exports) {
module.exports = "/tree-anim-c.981d0444.sheet";
},{}],"src/assets/spritesheets/*.{sheet,png,jpeg,jpg}":[function(require,module,exports) {
module.exports = {
  "bird_fly": {
    "png": require("./bird_fly.png")
  },
  "bird_still": {
    "png": require("./bird_still.png")
  },
  "butterfly": {
    "png": require("./butterfly.png"),
    "sheet": require("./butterfly.sheet")
  },
  "fish": {
    "png": require("./fish.png"),
    "sheet": require("./fish.sheet")
  },
  "fox": {
    "png": require("./fox.png"),
    "sheet": require("./fox.sheet")
  },
  "fox_sleep": {
    "png": require("./fox_sleep.png"),
    "sheet": require("./fox_sleep.sheet")
  },
  "fox_wakesup": {
    "png": require("./fox_wakesup.png"),
    "sheet": require("./fox_wakesup.sheet")
  },
  "ground-flowers": {
    "png": require("./ground-flowers.png"),
    "sheet": require("./ground-flowers.sheet")
  },
  "jumpingrabbit": {
    "png": require("./jumpingrabbit.png"),
    "sheet": require("./jumpingrabbit.sheet")
  },
  "owl": {
    "png": require("./owl.png")
  },
  "owl_sleep": {
    "png": require("./owl_sleep.png")
  },
  "owl_wakeup": {
    "png": require("./owl_wakeup.png")
  },
  "rabbit": {
    "png": require("./rabbit.png")
  },
  "seal": {
    "png": require("./seal.png")
  },
  "temp_grass_sprites": {
    "png": require("./temp_grass_sprites.png"),
    "sheet": require("./temp_grass_sprites.sheet")
  },
  "temp_sprites-0": {
    "png": require("./temp_sprites-0.png"),
    "sheet": require("./temp_sprites-0.sheet")
  },
  "temp_sprites-1": {
    "png": require("./temp_sprites-1.png"),
    "sheet": require("./temp_sprites-1.sheet")
  },
  "temp_sprites-2": {
    "png": require("./temp_sprites-2.png"),
    "sheet": require("./temp_sprites-2.sheet")
  },
  "tokens": {
    "png": require("./tokens.png"),
    "sheet": require("./tokens.sheet")
  },
  "tree-anim-a": {
    "png": require("./tree-anim-a.png"),
    "sheet": require("./tree-anim-a.sheet")
  },
  "tree-anim-b": {
    "png": require("./tree-anim-b.png"),
    "sheet": require("./tree-anim-b.sheet")
  },
  "tree-anim-c": {
    "png": require("./tree-anim-c.png"),
    "sheet": require("./tree-anim-c.sheet")
  }
};
},{"./bird_fly.png":"src/assets/spritesheets/bird_fly.png","./bird_still.png":"src/assets/spritesheets/bird_still.png","./butterfly.png":"src/assets/spritesheets/butterfly.png","./butterfly.sheet":"src/assets/spritesheets/butterfly.sheet","./fish.png":"src/assets/spritesheets/fish.png","./fish.sheet":"src/assets/spritesheets/fish.sheet","./fox.png":"src/assets/spritesheets/fox.png","./fox.sheet":"src/assets/spritesheets/fox.sheet","./fox_sleep.png":"src/assets/spritesheets/fox_sleep.png","./fox_sleep.sheet":"src/assets/spritesheets/fox_sleep.sheet","./fox_wakesup.png":"src/assets/spritesheets/fox_wakesup.png","./fox_wakesup.sheet":"src/assets/spritesheets/fox_wakesup.sheet","./ground-flowers.png":"src/assets/spritesheets/ground-flowers.png","./ground-flowers.sheet":"src/assets/spritesheets/ground-flowers.sheet","./jumpingrabbit.png":"src/assets/spritesheets/jumpingrabbit.png","./jumpingrabbit.sheet":"src/assets/spritesheets/jumpingrabbit.sheet","./owl.png":"src/assets/spritesheets/owl.png","./owl_sleep.png":"src/assets/spritesheets/owl_sleep.png","./owl_wakeup.png":"src/assets/spritesheets/owl_wakeup.png","./rabbit.png":"src/assets/spritesheets/rabbit.png","./seal.png":"src/assets/spritesheets/seal.png","./temp_grass_sprites.png":"src/assets/spritesheets/temp_grass_sprites.png","./temp_grass_sprites.sheet":"src/assets/spritesheets/temp_grass_sprites.sheet","./temp_sprites-0.png":"src/assets/spritesheets/temp_sprites-0.png","./temp_sprites-0.sheet":"src/assets/spritesheets/temp_sprites-0.sheet","./temp_sprites-1.png":"src/assets/spritesheets/temp_sprites-1.png","./temp_sprites-1.sheet":"src/assets/spritesheets/temp_sprites-1.sheet","./temp_sprites-2.png":"src/assets/spritesheets/temp_sprites-2.png","./temp_sprites-2.sheet":"src/assets/spritesheets/temp_sprites-2.sheet","./tokens.png":"src/assets/spritesheets/tokens.png","./tokens.sheet":"src/assets/spritesheets/tokens.sheet","./tree-anim-a.png":"src/assets/spritesheets/tree-anim-a.png","./tree-anim-a.sheet":"src/assets/spritesheets/tree-anim-a.sheet","./tree-anim-b.png":"src/assets/spritesheets/tree-anim-b.png","./tree-anim-b.sheet":"src/assets/spritesheets/tree-anim-b.sheet","./tree-anim-c.png":"src/assets/spritesheets/tree-anim-c.png","./tree-anim-c.sheet":"src/assets/spritesheets/tree-anim-c.sheet"}],"src/assets/json/haiku-phrases-en.json":[function(require,module,exports) {
module.exports = module.exports = {
  animal: [["distant wolf howling", "following wolf prints", "horned owl hoots above", "squirrels chasing by", "soft squirrel chatter", "otter softly sleeps", "bears hunting for fish", "following deer tracks", "wolf calls from afar"], ["a beaver's wake", "a coyote howls", "a deer hesitates", "a squirrel climbs", "a squirrel burrows", "the wolf howl fades"], ["above the bears den", "from a moose's chin", "across the wolf tracks"]],
  feather: [["wakened by birdsong", "scuffle of feathered wings", "drifting sparrow song", "birds lost in flight", "loons scatter away", "birdsong from above", "feather falls on grass", "wing beats overhead", "ducks paddling along", "evening birdsong"], ["the owl feather", "a seagulls flight", "the sparrows songs", "sparrow-song skitters", "a bird emerges", "an eagles talon", "birdsongs breaking", "the sound of wings", "goose honks echo", "a swell of swallows", "a faint birdsong"], ["in the cidadas chirp", "in a mockingbirds song", "in the bird nest", "between bird songs", "on a blackbirds wing", "by the loons call"]],
  fish: [["fly fishing again", "fish scale shine", "little fishes swim", "frogs croaking at dawn", "fish breaks the surface", "fish swimming upstream", "by the frog pond"], ["a fish leaps", "the frog's mouth", "a frog syncopates", "a fish rests", "a water snake"], ["as the trout rises"]],
  flower: [["three petals falling", "spring feel in the air", "yesterdays flowers", "approaching spring bloom", "half-blown dandelion", "sunflowers in bloom", "dandelion wishes", "air full of pollen", "picking spring flowers", "lilacs in full bloom", "when lavendar blooms", "suddenly spring"], ["a dandelion's dance", "the flower falls", "the first sunflower", "the tomato flowers", "a shower of petals", "the daffodil stems", "a field of dandelion fluffs", "the petals fall", "the wildflowers", "every flower", "a yellow dandelion", "the scent of lilacs", "sunflowers sway", "the roses shift", "flowers fading", "a fresh bloom", "iris in bloom", "the silk flowers", "a pear blossoms"], ["amid plum blossoms", "in the wildflowers", "in the dandelions", "through the blossoming cherries", "between the sunflowers", "in bloom", "into the sunflowers", "on the petals", "between roses", "into wildflowers", "from the roses", "between flowers", "between the flowers", "into blossoms", "in full bloom"]],
  grass: [["whistling across fields", "rhythmic blowing grass", "swaying knee-high grass", "dancing grass meadows", "dancing blades of grass", "wide open meadows", "wide sunlit meadows", "grass swaying rhythm"], ["the grass trapped", "the long grass", "the overgrown field", "grasses tiptoe", "the vastness of fields", "the smell of grass", "a wheat field rippling"], ["on a field", "across the meadows", "in the dry grass", "in the grasses", "above the sunlit meadow", "over the autumn fields", "above the fields", "through the grass", "in the field", "over the field", "on the meadow"]],
  insect: [["hornets buzzing by", "bees floating above", "spider's web catching", "weaving spider threads", "bee drifts to flower", "dancing butterflies", "mosquitos buzzing", "on dragonfly wings", "butterfly shadows", "caterpillars inch", "fluttering moth wind", "chasing butterflies"], ["a spider catches", "a worm writhes", "the blur of insects", "a moth escapes", "the flow of ants", "a wasp struggles", "a mosquito's buzz", "a butterfly's quest", "a grasshopper leaps", "an ant moves", "the moth's reflection", "the spider shadow moves", "a caterpillar reaches", "the grasshopper visits", "a wasp nest tumbles", "a spider hangs", "a bee floats", "a moth stirs", "a bee lands", "a spiders thread", "the spiders web", "the firefly glow"], ["inside the caterpillars tent", "over butterflies", "in a spider's web", "on a spider's thread"]],
  leaf: [["leaf shadows stipple", "leaves falling above", "falling maple leaf", "leaves drifting behind", "leaves rustling away", "falling leaf shadow", "finding scattered leaves", "leaves stirring softly", "leaf-catching at dusk"], ["a dry leaf", "a leaf falls", "a single leaf", "leaf shadow weaves", "the leaves fall", "each leaf brimming", "a leaf falling", "autumn leaves", "another leaf flutters", "the leaf shadow spreads"], ["in the leaf shadows", "on every leaf", "through the sunlit leaf", "beyond the leaf edge"]],
  mist: [["through dense morning haze", "lifting mist reveals", "rolling skyline fog", "haze over the hills", "morning dew drop mist", "shifting mist shadows", "caught in flowing mist", "autumn mist deepens", "horizon fog shifts"], ["one dew drop", "shrouded in mist", "fog climbing", "patches of fog", "the fog rises"], ["in the mist", "in the fog", "through the fog", "between the mist", "in the autumn haze", "in winter mist", "through the morning fog", "in the autumn mist", "in river mist", "into fog", "through the dew", "on the fog", "from the fog", "into mist", "through the mist"]],
  moon: [["moonless autumn night", "ambrosia moon night", "fireflies light the way", "moonless night again", "another moon day", "moonlight casts shadows", "moon gazing again", "dappled moon-lit floor", "moonlit stillness falls"], ["the moon dances", "a path of moonlight", "lost in the night", "the moon swallows", "the darkness lengthens", "the silence of the moon", "the moonlight lengthens", "the moons reflection", "moon shadows drift", "the silver of the moon", "moonlight reveals"], ["in the clear night", "against the night sky", "under the moonlight", "between the moon", "under a waning moon", "on a moonless night", "across the moon", "in the moonlight"]],
  rain: [["afternoon drizzle", "caught in sudden rain", "waiting for the rains", "pitter-patter rain", "chorus of rainfall", "steady rain drumming", "through sheets of rainfall", "quiet rain drop sounds"], ["the water falls", "a tumult of rain", "the river flowing", "rain bubbles burst", "a raindrop falls", "the soft rain", "the patter of raindrops", "the first raindrops", "another drop of rain", "the sound of water", "the weight of raindrops", "the pelting rain"], ["after the rain", "through the rain", "in every puddle", "before the rain", "under the rain", "in the gentle rain", "at the waters edge", "under the endless rain", "between raindrops", "on the water's surface"]],
  snow: [["snow-covered mountains", "footprints in the snow", "cold mountain shadow", "late winter morning", "soundless snowflakes fall", "quiet fall of snow", "snowflakes whirl into", "snow bent pine branches", "snowflakes blend and blur"], ["a fresh snow angel", "the shadow of snow", "a snowflake slides", "snow gathers", "a snowflake resting", "another inch of snow", "snowflakes melting", "the winter sky darkens", "snowflakes falling", "the sound of snow", "a snowflake caught", "a snowflake melts", "snowflakes blowing", "snowflakes collecting", "a hint of winter"], ["after the first freeze", "beneath the ice", "along the ice cracks", "in the winter haze", "between ice floes", "in the winter chill", "against the snow"]],
  stars: [["star speckled night sky", "watching shooting stars", "star gazing again", "distant stars sparkle", "pale stars far above", "twinkling starry sky", "scattered star-light falls", "below falling stars", "between glowing stars"], ["another star appears", "blizzards of stars", "a thread of light", "the stars peering", "a star falls from", "a shooting star", "a glimmer of light", "quivers of light"], ["against the light", "after the stars", "beyond the lights", "under the stars", "into the light", "against the stars", "between the stars"]],
  storm: [["sudden thunderclap!", "watching summer clouds", "whispering thunder", "looming storm clouds drift", "lightning flashes blind", "approaching storm cloud", "distant lightning crash", "storm-washed horizon", "mountain-top thunder", "rolling thunder wave"], ["clouds break", "the space between clouds", "the soft boom", "a flash of lightning", "a distant cloud rains", "a cloud passes through", "clap of thunder"], ["after the storm", "before the storm", "above the clouds", "after the hurricane", "through the storm", "in the clouds", "in a flash", "as thunder recedes", "through the storm door", "in the storms eye", "behind a cloud"]],
  sun: [["lengthening shadows", "warm summer morning", "last rays of sunset", "shadows in the sun", "pale sun flickering", "afternoon shadows", "sun-dappled shadows", "shimmering summer", "sun-soaked horizon", "shimmering sun lights"], ["a ray of sunshine streams", "the suns warmth", "fleeting sun shadows", "the sun mining", "the suns reflections", "the sun shines through", "a glimmer of sun", "sun shadows dance", "the midday sun", "the summer sky"], ["into the sun", "despite the days heat", "in the summer heat", "in the summer sunset", "in the autumn sun", "before the sun", "into summer", "toward the sun", "in dappled sun shadows"]],
  tree: [["filtered through pine branch", "between giant cedar trees ", "shivering aspen", "silhouette trees loom", "forest silence finds", "forest secrets hide", "tree shadows occlude", "between fallen trees"], ["a solitary oak", "glimpsed through trees", "rises above the branches", "a leafless tree", "each pine needle", "the leafless tree", "a solitary tree", "an acorn falls", "the willow tree", "every pine needle", "a branch drips", "a pine cone"], ["from leafless trees", "under the maple tree", "between the trees", "into the woods", "above the pine forest", "through the forest", "beneath the pine", "by the maple roots", "from a leafless branch", "on a withered branch", "in the pine branch", "behind the trees", "under tall pines", "upon a pine branch", "from a tree silhouette"]],
  wind: [["windblown shadows reach", "caterpillar breeze", "blossoms in the wind", "whistling wind catches", "carried by the wind", "gliding on the wind", "hidden in the wind", "gentle autumn wind"], ["floating in the breeze", "hanging in the air", "the wind plays", "carried on a breeze", "the sound of the wind", "caught by a breeze", "a change in the wind", "a soft breeze ripples", "a faint breeze rises"], ["before the wind", "in the wind", "against the winds chill", "in an autumn wind", "on the breeze", "on the wind", "into the wind", "against the wind"]]
};
;
},{}],"src/assets/json/haiku-phrases-fr.json":[function(require,module,exports) {
module.exports = module.exports = {
  animal: [["lointain hurlement d'un loup", "sur les traces d'un loup"], ["l'éveil d'un castor", "un coyote hurle"], ["au-dessus de la tanière de l'ours", "du menton d'un orignal"]],
  feather: [["chant d'un oiseau", "doux battement d'ailes"], ["la plume du hibou", "l'envol d'un goéland"], ["dans le chant des cigales", "dans la mélodie d'un oiseau moqueur"]],
  fish: [["jour de pêche à la mouche", "écaille scintillante d'un poisson"], ["un poisson s'élance", "la bouche d'une grenouille"], ["alors que la truite s'élève"]],
  flower: [["trois pétales tombent", "printemps dans l'air"], ["la danse d'un pissenlit", "la fleur tombe"], ["parmi les pruniers en fleurs", "parmi les fleurs sauvages"]],
  grass: [["sifflement à travers les champs", "l'herbe ondoie en rythme"], ["un brin d'herbe coincé", "les hautes herbes"], ["dans un champ", "au-delà des prairies"]],
  insect: [["les frelons bourdonnent", "les abeilles butinent"], ["une araignée capture", "un ver se tortille"], ["dans la tente de la chenille", "au-dessus des papillons"]],
  leaf: [["à l'ombre du feuillage", "les feuilles tombent doucement"], ["une feuille sèche", "une feuille tombe"], ["à l'ombre du feuillage", "sur chaque feuille"]],
  mist: [["dans l'épaisse brume du matin", "le brouillard se dissipe et révèle"], ["une goutte de rosée", "enveloppé de brume"], ["dans la brume", "dans le brouillard"]],
  moon: [["nuit d'automne sans lune", "nuit de lune d'ambroisie"], ["la lune danse", "un faisceau de clair de lune"], ["dans la nuit claire", "dans le ciel nocturne"]],
  rain: [["bruine d'après-midi", "ondée soudaine"], ["l'eau coule", "un tumulte de pluie"], ["après la pluie", "sous la pluie"]],
  snow: [["montagnes enneigées", "traces de pas sur la neige"], ["un ange tracé dans la neige", "l'ombre de la neige"], ["après la première gelée", "sous la glace"]],
  stars: [["ciel constellé d'étoiles", "regarder les étoiles filantes"], ["une autre étoile apparaît", "blizzards d'étoiles"], ["dans la lumière", "après les étoiles"]],
  storm: [["soudain coup de tonnerre!", "regarder les nuages d'été"], ["percée dans les nuages", "l'espace entre les nuages"], ["après la tempête", "avant la tempête"]],
  sun: [["les ombres s'allongent", "doux matin d'été"], ["un rayon de soleil jaillit", "la chaleur du soleil"], ["dans le soleil", "malgré le temps chaud"]],
  tree: [["à travers les branches des pins", "sous de gigantesques cèdres"], ["un chêne solitaire", "aperçu dans les arbres"], ["des arbres nus", "sous l'érable"]],
  wind: [["ombres portées par le vent", "brise de chenille"], ["flottant dans la brise", "suspendu dans l'air"], ["avant le vent", "dans le vent"]]
};
;
},{}],"src/assets/json/*.{json,txtjson}":[function(require,module,exports) {
module.exports = {
  "haiku-phrases-en": {
    "json": require("./haiku-phrases-en.json")
  },
  "haiku-phrases-fr": {
    "json": require("./haiku-phrases-fr.json")
  }
};
},{"./haiku-phrases-en.json":"src/assets/json/haiku-phrases-en.json","./haiku-phrases-fr.json":"src/assets/json/haiku-phrases-fr.json"}],"src/util/Assets.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var THREE = _interopRequireWildcard(require("three"));

var _ = _interopRequireDefault(require("../assets/image/**/*.{png,jpeg,jpg,svg}"));

var _2 = _interopRequireDefault(require("../assets/spritesheets/*.{sheet,png,jpeg,jpg}"));

var _3 = _interopRequireDefault(require("../assets/json/*.{json,txtjson}"));

var _array = require("./array");

var _rightNow = _interopRequireDefault(require("right-now"));

var _addFrameTasks = require("./addFrameTasks");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import gltf_image_data from "../assets/gltf/*.{sheet,png,jpg,json}";
const AssetWorker = null; // const AssetWorker = new Worker("./AssetWorker.js");
// AssetWorker.addEventListener("message", ({ data }) => {
//   if (data && data.error) console.error(`[AssetWorker] ${data.error}`);
// });

const useWorker = false && AssetWorker;
const urls = new Map();
traverseLeafUrls(_.default, (key, data) => {
  urls.set(key, data);
}, ["image"]); // traverseLeafUrls(
//   gltf_image_data,
//   (key, data) => {
//     urls.set(key, data);
//   },
//   ["gltf"]
// );

addUrls(urls, _3.default, "json", {
  type: "json"
});
addUrls(urls, _2.default, "spritesheets", {
  type: "spritesheet-legacy"
});
combineSheets(urls);
const imageWorkerExtensions = ["png", "webp", "jpg", "jpeg"];
const loaders = [{
  type: "image",
  extensions: ["svg", "png", "webp", "jpg", "jpeg"]
}, {
  type: "json",
  extensions: ["json", "sheet", "txtjson"]
}, {
  type: "spritesheet-legacy"
}];
const LOGGING = false;
const log = LOGGING ? (...args) => console.log("[Assets]", ...args) : () => {};
const forceRAF = false;
let requestIdle, cancelIdle;

if (!forceRAF && typeof window.requestIdleCallback === "function") {
  requestIdle = window.requestIdleCallback.bind(window);
  cancelIdle = window.cancelIdleCallback.bind(window);
} else {
  console.warn(`[Assets] Using Request Animation Frame`);
  requestIdle = window.requestAnimationFrame.bind(window);
  cancelIdle = window.cancelAnimationFrame.bind(window);
}

const canUseWebP = false; //  (() => {
//   var elem = document.createElement("canvas");
//   if (!!(elem.getContext && elem.getContext("2d"))) {
//     // was able or not to get WebP representation
//     return elem.toDataURL("image/webp").indexOf("data:image/webp") == 0;
//   } else {
//     // very old browser like IE 8, canvas not supported
//     return false;
//   }
// })();

const jsonPriority = ["json", "sheet"];
const imagePriority = ["jpg", "png"];
if (canUseWebP) imagePriority.unshift("webp");
imagePriority.unshift("svg");

class AssetManager {
  constructor() {
    this._idleHandle = null;
    this._idleTimeout = 1000;
    this._loadQueuedBound = this.loadQueued.bind(this);
    this._ready = Promise.resolve();
    this.urlMap = urls;
    this.queue = new Set();
    this.cache = new Map();
    this.config = new Map();
    this.timing = new Map();
  }

  urlToID(url) {
    this.urlMap.set(url, url);
    return url;
  }

  setConfig(id, opt) {
    this.config.set(id, opt);
  }

  getConfig(id) {
    return this.config.has(id) ? this.config.get(id) : {};
  }

  _processOnNextTick() {
    this._cancelIdle();

    this._idleHandle = requestIdle(this._loadQueuedBound, {
      timeout: this._idleTimeout
    });
  }

  _cancelIdle() {
    if (this._idleHandle != null) {
      cancelIdle(this._idleHandle);
      this._idleHandle = null;
    }
  }

  prepare(ids) {
    ids = Array.isArray(ids) ? ids : [ids];
    ids.forEach(id => {
      if (!urls.has(id)) {
        console.warn(`No asset by ID ${id}`);

        if (/\.[^.]+$/.test(id)) {
          console.warn(`[Hint] Don't include the extension like ".png" on the asset ID`);
        }
      }

      if (!this.queue.has(id) && !this.cache.has(id)) {
        // log("Queing", id);
        this.queue.add(id);
      }
    });

    this._processOnNextTick();
  }

  loadQueued() {
    this._cancelIdle(); // Loads the queue in parallel


    if (!this.queue.size) {
      return Promise.resolve();
    }

    log(`Loading ${this.queue.size} assets`);
    const then = (0, _rightNow.default)();
    const ids = Array.from(this.queue);
    this.queue.clear();
    return Promise.all(ids.map(id => this.load(id))).then(results => {
      const ms = (0, _rightNow.default)() - then;
      log(`Loaded queue in ${ms} ms`);
      return results;
    });
  }

  release(id) {
    if (this.queue.has(id)) this.queue.delete(id);
    if (this.cache.has(id)) this.cache.delete(id);
    if (this.config.has(id)) this.config.delete(id);
  }

  async loadGPUTexture(renderer, texture, id, settings) {
    const image = await this.load(id);
    texture.image = image;
    const texOpts = { ...this.getConfig(id),
      ...settings
    };
    const release = texOpts.release !== false;
    const init = texOpts.init !== false;
    if (texOpts.repeat) texture.repeat.copy(texOpts.repeat);
    if (texOpts.offset) texture.offset.copy(texOpts.offset);
    delete texOpts.release;
    delete texOpts.init;
    delete texOpts.crossOrigin;
    delete texOpts.repeat;
    delete texOpts.offset;
    Object.assign(texture, texOpts);
    texture.needsUpdate = true;

    if (init) {
      (0, _addFrameTasks.addFrameTask)(() => {
        renderer.initTexture(texture); // release reference

        if (release) {
          texture.image = {
            width: image.width,
            height: image.height
          };
          this.release(id);
        }
      });
    }

    return texture;
  } // Creates a texture and then releases all references to the CPU one


  async createGPUTexture(renderer, id, settings) {
    const texture = new THREE.Texture();
    return this.loadGPUTexture(renderer, texture, id, settings);
  }

  createGPUTextureTask(renderer, id, settings) {
    const texture = new THREE.Texture();
    const promise = this.loadGPUTexture(renderer, texture, id, settings);
    return [texture, promise];
  }

  async load(id) {
    // remove from queue if it's being waited on
    if (this.queue.has(id)) this.queue.delete(id); // if we have it in cache, return that

    if (this.cache.has(id)) {
      return this.cache.get(id);
    }

    const now = (0, _rightNow.default)();
    this.timing.set(id, now); // not in cache, get the data

    const data = urls.get(id);

    if (!data) {
      console.error(`Could not find URL for asset ID ${id}`);
      return null;
    } // find loader for data type...


    let loader;
    let dataType = Array.isArray(data) ? "spritesheet-legacy" : data.type;

    if (dataType) {
      loader = loaders.find(e => e.type === dataType);
    } else if (typeof data === "string") {
      const dataExt = getExt(data);

      if (!dataExt) {
        console.warn(`Could not extract loader type for ${id} with data: ${data}`);
        return;
      }

      loader = loaders.find(e => {
        return e.extensions.some(ext => {
          return ext === dataExt;
        });
      });
    } else {
      const keys = data ? Object.keys(data) : [];
      loader = loaders.find(e => {
        return e.extensions.some(ext => {
          return keys.includes(ext);
        });
      });
    }

    if (!loader) {
      console.warn(`Could not find loader for ${id} and URL object ${data}`);
      return;
    }

    const config = this.getConfig(id); // load

    let p;

    if (loader.type === "image") {
      p = loadImageAsset(id, data, config);
    } else if (loader.type === "json") {
      p = loadJsonAsset(id, data, config);
    } else if (loader.type === "spritesheet-legacy") {
      p = loadSpriteSheetAsset(id, data, config);
    } else {
      throw new Error(`Loader type ${loader.type} not yet implemented`);
    } // set cache


    this.cache.set(id, p);
    return p.then(result => {
      const now = (0, _rightNow.default)();
      const then = this.timing.get(id);
      const idName = typeof id === "object" ? Object.values(id)[0] : id;
      log(`Loaded ${idName} in ${Math.round(now - then)} ms`);
      return result;
    }).catch(err => {
      console.error(`Error loading Asset by ID ${id}`);
      console.error(err.message);
      this.release(id);
    });
  }

}

var _default = new AssetManager();

exports.default = _default;

function findBestURL(id, urls, priorities) {
  // some assets only have one type of extension, return that
  if (typeof urls === "string") {
    return {
      ext: getExt(urls),
      url: urls
    };
  }

  let ext;

  if (priorities) {
    // some assets can have multiple, and we find best based on priority
    ext = priorities.find(ext => ext in urls);
  } else {
    ext = Object.keys(urls)[0];
  }

  if (!ext) {
    console.log("NO EXT", urls, ext, priorities);
    throw new Error(`Could not find a suitable extension for ${id} from: ${Object.keys(urls)}`);
  }

  return {
    ext,
    url: urls[ext]
  };
}

function getExt(str) {
  const m = /\.([^.]+)$/.exec(str);
  if (!m || !m[1]) return "";
  return m[1].toLowerCase();
}

function combineSheets(urls) {
  const sheetUrls = Array.from(urls.entries()).filter(([key, value]) => value.type === "spritesheet-legacy");
  const sets = new Map();
  sheetUrls.forEach(([key, value]) => {
    let base = key;
    let id = 0;
    const m = /(.*)\-([\d]+)$/.exec(base);

    if (m) {
      base = m[1];
      id = parseInt(m[2], 10) || 0;
    }

    if (sets.has(base)) {
      sets.get(base).push({
        id,
        key
      });
    } else {
      sets.set(base, [{
        id,
        key
      }]);
    }
  });
  Array.from(sets.entries()).forEach(([key, value]) => {
    value.sort((a, b) => a.id - b.id);
    const datas = value.map(v => {
      const ret = urls.get(v.key);
      urls.delete(v.key);
      return ret;
    });
    urls.set(key, datas);
  });
}

async function loadSpriteSheetAsset(id, array, config) {
  const assets = array.map((obj, i) => {
    const uid = id + "-" + i;
    const imagePromise = loadImageAsset(uid, obj, config);
    const jsonPromise = loadJsonAsset(uid, obj, config);
    return [jsonPromise, imagePromise];
  });
  const promises = assets.flat();
  const results = await Promise.all(promises);
  const data = [];

  for (let i = 0; i < results.length; i += 2) {
    const json = results[i];
    const img = results[i + 1];
    data.push([json, img]);
  }

  return data;
}

async function loadJsonAsset(id, urls, config) {
  const {
    ext,
    url
  } = findBestURL(id, urls, jsonPriority);
  const resp = await fetch(url);
  return resp.json();
}

async function loadImageAsset(id, urls, config) {
  const {
    ext,
    url
  } = findBestURL(id, urls, imagePriority);
  if (useWorker && imageWorkerExtensions.includes(ext)) return loadImageWorkerThread(id, url, config);else return loadImageMainThread(url, config);
}

async function loadSVGToImage(url, opt = {}) {
  const resp = await fetch(url);
  const svg = await resp.text();
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const dataUrl = "data:image/svg+xml;charset-utf-8," + encodeURIComponent(svg);
  const image = await loadImage(dataUrl, opt);
  canvas.width = image.width;
  canvas.height = image.height;
  ctx.drawImage(image, 0, 0);
  return canvas;
}

async function loadImageWorkerThread(id, url, config = {}) {
  return new Promise((resolve, reject) => {
    AssetWorker.postMessage({
      type: "image",
      id,
      url,
      config
    });
    log(`Loading ${id} in worker...`);
    AssetWorker.addEventListener("message", receiver);

    function receiver(ev) {
      if (ev.data && ev.data.id === id) {
        AssetWorker.removeEventListener("message", receiver);

        if (ev.data.error) {
          let error = ev.data ? ev.data.error : `No Data Received`;
          console.error(`[AssetWorker] ${error}`);
          reject(new Error(error));
        } else {
          const result = ev.data.result;
          log(`Received ${id}`, result);
          resolve(result);
        }
      }
    }
  });
}

function loadImageMainThread(url, opt = {}) {
  return new Promise((resolve, reject) => {
    const img = new window.Image();

    img.onerror = () => {
      reject(new Error(`Error loading URL ${url}`));
    };

    img.onload = () => {
      resolve(img);
    };

    if (opt.crossOrigin != null) img.crossOrigin = opt.crossOrigin; // log(`Loading image ${url}`);

    img.src = url;
  });
}

function addUrls(map, obj, prefix, opts = {}) {
  Object.entries(obj).forEach(([key, urls]) => {
    const k = [prefix, key].join("/");

    if (map.has(k)) {
      console.error(`WARN: Asset map already has entry by key ${k}`);
    }

    if (urls && typeof urls === "object") {
      urls = { ...opts,
        ...urls
      };
    }

    map.set(k, urls);
  });
}

function traverseLeafUrls(tree, cb, prefixes = []) {
  Object.entries(tree).forEach(([key, value]) => {
    let isLeaf; // see if there's another child inside that object

    if (value && typeof value === "object") {
      const hasChildren = Object.values(value).some(e => {
        return e && typeof e === "object";
      });
      isLeaf = !hasChildren;
    } else if (typeof value === "string") {
      isLeaf = true;
    } else {
      isLeaf = false;
    }

    if (key === "json") isLeaf = true;
    const newPrefixes = [...prefixes, key];

    if (isLeaf) {
      const id = newPrefixes.join("/");
      cb(id, value);
    } else {
      traverseLeafUrls(value, cb, newPrefixes);
    }
  });
}
},{"three":"src/vendor/three.module.js","../assets/image/**/*.{png,jpeg,jpg,svg}":"src/assets/image/**/*.{png,jpeg,jpg,svg}","../assets/spritesheets/*.{sheet,png,jpeg,jpg}":"src/assets/spritesheets/*.{sheet,png,jpeg,jpg}","../assets/json/*.{json,txtjson}":"src/assets/json/*.{json,txtjson}","./array":"src/util/array.js","right-now":"node_modules/right-now/browser.js","./addFrameTasks":"src/util/addFrameTasks.js"}],"src/assets/image/tokens/ico_*.png":[function(require,module,exports) {
module.exports = {
  "animal": require("./ico_animal.png"),
  "feather": require("./ico_feather.png"),
  "fish": require("./ico_fish.png"),
  "flower": require("./ico_flower.png"),
  "grass": require("./ico_grass.png"),
  "insect": require("./ico_insect.png"),
  "leaf": require("./ico_leaf.png"),
  "mist": require("./ico_mist.png"),
  "moon": require("./ico_moon.png"),
  "rain.": require("./ico_rain..png"),
  "snow": require("./ico_snow.png"),
  "stars": require("./ico_stars.png"),
  "storm": require("./ico_storm.png"),
  "sun": require("./ico_sun.png"),
  "tree": require("./ico_tree.png"),
  "wind": require("./ico_wind.png")
};
},{"./ico_animal.png":"src/assets/image/tokens/ico_animal.png","./ico_feather.png":"src/assets/image/tokens/ico_feather.png","./ico_fish.png":"src/assets/image/tokens/ico_fish.png","./ico_flower.png":"src/assets/image/tokens/ico_flower.png","./ico_grass.png":"src/assets/image/tokens/ico_grass.png","./ico_insect.png":"src/assets/image/tokens/ico_insect.png","./ico_leaf.png":"src/assets/image/tokens/ico_leaf.png","./ico_mist.png":"src/assets/image/tokens/ico_mist.png","./ico_moon.png":"src/assets/image/tokens/ico_moon.png","./ico_rain..png":"src/assets/image/tokens/ico_rain..png","./ico_snow.png":"src/assets/image/tokens/ico_snow.png","./ico_stars.png":"src/assets/image/tokens/ico_stars.png","./ico_storm.png":"src/assets/image/tokens/ico_storm.png","./ico_sun.png":"src/assets/image/tokens/ico_sun.png","./ico_tree.png":"src/assets/image/tokens/ico_tree.png","./ico_wind.png":"src/assets/image/tokens/ico_wind.png"}],"src/assets/image/tokens-inverted/ico_*.png":[function(require,module,exports) {
module.exports = {
  "animal": require("./ico_animal.png"),
  "feather": require("./ico_feather.png"),
  "fish": require("./ico_fish.png"),
  "flower": require("./ico_flower.png"),
  "grass": require("./ico_grass.png"),
  "insect.": require("./ico_insect..png"),
  "leaf": require("./ico_leaf.png"),
  "mist": require("./ico_mist.png"),
  "moon": require("./ico_moon.png"),
  "rain": require("./ico_rain.png"),
  "snow": require("./ico_snow.png"),
  "stars": require("./ico_stars.png"),
  "storm": require("./ico_storm.png"),
  "sun": require("./ico_sun.png"),
  "tree": require("./ico_tree.png"),
  "wind": require("./ico_wind.png")
};
},{"./ico_animal.png":"src/assets/image/tokens-inverted/ico_animal.png","./ico_feather.png":"src/assets/image/tokens-inverted/ico_feather.png","./ico_fish.png":"src/assets/image/tokens-inverted/ico_fish.png","./ico_flower.png":"src/assets/image/tokens-inverted/ico_flower.png","./ico_grass.png":"src/assets/image/tokens-inverted/ico_grass.png","./ico_insect..png":"src/assets/image/tokens-inverted/ico_insect..png","./ico_leaf.png":"src/assets/image/tokens-inverted/ico_leaf.png","./ico_mist.png":"src/assets/image/tokens-inverted/ico_mist.png","./ico_moon.png":"src/assets/image/tokens-inverted/ico_moon.png","./ico_rain.png":"src/assets/image/tokens-inverted/ico_rain.png","./ico_snow.png":"src/assets/image/tokens-inverted/ico_snow.png","./ico_stars.png":"src/assets/image/tokens-inverted/ico_stars.png","./ico_storm.png":"src/assets/image/tokens-inverted/ico_storm.png","./ico_sun.png":"src/assets/image/tokens-inverted/ico_sun.png","./ico_tree.png":"src/assets/image/tokens-inverted/ico_tree.png","./ico_wind.png":"src/assets/image/tokens-inverted/ico_wind.png"}],"src/assets/image/tokens-collected/*.png":[function(require,module,exports) {
module.exports = {
  "animal": require("./animal.png"),
  "feather": require("./feather.png"),
  "fish": require("./fish.png"),
  "flower": require("./flower.png"),
  "grass": require("./grass.png"),
  "insect": require("./insect.png"),
  "leaf": require("./leaf.png"),
  "mist": require("./mist.png"),
  "moon": require("./moon.png"),
  "rain": require("./rain.png"),
  "snow": require("./snow.png"),
  "stars": require("./stars.png"),
  "storm": require("./storm.png"),
  "sun": require("./sun.png"),
  "tree": require("./tree.png"),
  "wind": require("./wind.png")
};
},{"./animal.png":"src/assets/image/tokens-collected/animal.png","./feather.png":"src/assets/image/tokens-collected/feather.png","./fish.png":"src/assets/image/tokens-collected/fish.png","./flower.png":"src/assets/image/tokens-collected/flower.png","./grass.png":"src/assets/image/tokens-collected/grass.png","./insect.png":"src/assets/image/tokens-collected/insect.png","./leaf.png":"src/assets/image/tokens-collected/leaf.png","./mist.png":"src/assets/image/tokens-collected/mist.png","./moon.png":"src/assets/image/tokens-collected/moon.png","./rain.png":"src/assets/image/tokens-collected/rain.png","./snow.png":"src/assets/image/tokens-collected/snow.png","./stars.png":"src/assets/image/tokens-collected/stars.png","./storm.png":"src/assets/image/tokens-collected/storm.png","./sun.png":"src/assets/image/tokens-collected/sun.png","./tree.png":"src/assets/image/tokens-collected/tree.png","./wind.png":"src/assets/image/tokens-collected/wind.png"}],"src/util/load.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadImage = loadImage;
exports.loadTexture = loadTexture;

var THREE = _interopRequireWildcard(require("three"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// export function load(opt = {}) {
//   return loadAsset(opt);
// }
function loadImage(url, opt = {}) {
  return new Promise(resolve => {
    const img = new window.Image();

    img.onerror = () => {
      console.error(`Could not load Texture by URL ${url}`); // TODO: nil canvas fallback image

      resolve(img);
    };

    img.onload = () => {
      resolve(img);
    };

    if (opt.crossOrigin != null) img.crossOrigin = opt.crossOrigin;
    img.src = url;
  });
}

let container;

function loadTexture(url, opt = {}) {
  const imgPromise = /\.svg$/i.test(url) ? loadSVGToImage(url, opt) : loadImage(url, opt);
  return imgPromise.then(img => {
    const tex = new THREE.Texture();
    tex.image = img;
    const texOpts = { ...opt
    };
    delete texOpts.crossOrigin;
    Object.assign(tex, texOpts);
    tex.needsUpdate = true;
    return tex;
  });
}

async function loadSVGToImage(url, opt = {}) {
  const resp = await fetch(url);
  const svg = await resp.text();
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const dataUrl = "data:image/svg+xml;charset-utf-8," + encodeURIComponent(svg);
  const image = await loadImage(dataUrl, opt);
  canvas.width = image.width;
  canvas.height = image.height;
  ctx.drawImage(image, 0, 0);
  return canvas;
} // async function svgToImage (svgStr, opt = {}) {
//   let blob;
//   try {
//     blob = new window.Blob([ svgStr ], {
//       type: 'image/svg+xml;charset=utf-8'
//     })
//   } catch (e) {
//     return Promise.reject(e);
//   }
//   const DOMURL = getURL();
//   let url = DOMURL.createObjectURL(blob);
//   loadImage(url, opt)
//     .then(img => {
//       revoke();
//     })
//     .catch(err => {
//       revoke();
//       // try again for Safari 8.0, using simple encodeURIComponent
//       // this will fail with DOM content but at least it works with SVG
//       var url2 = 'data:image/svg+xml,' + encodeURIComponent(svg.join(''))
//       return loadImage(url2, opt);
//     });
// }
// function getURL () {
//   return window.URL ||
//   window.webkitURL ||
//   window.mozURL ||
//   window.msURL
// }
},{"three":"src/vendor/three.module.js"}],"src/util/SpriteManager.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SpriteManager;

var THREE = _interopRequireWildcard(require("three"));

var _Assets = _interopRequireDefault(require("./Assets"));

var _load = require("./load");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

async function SpriteManager(sheets, renderer, opts = {}) {
  let atlases;

  if (typeof sheets === "string") {
    // asset ID
    const id = sheets;
    console.log("[sprites] Loading Sprite Sheet", id);
    const results = await _Assets.default.load(id);
    sheets = results.map(([data]) => {
      return {
        data
      };
    });
    atlases = results.map(([data, image]) => {
      const texture = new THREE.Texture();
      texture.image = image;
      texture.needsUpdate = true;
      renderer.initTexture(texture);

      if (opts.release !== false) {
        texture.image = {
          width: image.width,
          height: image.height
        };
      }

      return texture;
    }); // release cached item now that it's loaded

    if (opts.release !== false) _Assets.default.release(id);
  } else {
    sheets = await Promise.all(sheets.map(async s => {
      if (typeof s.data === "string") {
        const resp = await fetch(s.data);
        let data = await resp.json();
        s = { ...s,
          data
        };
      }

      return s;
    }));
    atlases = await Promise.all(sheets.map(({
      url
    }) => {
      return (0, _load.loadTexture)(url);
    }));
    atlases.forEach(atlas => renderer.initTexture(atlas));
  }

  const spriteMap = {};
  sheets.forEach(({
    data
  }, sheetIndex) => {
    // console.log(data, sheetIndex);
    data.frames.forEach((item, itemIndex) => {
      const frame = item.frame;
      const file = item.filename;
      const texture = new THREE.Texture();
      const spriteTextureSize = data.meta.size;
      const {
        w,
        h
      } = spriteTextureSize;
      texture.repeat.set(frame.w / w, frame.h / h);
      texture.offset.x = frame.x / w;
      texture.offset.y = 1 - frame.h / h - frame.y / h;
      let type = "";
      const id = file.toLowerCase().replace(/\.(png|jpg|jpeg)$/i, "");
      let basename = id;
      const slashIdx = id.lastIndexOf("/");

      if (slashIdx >= 0) {
        type = id.substring(0, slashIdx).toLowerCase();
        basename = id.substring(slashIdx + 1);
      } // const endpath = file.includes("/") ? file.split("/").pop() : file;
      // const id = endpath.toLowerCase().replace(/\.(png|jpg|jpeg)$/i, "");


      const frameNumMatch = id.match(/(^|[^\d])(\d+)$/);
      let idCount = itemIndex;

      if (frameNumMatch) {
        idCount = parseInt(frameNumMatch[2], 10);
      }

      const spriteItem = {
        // data,
        atlas: atlases[sheetIndex],
        sheetIndex,
        name: id,
        basename,
        data: frame,
        width: frame.w,
        height: frame.h,
        offset: texture.offset.clone(),
        repeat: texture.repeat.clone(),
        texture,
        type,
        idCount
      };

      if (item.trimmed) {// spriteItem.trimmed = true;
        // spriteItem.width = item.sourceSize.w;
        // spriteItem.height = item.sourceSize.h;
        // spriteItem.offset.x -= item.spriteSourceSize.x / w;
        // spriteItem.offset.y -= item.spriteSourceSize.y / h;
        // spriteItem.repeat.x /= item.frame.w / item.sourceSize.w;
        // spriteItem.repeat.y /= item.frame.h / item.sourceSize.h;
        // "frame": {"x":2737,"y":2124,"w":391,"h":478},
        // "rotated": false,
        // "trimmed": true,
        // "spriteSourceSize": {"x":65,"y":49,"w":391,"h":478},
        // "sourceSize": {"w":540,"h":540}
      }

      spriteMap[id] = spriteItem;
    });
  });
  const values = Object.values(spriteMap);
  const frames = values.slice().sort((a, b) => {
    return a.idCount - b.idCount;
  });
  return {
    atlases,
    map: spriteMap,
    frames,
    values
  };
}
},{"three":"src/vendor/three.module.js","./Assets":"src/util/Assets.js","./load":"src/util/load.js"}],"src/util/tokens.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTokenSheet = getTokenSheet;
exports.loadTokenSprites = loadTokenSprites;
exports.createTokenCanvas = createTokenCanvas;
exports.BiomeFeatures = exports.AllTokens = exports.TokenURLs = exports.CollectedTokenURLs = exports.InvertedTokenURLs = void 0;

var _ico_ = _interopRequireDefault(require("../assets/image/tokens/ico_*.png"));

var _ico_2 = _interopRequireDefault(require("../assets/image/tokens-inverted/ico_*.png"));

var _ = _interopRequireDefault(require("../assets/image/tokens-collected/*.png"));

var _SpriteManager = _interopRequireDefault(require("./SpriteManager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const InvertedTokenURLs = _ico_2.default;
exports.InvertedTokenURLs = InvertedTokenURLs;
const CollectedTokenURLs = _.default;
exports.CollectedTokenURLs = CollectedTokenURLs;
const TokenURLs = _ico_.default;
exports.TokenURLs = TokenURLs;
const AllTokens = ["sun", "moon", "wind", "mist", "rain", "storm", "tree", "leaf", "fish", "animal", "feather", "grass", "flower", "insect", "snow", "stars"];
exports.AllTokens = AllTokens;
const BiomeFeatures = {
  forest: {
    tokens: ["sun", "moon", // "wind",
    "mist", "rain", "storm", "tree", "leaf", "fish", "animal", "feather", // "grass",
    "flower", "insect", // "snow",
    "stars" // ...AllTokens,
    ]
  },
  grasslands: {
    tokens: ["sun", "moon", "wind", "mist", "rain", "storm", // "tree",
    // "leaf",
    "fish", "animal", "feather", "grass", "flower", "insect", // "snow",
    "stars" // ...AllTokens,
    ]
  },
  tundra: {
    tokens: [// "sun",
    "moon", "wind", "mist", "rain", "storm", "tree", // "leaf",
    "fish", "animal", "feather", // "grass",
    "flower", "insect", "snow", "stars" // ...AllTokens,
    ]
  }
};
exports.BiomeFeatures = BiomeFeatures;
const tokenTextureMap = new Map();
let tokenSpritePromiseResolved;
let tokenSpritePromise = new Promise(resolve => {
  tokenSpritePromiseResolved = resolve;
});
let canvasCache = {};

function getTokenSheet() {
  return tokenSpritePromise;
}

function loadTokenSprites(renderer) {
  // console.log("[Tokens] Loading");
  (0, _SpriteManager.default)("spritesheets/tokens", renderer, {
    release: false
  }).then(sheet => {
    // console.log("[Tokens] Loaded", sheet);
    // console.log(sheet.atlases[0].image);
    tokenSpritePromiseResolved(sheet);
  });
}

async function createTokenCanvas(name) {
  const sheet = await tokenSpritePromise;
  const canvas = document.createElement("canvas");

  if (name in sheet.map) {
    const frame = sheet.map[name];
    canvas.width = frame.width;
    canvas.height = frame.height;
    const ctx = canvas.getContext("2d"); // ctx.fillStyle = "red";
    // ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.drawImage(sheet.atlases[0].image, frame.data.x, frame.data.y, frame.data.w, frame.data.h, 0, 0, frame.width, frame.height);
  } else {
    console.error(`Name %s not in token sheet`, name);
  }

  return canvas;
}
},{"../assets/image/tokens/ico_*.png":"src/assets/image/tokens/ico_*.png","../assets/image/tokens-inverted/ico_*.png":"src/assets/image/tokens-inverted/ico_*.png","../assets/image/tokens-collected/*.png":"src/assets/image/tokens-collected/*.png","./SpriteManager":"src/util/SpriteManager.js"}],"src/components/Image.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _svelte = require("svelte");

var _transitions = require("../animations/transitions");

var _Assets = _interopRequireDefault(require("../util/Assets"));

var _tokens = require("../util/tokens");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* components/Image.svelte generated by Svelte v3.31.0 */
function create_fragment(ctx) {
  let div;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      div = (0, _internal.element)("div");
      (0, _internal.attr)(div, "class", "image-container svelte-kj6g8f");
      (0, _internal.set_style)(div, "width",
      /*width*/
      ctx[0]);
      (0, _internal.set_style)(div, "height",
      /*height*/
      ctx[1]);
      (0, _internal.toggle_class)(div, "ignorePointer",
      /*ignorePointer*/
      ctx[4]);
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      /*div_binding*/

      ctx[14](div);
      current = true;

      if (!mounted) {
        dispose = [(0, _internal.listen)(div, "introend",
        /*introend_handler*/
        ctx[10]), (0, _internal.listen)(div, "introstart",
        /*introstart_handler*/
        ctx[11]), (0, _internal.listen)(div, "outroend",
        /*outroend_handler*/
        ctx[12]), (0, _internal.listen)(div, "outrostart",
        /*outrostart_handler*/
        ctx[13])];
        mounted = true;
      }
    },

    p(ctx, [dirty]) {
      if (!current || dirty &
      /*width*/
      1) {
        (0, _internal.set_style)(div, "width",
        /*width*/
        ctx[0]);
      }

      if (!current || dirty &
      /*height*/
      2) {
        (0, _internal.set_style)(div, "height",
        /*height*/
        ctx[1]);
      }

      if (dirty &
      /*ignorePointer*/
      16) {
        (0, _internal.toggle_class)(div, "ignorePointer",
        /*ignorePointer*/
        ctx[4]);
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.add_render_callback)(() => {
        if (div_outro) div_outro.end(1);
        if (!div_intro) div_intro = (0, _internal.create_in_transition)(div,
        /*inTransition*/
        ctx[2], {});
        div_intro.start();
      });
      current = true;
    },

    o(local) {
      if (div_intro) div_intro.invalidate();
      div_outro = (0, _internal.create_out_transition)(div,
      /*outTransition*/
      ctx[3], {});
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      /*div_binding*/

      ctx[14](null);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      (0, _internal.run_all)(dispose);
    }

  };
}

function clearChildren(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
}

function instance($$self, $$props, $$invalidate) {
  let {
    alt = ""
  } = $$props;
  let {
    width = "initial"
  } = $$props;
  let {
    height = "initial"
  } = $$props;
  let {
    id
  } = $$props;
  let {
    image = undefined
  } = $$props;
  let {
    token = false
  } = $$props;
  let {
    inTransition = _transitions.emptyTransition
  } = $$props;
  let {
    outTransition = _transitions.emptyTransition
  } = $$props;
  let {
    ignorePointer = false
  } = $$props;
  let p = Promise.resolve();
  let events = [];
  let destroying = false;
  let container;
  (0, _svelte.onMount)(() => {
    events.forEach(fn => fn());
    events.length = 0;
    return () => {
      events.length = 0;
      destroying = true;
    }; // destroy...
  });

  async function change(image, token, id) {
    events.length = 0;
    await p;

    if (image) {
      if (typeof image.then === "function") p = image;else p = Promise.resolve(image);
    } else {
      if (token) {
        p = (0, _tokens.createTokenCanvas)(id);
      } else {
        p = _Assets.default.load(id);
      }
    }

    const img = await p;

    if (container) {
      // already mounted, clear and append
      mount();
    } else {
      events.push(mount);
    }

    function mount() {
      if (destroying) return;
      clearChildren(container);
      const newNode = image || token ? img : img.cloneNode();
      newNode.setAttribute("draggable", false);
      container.appendChild(newNode);
    }
  }

  function introend_handler(event) {
    (0, _internal.bubble)($$self, event);
  }

  function introstart_handler(event) {
    (0, _internal.bubble)($$self, event);
  }

  function outroend_handler(event) {
    (0, _internal.bubble)($$self, event);
  }

  function outrostart_handler(event) {
    (0, _internal.bubble)($$self, event);
  }

  function div_binding($$value) {
    _internal.binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(5, container);
    });
  }

  $$self.$$set = $$props => {
    if ("alt" in $$props) $$invalidate(6, alt = $$props.alt);
    if ("width" in $$props) $$invalidate(0, width = $$props.width);
    if ("height" in $$props) $$invalidate(1, height = $$props.height);
    if ("id" in $$props) $$invalidate(7, id = $$props.id);
    if ("image" in $$props) $$invalidate(8, image = $$props.image);
    if ("token" in $$props) $$invalidate(9, token = $$props.token);
    if ("inTransition" in $$props) $$invalidate(2, inTransition = $$props.inTransition);
    if ("outTransition" in $$props) $$invalidate(3, outTransition = $$props.outTransition);
    if ("ignorePointer" in $$props) $$invalidate(4, ignorePointer = $$props.ignorePointer);
  };

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*image, token, id*/
    896) {
      $: change(image, token, id);
    }
  };

  return [width, height, inTransition, outTransition, ignorePointer, container, alt, id, image, token, introend_handler, introstart_handler, outroend_handler, outrostart_handler, div_binding];
}

class Image extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      alt: 6,
      width: 0,
      height: 1,
      id: 7,
      image: 8,
      token: 9,
      inTransition: 2,
      outTransition: 3,
      ignorePointer: 4
    });
  }

}

var _default = Image;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","svelte":"node_modules/svelte/index.mjs","../animations/transitions":"src/animations/transitions.js","../util/Assets":"src/util/Assets.js","../util/tokens":"src/util/tokens.js"}],"node_modules/load-script/index.js":[function(require,module,exports) {

module.exports = function load (src, opts, cb) {
  var head = document.head || document.getElementsByTagName('head')[0]
  var script = document.createElement('script')

  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }

  opts = opts || {}
  cb = cb || function() {}

  script.type = opts.type || 'text/javascript'
  script.charset = opts.charset || 'utf8';
  script.async = 'async' in opts ? !!opts.async : true
  script.src = src

  if (opts.attrs) {
    setAttributes(script, opts.attrs)
  }

  if (opts.text) {
    script.text = '' + opts.text
  }

  var onend = 'onload' in script ? stdOnEnd : ieOnEnd
  onend(script, cb)

  // some good legacy browsers (firefox) fail the 'in' detection above
  // so as a fallback we always set onload
  // old IE will ignore this and new IE will set onload
  if (!script.onload) {
    stdOnEnd(script, cb);
  }

  head.appendChild(script)
}

function setAttributes(script, attrs) {
  for (var attr in attrs) {
    script.setAttribute(attr, attrs[attr]);
  }
}

function stdOnEnd (script, cb) {
  script.onload = function () {
    this.onerror = this.onload = null
    cb(null, script)
  }
  script.onerror = function () {
    // this.onload = null here is necessary
    // because even IE9 works not like others
    this.onerror = this.onload = null
    cb(new Error('Failed to load ' + this.src), script)
  }
}

function ieOnEnd (script, cb) {
  script.onreadystatechange = function () {
    if (this.readyState != 'complete' && this.readyState != 'loaded') return
    this.onreadystatechange = null
    cb(null, script) // there is no way to catch loading errors in IE8
  }
}

},{}],"src/util/isMobile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _default = /(Android|webOS|iPod|BlackBerry|Phone|playbook|silk|iOS|iPad|iPhone)/i.test(navigator.userAgent);

exports.default = _default;
},{}],"src/util/locale.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.localize = exports.language = void 0;

var _store = require("svelte/store");

var _config = _interopRequireDefault(require("../config"));

var _queryString = _interopRequireDefault(require("./query-string"));

var _isMobile = _interopRequireDefault(require("./isMobile"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const splitCopy = {
  nfbInteractiveLink: {
    en: "https://www.nfb.ca/interactive/",
    fr: "https://www.onf.ca/interactif/"
  },
  introBlurbOne: {
    en: "an animated journey across",
    fr: "une excursion animée"
  },
  introBlurbTwo: {
    en: "the poetry of the land",
    fr: "à travers la poésie du paysage"
  },
  startButton: {
    en: "start",
    fr: "démarrer"
  },
  resumeButton: {
    en: "resume",
    fr: "reprendre"
  },
  aboutButton: {
    en: "info",
    fr: "à propos"
  },
  skipButton: {
    en: "skip",
    fr: "passer"
  },
  continueButton: {
    en: "continue",
    fr: "continuer"
  },
  journalTitle: {
    en: "poems",
    fr: "poèmes"
  },
  newMemory: {
    en: "you've collected a new memory",
    fr: "tu as récupéré un nouveau souvenir"
  },
  introPlaceholder: {
    en: "nature is losing its memories...",
    fr: "TBD FR translation"
  },
  tapOrClickAndHold: {
    en: `${_isMobile.default ? "Tap" : "Click"} + Hold`,
    fr: `${_isMobile.default ? "Appuyez" : "Cliquez ou"} touchez`
  },
  tutorialTapHold: {
    en: `${_isMobile.default ? "Tap" : "Click"} and hold to explore`,
    fr: `${_isMobile.default ? "Appuyez" : "Cliquez ou "} et maintenez pour explorer`
  },
  tutorialResolve: {
    en: "Find the tree at the centre, to return the memories to the land",
    fr: "Trouvez l’arbre au centre du monde pour rendre à la terre ses souvenirs"
  },
  tutorialCollect: {
    en: "Collect tokens to recover nature’s lost memories",
    fr: "Rassemblez des éléments pour reconstituer la mémoire de la nature"
  },
  introVideoLine0: {
    en: "Nature's balance is endangered",
    fr: "L'équilibre naturel est en danger"
  },
  introVideoLine1: {
    en: "Memories of the land are fracturing",
    fr: "Les souvenirs de la terre s'évanouissent"
  },
  introVideoLine2: {
    en: "Recover the lost fragments to restore balance",
    fr: "Retrouvez les fragments perdus pour rétablir l'équilibre"
  },
  nfbProduction: {
    en: `A game by Matt DesLauriers`,
    fr: `Un jeu de Matt DesLauriers`
  },
  nfbSubcaption: {
    en: `Produced by the National Film Board of Canada`,
    fr: `Produit par l’Office national du film du Canada`
  },
  playHeader: {
    en: "play",
    fr: "jeu"
  },
  aboutHeader: {
    en: "about",
    fr: "à propos"
  },
  creditsHeader: {
    en: "credits",
    fr: "crédits"
  },
  moveCharacterText: {
    en: `to move the character across the landscape, in search of tokens that reveal lyrical fragments hidden in the wind.`,
    fr: `l'écran pour que le personnage se déplace dans son environnement à la recherche d'éléments qui révèleront des fragments lyriques cachés dans le vent.`
  },
  collectText: {
    en: `COLLECT`,
    fr: `AMASSEZ`
  },
  tokenStringText: {
    en: `tokens and string them together to form haiku-like poetry, recovering lost memories of nature.`,
    fr: `des éléments et assemblez-les pour former des poèmes ressemblant à des haïkus, retrouvant ainsi les souvenirs perdus de la nature.`
  },
  orientText: {
    en: `ORIENT`,
    fr: `ORIENTEZ-VOUS`
  },
  compassStringText: {
    en: `yourself with the Compass if you are lost or need a hint finding the closest tokens.`,
    fr: `à l’aide de la Boussole si vous êtes perdu ou avez besoin d’un indice pour découvrir les éléments autour de vous.`
  },
  returnText: {
    en: `RETURN`,
    fr: `RENDEZ`
  },
  memoriesStringText: {
    en: `the memories once you’ve collected enough to the Origin Tree at the centre of the world, advancing you to the next stage of the experience and bringing you closer to fully restoring nature’s balance.`,
    fr: `à la terre ses souvenirs. Lorsque vous aurez assemblé suffisamment de poèmes, trouvez l’Arbre Originel au centre de l’univers. Vous passerez alors à la prochaine étape de l’expérience, vous rapprochant de votre but ultime: restaurer entièrement l’équilibre de la nature.`
  },
  wayfinderStrongText: {
    en: `WAYFINDER`,
    fr: `TRAVERSÉES`
  },
  wayfinderTextParagraph: {
    en: `is an expression of our connectedness to the natural world. It's an opportunity to renew a damaged ecosystem through discovery and verse. The calming, contemplative gameplay is symbolic of the cause-and-effect relationship humans have with nature. It underscores our role in both affecting, but ultimately remedying, the effects of climate change through action and a greater appreciation of the environment.`,
    fr: `est une expression de notre connexion avec le monde naturel. C’est une occasion de renouveler, par l’entremise de la découverte et du vers, un écosystème endommagé. L’expérience de jeu, apaisante et contemplative, symbolise la relation de cause à effet que les humains entretiennent avec la nature. Elle souligne notre responsabilité face aux effets des changements climatiques et notre capacité à les entraîner, comme à y remédier, à travers nos actions et une plus grande appréciation de l’environnement.`
  },
  wayfinderFurtherTextParagraph: {
    en: `The art is generative. The visual assets and poetry are assembled procedurally and algorithmically through code, creating different combinations for each new visitor. The textured, hand-illustrated aesthetic is delivered in real-time, and the poetic verses are created with a mix of artificial intelligence/machine learning and generative processes, providing thousands of possible combinations. As such, Wayfinder is an ever-changing, emergent artwork with infinite possibilities. Each time it runs, it produces a new and individualized world.`,
    fr: `L’art est génératif. Les éléments visuels et la poésie sont assemblés de manière procédurale et algorithmique à l’aide de code, créant différentes combinaisons pour chaque nouveau visiteur. L’esthétique texturée et illustrée à la main est livrée en temps réel, et les vers poétiques sont créés par un mélange d’intelligence artificielle/apprentissage machine et de processus génératifs, offrant ainsi des milliers de combinaisons possibles. Par conséquent, Traversées est une œuvre d’art émergente en constante évolution, renfermant d’infinies possibilités, qui produit un monde nouveau et individualisé à chaque utilisation.`
  },
  moreAt: {
    en: `More at `,
    fr: `Plus d'infos à`
  },
  moreAtLink: {
    en: "https://www.nfb.ca/interactive/wayfinder/",
    fr: "https://www.onf.ca/interactif/traversees/"
  },
  moreAtLinkText: {
    en: "nfb.ca/interactive/wayfinder",
    fr: "onf.ca/interactif/traversees"
  },
  mattRole: {
    en: `Concept, Design and Code`,
    fr: `Concept, design et code`
  },
  guillaumeRole: {
    en: `Animation and 3D Modelling`,
    fr: `Animation et modélisation 3D`
  },
  cedrineRole: {
    en: `UI Design`,
    fr: `Conception UI`
  },
  williamRole: {
    en: `Creative Developer`,
    fr: `Développeur créatif`
  },
  boombox: {
    en: `Music & Sound`,
    fr: `Musique et son`
  },
  jelaniRole: {
    en: `Junior Developer`,
    fr: `Développeur junior`
  },
  nicholasRole: {
    en: `Producer`,
    fr: `Producteur`
  },
  robRole: {
    en: `Executive Producer`,
    fr: `Producteur exécutif`
  },
  jasmineRole: {
    en: `Senior Production Coordinator`,
    fr: `Coordonnatrice de production principale`
  },
  camilleJanineRole: {
    en: `Operation Managers`,
    fr: `Gestionnaires des opérations`
  },
  victoriaRole: {
    en: `Studio Administrator`,
    fr: `Administratrice du studio`
  },
  tammyRole: {
    en: `Marketing Managers`,
    fr: `Responsable marketing`
  },
  jenniferRole: {
    en: `Publicist`,
    fr: `Relationniste`
  },
  ericRole: {
    en: `Marketing Coordinator`,
    fr: `Coordonnateur marketing`
  },
  sergiuRole: {
    en: `Information Technology`,
    fr: `Technologie de l'information`
  },
  catherineRole: {
    en: `Digital Platforms`,
    fr: `Plateformes numériques`
  },
  christianRole: {
    en: `Legal Services`,
    fr: `Services juridiques`
  },
  socialRole: {
    en: `Social Media`,
    fr: `Médias sociaux`
  },
  gabrielleRole: {
    en: `French Translation by`,
    fr: `Traduction française par`
  },
  introPresents: {
    en: "The National Film Board of Canada Presents",
    fr: "L'Office national du film du Canada présente"
  },
  // harshitRole: {
  //   en: `Poem verses adapted from Haiku Dataset by <a href="https://www.kaggle.com/hjhalani30/haiku-dataset" target="_blank">Harshit Jhalani</a>, licensed under <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>`,
  //   fr: `Vers poétiques adaptés de Haiku Dataset par <a href="https://www.kaggle.com/hjhalani30/haiku-dataset" target="_blank">Harshit Jhalani</a>, licencié sous <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>`,
  // },
  endState0: {
    en: "You've recovered all the lost poetic fragments.",
    fr: "Vous avez retrouvé tous les fragments poétiques perdus."
  },
  endState1: {
    en: "With your help, nature's memories have been restored.",
    fr: "Avec votre aide, les souvenirs de la nature ont été restaurés."
  },
  endState2: {
    en: `Thanks for playing. See more NFB projects at <a href="https://www.nfb.ca/interactive/">nfb.ca/interactive</a>`,
    fr: `Merci d'avoir joué. Découvrez d'autres projets de l'ONF sur <a href="https://www.onf.ca/interactif/">onf.ca/interactif</a>`
  },
  endState2A: {
    en: `Thanks for playing.`,
    fr: `Merci d'avoir joué.`
  },
  endState2B: {
    en: `See more NFB projects at <a href="https://www.nfb.ca/interactive/">nfb.ca/interactive</a>`,
    fr: `Découvrez d'autres projets de l'ONF sur <a href="https://www.onf.ca/interactif/">onf.ca/interactif</a>`
  },
  journalButton: {
    en: "poems",
    fr: "poèmes"
  }
};

const toLangCopy = lang => Object.entries(splitCopy).reduce((dict, e) => {
  dict[e[0]] = e[1][lang];
  return dict;
}, {});

const copy = {
  en: toLangCopy("en"),
  fr: toLangCopy("fr")
};
const initialState = (0, _config.default)().lang === "fr" || /^fr$/i.test(_queryString.default.lang) ? "fr" : "en";
let currentState = initialState;
let currentCopy = copy[currentState];
const language = (0, _store.writable)(initialState);
exports.language = language;
const localize = (0, _store.writable)(currentCopy);
exports.localize = localize;

localize.get = function () {
  return currentCopy;
};

language.set = function (lang) {
  if (lang !== "en" && lang !== "fr") throw new Error(`Invalid language ${lang}`);
  return language.update(() => lang);
};

language.subscribe(lang => {
  currentState = lang;
  currentCopy = copy[currentState];
  localize.update(() => currentCopy);
});

language.get = function () {
  return currentState;
};
},{"svelte/store":"node_modules/svelte/store/index.mjs","../config":"src/config.js","./query-string":"src/util/query-string.js","./isMobile":"src/util/isMobile.js"}],"src/util/documentVisibility.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = documentVisibility;

function documentVisibility(cb) {
  var hidden, visibilityChange;

  if (typeof document.hidden !== "undefined") {
    // Opera 12.10 and Firefox 18 and later support
    hidden = "hidden";
    visibilityChange = "visibilitychange";
  } else if (typeof document.msHidden !== "undefined") {
    hidden = "msHidden";
    visibilityChange = "msvisibilitychange";
  } else if (typeof document.webkitHidden !== "undefined") {
    hidden = "webkitHidden";
    visibilityChange = "webkitvisibilitychange";
  }

  if (hidden) {
    const trigger = () => {
      if (document[hidden]) cb(false);else cb(true);
    }; // Handle page visibility change


    document.addEventListener(visibilityChange, trigger, false);
    trigger();
  } else {
    cb(true);
  }
}
},{}],"src/util/stores.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.audioState = void 0;

var _store = require("svelte/store");

var _documentVisibility = _interopRequireDefault(require("./documentVisibility"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const audioState = (0, _store.writable)({
  visible: true,
  muted: false
});
exports.audioState = audioState;
(0, _documentVisibility.default)(visible => {
  audioState.update(d => ({ ...d,
    visible
  }));
});
},{"svelte/store":"node_modules/svelte/store/index.mjs","./documentVisibility":"src/util/documentVisibility.js"}],"src/nfb.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sendTrackingPixel = sendTrackingPixel;
exports.revealHeader = revealHeader;
exports.hideHeader = hideHeader;
exports.sendAnalytics = sendAnalytics;
exports.startButtonTracking = startButtonTracking;

var _loadScript = _interopRequireDefault(require("load-script"));

var _config = _interopRequireDefault(require("./config.js"));

var _locale = require("./util/locale.js");

var _stores = require("./util/stores.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// const UA_ACCOUNTS = ["UA-32257069-1", "UA-124182036-7"];
const UA_ACCOUNTS = ["UA-124182036-7"];
const PROJECT_NAME = "wayfinder";
const USE_HEADER = true;
let headerTimer = null;
let headerVisible = false;
let resolve;
const promise = new Promise(cb => {
  resolve = cb;
});
let headerReady;
const headerReadyPromise = new Promise(cb => {
  headerReady = cb;
});

function sendTrackingPixel() {
  if (!(0, _config.default)().nfbHeader) return;
  const url = "https://ad.doubleclick.net/ddm/activity/src=10976879;type=1;cat=start0;dc_lat=;dc_rdid=;tag_for_child_directed_treatment=;tfua=;npa=;gdpr=${GDPR};gdpr_consent=${GDPR_CONSENT_755};ord=1?";
  let img = new Image();

  img.onload = () => {
    console.log("[analytics] Tracking Pixel");
    img = null;
  };

  img.onerror = () => {
    img = null;
    console.warn("[analytics] Tracking Pixel Ignored");
  };

  img.src = url;
}

async function revealHeader() {
  await Promise.all([promise, headerReadyPromise]); // if (headerVisible) return;
  // headerVisible = true;
  // clearTimeout(headerTimer);
  // headerTimer = null;

  window.ifw_header.reveal(); // document.body.classList.remove("hide-header");
  // document.body.classList.remove("anim-out-header");
  // if (window.ifw_header) window.ifw_header.reveal();
}

window.revealHeader = revealHeader;

async function hideHeader() {
  await Promise.all([promise, headerReadyPromise]); // if (!headerVisible) return;
  // headerVisible = false;
  // clearTimeout(headerTimer);
  // headerTimer = null;

  window.ifw_header.hide(); // // document.body.classList.add("anim-out-header");
  // headerTimer = setTimeout(() => {
  //   // document.body.classList.add("hide-header");
  // }, 1025);
  // if (window.ifw_header) window.ifw_header.hide();
}

async function sendAnalytics(opt = {}) {
  await promise;

  if (typeof google_analytics !== "undefined" && typeof google_analytics.gaTrack === "function") {
    console.log("[analytics] Sending", opt);

    const curLang = _locale.language.get();

    try {
      UA_ACCOUNTS.forEach(ua_code => {
        google_analytics.gaTrack({ ...opt,
          language: curLang,
          name: PROJECT_NAME,
          ua_code
        });
      });
    } catch (err) {
      console.warn(err);
    }
  }
}

if ((0, _config.default)().nfbHeader && USE_HEADER) {
  document.addEventListener("ifw_muteSound", ev => {
    _stores.audioState.update(d => ({ ...d,
      muted: true
    }));
  });
  document.addEventListener("ifw_unmuteSound", ev => {
    _stores.audioState.update(d => ({ ...d,
      muted: false
    }));
  });
  document.addEventListener("ifw_headerAdded", () => {
    window.ifw_header.hide();
    headerReady();
  });
  document.addEventListener("ifw_headerLoaded", () => {
    window.ifw_header.init({
      projectId: 237,
      baseUrl: {
        en: "http://wayfinder.nfb.ca/",
        fr: "http://traversees.onf.ca/"
      },
      analytics_name: "wayfinder",
      analytics_code: UA_ACCOUNTS[0],
      buttons: {
        shareTwitter: false,
        shareFB: false,
        // hideOnNoActivity: 10000,
        hideOnScroll: false
      },
      forceLocale: _locale.language.get()
    }); // setTimeout(revealHeader, 2500);
    // window.ifw_header.header.trackAnalytics = function () {
    //   debugger;
    //   return oldFunc.call(window.ifw_header.header);
    // };
    // window.ifw_header.stopAutoHide();
    // setTimeout(() => {
    //   window.ifw_header.hide();
    // }, 0);
    // document.querySelector('')

    console.log("NFB Header Loaded"); // document.body.classList.remove("hide-header");

    resolve();
    sendAnalytics({
      pageview: "index"
    });
    sendAnalytics({
      event: "auto_begin",
      eventLabel: "Wayfinder"
    }); // revealHeader();
  }); // document.body.classList.add("anim-out-header");

  (0, _loadScript.default)("https://interactive-pip.nfb.ca/v2/app.js", {
    async: true,
    type: "text/javascript"
  }, (err, script) => {
    if (err) {
      console.error("Could not load NFB header");
      console.error(err);
      resolve();
    }
  });
} else {
  setTimeout(resolve, 0);
}

function startButtonTracking() {
  const url = "https://ad.doubleclick.net/ddm/activity/src=10976879;type=1;cat=start0;dc_lat=;dc_rdid=;tag_for_child_directed_treatment=;tfua=;npa=;gdpr=${GDPR};gdpr_consent=${GDPR_CONSENT_755};ord=1?"; // what to do?
  // const img = new Image();
  // img.onload = () => console.error("image error");
  // img.src = url;
  // ,
  //   {
  //     type: "text/javascript",
  //   },
  //   (err, script) => {
  //     if (err) {
  //       console.error("[tracker] Could not load start tracking");
  //       console.error(err);
  //     } else {
  //       console.log("[tracker] Loaded start tracking");
  //     }
  //   }
  // );
}
},{"load-script":"node_modules/load-script/index.js","./config.js":"src/config.js","./util/locale.js":"src/util/locale.js","./util/stores.js":"src/util/stores.js"}],"node_modules/svelte/easing/index.mjs":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backIn = backIn;
exports.backInOut = backInOut;
exports.backOut = backOut;
exports.bounceIn = bounceIn;
exports.bounceInOut = bounceInOut;
exports.bounceOut = bounceOut;
exports.circIn = circIn;
exports.circInOut = circInOut;
exports.circOut = circOut;
exports.cubicIn = cubicIn;
exports.cubicInOut = cubicInOut;
exports.cubicOut = cubicOut;
exports.elasticIn = elasticIn;
exports.elasticInOut = elasticInOut;
exports.elasticOut = elasticOut;
exports.expoIn = expoIn;
exports.expoInOut = expoInOut;
exports.expoOut = expoOut;
exports.quadIn = quadIn;
exports.quadInOut = quadInOut;
exports.quadOut = quadOut;
exports.quartIn = quartIn;
exports.quartInOut = quartInOut;
exports.quartOut = quartOut;
exports.quintIn = quintIn;
exports.quintInOut = quintInOut;
exports.quintOut = quintOut;
exports.sineIn = sineIn;
exports.sineInOut = sineInOut;
exports.sineOut = sineOut;
Object.defineProperty(exports, "linear", {
  enumerable: true,
  get: function () {
    return _index.identity;
  }
});

var _index = require("../internal/index.mjs");

/*
Adapted from https://github.com/mattdesl
Distributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md
*/
function backInOut(t) {
  const s = 1.70158 * 1.525;
  if ((t *= 2) < 1) return 0.5 * (t * t * ((s + 1) * t - s));
  return 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2);
}

function backIn(t) {
  const s = 1.70158;
  return t * t * ((s + 1) * t - s);
}

function backOut(t) {
  const s = 1.70158;
  return --t * t * ((s + 1) * t + s) + 1;
}

function bounceOut(t) {
  const a = 4.0 / 11.0;
  const b = 8.0 / 11.0;
  const c = 9.0 / 10.0;
  const ca = 4356.0 / 361.0;
  const cb = 35442.0 / 1805.0;
  const cc = 16061.0 / 1805.0;
  const t2 = t * t;
  return t < a ? 7.5625 * t2 : t < b ? 9.075 * t2 - 9.9 * t + 3.4 : t < c ? ca * t2 - cb * t + cc : 10.8 * t * t - 20.52 * t + 10.72;
}

function bounceInOut(t) {
  return t < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0)) : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;
}

function bounceIn(t) {
  return 1.0 - bounceOut(1.0 - t);
}

function circInOut(t) {
  if ((t *= 2) < 1) return -0.5 * (Math.sqrt(1 - t * t) - 1);
  return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
}

function circIn(t) {
  return 1.0 - Math.sqrt(1.0 - t * t);
}

function circOut(t) {
  return Math.sqrt(1 - --t * t);
}

function cubicInOut(t) {
  return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;
}

function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  const f = t - 1.0;
  return f * f * f + 1.0;
}

function elasticInOut(t) {
  return t < 0.5 ? 0.5 * Math.sin(+13.0 * Math.PI / 2 * 2.0 * t) * Math.pow(2.0, 10.0 * (2.0 * t - 1.0)) : 0.5 * Math.sin(-13.0 * Math.PI / 2 * (2.0 * t - 1.0 + 1.0)) * Math.pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;
}

function elasticIn(t) {
  return Math.sin(13.0 * t * Math.PI / 2) * Math.pow(2.0, 10.0 * (t - 1.0));
}

function elasticOut(t) {
  return Math.sin(-13.0 * (t + 1.0) * Math.PI / 2) * Math.pow(2.0, -10.0 * t) + 1.0;
}

function expoInOut(t) {
  return t === 0.0 || t === 1.0 ? t : t < 0.5 ? +0.5 * Math.pow(2.0, 20.0 * t - 10.0) : -0.5 * Math.pow(2.0, 10.0 - t * 20.0) + 1.0;
}

function expoIn(t) {
  return t === 0.0 ? t : Math.pow(2.0, 10.0 * (t - 1.0));
}

function expoOut(t) {
  return t === 1.0 ? t : 1.0 - Math.pow(2.0, -10.0 * t);
}

function quadInOut(t) {
  t /= 0.5;
  if (t < 1) return 0.5 * t * t;
  t--;
  return -0.5 * (t * (t - 2) - 1);
}

function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return -t * (t - 2.0);
}

function quartInOut(t) {
  return t < 0.5 ? +8.0 * Math.pow(t, 4.0) : -8.0 * Math.pow(t - 1.0, 4.0) + 1.0;
}

function quartIn(t) {
  return Math.pow(t, 4.0);
}

function quartOut(t) {
  return Math.pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;
}

function quintInOut(t) {
  if ((t *= 2) < 1) return 0.5 * t * t * t * t * t;
  return 0.5 * ((t -= 2) * t * t * t * t + 2);
}

function quintIn(t) {
  return t * t * t * t * t;
}

function quintOut(t) {
  return --t * t * t * t * t + 1;
}

function sineInOut(t) {
  return -0.5 * (Math.cos(Math.PI * t) - 1);
}

function sineIn(t) {
  const v = Math.cos(t * Math.PI * 0.5);
  if (Math.abs(v) < 1e-14) return 1;else return 1 - v;
}

function sineOut(t) {
  return Math.sin(t * Math.PI / 2);
}
},{"../internal/index.mjs":"node_modules/svelte/internal/index.mjs"}],"node_modules/svelte/transition/index.mjs":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.blur = blur;
exports.crossfade = crossfade;
exports.draw = draw;
exports.fade = fade;
exports.fly = fly;
exports.scale = scale;
exports.slide = slide;

var _index = require("../easing/index.mjs");

var _index2 = require("../internal/index.mjs");

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

function blur(node, {
  delay = 0,
  duration = 400,
  easing = _index.cubicInOut,
  amount = 5,
  opacity = 0
}) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const f = style.filter === 'none' ? '' : style.filter;
  const od = target_opacity * (1 - opacity);
  return {
    delay,
    duration,
    easing,
    css: (_t, u) => `opacity: ${target_opacity - od * u}; filter: ${f} blur(${u * amount}px);`
  };
}

function fade(node, {
  delay = 0,
  duration = 400,
  easing = _index.linear
}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay,
    duration,
    easing,
    css: t => `opacity: ${t * o}`
  };
}

function fly(node, {
  delay = 0,
  duration = 400,
  easing = _index.cubicOut,
  x = 0,
  y = 0,
  opacity = 0
}) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const transform = style.transform === 'none' ? '' : style.transform;
  const od = target_opacity * (1 - opacity);
  return {
    delay,
    duration,
    easing,
    css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - od * u}`
  };
}

function slide(node, {
  delay = 0,
  duration = 400,
  easing = _index.cubicOut
}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const height = parseFloat(style.height);
  const padding_top = parseFloat(style.paddingTop);
  const padding_bottom = parseFloat(style.paddingBottom);
  const margin_top = parseFloat(style.marginTop);
  const margin_bottom = parseFloat(style.marginBottom);
  const border_top_width = parseFloat(style.borderTopWidth);
  const border_bottom_width = parseFloat(style.borderBottomWidth);
  return {
    delay,
    duration,
    easing,
    css: t => 'overflow: hidden;' + `opacity: ${Math.min(t * 20, 1) * opacity};` + `height: ${t * height}px;` + `padding-top: ${t * padding_top}px;` + `padding-bottom: ${t * padding_bottom}px;` + `margin-top: ${t * margin_top}px;` + `margin-bottom: ${t * margin_bottom}px;` + `border-top-width: ${t * border_top_width}px;` + `border-bottom-width: ${t * border_bottom_width}px;`
  };
}

function scale(node, {
  delay = 0,
  duration = 400,
  easing = _index.cubicOut,
  start = 0,
  opacity = 0
}) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const transform = style.transform === 'none' ? '' : style.transform;
  const sd = 1 - start;
  const od = target_opacity * (1 - opacity);
  return {
    delay,
    duration,
    easing,
    css: (_t, u) => `
			transform: ${transform} scale(${1 - sd * u});
			opacity: ${target_opacity - od * u}
		`
  };
}

function draw(node, {
  delay = 0,
  speed,
  duration,
  easing = _index.cubicInOut
}) {
  const len = node.getTotalLength();

  if (duration === undefined) {
    if (speed === undefined) {
      duration = 800;
    } else {
      duration = len / speed;
    }
  } else if (typeof duration === 'function') {
    duration = duration(len);
  }

  return {
    delay,
    duration,
    easing,
    css: (t, u) => `stroke-dasharray: ${t * len} ${u * len}`
  };
}

function crossfade(_a) {
  var {
    fallback
  } = _a,
      defaults = __rest(_a, ["fallback"]);

  const to_receive = new Map();
  const to_send = new Map();

  function crossfade(from, node, params) {
    const {
      delay = 0,
      duration = d => Math.sqrt(d) * 30,
      easing = _index.cubicOut
    } = (0, _index2.assign)((0, _index2.assign)({}, defaults), params);
    const to = node.getBoundingClientRect();
    const dx = from.left - to.left;
    const dy = from.top - to.top;
    const dw = from.width / to.width;
    const dh = from.height / to.height;
    const d = Math.sqrt(dx * dx + dy * dy);
    const style = getComputedStyle(node);
    const transform = style.transform === 'none' ? '' : style.transform;
    const opacity = +style.opacity;
    return {
      delay,
      duration: (0, _index2.is_function)(duration) ? duration(d) : duration,
      easing,
      css: (t, u) => `
				opacity: ${t * opacity};
				transform-origin: top left;
				transform: ${transform} translate(${u * dx}px,${u * dy}px) scale(${t + (1 - t) * dw}, ${t + (1 - t) * dh});
			`
    };
  }

  function transition(items, counterparts, intro) {
    return (node, params) => {
      items.set(params.key, {
        rect: node.getBoundingClientRect()
      });
      return () => {
        if (counterparts.has(params.key)) {
          const {
            rect
          } = counterparts.get(params.key);
          counterparts.delete(params.key);
          return crossfade(rect, node, params);
        } // if the node is disappearing altogether
        // (i.e. wasn't claimed by the other list)
        // then we need to supply an outro


        items.delete(params.key);
        return fallback && fallback(node, params, intro);
      };
    };
  }

  return [transition(to_send, to_receive, false), transition(to_receive, to_send, true)];
}
},{"../easing/index.mjs":"node_modules/svelte/easing/index.mjs","../internal/index.mjs":"node_modules/svelte/internal/index.mjs"}],"src/assets/video/intro.mp4":[function(require,module,exports) {
module.exports = "/intro.445d48d9.mp4";
},{}],"src/util/globalIntroVideo.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unmountVideo = unmountVideo;
exports.hasVideo = hasVideo;
exports.pauseVideo = pauseVideo;
exports.getMetadata = getMetadata;
exports.getVideo = getVideo;

var _intro = _interopRequireDefault(require("../assets/video/intro.mp4"));

var _stores = require("./stores");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let video;
let metadataCB;
let metadata = new Promise(resolve => {
  metadataCB = resolve;
});

_stores.audioState.subscribe(({
  muted,
  visible
}) => {
  const shouldMute = muted || !visible;

  if (hasVideo()) {
    const vid = getVideo();
    vid.muted = shouldMute;
  }
});

function unmountVideo() {
  if (video) {
    console.log("pausing video");
    video.pause();
    if (video.parentElement) video.parentElement.removeChild(video);
    video = null;
  }
}

function hasVideo() {
  return Boolean(video);
}

function pauseVideo() {
  if (video) video.pause();
}

function getMetadata() {
  return metadata;
}

function getVideo() {
  if (!video) {
    video = document.createElement("video");
    video.className = "global-intro-video";
    video.style.visibility = "hidden";
    video.setAttribute("src", _intro.default);
    video.setAttribute("webkit-playsinline", "webkit-playsinline");
    video.setAttribute("playsinline", "playsinline"); // video.setAttribute("volume", 0.3);

    video.setAttribute("preload", "auto");
    video.volume = 0.4;
    video.removeAttribute("controls");
    video.addEventListener("loadedmetadata", metadataCB);
    video.load();
  }

  return video;
}
},{"../assets/video/intro.mp4":"src/assets/video/intro.mp4","./stores":"src/util/stores.js"}],"src/components/PoemTagButton.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _locale = require("../util/locale.js");

var _ico_haiku = _interopRequireDefault(require("../assets/image/ui/ico_haiku.png"));

var _ico_haiku_leaf = _interopRequireDefault(require("../assets/image/ui/ico_haiku_leaf.png"));

var _transitions = require("../animations/transitions.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* components/PoemTagButton.svelte generated by Svelte v3.31.0 */
function create_fragment(ctx) {
  let div1;
  let img0;
  let img0_src_value;
  let t0;
  let div0;
  let img1;
  let img1_src_value;
  let t1;
  let p;
  let t2_value =
  /*$localize*/
  ctx[4].journalTitle + "";
  let t2;
  let div1_intro;
  let div1_outro;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = (0, _internal.element)("div");
      img0 = (0, _internal.element)("img");
      t0 = (0, _internal.space)();
      div0 = (0, _internal.element)("div");
      img1 = (0, _internal.element)("img");
      t1 = (0, _internal.space)();
      p = (0, _internal.element)("p");
      t2 = (0, _internal.text)(t2_value);
      if (img0.src !== (img0_src_value = _ico_haiku.default)) (0, _internal.attr)(img0, "src", img0_src_value);
      (0, _internal.attr)(img0, "alt", "Haiku Tag");
      (0, _internal.attr)(img0, "class", "haiku-tag svelte-n0azwu");
      if (img1.src !== (img1_src_value = _ico_haiku_leaf.default)) (0, _internal.attr)(img1, "src", img1_src_value);
      (0, _internal.attr)(img1, "alt", "Haiku Tag Leaf");
      (0, _internal.attr)(img1, "class", "haiku-tag-leaf svelte-n0azwu");
      (0, _internal.attr)(p, "class", "haiku-tag-text svelte-n0azwu");
      (0, _internal.attr)(div0, "class", "haiku-tag-text-container svelte-n0azwu");
      (0, _internal.attr)(div1, "class", "haiku-tag-container svelte-n0azwu");
      (0, _internal.toggle_class)(div1, "button",
      /*button*/
      ctx[0]);
      (0, _internal.toggle_class)(div1, "useMargin",
      /*useMargin*/
      ctx[3]);
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div1, anchor);
      (0, _internal.append)(div1, img0);
      (0, _internal.append)(div1, t0);
      (0, _internal.append)(div1, div0);
      (0, _internal.append)(div0, img1);
      (0, _internal.append)(div0, t1);
      (0, _internal.append)(div0, p);
      (0, _internal.append)(p, t2);
      current = true;

      if (!mounted) {
        dispose = (0, _internal.listen)(div1, "click",
        /*click_handler*/
        ctx[5]);
        mounted = true;
      }
    },

    p(ctx, [dirty]) {
      if ((!current || dirty &
      /*$localize*/
      16) && t2_value !== (t2_value =
      /*$localize*/
      ctx[4].journalTitle + "")) (0, _internal.set_data)(t2, t2_value);

      if (dirty &
      /*button*/
      1) {
        (0, _internal.toggle_class)(div1, "button",
        /*button*/
        ctx[0]);
      }

      if (dirty &
      /*useMargin*/
      8) {
        (0, _internal.toggle_class)(div1, "useMargin",
        /*useMargin*/
        ctx[3]);
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.add_render_callback)(() => {
        if (div1_outro) div1_outro.end(1);
        if (!div1_intro) div1_intro = (0, _internal.create_in_transition)(div1,
        /*inTransition*/
        ctx[1], {});
        div1_intro.start();
      });
      current = true;
    },

    o(local) {
      if (div1_intro) div1_intro.invalidate();
      div1_outro = (0, _internal.create_out_transition)(div1,
      /*outTransition*/
      ctx[2], {});
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div1);
      if (detaching && div1_outro) div1_outro.end();
      mounted = false;
      dispose();
    }

  };
}

function instance($$self, $$props, $$invalidate) {
  let $localize;
  (0, _internal.component_subscribe)($$self, _locale.localize, $$value => $$invalidate(4, $localize = $$value));
  let {
    button = true
  } = $$props;
  let {
    inTransition = _transitions.emptyTransition
  } = $$props;
  let {
    outTransition = _transitions.emptyTransition
  } = $$props;
  let {
    useMargin = true
  } = $$props;

  function click_handler(event) {
    (0, _internal.bubble)($$self, event);
  }

  $$self.$$set = $$props => {
    if ("button" in $$props) $$invalidate(0, button = $$props.button);
    if ("inTransition" in $$props) $$invalidate(1, inTransition = $$props.inTransition);
    if ("outTransition" in $$props) $$invalidate(2, outTransition = $$props.outTransition);
    if ("useMargin" in $$props) $$invalidate(3, useMargin = $$props.useMargin);
  };

  return [button, inTransition, outTransition, useMargin, $localize, click_handler];
}

class PoemTagButton extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      button: 0,
      inTransition: 1,
      outTransition: 2,
      useMargin: 3
    });
  }

}

var _default = PoemTagButton;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","../util/locale.js":"src/util/locale.js","../assets/image/ui/ico_haiku.png":"src/assets/image/ui/ico_haiku.png","../assets/image/ui/ico_haiku_leaf.png":"src/assets/image/ui/ico_haiku_leaf.png","../animations/transitions.js":"src/animations/transitions.js"}],"src/util/tiny-event.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _array = require("./array");

class Emitter {
  constructor() {
    this._events = {};
  }

  dispose() {
    for (let k in this._events) {
      if (this._events.hasOwnProperty(k)) {
        delete this._events;
      }
    }

    return this;
  }

  on(name, listener) {
    if (!(name in this._events)) {
      this._events[name] = [listener];
    } else {
      this._events[name].push(listener);
    }

    return this;
  }

  once(name, listener) {
    const wrapper = (...args) => {
      this.off(name, wrapper);
      return listener(...args);
    };

    return this.on(name, wrapper);
  }

  off(name, listener) {
    if (name in this._events) {
      (0, _array.spliceObject)(this._events[name], listener);
    }

    return this;
  }

  emit(name, ev) {
    if (name in this._events) {
      const array = this._events[name];

      for (let i = 0; i < array.length; i++) {
        array[i](ev);
      }
    }

    return this;
  }

}

exports.default = Emitter;
},{"./array":"src/util/array.js"}],"src/util/tiny-input.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createInputEvents;

var _tinyEvent = _interopRequireDefault(require("./tiny-event"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createInputEvents(opt) {
  if (opt == null) opt = window;
  if (isDOMNode(opt)) opt = {
    target: opt
  };
  const {
    target = window,
    parent = window,
    tapDistanceThreshold = 10,
    tapDelay = 300,
    preventDefault = false,
    filtered = true,
    passive = true
  } = opt;
  const eventOpts = passive ? {
    passive: true
  } : undefined;
  const emitter = new _tinyEvent.default();
  let initialIdentifier;
  let dragging = false;
  let lastTime;
  let lastPosition;
  let attached = false;
  attach();
  emitter.enable = attach;
  emitter.disable = detach;
  Object.defineProperties(emitter, {
    target: {
      get() {
        return target;
      }

    },
    parent: {
      get() {
        return parent;
      }

    }
  });
  return emitter;

  function mousedown(event) {
    // mark the drag event as having started
    dragging = true;
    const touch = getCurrentEvent(event);
    const result = createEvent(event, touch, target);
    lastPosition = result.position.slice();
    lastTime = Date.now();
    console.log("down");
    emitter.emit("down", result);
  }

  function mouseup(event) {
    const wasDragging = dragging;
    const touch = getCurrentEvent(event);
    let valid = true;

    if (filtered && event.changedTouches && (!touch || touch.identifier !== initialIdentifier)) {
      // skip entirely if this touch doesn't match expected
      valid = false;
    }

    if (touch && valid) {
      const result = createEvent(event, touch, target);
      initialIdentifier = null;

      if (wasDragging || result.inside) {
        // If the interaction was or is inside, emit an event
        emitter.emit("up", result);
      }

      if (lastPosition != null) {
        const nowTime = Date.now();
        const delta = nowTime - lastTime;
        const dist = distance(result.position, lastPosition);

        if (delta <= tapDelay && dist < tapDistanceThreshold) {
          emitter.emit("tap", result);
        }

        lastPosition = null;
      }

      dragging = false;
    }
  }

  function mousemove(event) {
    const touch = getCurrentEvent(event);

    if (touch) {
      // we didn't have an identifier and now we do
      if (filtered && event.changedTouches && touch.identifier != null) {
        const bounds = getElementBounds(target);

        if (isInsideBounds(touch, bounds)) {
          // ensure dragging is set to true
          dragging = true;
        }
      }

      const result = createEvent(event, touch, target);

      if (dragging || result.inside) {
        emitter.emit("move", result);
      }
    }
  }

  function attach() {
    if (attached) return;
    attached = true;
    target.addEventListener("touchstart", mousedown, eventOpts);
    parent.addEventListener("touchend", mouseup, eventOpts);
    parent.addEventListener("touchmove", mousemove, eventOpts);
    target.addEventListener("mousedown", mousedown, eventOpts);
    parent.addEventListener("mouseup", mouseup, eventOpts);
    parent.addEventListener("mousemove", mousemove, eventOpts);

    if (preventDefault) {
      window.addEventListener("dragstart", preventDefaultEvent, {
        passive: false
      });
      document.addEventListener("touchmove", preventDefaultEvent, {
        passive: false
      });
    }
  }

  function detach() {
    if (!attached) return;
    attached = false;
    target.removeEventListener("touchstart", mousedown);
    parent.removeEventListener("touchend", mouseup);
    parent.removeEventListener("touchmove", mousemove);
    target.removeEventListener("mousedown", mousedown);
    parent.removeEventListener("mouseup", mouseup);
    parent.removeEventListener("mousemove", mousemove);

    if (preventDefault) {
      window.removeEventListener("dragstart", preventDefaultEvent);
      document.removeEventListener("touchmove", preventDefaultEvent);
    }
  }

  function preventDefaultEvent(ev) {
    ev.preventDefault();
    return false;
  }

  function getCurrentEvent(event) {
    if (event.changedTouches) {
      const list = event.changedTouches;

      if (filtered) {
        if (initialIdentifier == null) {
          // first time tracking, mark identifier
          const first = getFirstTargetTouch(list) || list[0];
          initialIdentifier = first.identifier;
          return first;
        } else {
          // identifier exists, try to get it
          return getTouch(list, initialIdentifier);
        }
      } else {
        return list[0];
      }
    } else {
      return event;
    }
  }

  function getFirstTargetTouch(touches) {
    for (let i = 0; i < touches.length; i++) {
      const t = touches[i];
      if (t.target === target) return t;
    }

    return null;
  }

  function getTouch(touches, id) {
    for (let i = 0; i < touches.length; i++) {
      const t = touches[i];

      if (t.identifier === id) {
        return t;
      }
    }

    return null;
  }

  function createEvent(event, touch, target) {
    const bounds = getElementBounds(target);
    const position = getPosition(touch, target, bounds);
    const uv = getNormalizedPosition(position, bounds);
    return {
      dragging,
      touch,
      inside: isInsideBounds(touch, bounds),
      position,
      uv,
      event,
      bounds
    };
  }
}

function distance(a, b) {
  const x = b[0] - a[0];
  const y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}

function isInsideBounds(event, bounds) {
  const {
    clientX,
    clientY
  } = event;
  return clientX >= bounds.left && clientX < bounds.right && clientY >= bounds.top && clientY < bounds.bottom;
}

function getNormalizedPosition(position, bounds) {
  return [position[0] / bounds.width, position[1] / bounds.height];
}

function getPosition(event, target, bounds) {
  const {
    clientX,
    clientY
  } = event;
  const x = clientX - bounds.left;
  const y = clientY - bounds.top;
  return [x, y];
}

function getElementBounds(element) {
  if (element === window || element === document || element === document.body) {
    return {
      x: 0,
      y: 0,
      left: 0,
      top: 0,
      right: window.innerWidth,
      bottom: window.innerHeight,
      width: window.innerWidth,
      height: window.innerHeight
    };
  } else {
    return element.getBoundingClientRect();
  }
}

function isDOMNode(obj) {
  if (!obj || obj == null) return false;
  const winEl = typeof window !== "undefined" ? window : null;
  return obj === winEl || typeof obj.nodeType === "number" && typeof obj.nodeName === "string";
}
},{"./tiny-event":"src/util/tiny-event.js"}],"src/components/IconButton.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _Image = _interopRequireDefault(require("./Image.svelte"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* components/IconButton.svelte generated by Svelte v3.31.0 */
function create_if_block_1(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = (0, _internal.element)("img");
      (0, _internal.attr)(img, "class", "icon svelte-fi0yj6");
      if (img.src !== (img_src_value =
      /*icon*/
      ctx[0])) (0, _internal.attr)(img, "src", img_src_value);
      (0, _internal.attr)(img, "alt",
      /*alt*/
      ctx[4]);
    },

    m(target, anchor) {
      (0, _internal.insert)(target, img, anchor);
    },

    p(ctx, dirty) {
      if (dirty &
      /*icon*/
      1 && img.src !== (img_src_value =
      /*icon*/
      ctx[0])) {
        (0, _internal.attr)(img, "src", img_src_value);
      }

      if (dirty &
      /*alt*/
      16) {
        (0, _internal.attr)(img, "alt",
        /*alt*/
        ctx[4]);
      }
    },

    i: _internal.noop,
    o: _internal.noop,

    d(detaching) {
      if (detaching) (0, _internal.detach)(img);
    }

  };
} // (20:2) {#if id || image}


function create_if_block(ctx) {
  let image_1;
  let current;
  image_1 = new _Image.default({
    props: {
      id:
      /*id*/
      ctx[1],
      alt:
      /*alt*/
      ctx[4],
      image:
      /*image*/
      ctx[2],
      ignorePointer: true
    }
  });
  return {
    c() {
      (0, _internal.create_component)(image_1.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(image_1, target, anchor);
      current = true;
    },

    p(ctx, dirty) {
      const image_1_changes = {};
      if (dirty &
      /*id*/
      2) image_1_changes.id =
      /*id*/
      ctx[1];
      if (dirty &
      /*alt*/
      16) image_1_changes.alt =
      /*alt*/
      ctx[4];
      if (dirty &
      /*image*/
      4) image_1_changes.image =
      /*image*/
      ctx[2];
      image_1.$set(image_1_changes);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(image_1.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(image_1.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(image_1, detaching);
    }

  };
}

function create_fragment(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block, create_if_block_1];
  const if_blocks = [];

  function select_block_type(ctx, dirty) {
    if (
    /*id*/
    ctx[1] ||
    /*image*/
    ctx[2]) return 0;
    if (
    /*icon*/
    ctx[0]) return 1;
    return -1;
  }

  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }

  return {
    c() {
      div = (0, _internal.element)("div");
      if (if_block) if_block.c();
      (0, _internal.attr)(div, "class", "button svelte-fi0yj6");
      (0, _internal.toggle_class)(div, "small",
      /*small*/
      ctx[5]);
      (0, _internal.toggle_class)(div, "medium",
      /*medium*/
      ctx[6]);
      (0, _internal.toggle_class)(div, "large",
      /*large*/
      ctx[7]);
      (0, _internal.toggle_class)(div, "padded",
      /*padded*/
      ctx[3]);
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);

      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }

      current = true;

      if (!mounted) {
        dispose = (0, _internal.listen)(div, "click",
        /*click_handler*/
        ctx[9]);
        mounted = true;
      }
    },

    p(ctx, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);

      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        }
      } else {
        if (if_block) {
          (0, _internal.group_outros)();
          (0, _internal.transition_out)(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          (0, _internal.check_outros)();
        }

        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];

          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block.c();
          } else {
            if_block.p(ctx, dirty);
          }

          (0, _internal.transition_in)(if_block, 1);
          if_block.m(div, null);
        } else {
          if_block = null;
        }
      }

      if (dirty &
      /*small*/
      32) {
        (0, _internal.toggle_class)(div, "small",
        /*small*/
        ctx[5]);
      }

      if (dirty &
      /*medium*/
      64) {
        (0, _internal.toggle_class)(div, "medium",
        /*medium*/
        ctx[6]);
      }

      if (dirty &
      /*large*/
      128) {
        (0, _internal.toggle_class)(div, "large",
        /*large*/
        ctx[7]);
      }

      if (dirty &
      /*padded*/
      8) {
        (0, _internal.toggle_class)(div, "padded",
        /*padded*/
        ctx[3]);
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(if_block);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(if_block);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);

      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }

      mounted = false;
      dispose();
    }

  };
}

function instance($$self, $$props, $$invalidate) {
  let {
    icon = null
  } = $$props;
  let {
    id = null
  } = $$props;
  let {
    image = undefined
  } = $$props;
  let {
    padded = true
  } = $$props;
  let {
    size = null
  } = $$props;
  let {
    alt = ""
  } = $$props;
  let small, medium, large;

  function click_handler(event) {
    (0, _internal.bubble)($$self, event);
  }

  $$self.$$set = $$props => {
    if ("icon" in $$props) $$invalidate(0, icon = $$props.icon);
    if ("id" in $$props) $$invalidate(1, id = $$props.id);
    if ("image" in $$props) $$invalidate(2, image = $$props.image);
    if ("padded" in $$props) $$invalidate(3, padded = $$props.padded);
    if ("size" in $$props) $$invalidate(8, size = $$props.size);
    if ("alt" in $$props) $$invalidate(4, alt = $$props.alt);
  };

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*size*/
    256) {
      $: {
        $$invalidate(5, small = $$invalidate(6, medium = $$invalidate(7, large = false)));
        if (size === "small") $$invalidate(5, small = true);else if (size === "large") $$invalidate(7, large = true);else $$invalidate(6, medium = true);
      }
    }
  };

  return [icon, id, image, padded, alt, small, medium, large, size, click_handler];
}

class IconButton extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      icon: 0,
      id: 1,
      image: 2,
      padded: 3,
      size: 8,
      alt: 4
    });
  }

}

var _default = IconButton;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","./Image.svelte":"src/components/Image.svelte.js"}],"src/components/HaikuCard.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _tokens = require("../util/tokens");

var _ico_paperJournal1Rotated = _interopRequireDefault(require("../assets/image/ui/ico_paperJournal1-rotated.png"));

var _locale = require("../util/locale");

var _svelte = require("svelte");

var _transitions = require("../animations/transitions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* components/HaikuCard.svelte generated by Svelte v3.31.0 */
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  child_ctx[7] = i;
  return child_ctx;
}

function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  child_ctx[7] = i;
  return child_ctx;
} // (40:4) {#each tokens as token, i}


function create_each_block_1(ctx) {
  let div;
  let img;
  let img_src_value;
  let t;
  let div_intro;
  return {
    c() {
      div = (0, _internal.element)("div");
      img = (0, _internal.element)("img");
      t = (0, _internal.space)();
      if (img.src !== (img_src_value = _tokens.InvertedTokenURLs[
      /*token*/
      ctx[8]])) (0, _internal.attr)(img, "src", img_src_value);
      (0, _internal.attr)(img, "alt", "");
      (0, _internal.attr)(img, "class", "token-image svelte-wamszv");
      (0, _internal.attr)(div, "class", "token svelte-wamszv");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.append)(div, img);
      (0, _internal.append)(div, t);
    },

    p(ctx, dirty) {
      if (dirty &
      /*tokens*/
      2 && img.src !== (img_src_value = _tokens.InvertedTokenURLs[
      /*token*/
      ctx[8]])) {
        (0, _internal.attr)(img, "src", img_src_value);
      }
    },

    i(local) {
      if (!div_intro) {
        (0, _internal.add_render_callback)(() => {
          div_intro = (0, _internal.create_in_transition)(div,
          /*poemLinesAnimateIn*/
          ctx[2], {
            delay: 175 +
            /*i*/
            ctx[7] * 175 + 250,
            duration: 1000
          });
          div_intro.start();
        });
      }
    },

    o: _internal.noop,

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
    }

  };
} // (50:4) {#each lines as line, i}


function create_each_block(ctx) {
  let p;
  let t0_value =
  /*line*/
  ctx[5][
  /*curLang*/
  ctx[3]] + "";
  let t0;
  let t1;
  let p_intro;
  return {
    c() {
      p = (0, _internal.element)("p");
      t0 = (0, _internal.text)(t0_value);
      t1 = (0, _internal.space)();
      (0, _internal.attr)(p, "class", "svelte-wamszv");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, p, anchor);
      (0, _internal.append)(p, t0);
      (0, _internal.append)(p, t1);
    },

    p(ctx, dirty) {
      if (dirty &
      /*lines, curLang*/
      9 && t0_value !== (t0_value =
      /*line*/
      ctx[5][
      /*curLang*/
      ctx[3]] + "")) (0, _internal.set_data)(t0, t0_value);
    },

    i(local) {
      if (!p_intro) {
        (0, _internal.add_render_callback)(() => {
          p_intro = (0, _internal.create_in_transition)(p,
          /*poemLinesAnimateIn*/
          ctx[2], {
            delay: 175 + (4 +
            /*i*/
            ctx[7]) * 175 + 250,
            duration: 1000
          });
          p_intro.start();
        });
      }
    },

    o: _internal.noop,

    d(detaching) {
      if (detaching) (0, _internal.detach)(p);
    }

  };
}

function create_fragment(ctx) {
  let div2;
  let div0;
  let t;
  let div1;
  let div2_intro;
  let div2_outro;
  let current;
  let each_value_1 =
  /*tokens*/
  ctx[1];
  let each_blocks_1 = [];

  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }

  let each_value =
  /*lines*/
  ctx[0];
  let each_blocks = [];

  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }

  return {
    c() {
      div2 = (0, _internal.element)("div");
      div0 = (0, _internal.element)("div");

      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }

      t = (0, _internal.space)();
      div1 = (0, _internal.element)("div");

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }

      (0, _internal.attr)(div0, "class", "token-container svelte-wamszv");
      (0, _internal.attr)(div1, "class", "lines-container svelte-wamszv");
      (0, _internal.attr)(div2, "class", "container svelte-wamszv");
      (0, _internal.set_style)(div2, "background-image", "url(" + _ico_paperJournal1Rotated.default + ")");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div2, anchor);
      (0, _internal.append)(div2, div0);

      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(div0, null);
      }

      (0, _internal.append)(div2, t);
      (0, _internal.append)(div2, div1);

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }

      current = true;
    },

    p(ctx, [dirty]) {
      if (dirty &
      /*InvertedTokenURLs, tokens*/
      2) {
        each_value_1 =
        /*tokens*/
        ctx[1];
        let i;

        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx, each_value_1, i);

          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            (0, _internal.transition_in)(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            (0, _internal.transition_in)(each_blocks_1[i], 1);
            each_blocks_1[i].m(div0, null);
          }
        }

        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }

        each_blocks_1.length = each_value_1.length;
      }

      if (dirty &
      /*lines, curLang*/
      9) {
        each_value =
        /*lines*/
        ctx[0];
        let i;

        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx, each_value, i);

          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            (0, _internal.transition_in)(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            (0, _internal.transition_in)(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }

        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }

        each_blocks.length = each_value.length;
      }
    },

    i(local) {
      if (current) return;

      for (let i = 0; i < each_value_1.length; i += 1) {
        (0, _internal.transition_in)(each_blocks_1[i]);
      }

      for (let i = 0; i < each_value.length; i += 1) {
        (0, _internal.transition_in)(each_blocks[i]);
      }

      (0, _internal.add_render_callback)(() => {
        if (div2_outro) div2_outro.end(1);
        if (!div2_intro) div2_intro = (0, _internal.create_in_transition)(div2, _transitions.fadeTransition, {
          delay: 500,
          duration: 500
        });
        div2_intro.start();
      });
      current = true;
    },

    o(local) {
      if (div2_intro) div2_intro.invalidate();
      div2_outro = (0, _internal.create_out_transition)(div2, _transitions.fadeTransition, {
        duration: 250
      });
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div2);
      (0, _internal.destroy_each)(each_blocks_1, detaching);
      (0, _internal.destroy_each)(each_blocks, detaching);
      if (detaching && div2_outro) div2_outro.end();
    }

  };
}

function instance($$self, $$props, $$invalidate) {
  let {
    lines
  } = $$props;
  let {
    tokens
  } = $$props;
  let {
    animatePoem = false
  } = $$props;
  let poemLinesAnimateIn;

  let curLang = _locale.language.get();

  (0, _svelte.onMount)(() => {
    const detachLang = _locale.language.subscribe(s => {
      $$invalidate(3, curLang = s);
    });

    return () => {
      detachLang();
    };
  });

  $$self.$$set = $$props => {
    if ("lines" in $$props) $$invalidate(0, lines = $$props.lines);
    if ("tokens" in $$props) $$invalidate(1, tokens = $$props.tokens);
    if ("animatePoem" in $$props) $$invalidate(4, animatePoem = $$props.animatePoem);
  };

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*animatePoem*/
    16) {
      $: $$invalidate(2, poemLinesAnimateIn = animatePoem ? _transitions.fadeInTransition : _transitions.emptyTransition);
    }
  };

  return [lines, tokens, poemLinesAnimateIn, curLang, animatePoem];
}

class HaikuCard extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      lines: 0,
      tokens: 1,
      animatePoem: 4
    });
  }

}

var _default = HaikuCard;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","../util/tokens":"src/util/tokens.js","../assets/image/ui/ico_paperJournal1-rotated.png":"src/assets/image/ui/ico_paperJournal1-rotated.png","../util/locale":"src/util/locale.js","svelte":"node_modules/svelte/index.mjs","../animations/transitions":"src/animations/transitions.js"}],"node_modules/porter-stemmer/porter.js":[function(require,module,exports) {
// Porter stemmer in Javascript. Few comments, but it's easy to follow against
// the rules in the original paper, in
//
//  Porter, 1980, An algorithm for suffix stripping, Program, Vol. 14, no. 3,
//  pp 130-137,
//
// see also http://www.tartarus.org/~martin/PorterStemmer

// Release 1 be 'andargor', Jul 2004
// Release 2 (substantially revised) by Christopher McKenzie, Aug 2009
//
// CommonJS tweak by jedp

(function() {
  var step2list = {
      "ational" : "ate",
      "tional" : "tion",
      "enci" : "ence",
      "anci" : "ance",
      "izer" : "ize",
      "bli" : "ble",
      "alli" : "al",
      "entli" : "ent",
      "eli" : "e",
      "ousli" : "ous",
      "ization" : "ize",
      "ation" : "ate",
      "ator" : "ate",
      "alism" : "al",
      "iveness" : "ive",
      "fulness" : "ful",
      "ousness" : "ous",
      "aliti" : "al",
      "iviti" : "ive",
      "biliti" : "ble",
      "logi" : "log"
    };

  var step3list = {
      "icate" : "ic",
      "ative" : "",
      "alize" : "al",
      "iciti" : "ic",
      "ical" : "ic",
      "ful" : "",
      "ness" : ""
    };

  var c = "[^aeiou]";          // consonant
  var v = "[aeiouy]";          // vowel
  var C = c + "[^aeiouy]*";    // consonant sequence
  var V = v + "[aeiou]*";      // vowel sequence

  var mgr0 = "^(" + C + ")?" + V + C;               // [C]VC... is m>0
  var meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$";  // [C]VC[V] is m=1
  var mgr1 = "^(" + C + ")?" + V + C + V + C;       // [C]VCVC... is m>1
  var s_v = "^(" + C + ")?" + v;                   // vowel in stem

  function stemmer(w) {
    var stem;
    var suffix;
    var firstch;
    var re;
    var re2;
    var re3;
    var re4;
    var origword = w;

    if (w.length < 3) { return w; }

    firstch = w.substr(0,1);
    if (firstch == "y") {
      w = firstch.toUpperCase() + w.substr(1);
    }

    // Step 1a
    re = /^(.+?)(ss|i)es$/;
    re2 = /^(.+?)([^s])s$/;

    if (re.test(w)) { w = w.replace(re,"$1$2"); }
    else if (re2.test(w)) {  w = w.replace(re2,"$1$2"); }

    // Step 1b
    re = /^(.+?)eed$/;
    re2 = /^(.+?)(ed|ing)$/;
    if (re.test(w)) {
      var fp = re.exec(w);
      re = new RegExp(mgr0);
      if (re.test(fp[1])) {
        re = /.$/;
        w = w.replace(re,"");
      }
    } else if (re2.test(w)) {
      var fp = re2.exec(w);
      stem = fp[1];
      re2 = new RegExp(s_v);
      if (re2.test(stem)) {
        w = stem;
        re2 = /(at|bl|iz)$/;
        re3 = new RegExp("([^aeiouylsz])\\1$");
        re4 = new RegExp("^" + C + v + "[^aeiouwxy]$");
        if (re2.test(w)) { w = w + "e"; }
        else if (re3.test(w)) { re = /.$/; w = w.replace(re,""); }
        else if (re4.test(w)) { w = w + "e"; }
      }
    }

    // Step 1c
    re = /^(.+?)y$/;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      re = new RegExp(s_v);
      if (re.test(stem)) { w = stem + "i"; }
    }

    // Step 2
    re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      suffix = fp[2];
      re = new RegExp(mgr0);
      if (re.test(stem)) {
        w = stem + step2list[suffix];
      }
    }

    // Step 3
    re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      suffix = fp[2];
      re = new RegExp(mgr0);
      if (re.test(stem)) {
        w = stem + step3list[suffix];
      }
    }

    // Step 4
    re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
    re2 = /^(.+?)(s|t)(ion)$/;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      re = new RegExp(mgr1);
      if (re.test(stem)) {
        w = stem;
      }
    } else if (re2.test(w)) {
      var fp = re2.exec(w);
      stem = fp[1] + fp[2];
      re2 = new RegExp(mgr1);
      if (re2.test(stem)) {
        w = stem;
      }
    }

    // Step 5
    re = /^(.+?)e$/;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      re = new RegExp(mgr1);
      re2 = new RegExp(meq1);
      re3 = new RegExp("^" + C + v + "[^aeiouwxy]$");
      if (re.test(stem) || (re2.test(stem) && !(re3.test(stem)))) {
        w = stem;
      }
    }

    re = /ll$/;
    re2 = new RegExp(mgr1);
    if (re.test(w) && re2.test(w)) {
      re = /.$/;
      w = w.replace(re,"");
    }

    // and turn initial Y back to y

    if (firstch == "y") {
      w = firstch.toLowerCase() + w.substr(1);
    }

    return w;
  }

  // memoize at the module level
  var memo = {};
  var memoizingStemmer = function(w) {
    if (!memo[w]) {
      memo[w] = stemmer(w);
    }
    return memo[w];
  }

  if (typeof exports != 'undefined' && exports != null) {
    exports.stemmer = stemmer;
    exports.memoizingStemmer = memoizingStemmer;
  }

})();

},{}],"src/util/haikugen.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createHaikuGen;

var _Random = _interopRequireDefault(require("../util/Random"));

var _haikuPhrasesEn = _interopRequireDefault(require("../assets/json/haiku-phrases-en.json"));

var _haikuPhrasesFr = _interopRequireDefault(require("../assets/json/haiku-phrases-fr.json"));

var _porterStemmer = require("porter-stemmer");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const tokenize = line => line.replace(/\'[a-z]+/g, "").replace(/\-/g, " ").split(/\s+/g).filter(Boolean);

const stopwordStems = `of,the,on,for,and,in,a,from,at`.split(",").map(t => (0, _porterStemmer.stemmer)(t));

function createHaikuGen() {
  const data = _haikuPhrasesEn.default;
  const random = (0, _Random.default)();
  const tokens = Object.keys(data); // console.log("tokens", tokens);

  return {
    generate({
      tokens: curTokens,
      ignore = []
    } = {}) {
      curTokens = curTokens || this.randomTokens();
      let state = [];
      curTokens.forEach((token, stanza) => {
        const line = this.generateStanza({
          token,
          stanza,
          state,
          ignore
        });
        state.push(line);
      });
      return state;
    },

    randomTokens() {
      return random.shuffle(tokens).slice(0, 3);
    },

    generateStanza({
      stanza,
      token,
      state = [],
      ignore = []
    }) {
      const en = generateStanzaLocalized({
        lang: "en",
        stanza,
        token,
        state: state.map(s => s.en),
        ignore: ignore.map(s => s.en)
      });
      const fr = generateStanzaLocalized({
        // NOTE: French skips the state/ignore functionality as there's so few lines
        lang: "fr",
        stanza,
        token
      });
      return {
        en,
        fr
      };
    }

  };

  function generateStanzaLocalized({
    lang = "en",
    stanza,
    token,
    state = [],
    ignore = []
  }) {
    if (stanza == null || stanza < 0 && stanza > 2) throw new Error(`Must specify stanza index 0, 1 or 2 `);
    if (!token) throw new Error(`Must specify token`);
    const data = lang === "en" ? _haikuPhrasesEn.default : _haikuPhrasesFr.default;
    if (!(token in data)) throw new Error(`No haiku data for token ${token}`); // 1 - choose all available stanza phrases from data + token

    const phrases = data[token][stanza].map(t => t.trim()); // 2 - if we have some previous state (i.e. previous line(s) of poem)
    // then we combine and stem, and any phrases that have matches are ignored

    const stateStems = tokenize(state.join(" ")).map(t => (0, _porterStemmer.stemmer)(t));
    const stateKeywords = stateStems.filter(stem => !stopwordStems.includes(stem)); // console.log("kw", stateKeywords);

    let bestPhrases = phrases.slice();

    if (stateStems.length) {
      // 3 - Remove phrases that have a non-stopword match
      // with previous stems
      bestPhrases = filterThreshold(bestPhrases, phrase => {
        return !stateKeywords.some(stem => phrase.includes(stem));
      }, 2);
    } // 4 - remove any phrases that exactly match a previously picked phrase


    const ignoreLines = ignore.flat();
    const old = bestPhrases.slice();
    bestPhrases = filterThreshold(bestPhrases, phrase => {
      return !ignoreLines.includes(phrase);
    }, 2); // if (old.length !== bestPhrases.length) {
    //   console.log(
    //     "got some removed",
    //     filterThreshold(
    //       bestPhrases,
    //       (phrase) => {
    //         return ignoreLines.includes(phrase);
    //       },
    //       2
    //     )
    //   );
    // }
    // safeguard to avoid repetitive results

    bestPhrases = bestPhrases.length >= 2 ? bestPhrases : phrases;
    return random.pick(bestPhrases);
  }

  function filterThreshold(lines, filterFn, minThreshold = 1) {
    const newLines = lines.filter(filterFn);
    return newLines.length > minThreshold ? newLines : lines;
  }
}
},{"../util/Random":"src/util/Random.js","../assets/json/haiku-phrases-en.json":"src/assets/json/haiku-phrases-en.json","../assets/json/haiku-phrases-fr.json":"src/assets/json/haiku-phrases-fr.json","porter-stemmer":"node_modules/porter-stemmer/porter.js"}],"src/components/CloseButton.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _svelte = require("svelte");

var _transitions = require("../animations/transitions");

var _Image = _interopRequireDefault(require("../components/Image.svelte"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* components/CloseButton.svelte generated by Svelte v3.31.0 */
function create_fragment(ctx) {
  let div;
  let image;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  image = new _Image.default({
    props: {
      width: "100%",
      id: "image/ui/close-button"
    }
  });
  return {
    c() {
      div = (0, _internal.element)("div");
      (0, _internal.create_component)(image.$$.fragment);
      (0, _internal.attr)(div, "class", "close-button svelte-d162at");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.mount_component)(image, div, null);
      current = true;

      if (!mounted) {
        dispose = (0, _internal.listen)(div, "click",
        /*click_handler*/
        ctx[1]);
        mounted = true;
      }
    },

    p(new_ctx, [dirty]) {
      ctx = new_ctx;
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(image.$$.fragment, local);
      (0, _internal.add_render_callback)(() => {
        if (div_outro) div_outro.end(1);
        if (!div_intro) div_intro = (0, _internal.create_in_transition)(div, _transitions.fadeInTransition, {
          delay:
          /*delay*/
          ctx[0],
          duration: 100
        });
        div_intro.start();
      });
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(image.$$.fragment, local);
      if (div_intro) div_intro.invalidate();
      div_outro = (0, _internal.create_out_transition)(div, _transitions.fadeInTransition, {
        delay:
        /*delay*/
        ctx[0],
        duration: 100
      });
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      (0, _internal.destroy_component)(image);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      dispose();
    }

  };
}

function instance($$self, $$props, $$invalidate) {
  let {
    delay = 0
  } = $$props;

  function click_handler(event) {
    (0, _internal.bubble)($$self, event);
  }

  $$self.$$set = $$props => {
    if ("delay" in $$props) $$invalidate(0, delay = $$props.delay);
  };

  return [delay, click_handler];
}

class CloseButton extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      delay: 0
    });
  }

}

var _default = CloseButton;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","svelte":"node_modules/svelte/index.mjs","../animations/transitions":"src/animations/transitions.js","../components/Image.svelte":"src/components/Image.svelte.js"}],"src/overlays/PoemCollectionOverlay.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _tinyInput = _interopRequireDefault(require("../util/tiny-input"));

var _tokens = require("../util/tokens");

var _transition = require("svelte/transition");

var _svelte = require("svelte");

var _locale = require("../util/locale.js");

var _IconButton = _interopRequireDefault(require("../components/IconButton.svelte"));

var _ico_scrollbar = _interopRequireDefault(require("../assets/image/ui/ico_scrollbar.png"));

var _ico_toggle = _interopRequireDefault(require("../assets/image/ui/ico_toggle.png"));

var _ico_openjournal = _interopRequireDefault(require("../assets/image/ui/ico_openjournal.png"));

var _HaikuCard = _interopRequireDefault(require("../components/HaikuCard.svelte"));

var _haikugen = _interopRequireDefault(require("../util/haikugen"));

var _CloseButton = _interopRequireDefault(require("../components/CloseButton.svelte"));

var _PoemTagButton = _interopRequireDefault(require("../components/PoemTagButton.svelte"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* overlays/PoemCollectionOverlay.svelte generated by Svelte v3.31.0 */
// import paperJournalOne from "../assets/image/ui/ico_paperJournal1-rotated.png";
// import paperJournalTwo from "../assets/image/ui/ico_paperJournal2-rotated.png";
// import closeSquare from "../assets/image/ui/ico_closeJournal.png";
// import closeX from "../assets/image/ui/ico_XcloseJournal.png";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  child_ctx[17] = i;
  return child_ctx;
} // (134:6) {#each poems as poem, i}


function create_each_block(ctx) {
  let haikucard;
  let current;
  haikucard = new _HaikuCard.default({
    props: {
      tokens:
      /*poem*/
      ctx[15].tokens,
      lines:
      /*poem*/
      ctx[15].lines
    }
  });
  return {
    c() {
      (0, _internal.create_component)(haikucard.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(haikucard, target, anchor);
      current = true;
    },

    p(ctx, dirty) {
      const haikucard_changes = {};
      if (dirty &
      /*poems*/
      2) haikucard_changes.tokens =
      /*poem*/
      ctx[15].tokens;
      if (dirty &
      /*poems*/
      2) haikucard_changes.lines =
      /*poem*/
      ctx[15].lines;
      haikucard.$set(haikucard_changes);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(haikucard.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(haikucard.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(haikucard, detaching);
    }

  };
}

function create_fragment(ctx) {
  let div5;
  let div1;
  let poemtagbutton;
  let t0;
  let div0;
  let t1;
  let closebutton;
  let t2;
  let div4;
  let div3;
  let div2;
  let img;
  let img_src_value;
  let img_draggable_value;
  let div5_transition;
  let current;
  let mounted;
  let dispose;
  poemtagbutton = new _PoemTagButton.default({
    props: {
      button: false
    }
  });
  let each_value =
  /*poems*/
  ctx[1];
  let each_blocks = [];

  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }

  const out = i => (0, _internal.transition_out)(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });

  closebutton = new _CloseButton.default({});
  closebutton.$on("click",
  /*close*/
  ctx[8]);
  return {
    c() {
      div5 = (0, _internal.element)("div");
      div1 = (0, _internal.element)("div");
      (0, _internal.create_component)(poemtagbutton.$$.fragment);
      t0 = (0, _internal.space)();
      div0 = (0, _internal.element)("div");

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }

      t1 = (0, _internal.space)();
      (0, _internal.create_component)(closebutton.$$.fragment);
      t2 = (0, _internal.space)();
      div4 = (0, _internal.element)("div");
      div3 = (0, _internal.element)("div");
      div2 = (0, _internal.element)("div");
      img = (0, _internal.element)("img");
      (0, _internal.attr)(div0, "class", "poem-collection-container svelte-1iw8zw5");
      (0, _internal.attr)(div1, "class", "scroller svelte-1iw8zw5");
      if (img.src !== (img_src_value = _ico_toggle.default)) (0, _internal.attr)(img, "src", img_src_value);
      (0, _internal.attr)(img, "alt", "");
      (0, _internal.attr)(img, "draggable", img_draggable_value = false);
      (0, _internal.attr)(img, "class", "svelte-1iw8zw5");
      (0, _internal.attr)(div2, "class", "scrollbar-trackbar-thumb svelte-1iw8zw5");
      (0, _internal.set_style)(div2, "top",
      /*newScrollY*/
      ctx[4]);
      (0, _internal.attr)(div3, "class", "scrollbar-trackbar svelte-1iw8zw5");
      (0, _internal.set_style)(div3, "background-image", "url(" + _ico_scrollbar.default + ")");
      (0, _internal.attr)(div4, "class", "scrollbar-container svelte-1iw8zw5");
      (0, _internal.toggle_class)(div4, "hideScrollbar",
      /*hideScrollbar*/
      ctx[2]);
      (0, _internal.attr)(div5, "class", "container svelte-1iw8zw5");
      (0, _internal.toggle_class)(div5, "modal",
      /*modal*/
      ctx[0]);
      (0, _internal.toggle_class)(div5, "ignorePointer",
      /*ignorePointer*/
      ctx[3]);
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div5, anchor);
      (0, _internal.append)(div5, div1);
      (0, _internal.mount_component)(poemtagbutton, div1, null);
      (0, _internal.append)(div1, t0);
      (0, _internal.append)(div1, div0);

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div0, null);
      }
      /*div1_binding*/


      ctx[9](div1);
      (0, _internal.append)(div5, t1);
      (0, _internal.mount_component)(closebutton, div5, null);
      (0, _internal.append)(div5, t2);
      (0, _internal.append)(div5, div4);
      (0, _internal.append)(div4, div3);
      (0, _internal.append)(div3, div2);
      (0, _internal.append)(div2, img);
      /*div3_binding*/

      ctx[10](div3);
      current = true;

      if (!mounted) {
        dispose = (0, _internal.listen)(div1, "scroll",
        /*scrollUpdate*/
        ctx[7]);
        mounted = true;
      }
    },

    p(ctx, [dirty]) {
      if (dirty &
      /*poems*/
      2) {
        each_value =
        /*poems*/
        ctx[1];
        let i;

        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx, each_value, i);

          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            (0, _internal.transition_in)(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            (0, _internal.transition_in)(each_blocks[i], 1);
            each_blocks[i].m(div0, null);
          }
        }

        (0, _internal.group_outros)();

        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }

        (0, _internal.check_outros)();
      }

      if (!current || dirty &
      /*newScrollY*/
      16) {
        (0, _internal.set_style)(div2, "top",
        /*newScrollY*/
        ctx[4]);
      }

      if (dirty &
      /*hideScrollbar*/
      4) {
        (0, _internal.toggle_class)(div4, "hideScrollbar",
        /*hideScrollbar*/
        ctx[2]);
      }

      if (dirty &
      /*modal*/
      1) {
        (0, _internal.toggle_class)(div5, "modal",
        /*modal*/
        ctx[0]);
      }

      if (dirty &
      /*ignorePointer*/
      8) {
        (0, _internal.toggle_class)(div5, "ignorePointer",
        /*ignorePointer*/
        ctx[3]);
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(poemtagbutton.$$.fragment, local);

      for (let i = 0; i < each_value.length; i += 1) {
        (0, _internal.transition_in)(each_blocks[i]);
      }

      (0, _internal.transition_in)(closebutton.$$.fragment, local);
      (0, _internal.add_render_callback)(() => {
        if (!div5_transition) div5_transition = (0, _internal.create_bidirectional_transition)(div5, _transition.fade, {
          duration: 500
        }, true);
        div5_transition.run(1);
      });
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(poemtagbutton.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);

      for (let i = 0; i < each_blocks.length; i += 1) {
        (0, _internal.transition_out)(each_blocks[i]);
      }

      (0, _internal.transition_out)(closebutton.$$.fragment, local);
      if (!div5_transition) div5_transition = (0, _internal.create_bidirectional_transition)(div5, _transition.fade, {
        duration: 500
      }, false);
      div5_transition.run(0);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div5);
      (0, _internal.destroy_component)(poemtagbutton);
      (0, _internal.destroy_each)(each_blocks, detaching);
      /*div1_binding*/

      ctx[9](null);
      (0, _internal.destroy_component)(closebutton);
      /*div3_binding*/

      ctx[10](null);
      if (detaching && div5_transition) div5_transition.end();
      mounted = false;
      dispose();
    }

  };
}

let narrow = false;

function instance($$self, $$props, $$invalidate) {
  let {
    modal = false
  } = $$props;
  let {
    poems = []
  } = $$props; // const haiku = Haiku();
  // let poems = Array(6)
  //   .fill()
  //   .map(() => {
  //     const tokens = haiku.randomTokens();
  //     return {
  //       tokens,
  //       lines: haiku.generate({ tokens }),
  //     };
  //   });

  const dispatch = (0, _svelte.createEventDispatcher)();
  let hideScrollbar = false;
  let ignorePointer = false; // let trackBarElement;

  let newScrollY = "0%";
  let scrollContainerElement;
  let scrollbarElement; // $: narrow = poems.length <= 3;

  (0, _svelte.onMount)(() => {
    $$invalidate(3, ignorePointer = false);
    scrollUpdate();
    window.addEventListener("resize", resize, {
      passive: true
    });
    const destroyDrag = drag(scrollbarElement);
    return () => {
      destroyDrag();
      window.removeEventListener("resize", resize);
    };
  });

  function resize() {
    scrollUpdate();
  }

  function needsScrollbar() {
    return scrollContainerElement.scrollHeight > scrollContainerElement.clientHeight;
  }

  function scrollUpdate() {
    if (!scrollContainerElement) return;
    const v = scrollContainerElement.scrollTop / (scrollContainerElement.scrollHeight - scrollContainerElement.clientHeight); // trackBarElement.style.top

    $$invalidate(4, newScrollY = `${(v * 100).toFixed(5)}%`);
    $$invalidate(2, hideScrollbar = !needsScrollbar());
  }

  function drag(el) {
    const input = (0, _tinyInput.default)({
      target: el,
      parent: window
    });
    input.on("down", onInput).on("up", onInput).on("move", onInput); // on unmount

    return () => {
      input.disable();
    };

    function onInput(ev) {
      if (ev.dragging && scrollContainerElement) {
        updateSlider(ev.uv[1]);
      }
    }

    function updateSlider(v) {
      v = MathUtil.clamp01(v);
      const px = v * (scrollContainerElement.scrollHeight - scrollContainerElement.clientHeight);
      $$invalidate(5, scrollContainerElement.scrollTop = px, scrollContainerElement);
    }
  }

  function close() {
    $$invalidate(3, ignorePointer = true);
    dispatch("close");
    console.log("Poems Collection closed");
  }

  function div1_binding($$value) {
    _internal.binding_callbacks[$$value ? "unshift" : "push"](() => {
      scrollContainerElement = $$value;
      $$invalidate(5, scrollContainerElement);
    });
  }

  function div3_binding($$value) {
    _internal.binding_callbacks[$$value ? "unshift" : "push"](() => {
      scrollbarElement = $$value;
      $$invalidate(6, scrollbarElement);
    });
  }

  $$self.$$set = $$props => {
    if ("modal" in $$props) $$invalidate(0, modal = $$props.modal);
    if ("poems" in $$props) $$invalidate(1, poems = $$props.poems);
  };

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*poems*/
    2) {
      $: poems, $$invalidate(3, ignorePointer = false);
    }
  };

  return [modal, poems, hideScrollbar, ignorePointer, newScrollY, scrollContainerElement, scrollbarElement, scrollUpdate, close, div1_binding, div3_binding];
}

class PoemCollectionOverlay extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      modal: 0,
      poems: 1
    });
  }

}

var _default = PoemCollectionOverlay;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","../util/math":"src/util/math.js","../util/tiny-input":"src/util/tiny-input.js","../util/tokens":"src/util/tokens.js","svelte/transition":"node_modules/svelte/transition/index.mjs","svelte":"node_modules/svelte/index.mjs","../util/locale.js":"src/util/locale.js","../components/IconButton.svelte":"src/components/IconButton.svelte.js","../assets/image/ui/ico_scrollbar.png":"src/assets/image/ui/ico_scrollbar.png","../assets/image/ui/ico_toggle.png":"src/assets/image/ui/ico_toggle.png","../assets/image/ui/ico_openjournal.png":"src/assets/image/ui/ico_openjournal.png","../components/HaikuCard.svelte":"src/components/HaikuCard.svelte.js","../util/haikugen":"src/util/haikugen.js","../components/CloseButton.svelte":"src/components/CloseButton.svelte.js","../components/PoemTagButton.svelte":"src/components/PoemTagButton.svelte.js"}],"src/overlays/GamePageLanding.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _ico_resume = _interopRequireDefault(require("../assets/image/ui/ico_resume.png"));

var _ImageButton = _interopRequireDefault(require("../components/ImageButton.svelte"));

var _Image = _interopRequireDefault(require("../components/Image.svelte"));

var _nfb = require("../nfb");

var _store = require("svelte/store");

var _transitions = require("../animations/transitions");

var _svelte = require("svelte");

var _transition = require("svelte/transition");

var _Assets = _interopRequireDefault(require("../util/Assets"));

var _stores = require("../util/stores");

var _locale = require("../util/locale.js");

var _globalIntroVideo = require("../util/globalIntroVideo");

var _alecSvelte = require("../alec-svelte");

var _PoemTagButton = _interopRequireDefault(require("../components/PoemTagButton.svelte"));

var _PoemCollectionOverlay = _interopRequireDefault(require("./PoemCollectionOverlay.svelte"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* overlays/GamePageLanding.svelte generated by Svelte v3.31.0 */
// import AboutIconEN from "../assets/image/ui/ico_about.png";
// import AboutIconFR from "../assets/image/ui/ico_about.png";
// import RestartIcon from "../assets/image/ui/ico_restart.png";
// import LanguageToggle from "../components/LanguageToggle.svelte";
function create_else_block_1(ctx) {
  let p0;
  let t0_value =
  /*$localize*/
  ctx[9].introBlurbOne + "";
  let t0;
  let p0_intro;
  let t1;
  let p1;
  let t2_value =
  /*$localize*/
  ctx[9].introBlurbTwo + "";
  let t2;
  let p1_intro;
  return {
    c() {
      p0 = (0, _internal.element)("p");
      t0 = (0, _internal.text)(t0_value);
      t1 = (0, _internal.space)();
      p1 = (0, _internal.element)("p");
      t2 = (0, _internal.text)(t2_value);
      (0, _internal.attr)(p0, "class", "svelte-h4m3ya");
      (0, _internal.attr)(p1, "class", "svelte-h4m3ya");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, p0, anchor);
      (0, _internal.append)(p0, t0);
      (0, _internal.insert)(target, t1, anchor);
      (0, _internal.insert)(target, p1, anchor);
      (0, _internal.append)(p1, t2);
    },

    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty &
      /*$localize*/
      512 && t0_value !== (t0_value =
      /*$localize*/
      ctx[9].introBlurbOne + "")) (0, _internal.set_data)(t0, t0_value);
      if (dirty &
      /*$localize*/
      512 && t2_value !== (t2_value =
      /*$localize*/
      ctx[9].introBlurbTwo + "")) (0, _internal.set_data)(t2, t2_value);
    },

    i(local) {
      if (!p0_intro) {
        (0, _internal.add_render_callback)(() => {
          p0_intro = (0, _internal.create_in_transition)(p0, _transitions.fadeInTransition, {
            delay:
            /*contentDelay*/
            ctx[11] +
            /*titleDelay*/
            ctx[10],
            index: 1
          });
          p0_intro.start();
        });
      }

      if (!p1_intro) {
        (0, _internal.add_render_callback)(() => {
          p1_intro = (0, _internal.create_in_transition)(p1, _transitions.fadeInTransition, {
            delay:
            /*contentDelay*/
            ctx[11] +
            /*titleDelay*/
            ctx[10],
            index: 2
          });
          p1_intro.start();
        });
      }
    },

    o: _internal.noop,

    d(detaching) {
      if (detaching) (0, _internal.detach)(p0);
      if (detaching) (0, _internal.detach)(t1);
      if (detaching) (0, _internal.detach)(p1);
    }

  };
} // (174:8) {#if endState}


function create_if_block_3(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 =
  /*endTextAVisible*/
  ctx[4] && create_if_block_5(ctx);
  let if_block1 =
  /*endTextBVisible*/
  ctx[5] && create_if_block_4(ctx);
  return {
    c() {
      if (if_block0) if_block0.c();
      t = (0, _internal.space)();
      if (if_block1) if_block1.c();
      if_block1_anchor = (0, _internal.empty)();
    },

    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      (0, _internal.insert)(target, t, anchor);
      if (if_block1) if_block1.m(target, anchor);
      (0, _internal.insert)(target, if_block1_anchor, anchor);
      current = true;
    },

    p(ctx, dirty) {
      if (
      /*endTextAVisible*/
      ctx[4]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);

          if (dirty &
          /*endTextAVisible*/
          16) {
            (0, _internal.transition_in)(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5(ctx);
          if_block0.c();
          (0, _internal.transition_in)(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        (0, _internal.check_outros)();
      }

      if (
      /*endTextBVisible*/
      ctx[5]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);

          if (dirty &
          /*endTextBVisible*/
          32) {
            (0, _internal.transition_in)(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4(ctx);
          if_block1.c();
          (0, _internal.transition_in)(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(if_block0);
      (0, _internal.transition_in)(if_block1);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(if_block0);
      current = false;
    },

    d(detaching) {
      if (if_block0) if_block0.d(detaching);
      if (detaching) (0, _internal.detach)(t);
      if (if_block1) if_block1.d(detaching);
      if (detaching) (0, _internal.detach)(if_block1_anchor);
    }

  };
} // (175:10) {#if endTextAVisible}


function create_if_block_5(ctx) {
  let div;
  let p0;
  let strong;
  let t0_value =
  /*$localize*/
  ctx[9].endState0 + "";
  let t0;
  let t1;
  let p1;
  let t2_value =
  /*$localize*/
  ctx[9].endState1 + "";
  let t2;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      div = (0, _internal.element)("div");
      p0 = (0, _internal.element)("p");
      strong = (0, _internal.element)("strong");
      t0 = (0, _internal.text)(t0_value);
      t1 = (0, _internal.space)();
      p1 = (0, _internal.element)("p");
      t2 = (0, _internal.text)(t2_value);
      (0, _internal.attr)(p0, "class", "svelte-h4m3ya");
      (0, _internal.attr)(p1, "class", "svelte-h4m3ya");
      (0, _internal.attr)(div, "class", "paper-text");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.append)(div, p0);
      (0, _internal.append)(p0, strong);
      (0, _internal.append)(strong, t0);
      (0, _internal.append)(div, t1);
      (0, _internal.append)(div, p1);
      (0, _internal.append)(p1, t2);
      current = true;

      if (!mounted) {
        dispose = [(0, _internal.listen)(div, "introend",
        /*introend_handler*/
        ctx[15]), (0, _internal.listen)(div, "outroend",
        /*outroend_handler*/
        ctx[16])];
        mounted = true;
      }
    },

    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty &
      /*$localize*/
      512) && t0_value !== (t0_value =
      /*$localize*/
      ctx[9].endState0 + "")) (0, _internal.set_data)(t0, t0_value);
      if ((!current || dirty &
      /*$localize*/
      512) && t2_value !== (t2_value =
      /*$localize*/
      ctx[9].endState1 + "")) (0, _internal.set_data)(t2, t2_value);
    },

    i(local) {
      if (current) return;
      (0, _internal.add_render_callback)(() => {
        if (div_outro) div_outro.end(1);
        if (!div_intro) div_intro = (0, _internal.create_in_transition)(div, _transitions.fadeInTransition, {
          delay:
          /*titleDelay*/
          ctx[10],
          duration: 500,
          index: 1
        });
        div_intro.start();
      });
      current = true;
    },

    o(local) {
      if (div_intro) div_intro.invalidate();
      div_outro = (0, _internal.create_out_transition)(div, _transitions.fadeInTransition, {
        delay:
        /*titleDelay*/
        ctx[10] + 5000,
        duration: 250
      });
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      (0, _internal.run_all)(dispose);
    }

  };
} // (196:10) {#if endTextBVisible}


function create_if_block_4(ctx) {
  let div;
  let p;
  let raw_value =
  /*$localize*/
  ctx[9].endState2 + "";
  let div_intro;
  return {
    c() {
      div = (0, _internal.element)("div");
      p = (0, _internal.element)("p");
      (0, _internal.attr)(p, "class", "svelte-h4m3ya");
      (0, _internal.attr)(div, "class", "paper-text");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.append)(div, p);
      p.innerHTML = raw_value;
    },

    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty &
      /*$localize*/
      512 && raw_value !== (raw_value =
      /*$localize*/
      ctx[9].endState2 + "")) p.innerHTML = raw_value;
      ;
    },

    i(local) {
      if (!div_intro) {
        (0, _internal.add_render_callback)(() => {
          div_intro = (0, _internal.create_in_transition)(div, _transitions.fadeInTransition, {
            delay:
            /*titleDelay*/
            ctx[10],
            duration: 500,
            index: 1
          });
          div_intro.start();
        });
      }
    },

    o: _internal.noop,

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
    }

  };
} // (254:10) {:else}


function create_else_block(ctx) {
  let imagebutton;
  let current;
  imagebutton = new _ImageButton.default({
    props: {
      inTransition: (0, _transitions.transition)(_transitions.fadeInTransition, {
        delay:
        /*contentDelay*/
        ctx[11] +
        /*titleDelay*/
        ctx[10],
        index: 3
      }),
      icon: _ico_resume.default,
      text:
      /*$localize*/
      ctx[9].resumeButton,
      alt: "Resume experience"
    }
  });
  imagebutton.$on("click",
  /*click_handler_2*/
  ctx[19]);
  return {
    c() {
      (0, _internal.create_component)(imagebutton.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(imagebutton, target, anchor);
      current = true;
    },

    p(ctx, dirty) {
      const imagebutton_changes = {};
      if (dirty &
      /*$localize*/
      512) imagebutton_changes.text =
      /*$localize*/
      ctx[9].resumeButton;
      imagebutton.$set(imagebutton_changes);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(imagebutton.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(imagebutton.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(imagebutton, detaching);
    }

  };
} // (243:26) 


function create_if_block_2(ctx) {
  let imagebutton;
  let current;
  imagebutton = new _ImageButton.default({
    props: {
      inTransition: (0, _transitions.transition)(_transitions.fadeInTransition, {
        delay:
        /*contentDelay*/
        ctx[11] +
        /*titleDelay*/
        ctx[10],
        index: 3
      }),
      icon: _ico_resume.default,
      text:
      /*$localize*/
      ctx[9].startButton,
      alt: "Start experience"
    }
  });
  imagebutton.$on("click",
  /*click_handler_1*/
  ctx[18]);
  return {
    c() {
      (0, _internal.create_component)(imagebutton.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(imagebutton, target, anchor);
      current = true;
    },

    p(ctx, dirty) {
      const imagebutton_changes = {};
      if (dirty &
      /*$localize*/
      512) imagebutton_changes.text =
      /*$localize*/
      ctx[9].startButton;
      imagebutton.$set(imagebutton_changes);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(imagebutton.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(imagebutton.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(imagebutton, detaching);
    }

  };
} // (226:10) {#if endState}


function create_if_block_1(ctx) {
  let poemtagbutton;
  let current;
  poemtagbutton = new _PoemTagButton.default({
    props: {
      useMargin: false,
      button: true,
      inTransition: (0, _transitions.transition)(_transitions.fadeInTransition, {
        delay:
        /*contentDelay*/
        ctx[11] +
        /*titleDelay*/
        ctx[10],
        index: 3
      }),
      alt: "Poems"
    }
  });
  poemtagbutton.$on("click",
  /*click_handler*/
  ctx[17]);
  return {
    c() {
      (0, _internal.create_component)(poemtagbutton.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(poemtagbutton, target, anchor);
      current = true;
    },

    p: _internal.noop,

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(poemtagbutton.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(poemtagbutton.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(poemtagbutton, detaching);
    }

  };
} // (307:0) {#if isJournalOpen}


function create_if_block(ctx) {
  let poemcollectionoverlay;
  let current;
  poemcollectionoverlay = new _PoemCollectionOverlay.default({
    props: {
      poems:
      /*poems*/
      ctx[2],
      modal: true
    }
  });
  poemcollectionoverlay.$on("close",
  /*close_handler*/
  ctx[23]);
  return {
    c() {
      (0, _internal.create_component)(poemcollectionoverlay.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(poemcollectionoverlay, target, anchor);
      current = true;
    },

    p(ctx, dirty) {
      const poemcollectionoverlay_changes = {};
      if (dirty &
      /*poems*/
      4) poemcollectionoverlay_changes.poems =
      /*poems*/
      ctx[2];
      poemcollectionoverlay.$set(poemcollectionoverlay_changes);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(poemcollectionoverlay.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(poemcollectionoverlay.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(poemcollectionoverlay, detaching);
    }

  };
}

function create_fragment(ctx) {
  let div10;
  let section0;
  let t2;
  let section1;
  let div9;
  let div4;
  let image;
  let div4_intro;
  let t3;
  let div5;
  let current_block_type_index;
  let if_block0;
  let t4;
  let div8;
  let div6;
  let current_block_type_index_1;
  let if_block1;
  let t5;
  let div7;
  let imagebutton;
  let div10_intro;
  let div10_outro;
  let t6;
  let if_block2_anchor;
  let current;
  let mounted;
  let dispose;
  image = new _Image.default({
    props: {
      id: `image/ui/title2_${
      /*curLang*/
      ctx[8]}`
    }
  });
  const if_block_creators = [create_if_block_3, create_else_block_1];
  const if_blocks = [];

  function select_block_type(ctx, dirty) {
    if (
    /*endState*/
    ctx[1]) return 0;
    return 1;
  }

  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const if_block_creators_1 = [create_if_block_1, create_if_block_2, create_else_block];
  const if_blocks_1 = [];

  function select_block_type_1(ctx, dirty) {
    if (
    /*endState*/
    ctx[1]) return 0;
    if (
    /*start*/
    ctx[0]) return 1;
    return 2;
  }

  current_block_type_index_1 = select_block_type_1(ctx, -1);
  if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  imagebutton = new _ImageButton.default({
    props: {
      inTransition: (0, _transitions.transition)(_transitions.fadeInTransition, {
        delay:
        /*contentDelay*/
        ctx[11] +
        /*titleDelay*/
        ctx[10],
        index: 4
      }),
      text:
      /*$localize*/
      ctx[9].aboutButton,
      mode: "dark",
      alt: "About"
    }
  });
  imagebutton.$on("click",
  /*click_handler_3*/
  ctx[20]);
  let if_block2 =
  /*isJournalOpen*/
  ctx[6] && create_if_block(ctx);
  return {
    c() {
      div10 = (0, _internal.element)("div");
      section0 = (0, _internal.element)("section");
      section0.innerHTML = `<div class="top-buttons svelte-h4m3ya"><div class="top-left-container svelte-h4m3ya"></div> 
      <div class="top-center-container"></div> 
      <div class="top-right-container svelte-h4m3ya"></div></div>`;
      t2 = (0, _internal.space)();
      section1 = (0, _internal.element)("section");
      div9 = (0, _internal.element)("div");
      div4 = (0, _internal.element)("div");
      (0, _internal.create_component)(image.$$.fragment);
      t3 = (0, _internal.space)();
      div5 = (0, _internal.element)("div");
      if_block0.c();
      t4 = (0, _internal.space)();
      div8 = (0, _internal.element)("div");
      div6 = (0, _internal.element)("div");
      if_block1.c();
      t5 = (0, _internal.space)();
      div7 = (0, _internal.element)("div");
      (0, _internal.create_component)(imagebutton.$$.fragment);
      t6 = (0, _internal.space)();
      if (if_block2) if_block2.c();
      if_block2_anchor = (0, _internal.empty)();
      (0, _internal.attr)(section0, "class", "top fake-nav svelte-h4m3ya");
      (0, _internal.attr)(div4, "class", "wayfinder-placeholder svelte-h4m3ya");
      (0, _internal.toggle_class)(div4, "ignorePointer",
      /*ignorePointer*/
      ctx[7]);
      (0, _internal.attr)(div5, "class", "description-container svelte-h4m3ya");
      (0, _internal.toggle_class)(div5, "endState",
      /*endState*/
      ctx[1]);
      (0, _internal.attr)(div6, "class", "game-buttons svelte-h4m3ya");
      (0, _internal.attr)(div7, "class", "about-container svelte-h4m3ya");
      (0, _internal.attr)(div8, "class", "button-container svelte-h4m3ya");
      (0, _internal.attr)(div9, "class", "wayfinder-container svelte-h4m3ya");
      (0, _internal.attr)(section1, "class", "main-content svelte-h4m3ya");
      (0, _internal.attr)(div10, "class", "container svelte-h4m3ya");
      (0, _internal.toggle_class)(div10, "ignorePointer",
      /*ignorePointer*/
      ctx[7]);
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div10, anchor);
      (0, _internal.append)(div10, section0);
      (0, _internal.append)(div10, t2);
      (0, _internal.append)(div10, section1);
      (0, _internal.append)(section1, div9);
      (0, _internal.append)(div9, div4);
      (0, _internal.mount_component)(image, div4, null);
      (0, _internal.append)(div9, t3);
      (0, _internal.append)(div9, div5);
      if_blocks[current_block_type_index].m(div5, null);
      (0, _internal.append)(div9, t4);
      (0, _internal.append)(div9, div8);
      (0, _internal.append)(div8, div6);
      if_blocks_1[current_block_type_index_1].m(div6, null);
      (0, _internal.append)(div8, t5);
      (0, _internal.append)(div8, div7);
      (0, _internal.mount_component)(imagebutton, div7, null);
      (0, _internal.insert)(target, t6, anchor);
      if (if_block2) if_block2.m(target, anchor);
      (0, _internal.insert)(target, if_block2_anchor, anchor);
      current = true;

      if (!mounted) {
        dispose = [(0, _internal.listen)(div10, "introstart",
        /*introstart_handler*/
        ctx[21]), (0, _internal.listen)(div10, "outrostart",
        /*outrostart_handler*/
        ctx[22])];
        mounted = true;
      }
    },

    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const image_changes = {};
      if (dirty &
      /*curLang*/
      256) image_changes.id = `image/ui/title2_${
      /*curLang*/
      ctx[8]}`;
      image.$set(image_changes);

      if (dirty &
      /*ignorePointer*/
      128) {
        (0, _internal.toggle_class)(div4, "ignorePointer",
        /*ignorePointer*/
        ctx[7]);
      }

      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);

      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        (0, _internal.check_outros)();
        if_block0 = if_blocks[current_block_type_index];

        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block0.c();
        } else {
          if_block0.p(ctx, dirty);
        }

        (0, _internal.transition_in)(if_block0, 1);
        if_block0.m(div5, null);
      }

      if (dirty &
      /*endState*/
      2) {
        (0, _internal.toggle_class)(div5, "endState",
        /*endState*/
        ctx[1]);
      }

      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_1(ctx, dirty);

      if (current_block_type_index_1 === previous_block_index_1) {
        if_blocks_1[current_block_type_index_1].p(ctx, dirty);
      } else {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_blocks_1[previous_block_index_1], 1, 1, () => {
          if_blocks_1[previous_block_index_1] = null;
        });
        (0, _internal.check_outros)();
        if_block1 = if_blocks_1[current_block_type_index_1];

        if (!if_block1) {
          if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
          if_block1.c();
        } else {
          if_block1.p(ctx, dirty);
        }

        (0, _internal.transition_in)(if_block1, 1);
        if_block1.m(div6, null);
      }

      const imagebutton_changes = {};
      if (dirty &
      /*$localize*/
      512) imagebutton_changes.text =
      /*$localize*/
      ctx[9].aboutButton;
      imagebutton.$set(imagebutton_changes);

      if (dirty &
      /*ignorePointer*/
      128) {
        (0, _internal.toggle_class)(div10, "ignorePointer",
        /*ignorePointer*/
        ctx[7]);
      }

      if (
      /*isJournalOpen*/
      ctx[6]) {
        if (if_block2) {
          if_block2.p(ctx, dirty);

          if (dirty &
          /*isJournalOpen*/
          64) {
            (0, _internal.transition_in)(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block(ctx);
          if_block2.c();
          (0, _internal.transition_in)(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        (0, _internal.check_outros)();
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(image.$$.fragment, local);

      if (!div4_intro) {
        (0, _internal.add_render_callback)(() => {
          div4_intro = (0, _internal.create_in_transition)(div4, _transitions.fadeInTransition, {
            duration:
            /*introTitle*/
            ctx[3] ? 2500 : undefined,
            delay:
            /*contentDelay*/
            ctx[11]
          });
          div4_intro.start();
        });
      }

      (0, _internal.transition_in)(if_block0);
      (0, _internal.transition_in)(if_block1);
      (0, _internal.transition_in)(imagebutton.$$.fragment, local);
      (0, _internal.add_render_callback)(() => {
        if (div10_outro) div10_outro.end(1);
        if (!div10_intro) div10_intro = (0, _internal.create_in_transition)(div10, _transitions.fadeOpacityTransition, {});
        div10_intro.start();
      });
      (0, _internal.transition_in)(if_block2);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(image.$$.fragment, local);
      (0, _internal.transition_out)(if_block0);
      (0, _internal.transition_out)(if_block1);
      (0, _internal.transition_out)(imagebutton.$$.fragment, local);
      if (div10_intro) div10_intro.invalidate();
      div10_outro = (0, _internal.create_out_transition)(div10, _transitions.fadeOpacityTransition, {
        duration:
        /*start*/
        ctx[0] ? 1000 : undefined,
        delay: 0
      });
      (0, _internal.transition_out)(if_block2);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div10);
      (0, _internal.destroy_component)(image);
      if_blocks[current_block_type_index].d();
      if_blocks_1[current_block_type_index_1].d();
      (0, _internal.destroy_component)(imagebutton);
      if (detaching && div10_outro) div10_outro.end();
      if (detaching) (0, _internal.detach)(t6);
      if (if_block2) if_block2.d(detaching);
      if (detaching) (0, _internal.detach)(if_block2_anchor);
      mounted = false;
      (0, _internal.run_all)(dispose);
    }

  };
}

function triggerFullscreen() {
  if (!document.fullscreenElement) {
    if (typeof document.documentElement.requestFullscreen === "function") {
      document.documentElement.requestFullscreen();
    }
  } else {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    }
  }

  console.log("Fullscreen requested");
}

function triggerRestart() {
  console.log("restart requested");
}

function instance($$self, $$props, $$invalidate) {
  let $localize;
  (0, _internal.component_subscribe)($$self, _locale.localize, $$value => $$invalidate(9, $localize = $$value));
  const dispatcher = (0, _svelte.createEventDispatcher)();
  let {
    start = true
  } = $$props;
  let {
    endState = false
  } = $$props;
  let {
    poems = []
  } = $$props;
  let {
    introTitle = false
  } = $$props;
  let endTextAVisible = true;
  let endTextBVisible = false;
  let isJournalOpen = false;
  let ignorePointer = false;
  let curLang;

  const unsub = _locale.language.subscribe(lang => {
    $$invalidate(8, curLang = lang);
  });

  (0, _svelte.onMount)(() => {
    (0, _nfb.revealHeader)();
    $$invalidate(7, ignorePointer = false);
    return () => {
      unsub();
    };
  });
  let titleDelay = introTitle ? 1000 : 0;
  let contentDelay = endState ? 2500 : 0;
  let hasFullscreen = typeof document.documentElement.requestFullscreen === "function";

  function triggerResume(ev) {
    if (ev) {
      ev.preventDefault();
      ev.stopPropagation();
      ev.stopImmediatePropagation();
    }

    dispatcher("play");
  }

  function triggerPlay(ev) {
    if (ev) {
      ev.preventDefault();
      ev.stopPropagation();
      ev.stopImmediatePropagation();
    }

    dispatcher("play");
    const video = (0, _globalIntroVideo.getVideo)();
    const isMute = (0, _store.get)(_stores.audioState).muted;
    video.muted = isMute;
    video.play();
  }

  function triggerAbout() {
    dispatcher("about");
  }

  const introend_handler = () => {
    $$invalidate(4, endTextAVisible = false);
  };

  const outroend_handler = () => {
    $$invalidate(5, endTextBVisible = true);
  };

  const click_handler = ev => {
    (0, _nfb.sendAnalytics)({
      event: "journal_open",
      eventLabel: "journal_open"
    });
    $$invalidate(6, isJournalOpen = true);
  };

  const click_handler_1 = ev => triggerPlay(ev);

  const click_handler_2 = ev => triggerResume(ev);

  const click_handler_3 = () => triggerAbout();

  const introstart_handler = () => {
    $$invalidate(7, ignorePointer = false);
  };

  const outrostart_handler = () => {
    $$invalidate(7, ignorePointer = true);
  };

  const close_handler = () => {
    $$invalidate(6, isJournalOpen = false);
  };

  $$self.$$set = $$props => {
    if ("start" in $$props) $$invalidate(0, start = $$props.start);
    if ("endState" in $$props) $$invalidate(1, endState = $$props.endState);
    if ("poems" in $$props) $$invalidate(2, poems = $$props.poems);
    if ("introTitle" in $$props) $$invalidate(3, introTitle = $$props.introTitle);
  };

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*start*/
    1) {
      $: start, $$invalidate(7, ignorePointer = false);
    }
  };

  return [start, endState, poems, introTitle, endTextAVisible, endTextBVisible, isJournalOpen, ignorePointer, curLang, $localize, titleDelay, contentDelay, triggerResume, triggerPlay, triggerAbout, introend_handler, outroend_handler, click_handler, click_handler_1, click_handler_2, click_handler_3, introstart_handler, outrostart_handler, close_handler];
}

class GamePageLanding extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      start: 0,
      endState: 1,
      poems: 2,
      introTitle: 3
    });
  }

}

var _default = GamePageLanding;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","../assets/image/ui/ico_resume.png":"src/assets/image/ui/ico_resume.png","../components/ImageButton.svelte":"src/components/ImageButton.svelte.js","../components/Image.svelte":"src/components/Image.svelte.js","../nfb":"src/nfb.js","svelte/store":"node_modules/svelte/store/index.mjs","../animations/transitions":"src/animations/transitions.js","svelte":"node_modules/svelte/index.mjs","svelte/transition":"node_modules/svelte/transition/index.mjs","../util/Assets":"src/util/Assets.js","../util/stores":"src/util/stores.js","../util/locale.js":"src/util/locale.js","../util/globalIntroVideo":"src/util/globalIntroVideo.js","../alec-svelte":"src/alec-svelte/index.js","../components/PoemTagButton.svelte":"src/components/PoemTagButton.svelte.js","./PoemCollectionOverlay.svelte":"src/overlays/PoemCollectionOverlay.svelte.js"}],"src/overlays/About.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _svelte = require("svelte");

var _alecSvelte = require("../alec-svelte");

var _locale = require("../util/locale");

var _transitions = require("../animations/transitions");

var Tags = _interopRequireWildcard(require("../tags"));

var _Image = _interopRequireDefault(require("../components/Image.svelte"));

var _CloseButton = _interopRequireDefault(require("../components/CloseButton.svelte"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* overlays/About.svelte generated by Svelte v3.31.0 */
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}

function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  child_ctx[13] = i;
  return child_ctx;
} // (166:12) {:else}


function create_else_block(ctx) {
  let each_1_anchor;
  let each_value_1 =
  /*credit*/
  ctx[8];
  let each_blocks = [];

  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }

  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }

      each_1_anchor = (0, _internal.empty)();
    },

    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }

      (0, _internal.insert)(target, each_1_anchor, anchor);
    },

    p(ctx, dirty) {
      if (dirty &
      /*credits*/
      8) {
        each_value_1 =
        /*credit*/
        ctx[8];
        let i;

        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx, each_value_1, i);

          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }

        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }

        each_blocks.length = each_value_1.length;
      }
    },

    i: _internal.noop,
    o: _internal.noop,

    d(detaching) {
      (0, _internal.destroy_each)(each_blocks, detaching);
      if (detaching) (0, _internal.detach)(each_1_anchor);
    }

  };
} // (164:34) 


function create_if_block_1(ctx) {
  let p;
  let raw_value =
  /*credit*/
  ctx[8].html + "";
  return {
    c() {
      p = (0, _internal.element)("p");
      (0, _internal.attr)(p, "class", "svelte-48fouy");
      (0, _internal.toggle_class)(p, "isTitle", true);
    },

    m(target, anchor) {
      (0, _internal.insert)(target, p, anchor);
      p.innerHTML = raw_value;
    },

    p: _internal.noop,
    i: _internal.noop,
    o: _internal.noop,

    d(detaching) {
      if (detaching) (0, _internal.detach)(p);
    }

  };
} // (160:12) {#if credit === "LEAF"}


function create_if_block(ctx) {
  let div;
  let image;
  let current;
  image = new _Image.default({
    props: {
      width: "100%",
      id: "image/ui/ico_about"
    }
  });
  return {
    c() {
      div = (0, _internal.element)("div");
      (0, _internal.create_component)(image.$$.fragment);
      (0, _internal.attr)(div, "class", "leaf credit-leaf svelte-48fouy");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.mount_component)(image, div, null);
      current = true;
    },

    p: _internal.noop,

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(image.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(image.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      (0, _internal.destroy_component)(image);
    }

  };
} // (167:14) {#each credit as line, i}


function create_each_block_1(ctx) {
  let p;
  let t_value =
  /*line*/
  ctx[11] + "";
  let t;
  return {
    c() {
      p = (0, _internal.element)("p");
      t = (0, _internal.text)(t_value);
      (0, _internal.attr)(p, "class", "svelte-48fouy");
      (0, _internal.toggle_class)(p, "isTitle",
      /*i*/
      ctx[13] === 0);
    },

    m(target, anchor) {
      (0, _internal.insert)(target, p, anchor);
      (0, _internal.append)(p, t);
    },

    p: _internal.noop,

    d(detaching) {
      if (detaching) (0, _internal.detach)(p);
    }

  };
} // (158:8) {#each credits as credit}


function create_each_block(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let t;
  let current;
  const if_block_creators = [create_if_block, create_if_block_1, create_else_block];
  const if_blocks = [];

  function select_block_type(ctx, dirty) {
    if (
    /*credit*/
    ctx[8] === "LEAF") return 0;
    if (
    /*credit*/
    ctx[8].html) return 1;
    return 2;
  }

  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = (0, _internal.element)("div");
      if_block.c();
      t = (0, _internal.space)();
      (0, _internal.attr)(div, "class", "credit-block svelte-48fouy");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      (0, _internal.append)(div, t);
      current = true;
    },

    p(ctx, dirty) {
      if_block.p(ctx, dirty);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(if_block);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(if_block);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      if_blocks[current_block_type_index].d();
    }

  };
}

function create_fragment(ctx) {
  let div16;
  let div15;
  let div0;
  let a0;
  let image0;
  let a0_href_value;
  let t0;
  let div1;
  let p0;
  let t1_value =
  /*$localize*/
  ctx[0].nfbProduction + "";
  let t1;
  let t2;
  let p1;
  let t3_value =
  /*$localize*/
  ctx[0].nfbSubcaption + "";
  let t3;
  let t4;
  let main;
  let h10;
  let div2;
  let image1;
  let t5;
  let t6_value =
  /*$localize*/
  ctx[0].playHeader + "";
  let t6;
  let t7;
  let div4;
  let div3;
  let image2;
  let t8;
  let p2;
  let strong0;
  let t9_value =
  /*$localize*/
  ctx[0].tapOrClickAndHold + "";
  let t9;
  let t10;
  let t11_value =
  /*$localize*/
  ctx[0].moveCharacterText + "";
  let t11;
  let t12;
  let div6;
  let div5;
  let image3;
  let t13;
  let p3;
  let strong1;
  let t14_value =
  /*$localize*/
  ctx[0].collectText + "";
  let t14;
  let t15;
  let t16_value =
  /*$localize*/
  ctx[0].tokenStringText + "";
  let t16;
  let t17;
  let div8;
  let div7;
  let image4;
  let t18;
  let p4;
  let strong2;
  let t19_value =
  /*$localize*/
  ctx[0].orientText + "";
  let t19;
  let t20;
  let t21_value =
  /*$localize*/
  ctx[0].compassStringText + "";
  let t21;
  let t22;
  let div10;
  let div9;
  let image5;
  let t23;
  let p5;
  let strong3;
  let t24_value =
  /*$localize*/
  ctx[0].returnText + "";
  let t24;
  let t25;
  let t26_value =
  /*$localize*/
  ctx[0].memoriesStringText + "";
  let t26;
  let t27;
  let h11;
  let div11;
  let image6;
  let t28;
  let t29_value =
  /*$localize*/
  ctx[0].aboutHeader + "";
  let t29;
  let t30;
  let p6;
  let strong4;
  let t31_value =
  /*$localize*/
  ctx[0].wayfinderStrongText + "";
  let t31;
  let t32;
  let t33_value =
  /*$localize*/
  ctx[0].wayfinderTextParagraph + "";
  let t33;
  let t34;
  let p7;
  let t35_value =
  /*$localize*/
  ctx[0].wayfinderFurtherTextParagraph + "";
  let t35;
  let t36;
  let p8;
  let t37_value =
  /*$localize*/
  ctx[0].moreAt + "";
  let t37;
  let t38;
  let a1;
  let t39_value =
  /*$localize*/
  ctx[0].moreAtLinkText + "";
  let t39;
  let a1_href_value;
  let t40;
  let h12;
  let div12;
  let image7;
  let t41;
  let t42_value =
  /*$localize*/
  ctx[0].creditsHeader + "";
  let t42;
  let t43;
  let div13;
  let t44;
  let div14;
  let image8;
  let div16_intro;
  let div16_outro;
  let t45;
  let closebutton;
  let current;
  let mounted;
  let dispose;
  image0 = new _Image.default({
    props: {
      width: "100px",
      id: "image/svg/nfblogo"
    }
  });
  image1 = new _Image.default({
    props: {
      width: "100%",
      id: "image/ui/ico_about_orange"
    }
  });
  image2 = new _Image.default({
    props: {
      width: "42px",
      id: "image/ui/touch"
    }
  });
  image3 = new _Image.default({
    props: {
      width: "42px",
      id: "image/tokens/ico_fish"
    }
  });
  image4 = new _Image.default({
    props: {
      width: "46px",
      id: "image/ui/compass3"
    }
  });
  image5 = new _Image.default({
    props: {
      width: "38px",
      id: "image/ui/tree"
    }
  });
  image6 = new _Image.default({
    props: {
      width: "100%",
      id: "image/ui/ico_about_orange"
    }
  });
  image7 = new _Image.default({
    props: {
      width: "100%",
      id: "image/ui/ico_about_orange"
    }
  });
  let each_value =
  /*credits*/
  ctx[3];
  let each_blocks = [];

  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }

  const out = i => (0, _internal.transition_out)(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });

  image8 = new _Image.default({
    props: {
      width: "100%",
      id: "image/ui/bird"
    }
  });
  closebutton = new _CloseButton.default({
    props: {
      delay: introDelay
    }
  });
  closebutton.$on("click",
  /*click_handler*/
  ctx[6]);
  return {
    c() {
      div16 = (0, _internal.element)("div");
      div15 = (0, _internal.element)("div");
      div0 = (0, _internal.element)("div");
      a0 = (0, _internal.element)("a");
      (0, _internal.create_component)(image0.$$.fragment);
      t0 = (0, _internal.space)();
      div1 = (0, _internal.element)("div");
      p0 = (0, _internal.element)("p");
      t1 = (0, _internal.text)(t1_value);
      t2 = (0, _internal.space)();
      p1 = (0, _internal.element)("p");
      t3 = (0, _internal.text)(t3_value);
      t4 = (0, _internal.space)();
      main = (0, _internal.element)("main");
      h10 = (0, _internal.element)("h1");
      div2 = (0, _internal.element)("div");
      (0, _internal.create_component)(image1.$$.fragment);
      t5 = (0, _internal.space)();
      t6 = (0, _internal.text)(t6_value);
      t7 = (0, _internal.space)();
      div4 = (0, _internal.element)("div");
      div3 = (0, _internal.element)("div");
      (0, _internal.create_component)(image2.$$.fragment);
      t8 = (0, _internal.space)();
      p2 = (0, _internal.element)("p");
      strong0 = (0, _internal.element)("strong");
      t9 = (0, _internal.text)(t9_value);
      t10 = (0, _internal.space)();
      t11 = (0, _internal.text)(t11_value);
      t12 = (0, _internal.space)();
      div6 = (0, _internal.element)("div");
      div5 = (0, _internal.element)("div");
      (0, _internal.create_component)(image3.$$.fragment);
      t13 = (0, _internal.space)();
      p3 = (0, _internal.element)("p");
      strong1 = (0, _internal.element)("strong");
      t14 = (0, _internal.text)(t14_value);
      t15 = (0, _internal.space)();
      t16 = (0, _internal.text)(t16_value);
      t17 = (0, _internal.space)();
      div8 = (0, _internal.element)("div");
      div7 = (0, _internal.element)("div");
      (0, _internal.create_component)(image4.$$.fragment);
      t18 = (0, _internal.space)();
      p4 = (0, _internal.element)("p");
      strong2 = (0, _internal.element)("strong");
      t19 = (0, _internal.text)(t19_value);
      t20 = (0, _internal.space)();
      t21 = (0, _internal.text)(t21_value);
      t22 = (0, _internal.space)();
      div10 = (0, _internal.element)("div");
      div9 = (0, _internal.element)("div");
      (0, _internal.create_component)(image5.$$.fragment);
      t23 = (0, _internal.space)();
      p5 = (0, _internal.element)("p");
      strong3 = (0, _internal.element)("strong");
      t24 = (0, _internal.text)(t24_value);
      t25 = (0, _internal.space)();
      t26 = (0, _internal.text)(t26_value);
      t27 = (0, _internal.space)();
      h11 = (0, _internal.element)("h1");
      div11 = (0, _internal.element)("div");
      (0, _internal.create_component)(image6.$$.fragment);
      t28 = (0, _internal.space)();
      t29 = (0, _internal.text)(t29_value);
      t30 = (0, _internal.space)();
      p6 = (0, _internal.element)("p");
      strong4 = (0, _internal.element)("strong");
      t31 = (0, _internal.text)(t31_value);
      t32 = (0, _internal.space)();
      t33 = (0, _internal.text)(t33_value);
      t34 = (0, _internal.space)();
      p7 = (0, _internal.element)("p");
      t35 = (0, _internal.text)(t35_value);
      t36 = (0, _internal.space)();
      p8 = (0, _internal.element)("p");
      t37 = (0, _internal.text)(t37_value);
      t38 = (0, _internal.space)();
      a1 = (0, _internal.element)("a");
      t39 = (0, _internal.text)(t39_value);
      t40 = (0, _internal.space)();
      h12 = (0, _internal.element)("h1");
      div12 = (0, _internal.element)("div");
      (0, _internal.create_component)(image7.$$.fragment);
      t41 = (0, _internal.space)();
      t42 = (0, _internal.text)(t42_value);
      t43 = (0, _internal.space)();
      div13 = (0, _internal.element)("div");

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }

      t44 = (0, _internal.space)();
      div14 = (0, _internal.element)("div");
      (0, _internal.create_component)(image8.$$.fragment);
      t45 = (0, _internal.space)();
      (0, _internal.create_component)(closebutton.$$.fragment);
      (0, _internal.attr)(a0, "href", a0_href_value =
      /*$localize*/
      ctx[0].nfbInteractiveLink);
      (0, _internal.attr)(a0, "target", "_blank");
      (0, _internal.attr)(a0, "alt", "NFB-ONF");
      (0, _internal.attr)(div0, "class", "nfb-logo");
      (0, _internal.attr)(p0, "class", "nfb-production svelte-48fouy");
      (0, _internal.attr)(p1, "class", "nfb-subcaption svelte-48fouy");
      (0, _internal.attr)(div1, "class", "nfb-caption svelte-48fouy");
      (0, _internal.attr)(div2, "class", "leaf svelte-48fouy");
      (0, _internal.attr)(h10, "class", "svelte-48fouy");
      (0, _internal.attr)(div3, "class", "about-icon svelte-48fouy");
      (0, _internal.attr)(strong0, "class", "upper svelte-48fouy");
      (0, _internal.attr)(p2, "class", "left svelte-48fouy");
      (0, _internal.attr)(div4, "class", "left about-row svelte-48fouy");
      (0, _internal.attr)(div5, "class", "about-icon svelte-48fouy");
      (0, _internal.attr)(strong1, "class", "svelte-48fouy");
      (0, _internal.attr)(p3, "class", "left svelte-48fouy");
      (0, _internal.attr)(div6, "class", "left about-row svelte-48fouy");
      (0, _internal.attr)(div7, "class", "about-icon svelte-48fouy");
      (0, _internal.attr)(strong2, "class", "svelte-48fouy");
      (0, _internal.attr)(p4, "class", "left svelte-48fouy");
      (0, _internal.attr)(div8, "class", "left about-row svelte-48fouy");
      (0, _internal.attr)(div9, "class", "about-icon left-push svelte-48fouy");
      (0, _internal.attr)(strong3, "class", "svelte-48fouy");
      (0, _internal.attr)(p5, "class", "left svelte-48fouy");
      (0, _internal.attr)(div10, "class", "left about-row svelte-48fouy");
      (0, _internal.attr)(div11, "class", "leaf svelte-48fouy");
      (0, _internal.attr)(h11, "class", "svelte-48fouy");
      (0, _internal.attr)(strong4, "class", "svelte-48fouy");
      (0, _internal.attr)(p6, "class", "left svelte-48fouy");
      (0, _internal.attr)(p7, "class", "left svelte-48fouy");
      (0, _internal.attr)(a1, "target", "_blank");
      (0, _internal.attr)(a1, "href", a1_href_value =
      /*$localize*/
      ctx[0].moreAtLink);
      (0, _internal.attr)(a1, "class", "svelte-48fouy");
      (0, _internal.attr)(p8, "class", "svelte-48fouy");
      (0, _internal.attr)(div12, "class", "leaf svelte-48fouy");
      (0, _internal.attr)(h12, "class", "svelte-48fouy");
      (0, _internal.attr)(div13, "class", "credits-list svelte-48fouy");
      (0, _internal.attr)(div14, "class", "bird svelte-48fouy");
      (0, _internal.attr)(main, "class", "copy svelte-48fouy");
      (0, _internal.attr)(div15, "class", "about-content svelte-48fouy");
      (0, _internal.attr)(div16, "class", "about-container svelte-48fouy");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div16, anchor);
      (0, _internal.append)(div16, div15);
      (0, _internal.append)(div15, div0);
      (0, _internal.append)(div0, a0);
      (0, _internal.mount_component)(image0, a0, null);
      (0, _internal.append)(div15, t0);
      (0, _internal.append)(div15, div1);
      (0, _internal.append)(div1, p0);
      (0, _internal.append)(p0, t1);
      (0, _internal.append)(div1, t2);
      (0, _internal.append)(div1, p1);
      (0, _internal.append)(p1, t3);
      (0, _internal.append)(div15, t4);
      (0, _internal.append)(div15, main);
      (0, _internal.append)(main, h10);
      (0, _internal.append)(h10, div2);
      (0, _internal.mount_component)(image1, div2, null);
      (0, _internal.append)(h10, t5);
      (0, _internal.append)(h10, t6);
      (0, _internal.append)(main, t7);
      (0, _internal.append)(main, div4);
      (0, _internal.append)(div4, div3);
      (0, _internal.mount_component)(image2, div3, null);
      (0, _internal.append)(div4, t8);
      (0, _internal.append)(div4, p2);
      (0, _internal.append)(p2, strong0);
      (0, _internal.append)(strong0, t9);
      (0, _internal.append)(p2, t10);
      (0, _internal.append)(p2, t11);
      (0, _internal.append)(main, t12);
      (0, _internal.append)(main, div6);
      (0, _internal.append)(div6, div5);
      (0, _internal.mount_component)(image3, div5, null);
      (0, _internal.append)(div6, t13);
      (0, _internal.append)(div6, p3);
      (0, _internal.append)(p3, strong1);
      (0, _internal.append)(strong1, t14);
      (0, _internal.append)(p3, t15);
      (0, _internal.append)(p3, t16);
      (0, _internal.append)(main, t17);
      (0, _internal.append)(main, div8);
      (0, _internal.append)(div8, div7);
      (0, _internal.mount_component)(image4, div7, null);
      (0, _internal.append)(div8, t18);
      (0, _internal.append)(div8, p4);
      (0, _internal.append)(p4, strong2);
      (0, _internal.append)(strong2, t19);
      (0, _internal.append)(p4, t20);
      (0, _internal.append)(p4, t21);
      (0, _internal.append)(main, t22);
      (0, _internal.append)(main, div10);
      (0, _internal.append)(div10, div9);
      (0, _internal.mount_component)(image5, div9, null);
      (0, _internal.append)(div10, t23);
      (0, _internal.append)(div10, p5);
      (0, _internal.append)(p5, strong3);
      (0, _internal.append)(strong3, t24);
      (0, _internal.append)(p5, t25);
      (0, _internal.append)(p5, t26);
      (0, _internal.append)(main, t27);
      (0, _internal.append)(main, h11);
      (0, _internal.append)(h11, div11);
      (0, _internal.mount_component)(image6, div11, null);
      (0, _internal.append)(h11, t28);
      (0, _internal.append)(h11, t29);
      (0, _internal.append)(main, t30);
      (0, _internal.append)(main, p6);
      (0, _internal.append)(p6, strong4);
      (0, _internal.append)(strong4, t31);
      (0, _internal.append)(p6, t32);
      (0, _internal.append)(p6, t33);
      (0, _internal.append)(main, t34);
      (0, _internal.append)(main, p7);
      (0, _internal.append)(p7, t35);
      (0, _internal.append)(main, t36);
      (0, _internal.append)(main, p8);
      (0, _internal.append)(p8, t37);
      (0, _internal.append)(p8, t38);
      (0, _internal.append)(p8, a1);
      (0, _internal.append)(a1, t39);
      (0, _internal.append)(main, t40);
      (0, _internal.append)(main, h12);
      (0, _internal.append)(h12, div12);
      (0, _internal.mount_component)(image7, div12, null);
      (0, _internal.append)(h12, t41);
      (0, _internal.append)(h12, t42);
      (0, _internal.append)(main, t43);
      (0, _internal.append)(main, div13);

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div13, null);
      }

      (0, _internal.append)(main, t44);
      (0, _internal.append)(main, div14);
      (0, _internal.mount_component)(image8, div14, null);
      (0, _internal.insert)(target, t45, anchor);
      (0, _internal.mount_component)(closebutton, target, anchor);
      current = true;

      if (!mounted) {
        dispose = [(0, _internal.listen)(div16, "introend",
        /*introend_handler*/
        ctx[4]), (0, _internal.listen)(div16, "outrostart",
        /*outrostart_handler*/
        ctx[5])];
        mounted = true;
      }
    },

    p(new_ctx, [dirty]) {
      ctx = new_ctx;

      if (!current || dirty &
      /*$localize*/
      1 && a0_href_value !== (a0_href_value =
      /*$localize*/
      ctx[0].nfbInteractiveLink)) {
        (0, _internal.attr)(a0, "href", a0_href_value);
      }

      if ((!current || dirty &
      /*$localize*/
      1) && t1_value !== (t1_value =
      /*$localize*/
      ctx[0].nfbProduction + "")) (0, _internal.set_data)(t1, t1_value);
      if ((!current || dirty &
      /*$localize*/
      1) && t3_value !== (t3_value =
      /*$localize*/
      ctx[0].nfbSubcaption + "")) (0, _internal.set_data)(t3, t3_value);
      if ((!current || dirty &
      /*$localize*/
      1) && t6_value !== (t6_value =
      /*$localize*/
      ctx[0].playHeader + "")) (0, _internal.set_data)(t6, t6_value);
      if ((!current || dirty &
      /*$localize*/
      1) && t9_value !== (t9_value =
      /*$localize*/
      ctx[0].tapOrClickAndHold + "")) (0, _internal.set_data)(t9, t9_value);
      if ((!current || dirty &
      /*$localize*/
      1) && t11_value !== (t11_value =
      /*$localize*/
      ctx[0].moveCharacterText + "")) (0, _internal.set_data)(t11, t11_value);
      if ((!current || dirty &
      /*$localize*/
      1) && t14_value !== (t14_value =
      /*$localize*/
      ctx[0].collectText + "")) (0, _internal.set_data)(t14, t14_value);
      if ((!current || dirty &
      /*$localize*/
      1) && t16_value !== (t16_value =
      /*$localize*/
      ctx[0].tokenStringText + "")) (0, _internal.set_data)(t16, t16_value);
      if ((!current || dirty &
      /*$localize*/
      1) && t19_value !== (t19_value =
      /*$localize*/
      ctx[0].orientText + "")) (0, _internal.set_data)(t19, t19_value);
      if ((!current || dirty &
      /*$localize*/
      1) && t21_value !== (t21_value =
      /*$localize*/
      ctx[0].compassStringText + "")) (0, _internal.set_data)(t21, t21_value);
      if ((!current || dirty &
      /*$localize*/
      1) && t24_value !== (t24_value =
      /*$localize*/
      ctx[0].returnText + "")) (0, _internal.set_data)(t24, t24_value);
      if ((!current || dirty &
      /*$localize*/
      1) && t26_value !== (t26_value =
      /*$localize*/
      ctx[0].memoriesStringText + "")) (0, _internal.set_data)(t26, t26_value);
      if ((!current || dirty &
      /*$localize*/
      1) && t29_value !== (t29_value =
      /*$localize*/
      ctx[0].aboutHeader + "")) (0, _internal.set_data)(t29, t29_value);
      if ((!current || dirty &
      /*$localize*/
      1) && t31_value !== (t31_value =
      /*$localize*/
      ctx[0].wayfinderStrongText + "")) (0, _internal.set_data)(t31, t31_value);
      if ((!current || dirty &
      /*$localize*/
      1) && t33_value !== (t33_value =
      /*$localize*/
      ctx[0].wayfinderTextParagraph + "")) (0, _internal.set_data)(t33, t33_value);
      if ((!current || dirty &
      /*$localize*/
      1) && t35_value !== (t35_value =
      /*$localize*/
      ctx[0].wayfinderFurtherTextParagraph + "")) (0, _internal.set_data)(t35, t35_value);
      if ((!current || dirty &
      /*$localize*/
      1) && t37_value !== (t37_value =
      /*$localize*/
      ctx[0].moreAt + "")) (0, _internal.set_data)(t37, t37_value);
      if ((!current || dirty &
      /*$localize*/
      1) && t39_value !== (t39_value =
      /*$localize*/
      ctx[0].moreAtLinkText + "")) (0, _internal.set_data)(t39, t39_value);

      if (!current || dirty &
      /*$localize*/
      1 && a1_href_value !== (a1_href_value =
      /*$localize*/
      ctx[0].moreAtLink)) {
        (0, _internal.attr)(a1, "href", a1_href_value);
      }

      if ((!current || dirty &
      /*$localize*/
      1) && t42_value !== (t42_value =
      /*$localize*/
      ctx[0].creditsHeader + "")) (0, _internal.set_data)(t42, t42_value);

      if (dirty &
      /*credits*/
      8) {
        each_value =
        /*credits*/
        ctx[3];
        let i;

        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx, each_value, i);

          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            (0, _internal.transition_in)(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            (0, _internal.transition_in)(each_blocks[i], 1);
            each_blocks[i].m(div13, null);
          }
        }

        (0, _internal.group_outros)();

        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }

        (0, _internal.check_outros)();
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(image0.$$.fragment, local);
      (0, _internal.transition_in)(image1.$$.fragment, local);
      (0, _internal.transition_in)(image2.$$.fragment, local);
      (0, _internal.transition_in)(image3.$$.fragment, local);
      (0, _internal.transition_in)(image4.$$.fragment, local);
      (0, _internal.transition_in)(image5.$$.fragment, local);
      (0, _internal.transition_in)(image6.$$.fragment, local);
      (0, _internal.transition_in)(image7.$$.fragment, local);

      for (let i = 0; i < each_value.length; i += 1) {
        (0, _internal.transition_in)(each_blocks[i]);
      }

      (0, _internal.transition_in)(image8.$$.fragment, local);
      (0, _internal.add_render_callback)(() => {
        if (div16_outro) div16_outro.end(1);
        if (!div16_intro) div16_intro = (0, _internal.create_in_transition)(div16, _transitions.fadeInTransition, {
          y: 0,
          delay: 10,
          duration: introDelay
        });
        div16_intro.start();
      });
      (0, _internal.transition_in)(closebutton.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(image0.$$.fragment, local);
      (0, _internal.transition_out)(image1.$$.fragment, local);
      (0, _internal.transition_out)(image2.$$.fragment, local);
      (0, _internal.transition_out)(image3.$$.fragment, local);
      (0, _internal.transition_out)(image4.$$.fragment, local);
      (0, _internal.transition_out)(image5.$$.fragment, local);
      (0, _internal.transition_out)(image6.$$.fragment, local);
      (0, _internal.transition_out)(image7.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);

      for (let i = 0; i < each_blocks.length; i += 1) {
        (0, _internal.transition_out)(each_blocks[i]);
      }

      (0, _internal.transition_out)(image8.$$.fragment, local);
      if (div16_intro) div16_intro.invalidate();
      div16_outro = (0, _internal.create_out_transition)(div16, _transitions.fadeInTransition, {
        y: 0,
        delay: 0,
        duration: introDelay
      });
      (0, _internal.transition_out)(closebutton.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div16);
      (0, _internal.destroy_component)(image0);
      (0, _internal.destroy_component)(image1);
      (0, _internal.destroy_component)(image2);
      (0, _internal.destroy_component)(image3);
      (0, _internal.destroy_component)(image4);
      (0, _internal.destroy_component)(image5);
      (0, _internal.destroy_component)(image6);
      (0, _internal.destroy_component)(image7);
      (0, _internal.destroy_each)(each_blocks, detaching);
      (0, _internal.destroy_component)(image8);
      if (detaching && div16_outro) div16_outro.end();
      if (detaching) (0, _internal.detach)(t45);
      (0, _internal.destroy_component)(closebutton, detaching);
      mounted = false;
      (0, _internal.run_all)(dispose);
    }

  };
}

const introDelay = 250;

function instance($$self, $$props, $$invalidate) {
  let $localize;
  (0, _internal.component_subscribe)($$self, _locale.localize, $$value => $$invalidate(0, $localize = $$value));
  const tapClickText = /(iOS|Android|iPhone|iPad)/i.test(navigator.userAgent) ? "Tap" : "Click";
  const dispatch = (0, _svelte.createEventDispatcher)();
  const {
    world
  } = (0, _alecSvelte.context)();
  const credits = [[$localize.mattRole, "Matt DesLauriers"], [$localize.guillaumeRole, "Guillaume Le Roux"], ["Illustration", "Tiffany Beucher"], [$localize.cedrineRole, "Cédrine Pradier"], [$localize.williamRole, "William Mapan"], [$localize.boombox, "Drew Thomas & S. Quinn Hoodless — BoomBox Sound"], [$localize.jelaniRole, "Jelani Thompson"], "LEAF", [$localize.nicholasRole, "Nicholas Klassen"], [$localize.robRole, "Rob McLaughlin"], [$localize.jasmineRole, "Jasmine Pullukatt"], [$localize.camilleJanineRole, "Camille Fillion", "Janine Steele"], [$localize.victoriaRole, "Victoria Angell"], [$localize.tammyRole, "Tammy Peddle"], [$localize.jenniferRole, "Jennifer Mair"], [$localize.ericRole, "Éric Bondo"], [$localize.sergiuRole, "Sergiu Raul Suciu"], [$localize.catherineRole, "Catherine Perreault"], [$localize.christianRole, "Christian Pitchen"], [$localize.socialRole, "Hannah Martin"], [$localize.gabrielleRole, "Gabrielle Lisa Collard"]]; // { html: $localize.harshitRole },

  const introend_handler = () => {
    world.findTag(Tags.AppState).running = false;
  };

  const outrostart_handler = () => {
    world.findTag(Tags.AppState).running = true;
  };

  const click_handler = () => dispatch("close");

  return [$localize, dispatch, world, credits, introend_handler, outrostart_handler, click_handler];
}

class About extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {});
  }

}

var _default = About;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","svelte":"node_modules/svelte/index.mjs","../alec-svelte":"src/alec-svelte/index.js","../util/locale":"src/util/locale.js","../animations/transitions":"src/animations/transitions.js","../tags":"src/tags/index.js","../components/Image.svelte":"src/components/Image.svelte.js","../components/CloseButton.svelte":"src/components/CloseButton.svelte.js"}],"src/components/AbsoluteOverlay.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _transition = require("svelte/transition");

var _transitions = require("../animations/transitions");

/* components/AbsoluteOverlay.svelte generated by Svelte v3.31.0 */
function create_fragment(ctx) {
  let div;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template =
  /*#slots*/
  ctx[6].default;
  const default_slot = (0, _internal.create_slot)(default_slot_template, ctx,
  /*$$scope*/
  ctx[5], null);
  return {
    c() {
      div = (0, _internal.element)("div");
      if (default_slot) default_slot.c();
      (0, _internal.attr)(div, "class", "svelte-r34ayh");
      (0, _internal.toggle_class)(div, "disableInteraction",
      /*disableInteraction*/
      ctx[2]);
      (0, _internal.toggle_class)(div, "darken",
      /*darken*/
      ctx[0]);
      (0, _internal.toggle_class)(div, "darkenTransition",
      /*darkenTransition*/
      ctx[1]);
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);

      if (default_slot) {
        default_slot.m(div, null);
      }

      current = true;

      if (!mounted) {
        dispose = (0, _internal.listen)(div, "click",
        /*click_handler*/
        ctx[7]);
        mounted = true;
      }
    },

    p(ctx, [dirty]) {
      if (default_slot) {
        if (default_slot.p && dirty &
        /*$$scope*/
        32) {
          (0, _internal.update_slot)(default_slot, default_slot_template, ctx,
          /*$$scope*/
          ctx[5], dirty, null, null);
        }
      }

      if (dirty &
      /*disableInteraction*/
      4) {
        (0, _internal.toggle_class)(div, "disableInteraction",
        /*disableInteraction*/
        ctx[2]);
      }

      if (dirty &
      /*darken*/
      1) {
        (0, _internal.toggle_class)(div, "darken",
        /*darken*/
        ctx[0]);
      }

      if (dirty &
      /*darkenTransition*/
      2) {
        (0, _internal.toggle_class)(div, "darkenTransition",
        /*darkenTransition*/
        ctx[1]);
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(default_slot, local);
      (0, _internal.add_render_callback)(() => {
        if (!div_transition) div_transition = (0, _internal.create_bidirectional_transition)(div,
        /*fadeInOut*/
        ctx[3], {}, true);
        div_transition.run(1);
      });
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(default_slot, local);
      if (!div_transition) div_transition = (0, _internal.create_bidirectional_transition)(div,
      /*fadeInOut*/
      ctx[3], {}, false);
      div_transition.run(0);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_transition) div_transition.end();
      mounted = false;
      dispose();
    }

  };
}

function instance($$self, $$props, $$invalidate) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  let {
    darken = false
  } = $$props;
  let {
    darkenTransition = false
  } = $$props;
  let {
    disableInteraction = false
  } = $$props;
  let {
    fade = true
  } = $$props;
  let fadeInOut = fade ? _transitions.fadeOpacityTransition : () => {};

  function click_handler(event) {
    (0, _internal.bubble)($$self, event);
  }

  $$self.$$set = $$props => {
    if ("darken" in $$props) $$invalidate(0, darken = $$props.darken);
    if ("darkenTransition" in $$props) $$invalidate(1, darkenTransition = $$props.darkenTransition);
    if ("disableInteraction" in $$props) $$invalidate(2, disableInteraction = $$props.disableInteraction);
    if ("fade" in $$props) $$invalidate(4, fade = $$props.fade);
    if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
  };

  return [darken, darkenTransition, disableInteraction, fadeInOut, fade, $$scope, slots, click_handler];
}

class AbsoluteOverlay extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      darken: 0,
      darkenTransition: 1,
      disableInteraction: 2,
      fade: 4
    });
  }

}

var _default = AbsoluteOverlay;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","svelte/transition":"node_modules/svelte/transition/index.mjs","../animations/transitions":"src/animations/transitions.js"}],"src/components/HaikuInventorySlot.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _ico_emptyHaiku = _interopRequireDefault(require("../assets/image/ui/ico_emptyHaiku.png"));

var _ico_completedHaiku = _interopRequireDefault(require("../assets/image/ui/ico_completedHaiku.png"));

var _Assets = _interopRequireDefault(require("../util/Assets"));

var _Image = _interopRequireDefault(require("./Image.svelte"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* components/HaikuInventorySlot.svelte generated by Svelte v3.31.0 */
function create_fragment(ctx) {
  let div;
  let image;
  let current;
  image = new _Image.default({
    props: {
      id:
      /*collected*/
      ctx[0] ? filled : empty
    }
  });
  return {
    c() {
      div = (0, _internal.element)("div");
      (0, _internal.create_component)(image.$$.fragment);
      (0, _internal.attr)(div, "class", "haiku-slot svelte-ohjn7u");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.mount_component)(image, div, null);
      current = true;
    },

    p(ctx, [dirty]) {
      const image_changes = {};
      if (dirty &
      /*collected*/
      1) image_changes.id =
      /*collected*/
      ctx[0] ? filled : empty;
      image.$set(image_changes);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(image.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(image.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      (0, _internal.destroy_component)(image);
    }

  };
}

const empty = "image/ui/ico_emptyHaiku";
const filled = "image/ui/ico_completedHaiku";

function instance($$self, $$props, $$invalidate) {
  _Assets.default.prepare(empty);

  let {
    collected = false
  } = $$props;

  $$self.$$set = $$props => {
    if ("collected" in $$props) $$invalidate(0, collected = $$props.collected);
  };

  return [collected];
}

class HaikuInventorySlot extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      collected: 0
    });
  }

}

var _default = HaikuInventorySlot;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","../assets/image/ui/ico_emptyHaiku.png":"src/assets/image/ui/ico_emptyHaiku.png","../assets/image/ui/ico_completedHaiku.png":"src/assets/image/ui/ico_completedHaiku.png","../util/Assets":"src/util/Assets.js","./Image.svelte":"src/components/Image.svelte.js"}],"src/components/CornerMenuButton.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _IconButton = _interopRequireDefault(require("./IconButton.svelte"));

var _transition = require("svelte/transition");

var _transitions = require("../animations/transitions");

var _eases = _interopRequireDefault(require("eases"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* components/CornerMenuButton.svelte generated by Svelte v3.31.0 */
function create_if_block(ctx) {
  let div;
  let div_intro;
  let div_outro;
  let current;
  return {
    c() {
      div = (0, _internal.element)("div");
      (0, _internal.attr)(div, "class", "notification svelte-bbjv");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      current = true;
    },

    p(new_ctx, dirty) {
      ctx = new_ctx;
    },

    i(local) {
      if (current) return;
      (0, _internal.add_render_callback)(() => {
        if (div_outro) div_outro.end(1);
        if (!div_intro) div_intro = (0, _internal.create_in_transition)(div, transitionScale, {
          delay: 500,
          easing: _eases.default.expoOut,
          duration: 1000
        });
        div_intro.start();
      });
      current = true;
    },

    o(local) {
      if (div_intro) div_intro.invalidate();
      div_outro = (0, _internal.create_out_transition)(div, transitionScale, {
        delay: 0,
        easing: _eases.default.expoOut,
        duration: 1000
      });
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      if (detaching && div_outro) div_outro.end();
    }

  };
}

function create_fragment(ctx) {
  let div;
  let iconbutton;
  let t;
  let div_intro;
  let div_outro;
  let current;
  iconbutton = new _IconButton.default({
    props: {
      size:
      /*size*/
      ctx[6],
      icon:
      /*icon*/
      ctx[3],
      image:
      /*image*/
      ctx[4],
      id:
      /*id*/
      ctx[5]
    }
  });
  iconbutton.$on("click",
  /*click_handler*/
  ctx[10]);
  iconbutton.$on("touchstart",
  /*touchstart_handler*/
  ctx[11]);
  iconbutton.$on("mousedown",
  /*mousedown_handler*/
  ctx[12]);
  let if_block =
  /*showNotification*/
  ctx[8] && create_if_block(ctx);
  return {
    c() {
      div = (0, _internal.element)("div");
      (0, _internal.create_component)(iconbutton.$$.fragment);
      t = (0, _internal.space)();
      if (if_block) if_block.c();
      (0, _internal.attr)(div, "class", "menu-button svelte-bbjv");
      (0, _internal.attr)(div, "style",
      /*style*/
      ctx[7]);
      (0, _internal.toggle_class)(div, "topLeft",
      /*topLeft*/
      ctx[0]);
      (0, _internal.toggle_class)(div, "topRight",
      /*topRight*/
      ctx[1]);
      (0, _internal.toggle_class)(div, "bottomRight",
      /*bottomRight*/
      ctx[2]);
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.mount_component)(iconbutton, div, null);
      (0, _internal.append)(div, t);
      if (if_block) if_block.m(div, null);
      current = true;
    },

    p(ctx, [dirty]) {
      const iconbutton_changes = {};
      if (dirty &
      /*size*/
      64) iconbutton_changes.size =
      /*size*/
      ctx[6];
      if (dirty &
      /*icon*/
      8) iconbutton_changes.icon =
      /*icon*/
      ctx[3];
      if (dirty &
      /*image*/
      16) iconbutton_changes.image =
      /*image*/
      ctx[4];
      if (dirty &
      /*id*/
      32) iconbutton_changes.id =
      /*id*/
      ctx[5];
      iconbutton.$set(iconbutton_changes);

      if (
      /*showNotification*/
      ctx[8]) {
        if (if_block) {
          if_block.p(ctx, dirty);

          if (dirty &
          /*showNotification*/
          256) {
            (0, _internal.transition_in)(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          (0, _internal.transition_in)(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_block, 1, 1, () => {
          if_block = null;
        });
        (0, _internal.check_outros)();
      }

      if (!current || dirty &
      /*style*/
      128) {
        (0, _internal.attr)(div, "style",
        /*style*/
        ctx[7]);
      }

      if (dirty &
      /*topLeft*/
      1) {
        (0, _internal.toggle_class)(div, "topLeft",
        /*topLeft*/
        ctx[0]);
      }

      if (dirty &
      /*topRight*/
      2) {
        (0, _internal.toggle_class)(div, "topRight",
        /*topRight*/
        ctx[1]);
      }

      if (dirty &
      /*bottomRight*/
      4) {
        (0, _internal.toggle_class)(div, "bottomRight",
        /*bottomRight*/
        ctx[2]);
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(iconbutton.$$.fragment, local);
      (0, _internal.transition_in)(if_block);
      (0, _internal.add_render_callback)(() => {
        if (div_outro) div_outro.end(1);
        if (!div_intro) div_intro = (0, _internal.create_in_transition)(div, _transitions.fadeOpacityTransition, {
          delay: 250
        });
        div_intro.start();
      });
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(iconbutton.$$.fragment, local);
      (0, _internal.transition_out)(if_block);
      if (div_intro) div_intro.invalidate();
      div_outro = (0, _internal.create_out_transition)(div, _transitions.fadeOpacityTransition, {});
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      (0, _internal.destroy_component)(iconbutton);
      if (if_block) if_block.d();
      if (detaching && div_outro) div_outro.end();
    }

  };
}

function transitionScale(node, {
  delay = 0,
  duration = 500,
  easing = x => x,
  baseScale = 0
}) {
  // const o = +getComputedStyle(node).opacity;
  const m = getComputedStyle(node).transform.match(/scale\(([0-9.]+)\)/);
  const s = m ? m[1] : 1;
  const is = 1 - baseScale;
  return {
    delay,
    duration,
    css: t => {
      const eased = easing(t);
      return `transform: scale(${eased * s * is + baseScale})`;
    }
  };
}

function instance($$self, $$props, $$invalidate) {
  let {
    topLeft = false
  } = $$props;
  let {
    topRight = false
  } = $$props;
  let {
    bottomRight = false
  } = $$props;
  let {
    icon = undefined
  } = $$props;
  let {
    image = undefined
  } = $$props;
  let {
    id = undefined
  } = $$props;
  let {
    size = null
  } = $$props;
  let {
    style = ""
  } = $$props;
  let showNotification = false,
      notifyTimer = null;

  function notify() {
    $$invalidate(8, showNotification = true);
    clearTimeout(notifyTimer);
    notifyTimer = setTimeout(() => {
      $$invalidate(8, showNotification = false);
    }, 1500);
  }

  function click_handler(event) {
    (0, _internal.bubble)($$self, event);
  }

  function touchstart_handler(event) {
    (0, _internal.bubble)($$self, event);
  }

  function mousedown_handler(event) {
    (0, _internal.bubble)($$self, event);
  }

  $$self.$$set = $$props => {
    if ("topLeft" in $$props) $$invalidate(0, topLeft = $$props.topLeft);
    if ("topRight" in $$props) $$invalidate(1, topRight = $$props.topRight);
    if ("bottomRight" in $$props) $$invalidate(2, bottomRight = $$props.bottomRight);
    if ("icon" in $$props) $$invalidate(3, icon = $$props.icon);
    if ("image" in $$props) $$invalidate(4, image = $$props.image);
    if ("id" in $$props) $$invalidate(5, id = $$props.id);
    if ("size" in $$props) $$invalidate(6, size = $$props.size);
    if ("style" in $$props) $$invalidate(7, style = $$props.style);
  };

  return [topLeft, topRight, bottomRight, icon, image, id, size, style, showNotification, notify, click_handler, touchstart_handler, mousedown_handler];
}

class CornerMenuButton extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      topLeft: 0,
      topRight: 1,
      bottomRight: 2,
      icon: 3,
      image: 4,
      id: 5,
      size: 6,
      style: 7,
      notify: 9
    });
  }

  get notify() {
    return this.$$.ctx[9];
  }

}

var _default = CornerMenuButton;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","./IconButton.svelte":"src/components/IconButton.svelte.js","svelte/transition":"node_modules/svelte/transition/index.mjs","../animations/transitions":"src/animations/transitions.js","eases":"node_modules/eases/index.js"}],"src/components/HaikuInventory.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _transition = require("svelte/transition");

var _svelte = require("svelte");

var _transitions = require("../animations/transitions");

var _HaikuInventorySlot = _interopRequireDefault(require("./HaikuInventorySlot.svelte"));

var _ico_emptyHaiku = _interopRequireDefault(require("../assets/image/ui/ico_emptyHaiku.png"));

var _ico_completedHaiku = _interopRequireDefault(require("../assets/image/ui/ico_completedHaiku.png"));

var _ico_journal = _interopRequireDefault(require("../assets/image/ui/ico_journal.png"));

var _CornerMenuButton = _interopRequireDefault(require("./CornerMenuButton.svelte"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* components/HaikuInventory.svelte generated by Svelte v3.31.0 */
const {
  Boolean: Boolean_1
} = _internal.globals;

function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i];
  return child_ctx;
} // (81:2) {#each elements as collected}


function create_each_block(ctx) {
  let haikuinventoryslot;
  let current;
  haikuinventoryslot = new _HaikuInventorySlot.default({
    props: {
      collected:
      /*collected*/
      ctx[13]
    }
  });
  return {
    c() {
      (0, _internal.create_component)(haikuinventoryslot.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(haikuinventoryslot, target, anchor);
      current = true;
    },

    p(ctx, dirty) {
      const haikuinventoryslot_changes = {};
      if (dirty &
      /*elements*/
      1) haikuinventoryslot_changes.collected =
      /*collected*/
      ctx[13];
      haikuinventoryslot.$set(haikuinventoryslot_changes);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(haikuinventoryslot.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(haikuinventoryslot.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(haikuinventoryslot, detaching);
    }

  };
}

function create_fragment(ctx) {
  let div;
  let div_intro;
  let div_outro;
  let current;
  let each_value =
  /*elements*/
  ctx[0];
  let each_blocks = [];

  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }

  const out = i => (0, _internal.transition_out)(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });

  return {
    c() {
      div = (0, _internal.element)("div");

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }

      (0, _internal.attr)(div, "class", "haiku-container svelte-1wphodo");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }

      current = true;
    },

    p(ctx, [dirty]) {
      if (dirty &
      /*elements*/
      1) {
        each_value =
        /*elements*/
        ctx[0];
        let i;

        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx, each_value, i);

          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            (0, _internal.transition_in)(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            (0, _internal.transition_in)(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }

        (0, _internal.group_outros)();

        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }

        (0, _internal.check_outros)();
      }
    },

    i(local) {
      if (current) return;

      for (let i = 0; i < each_value.length; i += 1) {
        (0, _internal.transition_in)(each_blocks[i]);
      }

      (0, _internal.add_render_callback)(() => {
        if (div_outro) div_outro.end(1);
        if (!div_intro) div_intro = (0, _internal.create_in_transition)(div, _transitions.fadeOpacityTransition, {
          delay: 250
        });
        div_intro.start();
      });
      current = true;
    },

    o(local) {
      each_blocks = each_blocks.filter(Boolean_1);

      for (let i = 0; i < each_blocks.length; i += 1) {
        (0, _internal.transition_out)(each_blocks[i]);
      }

      if (div_intro) div_intro.invalidate();
      div_outro = (0, _internal.create_out_transition)(div, _transitions.fadeOpacityTransition, {});
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      (0, _internal.destroy_each)(each_blocks, detaching);
      if (detaching && div_outro) div_outro.end();
    }

  };
}

const forceShowDuration = 4000;

function instance($$self, $$props, $$invalidate) {
  const dispatch = (0, _svelte.createEventDispatcher)();
  let {
    store
  } = $$props;
  let slots = [];
  let showTimeout = null;
  let forceShow = false;
  let elements = [];
  let lastCollected = 0;
  let moving = false;
  let shouldShow = false;
  let mounted = false;
  let state;
  const unmount = store.subscribe(v => {
    moving = v.moving;
    state = v.state; // not sure why svelte needs to track this inside this component?

    const total = v.haikusTotal;
    const collected = v.haikusCollected || 0;
    $$invalidate(0, elements = new Array(total).fill(false).map((_, i) => {
      return i < collected;
    }));

    if (lastCollected !== collected) {
      forceShow = true;
      clearTimeout(showTimeout);
      showTimeout = setTimeout(() => {
        forceShow = false;
        updateShow();
      }, forceShowDuration);
    }

    lastCollected = collected;
    updateShow();
  });
  (0, _svelte.onMount)(() => {
    mounted = true;
  });
  (0, _svelte.onDestroy)(() => {
    mounted = false;
    forceShow = false;
    clearTimeout(showTimeout);
    unmount();
  });

  function updateShow() {
    shouldShow = !state && (forceShow || !moving || elements.length > 0 && elements.every(Boolean));
  }

  $$self.$$set = $$props => {
    if ("store" in $$props) $$invalidate(1, store = $$props.store);
  };

  return [elements, store];
}

class HaikuInventory extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      store: 1
    });
  }

}

var _default = HaikuInventory;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","svelte/transition":"node_modules/svelte/transition/index.mjs","svelte":"node_modules/svelte/index.mjs","../animations/transitions":"src/animations/transitions.js","./HaikuInventorySlot.svelte":"src/components/HaikuInventorySlot.svelte.js","../assets/image/ui/ico_emptyHaiku.png":"src/assets/image/ui/ico_emptyHaiku.png","../assets/image/ui/ico_completedHaiku.png":"src/assets/image/ui/ico_completedHaiku.png","../assets/image/ui/ico_journal.png":"src/assets/image/ui/ico_journal.png","./CornerMenuButton.svelte":"src/components/CornerMenuButton.svelte.js"}],"src/components/GameProgress.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _transitions = require("../animations/transitions");

var _config = _interopRequireDefault(require("../config"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _Image = _interopRequireDefault(require("./Image.svelte"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* components/GameProgress.svelte generated by Svelte v3.31.0 */
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  child_ctx[0] = i;
  return child_ctx;
}

function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  child_ctx[13] = i;
  return child_ctx;
} // (89:14) {:else}


function create_else_block(ctx) {
  let div;
  let image;
  let div_intro;
  let current;
  image = new _Image.default({
    props: {
      width: "100%",
      height: "100%",
      id: "image/ui/empty_box"
    }
  });
  return {
    c() {
      div = (0, _internal.element)("div");
      (0, _internal.create_component)(image.$$.fragment);
      (0, _internal.attr)(div, "class", "haiku-card-icon svelte-rdjqne");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.mount_component)(image, div, null);
      current = true;
    },

    p(new_ctx, dirty) {
      ctx = new_ctx;
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(image.$$.fragment, local);

      if (!div_intro) {
        (0, _internal.add_render_callback)(() => {
          div_intro = (0, _internal.create_in_transition)(div, _transitions.fadeTransition, {
            delay: stagger(
            /*biomeIndex*/
            ctx[0] * 4 + 1 +
            /*i*/
            ctx[13])
          });
          div_intro.start();
        });
      }

      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(image.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      (0, _internal.destroy_component)(image);
    }

  };
} // (78:14) {#if card.collected}


function create_if_block(ctx) {
  let div;
  let image;
  let div_intro;
  let current;
  image = new _Image.default({
    props: {
      width: "100%",
      height: "100%",
      id: "image/ui/filled_box"
    }
  });
  return {
    c() {
      div = (0, _internal.element)("div");
      (0, _internal.create_component)(image.$$.fragment);
      (0, _internal.attr)(div, "class", "haiku-card-icon svelte-rdjqne");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.mount_component)(image, div, null);
      current = true;
    },

    p(new_ctx, dirty) {
      ctx = new_ctx;
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(image.$$.fragment, local);

      if (!div_intro) {
        (0, _internal.add_render_callback)(() => {
          div_intro = (0, _internal.create_in_transition)(div, _transitions.fadeTransition, {
            delay: stagger(
            /*biomeIndex*/
            ctx[0] * 4 + 1 +
            /*i*/
            ctx[13])
          });
          div_intro.start();
        });
      }

      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(image.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      (0, _internal.destroy_component)(image);
    }

  };
} // (70:10) {#each el.cards as card, i (card)}


function create_each_block_1(key_1, ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let t;
  let div_style_value;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];

  function select_block_type(ctx, dirty) {
    if (
    /*card*/
    ctx[11].collected) return 0;
    return 1;
  }

  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    key: key_1,
    first: null,

    c() {
      div = (0, _internal.element)("div");
      if_block.c();
      t = (0, _internal.space)();
      (0, _internal.attr)(div, "class", "haiku-card svelte-rdjqne");
      (0, _internal.attr)(div, "style", div_style_value =
      /*card*/
      ctx[11].style);
      (0, _internal.toggle_class)(div, "locked",
      /*el*/
      ctx[9].locked);
      (0, _internal.toggle_class)(div, "active",
      /*el*/
      ctx[9].active);
      (0, _internal.toggle_class)(div, "collected",
      /*card*/
      ctx[11].collected);
      this.first = div;
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      (0, _internal.append)(div, t);
      current = true;
    },

    p(ctx, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);

      if (current_block_type_index !== previous_block_index) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        (0, _internal.check_outros)();
        if_block = if_blocks[current_block_type_index];

        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }

        (0, _internal.transition_in)(if_block, 1);
        if_block.m(div, t);
      }

      if (!current || dirty &
      /*elements*/
      2 && div_style_value !== (div_style_value =
      /*card*/
      ctx[11].style)) {
        (0, _internal.attr)(div, "style", div_style_value);
      }

      if (dirty &
      /*elements*/
      2) {
        (0, _internal.toggle_class)(div, "locked",
        /*el*/
        ctx[9].locked);
      }

      if (dirty &
      /*elements*/
      2) {
        (0, _internal.toggle_class)(div, "active",
        /*el*/
        ctx[9].active);
      }

      if (dirty &
      /*elements*/
      2) {
        (0, _internal.toggle_class)(div, "collected",
        /*card*/
        ctx[11].collected);
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(if_block);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(if_block);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      if_blocks[current_block_type_index].d();
    }

  };
} // (56:2) {#each elements as el, biomeIndex (el)}


function create_each_block(key_1, ctx) {
  let div0;
  let image0;
  let div0_transition;
  let t0;
  let div5;
  let div2;
  let div1;
  let each_blocks = [];
  let each_1_lookup = new Map();
  let t1;
  let div4;
  let div3;
  let image1;
  let div3_intro;
  let current;
  image0 = new _Image.default({
    props: {
      width: "100%",
      height: "100%",
      id: "image/ui/vertical-rule"
    }
  });
  let each_value_1 =
  /*el*/
  ctx[9].cards;

  const get_key = ctx =>
  /*card*/
  ctx[11];

  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
  }

  image1 = new _Image.default({
    props: {
      width: "100%",
      height: "100%",
      id:
      /*getBiomeId*/
      ctx[2](
      /*el*/
      ctx[9].name,
      /*el*/
      ctx[9].finished)
    }
  });
  return {
    key: key_1,
    first: null,

    c() {
      div0 = (0, _internal.element)("div");
      (0, _internal.create_component)(image0.$$.fragment);
      t0 = (0, _internal.space)();
      div5 = (0, _internal.element)("div");
      div2 = (0, _internal.element)("div");
      div1 = (0, _internal.element)("div");

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }

      t1 = (0, _internal.space)();
      div4 = (0, _internal.element)("div");
      div3 = (0, _internal.element)("div");
      (0, _internal.create_component)(image1.$$.fragment);
      (0, _internal.attr)(div0, "class", "vertical-rule svelte-rdjqne");
      (0, _internal.attr)(div1, "class", "haiku-card-container svelte-rdjqne");
      (0, _internal.toggle_class)(div1, "locked",
      /*el*/
      ctx[9].locked);
      (0, _internal.toggle_class)(div1, "acitve",
      /*el*/
      ctx[9].active);
      (0, _internal.attr)(div2, "class", "top-row svelte-rdjqne");
      (0, _internal.attr)(div3, "class", "biome-icon svelte-rdjqne");
      (0, _internal.toggle_class)(div3, "locked",
      /*el*/
      ctx[9].locked);
      (0, _internal.attr)(div4, "class", "biome-icon-container svelte-rdjqne");
      (0, _internal.attr)(div5, "class", "biome-container svelte-rdjqne");
      this.first = div0;
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div0, anchor);
      (0, _internal.mount_component)(image0, div0, null);
      (0, _internal.insert)(target, t0, anchor);
      (0, _internal.insert)(target, div5, anchor);
      (0, _internal.append)(div5, div2);
      (0, _internal.append)(div2, div1);

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }

      (0, _internal.append)(div5, t1);
      (0, _internal.append)(div5, div4);
      (0, _internal.append)(div4, div3);
      (0, _internal.mount_component)(image1, div3, null);
      current = true;
    },

    p(new_ctx, dirty) {
      ctx = new_ctx;

      if (dirty &
      /*elements*/
      2) {
        const each_value_1 =
        /*el*/
        ctx[9].cards;
        (0, _internal.group_outros)();
        each_blocks = (0, _internal.update_keyed_each)(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div1, _internal.outro_and_destroy_block, create_each_block_1, null, get_each_context_1);
        (0, _internal.check_outros)();
      }

      if (dirty &
      /*elements*/
      2) {
        (0, _internal.toggle_class)(div1, "locked",
        /*el*/
        ctx[9].locked);
      }

      if (dirty &
      /*elements*/
      2) {
        (0, _internal.toggle_class)(div1, "acitve",
        /*el*/
        ctx[9].active);
      }

      const image1_changes = {};
      if (dirty &
      /*elements*/
      2) image1_changes.id =
      /*getBiomeId*/
      ctx[2](
      /*el*/
      ctx[9].name,
      /*el*/
      ctx[9].finished);
      image1.$set(image1_changes);

      if (dirty &
      /*elements*/
      2) {
        (0, _internal.toggle_class)(div3, "locked",
        /*el*/
        ctx[9].locked);
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(image0.$$.fragment, local);
      (0, _internal.add_render_callback)(() => {
        if (!div0_transition) div0_transition = (0, _internal.create_bidirectional_transition)(div0, _transitions.fadeTransition, {
          delay: stagger(
          /*biomeIndex*/
          ctx[0] * 4)
        }, true);
        div0_transition.run(1);
      });

      for (let i = 0; i < each_value_1.length; i += 1) {
        (0, _internal.transition_in)(each_blocks[i]);
      }

      (0, _internal.transition_in)(image1.$$.fragment, local);

      if (!div3_intro) {
        (0, _internal.add_render_callback)(() => {
          div3_intro = (0, _internal.create_in_transition)(div3, _transitions.fadeTransition, {
            delay: stagger(
            /*biomeIndex*/
            ctx[0] * 4 + 1)
          });
          div3_intro.start();
        });
      }

      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(image0.$$.fragment, local);
      if (!div0_transition) div0_transition = (0, _internal.create_bidirectional_transition)(div0, _transitions.fadeTransition, {
        delay: stagger(
        /*biomeIndex*/
        ctx[0] * 4)
      }, false);
      div0_transition.run(0);

      for (let i = 0; i < each_blocks.length; i += 1) {
        (0, _internal.transition_out)(each_blocks[i]);
      }

      (0, _internal.transition_out)(image1.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div0);
      (0, _internal.destroy_component)(image0);
      if (detaching && div0_transition) div0_transition.end();
      if (detaching) (0, _internal.detach)(t0);
      if (detaching) (0, _internal.detach)(div5);

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }

      (0, _internal.destroy_component)(image1);
    }

  };
}

function create_fragment(ctx) {
  let div1;
  let each_blocks = [];
  let each_1_lookup = new Map();
  let t;
  let div0;
  let image;
  let div0_intro;
  let current;
  let each_value =
  /*elements*/
  ctx[1];

  const get_key = ctx =>
  /*el*/
  ctx[9];

  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }

  image = new _Image.default({
    props: {
      width: "100%",
      height: "100%",
      id: "image/ui/vertical-rule"
    }
  });
  return {
    c() {
      div1 = (0, _internal.element)("div");

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }

      t = (0, _internal.space)();
      div0 = (0, _internal.element)("div");
      (0, _internal.create_component)(image.$$.fragment);
      (0, _internal.attr)(div0, "class", "vertical-rule svelte-rdjqne");
      (0, _internal.attr)(div1, "class", "progress-container svelte-rdjqne");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div1, anchor);

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }

      (0, _internal.append)(div1, t);
      (0, _internal.append)(div1, div0);
      (0, _internal.mount_component)(image, div0, null);
      current = true;
    },

    p(new_ctx, [dirty]) {
      ctx = new_ctx;

      if (dirty &
      /*elements, getBiomeId, stagger*/
      6) {
        const each_value =
        /*elements*/
        ctx[1];
        (0, _internal.group_outros)();
        each_blocks = (0, _internal.update_keyed_each)(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div1, _internal.outro_and_destroy_block, create_each_block, t, get_each_context);
        (0, _internal.check_outros)();
      }
    },

    i(local) {
      if (current) return;

      for (let i = 0; i < each_value.length; i += 1) {
        (0, _internal.transition_in)(each_blocks[i]);
      }

      (0, _internal.transition_in)(image.$$.fragment, local);

      if (!div0_intro) {
        (0, _internal.add_render_callback)(() => {
          div0_intro = (0, _internal.create_in_transition)(div0, _transitions.fadeTransition, {
            delay: stagger(3 * 4)
          });
          div0_intro.start();
        });
      }

      current = true;
    },

    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        (0, _internal.transition_out)(each_blocks[i]);
      }

      (0, _internal.transition_out)(image.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div1);

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }

      (0, _internal.destroy_component)(image);
    }

  };
}

function stagger(i) {
  return 50 + i * 100;
}

function instance($$self, $$props, $$invalidate) {
  const random = (0, _Random.default)();
  let {
    biome = "forest"
  } = $$props;
  let {
    biomeIndex = 0
  } = $$props;
  let {
    haikusCollected = 0
  } = $$props;
  const haikusPerBiome = (0, _config.default)().haikusPerBiome;
  const biomes = ["forest", "grasslands", "tundra"];
  const biomeIcons = {
    forest: "biomeforest",
    grasslands: "biomegrass",
    tundra: "biometundra"
  };
  let elements;

  function getBiomeId(name, finished) {
    return `image/ui/${biomeIcons[name]}${finished ? "-alt" : ""}`;
  }

  $$self.$$set = $$props => {
    if ("biome" in $$props) $$invalidate(3, biome = $$props.biome);
    if ("biomeIndex" in $$props) $$invalidate(0, biomeIndex = $$props.biomeIndex);
    if ("haikusCollected" in $$props) $$invalidate(4, haikusCollected = $$props.haikusCollected);
  };

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*biomeIndex, haikusCollected*/
    17) {
      $: $$invalidate(1, elements = biomes.map((name, index) => {
        let collected;
        if (index < biomeIndex) collected = haikusPerBiome;else if (index > biomeIndex) collected = 0;else collected = haikusCollected;
        return {
          name,
          finished: biomeIndex > index,
          active: biomeIndex === index,
          locked: index > biomeIndex,
          cards: new Array(haikusPerBiome).fill(null).map((_, i) => {
            const offset = random.range(-0.75, 0.75);
            const rotation = random.range(-4, 1.5);
            return {
              style: `transform: translate(0px, ${offset}px) rotateZ(${rotation}deg);`,
              collected: i < collected,
              mostRecent: false
            };
          }),
          index
        };
      }));
    }
  };

  return [biomeIndex, elements, getBiomeId, biome, haikusCollected];
}

class GameProgress extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      biome: 3,
      biomeIndex: 0,
      haikusCollected: 4
    });
  }

}

var _default = GameProgress;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","../animations/transitions":"src/animations/transitions.js","../config":"src/config.js","../util/Random":"src/util/Random.js","./Image.svelte":"src/components/Image.svelte.js"}],"src/overlays/HaikuPopup.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _tokens = require("../util/tokens");

var _ImageButton = _interopRequireDefault(require("../components/ImageButton.svelte"));

var _AbsoluteOverlay = _interopRequireDefault(require("../components/AbsoluteOverlay.svelte"));

var _HaikuInventory = _interopRequireDefault(require("../components/HaikuInventory.svelte"));

var Tags = _interopRequireWildcard(require("../tags"));

var _ico_paperJournal1Rotated = _interopRequireDefault(require("../assets/image/ui/ico_paperJournal1-rotated.png"));

var _GameProgress = _interopRequireDefault(require("../components/GameProgress.svelte"));

var _locale = require("../util/locale");

var _svelte = require("svelte");

var _transitions = require("../animations/transitions");

var _alecSvelte = require("../alec-svelte");

var _HaikuCard = _interopRequireDefault(require("../components/HaikuCard.svelte"));

var _config = _interopRequireDefault(require("../config"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* overlays/HaikuPopup.svelte generated by Svelte v3.31.0 */
function create_fragment(ctx) {
  let div2;
  let div0;
  let gameprogress;
  let t0;
  let haikucard;
  let t1;
  let div1;
  let imagebutton;
  let div1_intro;
  let div1_outro;
  let div2_intro;
  let div2_outro;
  let current;
  const gameprogress_spread_levels = [
  /*getProgressData*/
  ctx[5]()];
  let gameprogress_props = {};

  for (let i = 0; i < gameprogress_spread_levels.length; i += 1) {
    gameprogress_props = (0, _internal.assign)(gameprogress_props, gameprogress_spread_levels[i]);
  }

  gameprogress = new _GameProgress.default({
    props: gameprogress_props
  });
  haikucard = new _HaikuCard.default({
    props: {
      animatePoem: true,
      lines:
      /*lines*/
      ctx[0],
      tokens:
      /*tokens*/
      ctx[1]
    }
  });
  imagebutton = new _ImageButton.default({
    props: {
      text:
      /*$localize*/
      ctx[3].continueButton,
      mode: "normal_small"
    }
  });
  imagebutton.$on("click",
  /*closePopup*/
  ctx[4]);
  return {
    c() {
      div2 = (0, _internal.element)("div");
      div0 = (0, _internal.element)("div");
      (0, _internal.create_component)(gameprogress.$$.fragment);
      t0 = (0, _internal.space)();
      (0, _internal.create_component)(haikucard.$$.fragment);
      t1 = (0, _internal.space)();
      div1 = (0, _internal.element)("div");
      (0, _internal.create_component)(imagebutton.$$.fragment);
      (0, _internal.attr)(div0, "class", "progress-wrapper svelte-1wd0urs");
      (0, _internal.attr)(div1, "class", "save-memory-container svelte-1wd0urs");
      (0, _internal.attr)(div2, "class", "page-container svelte-1wd0urs");
      (0, _internal.toggle_class)(div2, "ignorePointer",
      /*ignorePointer*/
      ctx[2]);
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div2, anchor);
      (0, _internal.append)(div2, div0);
      (0, _internal.mount_component)(gameprogress, div0, null);
      (0, _internal.append)(div2, t0);
      (0, _internal.mount_component)(haikucard, div2, null);
      (0, _internal.append)(div2, t1);
      (0, _internal.append)(div2, div1);
      (0, _internal.mount_component)(imagebutton, div1, null);
      current = true;
    },

    p(ctx, [dirty]) {
      const gameprogress_changes = dirty &
      /*getProgressData*/
      32 ? (0, _internal.get_spread_update)(gameprogress_spread_levels, [(0, _internal.get_spread_object)(
      /*getProgressData*/
      ctx[5]())]) : {};
      gameprogress.$set(gameprogress_changes);
      const haikucard_changes = {};
      if (dirty &
      /*lines*/
      1) haikucard_changes.lines =
      /*lines*/
      ctx[0];
      if (dirty &
      /*tokens*/
      2) haikucard_changes.tokens =
      /*tokens*/
      ctx[1];
      haikucard.$set(haikucard_changes);
      const imagebutton_changes = {};
      if (dirty &
      /*$localize*/
      8) imagebutton_changes.text =
      /*$localize*/
      ctx[3].continueButton;
      imagebutton.$set(imagebutton_changes);

      if (dirty &
      /*ignorePointer*/
      4) {
        (0, _internal.toggle_class)(div2, "ignorePointer",
        /*ignorePointer*/
        ctx[2]);
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(gameprogress.$$.fragment, local);
      (0, _internal.transition_in)(haikucard.$$.fragment, local);
      (0, _internal.transition_in)(imagebutton.$$.fragment, local);
      (0, _internal.add_render_callback)(() => {
        if (div1_outro) div1_outro.end(1);
        if (!div1_intro) div1_intro = (0, _internal.create_in_transition)(div1, _transitions.fadeTransition, {
          delay: 500 + 250,
          duration: 500
        });
        div1_intro.start();
      });
      (0, _internal.add_render_callback)(() => {
        if (div2_outro) div2_outro.end(1);
        if (!div2_intro) div2_intro = (0, _internal.create_in_transition)(div2, _transitions.fadeOpacityTransition, {
          delay: 0,
          duration: 500
        });
        div2_intro.start();
      });
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(gameprogress.$$.fragment, local);
      (0, _internal.transition_out)(haikucard.$$.fragment, local);
      (0, _internal.transition_out)(imagebutton.$$.fragment, local);
      if (div1_intro) div1_intro.invalidate();
      div1_outro = (0, _internal.create_out_transition)(div1, _transitions.fadeTransition, {
        duration: 250
      });
      if (div2_intro) div2_intro.invalidate();
      div2_outro = (0, _internal.create_out_transition)(div2, _transitions.fadeOpacityTransition, {
        delay: 50,
        duration: 500
      });
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div2);
      (0, _internal.destroy_component)(gameprogress);
      (0, _internal.destroy_component)(haikucard);
      (0, _internal.destroy_component)(imagebutton);
      if (detaching && div1_outro) div1_outro.end();
      if (detaching && div2_outro) div2_outro.end();
    }

  };
}

function instance($$self, $$props, $$invalidate) {
  let $localize;
  (0, _internal.component_subscribe)($$self, _locale.localize, $$value => $$invalidate(3, $localize = $$value));
  const dispatcher = (0, _svelte.createEventDispatcher)();
  const {
    world
  } = (0, _alecSvelte.context)();
  const haikusPerBiome = (0, _config.default)().haikusPerBiome;
  let {
    lines
  } = $$props;
  let {
    tokens
  } = $$props;
  let {
    store
  } = $$props;
  let ignorePointer = false;

  let curLang = _locale.language.get();

  let storeData;
  const unsubscribe = store.subscribe(v => {
    storeData = v;
  });
  const biomes = ["forest", "grasslands", "tundra"];

  function closePopup() {
    $$invalidate(2, ignorePointer = true);
    dispatcher("close");
  }

  function getProgressData() {
    const q = world.query(Tags.HaikuInInventory);
    const active = world.findEntity(Tags.ActiveEnvironmentState);
    const name = active ? active.get(Tags.EnvironmentState).name : "forest";
    const biomeIndex = biomes.includes(name) ? biomes.indexOf(name) : 0;
    return {
      biome: name,
      biomeIndex,
      haikusCollected: Math.min(haikusPerBiome, Math.max(0, q.entities.length))
    }; // haikusPerBiome: haikusPerBiome,
  }

  (0, _svelte.onMount)(() => {
    store.update(d => ({ ...d,
      playing: false
    }));
    $$invalidate(2, ignorePointer = false);

    const detachLang = _locale.language.subscribe(s => {
      curLang = s;
    });

    return () => {
      unsubscribe();
      detachLang();
    };
  });

  $$self.$$set = $$props => {
    if ("lines" in $$props) $$invalidate(0, lines = $$props.lines);
    if ("tokens" in $$props) $$invalidate(1, tokens = $$props.tokens);
    if ("store" in $$props) $$invalidate(6, store = $$props.store);
  };

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*lines, tokens*/
    3) {
      $: lines, tokens, $$invalidate(2, ignorePointer = false);
    }
  };

  return [lines, tokens, ignorePointer, $localize, closePopup, getProgressData, store];
}

class HaikuPopup extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      lines: 0,
      tokens: 1,
      store: 6
    });
  }

}

var _default = HaikuPopup;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","../util/tokens":"src/util/tokens.js","../components/ImageButton.svelte":"src/components/ImageButton.svelte.js","../components/AbsoluteOverlay.svelte":"src/components/AbsoluteOverlay.svelte.js","../components/HaikuInventory.svelte":"src/components/HaikuInventory.svelte.js","../tags":"src/tags/index.js","../assets/image/ui/ico_paperJournal1-rotated.png":"src/assets/image/ui/ico_paperJournal1-rotated.png","../components/GameProgress.svelte":"src/components/GameProgress.svelte.js","../util/locale":"src/util/locale.js","svelte":"node_modules/svelte/index.mjs","../animations/transitions":"src/animations/transitions.js","../alec-svelte":"src/alec-svelte/index.js","../components/HaikuCard.svelte":"src/components/HaikuCard.svelte.js","../config":"src/config.js"}],"src/overlays/SimpleHintOverlay.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _transition = require("svelte/transition");

var _svelte = require("svelte");

var _iconTouch = _interopRequireDefault(require("../assets/image/svg/icon-touch.svg"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* overlays/SimpleHintOverlay.svelte generated by Svelte v3.31.0 */
function create_fragment(ctx) {
  let div2;
  let div1;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let p;
  let div2_intro;
  let div2_outro;
  let current;
  return {
    c() {
      div2 = (0, _internal.element)("div");
      div1 = (0, _internal.element)("div");
      div0 = (0, _internal.element)("div");
      img = (0, _internal.element)("img");
      t0 = (0, _internal.space)();
      p = (0, _internal.element)("p");
      p.textContent = `${
      /*isMobile*/
      ctx[0] ? "tap + hold" : "click + hold"} to explore`;
      if (img.src !== (img_src_value = _iconTouch.default)) (0, _internal.attr)(img, "src", img_src_value);
      (0, _internal.attr)(img, "alt", "");
      (0, _internal.attr)(div0, "class", "image-container svelte-1rmuk9w");
      (0, _internal.attr)(p, "class", "svelte-1rmuk9w");
      (0, _internal.attr)(div1, "class", "info svelte-1rmuk9w");
      (0, _internal.attr)(div2, "class", "container svelte-1rmuk9w");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div2, anchor);
      (0, _internal.append)(div2, div1);
      (0, _internal.append)(div1, div0);
      (0, _internal.append)(div0, img);
      (0, _internal.append)(div1, t0);
      (0, _internal.append)(div1, p);
      current = true;
    },

    p: _internal.noop,

    i(local) {
      if (current) return;
      (0, _internal.add_render_callback)(() => {
        if (div2_outro) div2_outro.end(1);
        if (!div2_intro) div2_intro = (0, _internal.create_in_transition)(div2, _transition.fade, {
          delay: 1000,
          duration: 1500
        });
        div2_intro.start();
      });
      current = true;
    },

    o(local) {
      if (div2_intro) div2_intro.invalidate();
      div2_outro = (0, _internal.create_out_transition)(div2, _transition.fade, {
        duration: 800
      });
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div2);
      if (detaching && div2_outro) div2_outro.end();
    }

  };
}

function instance($$self) {
  const isMobile = /(Android|iOS|iPad|iPod|iPhone)/i.test(navigator.userAgent);
  return [isMobile];
}

class SimpleHintOverlay extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {});
  }

}

var _default = SimpleHintOverlay;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","svelte/transition":"node_modules/svelte/transition/index.mjs","svelte":"node_modules/svelte/index.mjs","../assets/image/svg/icon-touch.svg":"src/assets/image/svg/icon-touch.svg"}],"src/components/TokenInventorySlot.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _tokens = require("../util/tokens");

var _easing = require("svelte/easing");

var _Image = _interopRequireDefault(require("./Image.svelte"));

var _Assets = _interopRequireDefault(require("../util/Assets"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* components/TokenInventorySlot.svelte generated by Svelte v3.31.0 */
function create_if_block_1(ctx) {
  let div;
  let image;
  let div_transition;
  let current;
  image = new _Image.default({
    props: {
      id: emptyToken
    }
  });
  return {
    c() {
      div = (0, _internal.element)("div");
      (0, _internal.create_component)(image.$$.fragment);
      (0, _internal.attr)(div, "class", "img-container svelte-1xnqt9x");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.mount_component)(image, div, null);
      current = true;
    },

    p: _internal.noop,

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(image.$$.fragment, local);
      (0, _internal.add_render_callback)(() => {
        if (!div_transition) div_transition = (0, _internal.create_bidirectional_transition)(div,
        /*transition*/
        ctx[2], {}, true);
        div_transition.run(1);
      });
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(image.$$.fragment, local);
      if (!div_transition) div_transition = (0, _internal.create_bidirectional_transition)(div,
      /*transition*/
      ctx[2], {}, false);
      div_transition.run(0);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      (0, _internal.destroy_component)(image);
      if (detaching && div_transition) div_transition.end();
    }

  };
} // (66:4) {#if collected}


function create_if_block(ctx) {
  let div;
  let img;
  let img_src_value;
  let div_transition;
  let current;
  return {
    c() {
      div = (0, _internal.element)("div");
      img = (0, _internal.element)("img");
      if (img.src !== (img_src_value =
      /*src*/
      ctx[0])) (0, _internal.attr)(img, "src", img_src_value);
      (0, _internal.attr)(img, "alt", "");
      (0, _internal.attr)(img, "class", "svelte-1xnqt9x");
      (0, _internal.attr)(div, "class", "img-container svelte-1xnqt9x");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.append)(div, img);
      current = true;
    },

    p(ctx, dirty) {
      if (!current || dirty &
      /*src*/
      1 && img.src !== (img_src_value =
      /*src*/
      ctx[0])) {
        (0, _internal.attr)(img, "src", img_src_value);
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.add_render_callback)(() => {
        if (!div_transition) div_transition = (0, _internal.create_bidirectional_transition)(div,
        /*transition*/
        ctx[2], {}, true);
        div_transition.run(1);
      });
      current = true;
    },

    o(local) {
      if (!div_transition) div_transition = (0, _internal.create_bidirectional_transition)(div,
      /*transition*/
      ctx[2], {}, false);
      div_transition.run(0);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      if (detaching && div_transition) div_transition.end();
    }

  };
}

function create_fragment(ctx) {
  let div2;
  let div0;
  let t;
  let div1;
  let current;
  let if_block0 = !
  /*collected*/
  ctx[1] && create_if_block_1(ctx);
  let if_block1 =
  /*collected*/
  ctx[1] && create_if_block(ctx);
  return {
    c() {
      div2 = (0, _internal.element)("div");
      div0 = (0, _internal.element)("div");
      if (if_block0) if_block0.c();
      t = (0, _internal.space)();
      div1 = (0, _internal.element)("div");
      if (if_block1) if_block1.c();
      (0, _internal.attr)(div0, "class", "outline svelte-1xnqt9x");
      (0, _internal.attr)(div1, "class", "content svelte-1xnqt9x");
      (0, _internal.attr)(div2, "class", "container svelte-1xnqt9x");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div2, anchor);
      (0, _internal.append)(div2, div0);
      if (if_block0) if_block0.m(div0, null);
      (0, _internal.append)(div2, t);
      (0, _internal.append)(div2, div1);
      if (if_block1) if_block1.m(div1, null);
      current = true;
    },

    p(ctx, [dirty]) {
      if (!
      /*collected*/
      ctx[1]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);

          if (dirty &
          /*collected*/
          2) {
            (0, _internal.transition_in)(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx);
          if_block0.c();
          (0, _internal.transition_in)(if_block0, 1);
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        (0, _internal.check_outros)();
      }

      if (
      /*collected*/
      ctx[1]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);

          if (dirty &
          /*collected*/
          2) {
            (0, _internal.transition_in)(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block(ctx);
          if_block1.c();
          (0, _internal.transition_in)(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        (0, _internal.check_outros)();
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(if_block0);
      (0, _internal.transition_in)(if_block1);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(if_block0);
      (0, _internal.transition_out)(if_block1);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div2);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
    }

  };
}

const emptyToken = "image/ui/ico_emptytoken";

function fadeScale(node, {
  delay = 0,
  duration = 200,
  easing = x => x,
  baseScale = 0
}) {
  const o = +getComputedStyle(node).opacity;
  const m = getComputedStyle(node).transform.match(/scale\(([0-9.]+)\)/);
  const s = m ? m[1] : 1;
  const is = 1 - baseScale;
  return {
    delay,
    duration,
    css: t => {
      const eased = easing(t);
      return `opacity: ${eased * o}; transform: scale(${eased * s * is + baseScale})`;
    }
  };
}

function instance($$self, $$props, $$invalidate) {
  _Assets.default.prepare(emptyToken);

  let {
    src = null
  } = $$props;
  let {
    collected = false
  } = $$props;
  let outlineIcon, tokenIcon;

  function setToken(icon) {
    $$invalidate(0, src = icon ? _tokens.CollectedTokenURLs[icon] : null);
    $$invalidate(1, collected = Boolean(icon && src));
  }

  const transition = (node, opts) => {
    return fadeScale(node, {
      delay: 0,
      duration: 1000,
      easing: _easing.cubicInOut,
      baseScale: 0.5,
      ...opts
    });
  };

  $$self.$$set = $$props => {
    if ("src" in $$props) $$invalidate(0, src = $$props.src);
    if ("collected" in $$props) $$invalidate(1, collected = $$props.collected);
  };

  return [src, collected, transition, setToken];
}

class TokenInventorySlot extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      src: 0,
      collected: 1,
      setToken: 3
    });
  }

  get setToken() {
    return this.$$.ctx[3];
  }

}

var _default = TokenInventorySlot;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","../util/tokens":"src/util/tokens.js","svelte/easing":"node_modules/svelte/easing/index.mjs","./Image.svelte":"src/components/Image.svelte.js","../util/Assets":"src/util/Assets.js"}],"src/components/TokenInventory.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _TokenInventorySlot = _interopRequireDefault(require("./TokenInventorySlot.svelte"));

var _svelte = require("svelte");

var _transitions = require("../animations/transitions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* components/TokenInventory.svelte generated by Svelte v3.31.0 */
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  child_ctx[4] = list;
  child_ctx[5] = i;
  return child_ctx;
} // (24:4) {#each elements as element, i}


function create_each_block(ctx) {
  let tokeninventoryslot;
  let i =
  /*i*/
  ctx[5];
  let current;

  const assign_tokeninventoryslot = () =>
  /*tokeninventoryslot_binding*/
  ctx[2](tokeninventoryslot, i);

  const unassign_tokeninventoryslot = () =>
  /*tokeninventoryslot_binding*/
  ctx[2](null, i);

  let tokeninventoryslot_props = {};
  tokeninventoryslot = new _TokenInventorySlot.default({
    props: tokeninventoryslot_props
  });
  assign_tokeninventoryslot();
  return {
    c() {
      (0, _internal.create_component)(tokeninventoryslot.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(tokeninventoryslot, target, anchor);
      current = true;
    },

    p(ctx, dirty) {
      if (i !==
      /*i*/
      ctx[5]) {
        unassign_tokeninventoryslot();
        i =
        /*i*/
        ctx[5];
        assign_tokeninventoryslot();
      }

      const tokeninventoryslot_changes = {};
      tokeninventoryslot.$set(tokeninventoryslot_changes);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(tokeninventoryslot.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(tokeninventoryslot.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      unassign_tokeninventoryslot();
      (0, _internal.destroy_component)(tokeninventoryslot, detaching);
    }

  };
}

function create_fragment(ctx) {
  let div1;
  let div0;
  let current;
  let each_value =
  /*elements*/
  ctx[0];
  let each_blocks = [];

  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }

  const out = i => (0, _internal.transition_out)(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });

  return {
    c() {
      div1 = (0, _internal.element)("div");
      div0 = (0, _internal.element)("div");

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }

      (0, _internal.attr)(div0, "class", "row svelte-l0oa72");
      (0, _internal.attr)(div1, "class", "container svelte-l0oa72");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div1, anchor);
      (0, _internal.append)(div1, div0);

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div0, null);
      }

      current = true;
    },

    p(ctx, [dirty]) {
      if (dirty &
      /*elements*/
      1) {
        each_value =
        /*elements*/
        ctx[0];
        let i;

        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx, each_value, i);

          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            (0, _internal.transition_in)(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            (0, _internal.transition_in)(each_blocks[i], 1);
            each_blocks[i].m(div0, null);
          }
        }

        (0, _internal.group_outros)();

        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }

        (0, _internal.check_outros)();
      }
    },

    i(local) {
      if (current) return;

      for (let i = 0; i < each_value.length; i += 1) {
        (0, _internal.transition_in)(each_blocks[i]);
      }

      current = true;
    },

    o(local) {
      each_blocks = each_blocks.filter(Boolean);

      for (let i = 0; i < each_blocks.length; i += 1) {
        (0, _internal.transition_out)(each_blocks[i]);
      }

      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div1);
      (0, _internal.destroy_each)(each_blocks, detaching);
    }

  };
}

function instance($$self, $$props, $$invalidate) {
  let {
    store
  } = $$props;
  let elements = new Array(3).fill(null);
  (0, _svelte.onMount)(() => {
    const unmount = store.subscribe(v => {
      const tokens = v.tokensCollected || [];

      for (let i = 0; i < elements.length; i++) {
        elements[i].setToken(tokens[i]);
      }
    });
    return () => {
      unmount();
    };
  });

  function tokeninventoryslot_binding($$value, i) {
    _internal.binding_callbacks[$$value ? "unshift" : "push"](() => {
      elements[i] = $$value;
      $$invalidate(0, elements);
    });
  }

  $$self.$$set = $$props => {
    if ("store" in $$props) $$invalidate(1, store = $$props.store);
  };

  return [elements, store, tokeninventoryslot_binding];
}

class TokenInventory extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      store: 1
    });
  }

}

var _default = TokenInventory;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","./TokenInventorySlot.svelte":"src/components/TokenInventorySlot.svelte.js","svelte":"node_modules/svelte/index.mjs","../animations/transitions":"src/animations/transitions.js"}],"src/overlays/GameHUD.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _HaikuInventory = _interopRequireDefault(require("../components/HaikuInventory.svelte"));

var _TokenInventory = _interopRequireDefault(require("../components/TokenInventory.svelte"));

var _svelte = require("svelte");

var _CornerMenuButton = _interopRequireDefault(require("../components/CornerMenuButton.svelte"));

var _Assets = _interopRequireDefault(require("../util/Assets"));

var _alecSvelte = require("../alec-svelte");

var Tags = _interopRequireWildcard(require("../tags"));

var _nfb = require("../nfb");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* overlays/GameHUD.svelte generated by Svelte v3.31.0 */
function create_if_block_3(ctx) {
  let cornermenubutton;
  let current;
  cornermenubutton = new _CornerMenuButton.default({
    props: {
      style: "top: 8px; left: 6px",
      image:
      /*pausePromise*/
      ctx[5]
    }
  });
  cornermenubutton.$on("click",
  /*click_handler*/
  ctx[14]);
  return {
    c() {
      (0, _internal.create_component)(cornermenubutton.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(cornermenubutton, target, anchor);
      current = true;
    },

    p: _internal.noop,

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(cornermenubutton.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(cornermenubutton.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(cornermenubutton, detaching);
    }

  };
} // (93:0) {#if canCollectTokens}


function create_if_block_2(ctx) {
  let tokeninventory;
  let t;
  let cornermenubutton;
  let current;
  tokeninventory = new _TokenInventory.default({
    props: {
      store:
      /*store*/
      ctx[0]
    }
  });
  cornermenubutton = new _CornerMenuButton.default({
    props: {
      size: "large",
      style: "top: 7px; right: 7px",
      image:
      /*compassPromise*/
      ctx[7]
    }
  });
  cornermenubutton.$on("click",
  /*click_handler_1*/
  ctx[15]);
  return {
    c() {
      (0, _internal.create_component)(tokeninventory.$$.fragment);
      t = (0, _internal.space)();
      (0, _internal.create_component)(cornermenubutton.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(tokeninventory, target, anchor);
      (0, _internal.insert)(target, t, anchor);
      (0, _internal.mount_component)(cornermenubutton, target, anchor);
      current = true;
    },

    p(ctx, dirty) {
      const tokeninventory_changes = {};
      if (dirty &
      /*store*/
      1) tokeninventory_changes.store =
      /*store*/
      ctx[0];
      tokeninventory.$set(tokeninventory_changes);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(tokeninventory.$$.fragment, local);
      (0, _internal.transition_in)(cornermenubutton.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(tokeninventory.$$.fragment, local);
      (0, _internal.transition_out)(cornermenubutton.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(tokeninventory, detaching);
      if (detaching) (0, _internal.detach)(t);
      (0, _internal.destroy_component)(cornermenubutton, detaching);
    }

  };
} // (105:0) {#if currentHaikuCount > 0 && !currentHaiku}


function create_if_block(ctx) {
  let t;
  let cornermenubutton;
  let current;
  let if_block =
  /*canCollectTokens*/
  ctx[1] && create_if_block_1(ctx);
  let cornermenubutton_props = {
    image:
    /*journalPromise*/
    ctx[6],
    style: "bottom: 12px; right: 10px",
    id: JOURNAL_ID
  };
  cornermenubutton = new _CornerMenuButton.default({
    props: cornermenubutton_props
  });
  /*cornermenubutton_binding*/

  ctx[17](cornermenubutton);
  cornermenubutton.$on("click",
  /*click_handler_2*/
  ctx[18]);
  return {
    c() {
      if (if_block) if_block.c();
      t = (0, _internal.space)();
      (0, _internal.create_component)(cornermenubutton.$$.fragment);
    },

    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      (0, _internal.insert)(target, t, anchor);
      (0, _internal.mount_component)(cornermenubutton, target, anchor);
      current = true;
    },

    p(ctx, dirty) {
      if (
      /*canCollectTokens*/
      ctx[1]) {
        if (if_block) {
          if_block.p(ctx, dirty);

          if (dirty &
          /*canCollectTokens*/
          2) {
            (0, _internal.transition_in)(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx);
          if_block.c();
          (0, _internal.transition_in)(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_block, 1, 1, () => {
          if_block = null;
        });
        (0, _internal.check_outros)();
      }

      const cornermenubutton_changes = {};
      cornermenubutton.$set(cornermenubutton_changes);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(if_block);
      (0, _internal.transition_in)(cornermenubutton.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(if_block);
      (0, _internal.transition_out)(cornermenubutton.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      if (if_block) if_block.d(detaching);
      if (detaching) (0, _internal.detach)(t);
      /*cornermenubutton_binding*/

      ctx[17](null);
      (0, _internal.destroy_component)(cornermenubutton, detaching);
    }

  };
} // (106:2) {#if canCollectTokens}


function create_if_block_1(ctx) {
  let haikuinventory;
  let current;
  haikuinventory = new _HaikuInventory.default({
    props: {
      store:
      /*store*/
      ctx[0]
    }
  });
  haikuinventory.$on("journal",
  /*journal_handler*/
  ctx[16]);
  return {
    c() {
      (0, _internal.create_component)(haikuinventory.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(haikuinventory, target, anchor);
      current = true;
    },

    p(ctx, dirty) {
      const haikuinventory_changes = {};
      if (dirty &
      /*store*/
      1) haikuinventory_changes.store =
      /*store*/
      ctx[0];
      haikuinventory.$set(haikuinventory_changes);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(haikuinventory.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(haikuinventory.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(haikuinventory, detaching);
    }

  };
}

function create_fragment(ctx) {
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = !
  /*currentHaiku*/
  ctx[2] && create_if_block_3(ctx);
  let if_block1 =
  /*canCollectTokens*/
  ctx[1] && create_if_block_2(ctx);
  let if_block2 =
  /*currentHaikuCount*/
  ctx[3] > 0 && !
  /*currentHaiku*/
  ctx[2] && create_if_block(ctx);
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = (0, _internal.space)();
      if (if_block1) if_block1.c();
      t1 = (0, _internal.space)();
      if (if_block2) if_block2.c();
      if_block2_anchor = (0, _internal.empty)();
    },

    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      (0, _internal.insert)(target, t0, anchor);
      if (if_block1) if_block1.m(target, anchor);
      (0, _internal.insert)(target, t1, anchor);
      if (if_block2) if_block2.m(target, anchor);
      (0, _internal.insert)(target, if_block2_anchor, anchor);
      current = true;
    },

    p(ctx, [dirty]) {
      if (!
      /*currentHaiku*/
      ctx[2]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);

          if (dirty &
          /*currentHaiku*/
          4) {
            (0, _internal.transition_in)(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx);
          if_block0.c();
          (0, _internal.transition_in)(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        (0, _internal.check_outros)();
      }

      if (
      /*canCollectTokens*/
      ctx[1]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);

          if (dirty &
          /*canCollectTokens*/
          2) {
            (0, _internal.transition_in)(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2(ctx);
          if_block1.c();
          (0, _internal.transition_in)(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        (0, _internal.check_outros)();
      }

      if (
      /*currentHaikuCount*/
      ctx[3] > 0 && !
      /*currentHaiku*/
      ctx[2]) {
        if (if_block2) {
          if_block2.p(ctx, dirty);

          if (dirty &
          /*currentHaikuCount, currentHaiku*/
          12) {
            (0, _internal.transition_in)(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block(ctx);
          if_block2.c();
          (0, _internal.transition_in)(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        (0, _internal.check_outros)();
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(if_block0);
      (0, _internal.transition_in)(if_block1);
      (0, _internal.transition_in)(if_block2);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(if_block0);
      (0, _internal.transition_out)(if_block1);
      (0, _internal.transition_out)(if_block2);
      current = false;
    },

    d(detaching) {
      if (if_block0) if_block0.d(detaching);
      if (detaching) (0, _internal.detach)(t0);
      if (if_block1) if_block1.d(detaching);
      if (detaching) (0, _internal.detach)(t1);
      if (if_block2) if_block2.d(detaching);
      if (detaching) (0, _internal.detach)(if_block2_anchor);
    }

  };
}

const PAUSE_ID = "image/ui/btn_pause";
const JOURNAL_ID = "image/ui/ico_journal";
const COMPASS_ID = "image/ui/compass3";

function instance($$self, $$props, $$invalidate) {
  _Assets.default.prepare([PAUSE_ID, JOURNAL_ID, COMPASS_ID]);

  const pausePromise = _Assets.default.load(PAUSE_ID);

  const journalPromise = _Assets.default.load(JOURNAL_ID);

  const compassPromise = _Assets.default.load(COMPASS_ID);

  const dispatch = (0, _svelte.createEventDispatcher)();
  const {
    world
  } = (0, _alecSvelte.context)();
  const entity = world.entity();
  let {
    store
  } = $$props;
  let {
    moving = false
  } = $$props;
  let {
    canCollectTokens = false
  } = $$props;
  let {
    finishedHaikus = []
  } = $$props;
  let {
    currentHaiku = false
  } = $$props;
  let currentHaikuCount = 0;
  let journalButton;

  const onNotifyHaiku = () => {
    if (journalButton) journalButton.notify();
  };

  store.update(d => ({ ...d,
    onNotifyHaiku
  }));
  (0, _svelte.onMount)(() => {
    const unsub = store.subscribe(v => {
      $$invalidate(3, currentHaikuCount = v.finishedHaikus.length);
    });
    return () => {
      unsub();
    };
  });

  function handleCompass(ev) {
    ev.preventDefault();
    ev.stopPropagation();
    ev.stopImmediatePropagation();
    const pos = world.findTag(Tags.UserTarget).position;
    entity.tagOn(Tags.CompassVisible); // entity.tagOn(Tags.CameraZoomOut);

    const vis = entity.get(Tags.CompassVisible);
    vis.position.copy(pos);
    (0, _nfb.sendAnalytics)({
      event: "compass_open",
      eventLabel: "compass_open"
    });
  }

  const click_handler = ev => {
    if (world.findTag(Tags.ShowBiomeResolution) || world.findTag(Tags.TransitionToNextBiome)) {
      return;
    }

    ev.preventDefault();
    ev.stopImmediatePropagation();
    entity.tagOff(Tags.ButtonClick);
    entity.tagOn(Tags.ButtonClick);
    dispatch("pause");
    (0, _nfb.sendAnalytics)({
      event: "menu_open",
      eventLabel: "menu_open"
    });
  };

  const click_handler_1 = ev => {
    handleCompass(ev);
  };

  function journal_handler(event) {
    (0, _internal.bubble)($$self, event);
  }

  function cornermenubutton_binding($$value) {
    _internal.binding_callbacks[$$value ? "unshift" : "push"](() => {
      journalButton = $$value;
      $$invalidate(4, journalButton);
    });
  }

  const click_handler_2 = ev => {
    if (world.findTag(Tags.ShowBiomeResolution) || world.findTag(Tags.TransitionToNextBiome)) {
      return;
    }

    dispatch("journal");
    (0, _nfb.sendAnalytics)({
      event: "journal_open",
      eventLabel: "journal_open"
    });
  };

  $$self.$$set = $$props => {
    if ("store" in $$props) $$invalidate(0, store = $$props.store);
    if ("moving" in $$props) $$invalidate(12, moving = $$props.moving);
    if ("canCollectTokens" in $$props) $$invalidate(1, canCollectTokens = $$props.canCollectTokens);
    if ("finishedHaikus" in $$props) $$invalidate(13, finishedHaikus = $$props.finishedHaikus);
    if ("currentHaiku" in $$props) $$invalidate(2, currentHaiku = $$props.currentHaiku);
  };

  return [store, canCollectTokens, currentHaiku, currentHaikuCount, journalButton, pausePromise, journalPromise, compassPromise, dispatch, world, entity, handleCompass, moving, finishedHaikus, click_handler, click_handler_1, journal_handler, cornermenubutton_binding, click_handler_2];
}

class GameHUD extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      store: 0,
      moving: 12,
      canCollectTokens: 1,
      finishedHaikus: 13,
      currentHaiku: 2
    });
  }

}

var _default = GameHUD;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","../components/HaikuInventory.svelte":"src/components/HaikuInventory.svelte.js","../components/TokenInventory.svelte":"src/components/TokenInventory.svelte.js","svelte":"node_modules/svelte/index.mjs","../components/CornerMenuButton.svelte":"src/components/CornerMenuButton.svelte.js","../util/Assets":"src/util/Assets.js","../alec-svelte":"src/alec-svelte/index.js","../tags":"src/tags/index.js","../nfb":"src/nfb.js"}],"src/assets/video/transition.mp4":[function(require,module,exports) {
module.exports = "/transition.5a268ddd.mp4";
},{}],"src/util/objectFit.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = objectFit;

function objectFit({
  parentWidth,
  parentHeight,
  childWidth,
  childHeight,
  fit = "contain",
  scale = 1,
  offsetX = 0.5,
  offsetY = 0.5
}) {
  const childRatio = childWidth / childHeight;
  const parentRatio = parentWidth / parentHeight;
  let w = childWidth * scale;
  let h = childHeight * scale;
  let x = 0;
  let y = 0;

  if (fit === "scale-down") {
    const ratio = Math.min(parentWidth / childWidth, parentHeight / childHeight);
    w = childWidth * scale * ratio;
    h = childHeight * scale * ratio;
  } else if (fit === "contain" || fit === "cover") {
    w = parentWidth * scale;
    h = parentHeight * scale;
    const contains = fit === "contain";
    const useWidth = contains ? childRatio > parentRatio : childRatio < parentRatio;

    if (useWidth) {
      h = w / childRatio;
    } else {
      w = h * childRatio;
    }
  } else if (fit === "fill") {
    w = parentWidth * scale;
    h = parentHeight * scale;
  }

  x = (parentWidth - w) * offsetX;
  y = (parentHeight - h) * offsetY;
  return [x, y, w, h];
}
},{}],"src/components/LeafVideo.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _svelte = require("svelte");

var _transition = _interopRequireDefault(require("../assets/video/transition.mp4"));

var _transitions = require("../animations/transitions");

var _objectFit = _interopRequireDefault(require("../util/objectFit"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* components/LeafVideo.svelte generated by Svelte v3.31.0 */
const {
  window: window_1
} = _internal.globals;

function create_fragment(ctx) {
  let div;
  let video_1;
  let video_1_src_value;
  let video_1_intro;
  let video_1_outro;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      div = (0, _internal.element)("div");
      video_1 = (0, _internal.element)("video");
      (0, _internal.attr)(video_1, "class", "leaf-video svelte-fpz107");
      video_1.autoplay = true;
      video_1.muted = true;
      video_1.playsInline = true;
      if (video_1.src !== (video_1_src_value = _transition.default)) (0, _internal.attr)(video_1, "src", video_1_src_value);
      (0, _internal.attr)(div, "class", "leaf-video-container svelte-fpz107");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.append)(div, video_1);
      /*video_1_binding*/

      ctx[4](video_1);
      current = true;

      if (!mounted) {
        dispose = (0, _internal.listen)(window_1, "resize",
        /*onScreenResize*/
        ctx[3], {
          passive: true
        });
        mounted = true;
      }
    },

    p(new_ctx, [dirty]) {
      ctx = new_ctx;
    },

    i(local) {
      if (current) return;
      (0, _internal.add_render_callback)(() => {
        if (video_1_outro) video_1_outro.end(1);
        if (!video_1_intro) video_1_intro = (0, _internal.create_in_transition)(video_1, _transitions.fadeInTransition, {
          delay: 0,
          y: 0,
          ...
          /*fadeInOptions*/
          ctx[0]
        });
        video_1_intro.start();
      });
      current = true;
    },

    o(local) {
      if (video_1_intro) video_1_intro.invalidate();
      video_1_outro = (0, _internal.create_out_transition)(video_1, _transitions.fadeInTransition, {
        y: 0,
        ...
        /*fadeOutOptions*/
        ctx[1]
      });
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      /*video_1_binding*/

      ctx[4](null);
      if (detaching && video_1_outro) video_1_outro.end();
      mounted = false;
      dispose();
    }

  };
}

function instance($$self, $$props, $$invalidate) {
  let {
    fadeInOptions = {}
  } = $$props;
  let {
    fadeOutOptions = {}
  } = $$props;
  let video; // let x, y, width, height;

  let metadataCB;
  let metadata = new Promise(resolve => {
    metadataCB = resolve;
  });
  (0, _svelte.onMount)(() => {
    let detach = () => {};

    if (video.readyState <= 0) {
      video.addEventListener("loadedmetadata", metadataCB);

      detach = () => video.removeEventListener("loadedmetadata", metadataCB);
    } else {
      metadataCB();
    }

    onScreenResize();
    $$invalidate(2, video.muted = true, video);
    video.play();
    return () => {
      if (video) {
        video.pause();
      }

      detach();
    };
  });

  function onScreenResize() {
    if (!video) return;

    if (video.readyState <= 0) {
      metadata.then(() => resizeVideo());
    } else {
      resizeVideo();
    }
  }

  function resizeVideo() {
    if (video) {
      const aspect = window.innerWidth / window.innerHeight;
      const [tx, ty, sw, sh] = (0, _objectFit.default)({
        parentWidth: window.innerWidth,
        parentHeight: window.innerHeight,
        childWidth: video.videoWidth,
        childHeight: video.videoHeight,
        fit: window.innerWidth < window.innerHeight ? "cover" : "contain"
      }); // y = ty;
      // x = tx;
      // width = sw;
      // height = sh;

      Object.assign(video.style, {
        left: `${tx}px`,
        top: `${ty}px`,
        width: `${sw}px`,
        height: `${sh}px`
      });
      const fontHeight = 32;
    } // textYPosition = window.innerHeight * 0.895;

  }

  function video_1_binding($$value) {
    _internal.binding_callbacks[$$value ? "unshift" : "push"](() => {
      video = $$value;
      $$invalidate(2, video);
    });
  }

  $$self.$$set = $$props => {
    if ("fadeInOptions" in $$props) $$invalidate(0, fadeInOptions = $$props.fadeInOptions);
    if ("fadeOutOptions" in $$props) $$invalidate(1, fadeOutOptions = $$props.fadeOutOptions);
  };

  return [fadeInOptions, fadeOutOptions, video, onScreenResize, video_1_binding];
}

class LeafVideo extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      fadeInOptions: 0,
      fadeOutOptions: 1
    });
  }

}

var _default = LeafVideo;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","svelte":"node_modules/svelte/index.mjs","../assets/video/transition.mp4":"src/assets/video/transition.mp4","../animations/transitions":"src/animations/transitions.js","../util/objectFit":"src/util/objectFit.js"}],"src/overlays/GameUIIntro.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _svelte = require("svelte");

var _transitions = require("../animations/transitions");

var _locale = require("../util/locale");

var _Image = _interopRequireDefault(require("../components/Image.svelte"));

var _LeafVideo = _interopRequireDefault(require("../components/LeafVideo.svelte"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* overlays/GameUIIntro.svelte generated by Svelte v3.31.0 */
function create_if_block_1(ctx) {
  let leafvideo;
  let current;
  leafvideo = new _LeafVideo.default({
    props: {
      fadeInOptions: {
        delay: 0,
        duration: 2000
      },
      fadeOutOptions: {
        delay: 2000,
        duration: 500
      }
    }
  });
  return {
    c() {
      (0, _internal.create_component)(leafvideo.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(leafvideo, target, anchor);
      current = true;
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(leafvideo.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(leafvideo.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(leafvideo, detaching);
    }

  };
} // (37:2) {#if showLogo}


function create_if_block(ctx) {
  let image;
  let t0;
  let div;
  let t1_value =
  /*$localize*/
  ctx[2].introPresents + "";
  let t1;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  image = new _Image.default({
    props: {
      inTransition: (0, _transitions.transition)(_transitions.fadeInTransition, {
        duration: 1500
      }),
      outTransition: (0, _transitions.transition)(_transitions.fadeOutTransition, {
        delay: 2000
      }),
      width: "150px",
      id: "image/svg/nfblogo"
    }
  });
  image.$on("introend",
  /*introend_handler*/
  ctx[4]);
  image.$on("outroend",
  /*outroend_handler*/
  ctx[5]);
  image.$on("outrostart",
  /*outrostart_handler*/
  ctx[6]);
  return {
    c() {
      (0, _internal.create_component)(image.$$.fragment);
      t0 = (0, _internal.space)();
      div = (0, _internal.element)("div");
      t1 = (0, _internal.text)(t1_value);
      (0, _internal.attr)(div, "class", "presented svelte-1th3gw3");
    },

    m(target, anchor) {
      (0, _internal.mount_component)(image, target, anchor);
      (0, _internal.insert)(target, t0, anchor);
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.append)(div, t1);
      current = true;

      if (!mounted) {
        dispose = (0, _internal.listen)(div, "introend",
        /*introend_handler_1*/
        ctx[7]);
        mounted = true;
      }
    },

    p(ctx, dirty) {
      if ((!current || dirty &
      /*$localize*/
      4) && t1_value !== (t1_value =
      /*$localize*/
      ctx[2].introPresents + "")) (0, _internal.set_data)(t1, t1_value);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(image.$$.fragment, local);
      (0, _internal.add_render_callback)(() => {
        if (div_outro) div_outro.end(1);
        if (!div_intro) div_intro = (0, _internal.create_in_transition)(div, _transitions.fadeInTransition, {
          delay: 500,
          duration: 1250
        });
        div_intro.start();
      });
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(image.$$.fragment, local);
      if (div_intro) div_intro.invalidate();
      div_outro = (0, _internal.create_out_transition)(div, _transitions.fadeOutTransition, {
        delay: 1750
      });
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(image, detaching);
      if (detaching) (0, _internal.detach)(t0);
      if (detaching) (0, _internal.detach)(div);
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      dispose();
    }

  };
}

function create_fragment(ctx) {
  let main;
  let t;
  let current;
  let if_block0 =
  /*showVideo*/
  ctx[1] && create_if_block_1(ctx);
  let if_block1 =
  /*showLogo*/
  ctx[0] && create_if_block(ctx);
  return {
    c() {
      main = (0, _internal.element)("main");
      if (if_block0) if_block0.c();
      t = (0, _internal.space)();
      if (if_block1) if_block1.c();
      (0, _internal.attr)(main, "class", "svelte-1th3gw3");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, main, anchor);
      if (if_block0) if_block0.m(main, null);
      (0, _internal.append)(main, t);
      if (if_block1) if_block1.m(main, null);
      current = true;
    },

    p(ctx, [dirty]) {
      if (
      /*showVideo*/
      ctx[1]) {
        if (if_block0) {
          if (dirty &
          /*showVideo*/
          2) {
            (0, _internal.transition_in)(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx);
          if_block0.c();
          (0, _internal.transition_in)(if_block0, 1);
          if_block0.m(main, t);
        }
      } else if (if_block0) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        (0, _internal.check_outros)();
      }

      if (
      /*showLogo*/
      ctx[0]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);

          if (dirty &
          /*showLogo*/
          1) {
            (0, _internal.transition_in)(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block(ctx);
          if_block1.c();
          (0, _internal.transition_in)(if_block1, 1);
          if_block1.m(main, null);
        }
      } else if (if_block1) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        (0, _internal.check_outros)();
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(if_block0);
      (0, _internal.transition_in)(if_block1);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(if_block0);
      (0, _internal.transition_out)(if_block1);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(main);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
    }

  };
}

function instance($$self, $$props, $$invalidate) {
  let $localize;
  (0, _internal.component_subscribe)($$self, _locale.localize, $$value => $$invalidate(2, $localize = $$value));
  const dispatcher = (0, _svelte.createEventDispatcher)();
  let showLogo = true;
  let showVideo = true;
  (0, _svelte.onMount)(() => {
    return () => {};
  });

  const introend_handler = () => {
    $$invalidate(0, showLogo = false);
  };

  const outroend_handler = () => {
    dispatcher("end");
  };

  const outrostart_handler = () => {
    $$invalidate(1, showVideo = false);
  };

  const introend_handler_1 = () => {
    dispatcher("inbetween");
  };

  return [showLogo, showVideo, $localize, dispatcher, introend_handler, outroend_handler, outrostart_handler, introend_handler_1];
}

class GameUIIntro extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {});
  }

}

var _default = GameUIIntro;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","svelte":"node_modules/svelte/index.mjs","../animations/transitions":"src/animations/transitions.js","../util/locale":"src/util/locale.js","../components/Image.svelte":"src/components/Image.svelte.js","../components/LeafVideo.svelte":"src/components/LeafVideo.svelte.js"}],"src/components/AnimatedTextSpan.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _transitions = require("../animations/transitions");

var _svelte = require("svelte");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* components/AnimatedTextSpan.svelte generated by Svelte v3.31.0 */
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i];
  return child_ctx;
} // (101:2) {#each children as node}


function create_each_block(ctx) {
  let span;
  let t_value =
  /*node*/
  ctx[10].value + "";
  let t;
  let span_style_value;
  let span_transition;
  let current;
  return {
    c() {
      span = (0, _internal.element)("span");
      t = (0, _internal.text)(t_value);
      (0, _internal.attr)(span, "style", span_style_value = `min-width: ${
      /*node*/
      ctx[10].whitespace ? spaceWidth : 0}px;`);
      (0, _internal.attr)(span, "class", "text-node svelte-niwj3w");
      (0, _internal.toggle_class)(span, "whitespace",
      /*node*/
      ctx[10].whitespace);
    },

    m(target, anchor) {
      (0, _internal.insert)(target, span, anchor);
      (0, _internal.append)(span, t);
      current = true;
    },

    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty &
      /*children*/
      8) && t_value !== (t_value =
      /*node*/
      ctx[10].value + "")) (0, _internal.set_data)(t, t_value);

      if (!current || dirty &
      /*children*/
      8 && span_style_value !== (span_style_value = `min-width: ${
      /*node*/
      ctx[10].whitespace ? spaceWidth : 0}px;`)) {
        (0, _internal.attr)(span, "style", span_style_value);
      }

      if (dirty &
      /*children*/
      8) {
        (0, _internal.toggle_class)(span, "whitespace",
        /*node*/
        ctx[10].whitespace);
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.add_render_callback)(() => {
        if (!span_transition) span_transition = (0, _internal.create_bidirectional_transition)(span, _transitions.fadeTransition, { ...
          /*node*/
          ctx[10],
          delay:
          /*delay*/
          ctx[0] +
          /*node*/
          ctx[10].delay
        }, true);
        span_transition.run(1);
      });
      current = true;
    },

    o(local) {
      if (!span_transition) span_transition = (0, _internal.create_bidirectional_transition)(span, _transitions.fadeTransition, { ...
        /*node*/
        ctx[10],
        delay:
        /*delay*/
        ctx[0] +
        /*node*/
        ctx[10].delay
      }, false);
      span_transition.run(0);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(span);
      if (detaching && span_transition) span_transition.end();
    }

  };
}

function create_fragment(ctx) {
  let p;
  let p_transition;
  let current;
  let each_value =
  /*children*/
  ctx[3];
  let each_blocks = [];

  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }

  const out = i => (0, _internal.transition_out)(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });

  return {
    c() {
      p = (0, _internal.element)("p");

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }

      (0, _internal.set_style)(p, "letter-spacing", letterSpacing + "px");
      (0, _internal.set_style)(p, "font-size", fontSize + "px");
      (0, _internal.set_style)(p, "font-weight", fontWeight);
      (0, _internal.set_style)(p, "font-style", fontStyle);
      (0, _internal.attr)(p, "class", "svelte-niwj3w");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, p, anchor);

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(p, null);
      }

      current = true;
    },

    p(new_ctx, [dirty]) {
      ctx = new_ctx;

      if (dirty &
      /*children, spaceWidth, delay*/
      9) {
        each_value =
        /*children*/
        ctx[3];
        let i;

        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx, each_value, i);

          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            (0, _internal.transition_in)(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            (0, _internal.transition_in)(each_blocks[i], 1);
            each_blocks[i].m(p, null);
          }
        }

        (0, _internal.group_outros)();

        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }

        (0, _internal.check_outros)();
      }
    },

    i(local) {
      if (current) return;

      for (let i = 0; i < each_value.length; i += 1) {
        (0, _internal.transition_in)(each_blocks[i]);
      }

      (0, _internal.add_render_callback)(() => {
        if (!p_transition) p_transition = (0, _internal.create_bidirectional_transition)(p, _transitions.fadeTransition, {
          opacity: 1,
          y:
          /*y*/
          ctx[2],
          endX:
          /*x*/
          ctx[1],
          endY:
          /*y*/
          ctx[2]
        }, true);
        p_transition.run(1);
      });
      current = true;
    },

    o(local) {
      each_blocks = each_blocks.filter(Boolean);

      for (let i = 0; i < each_blocks.length; i += 1) {
        (0, _internal.transition_out)(each_blocks[i]);
      }

      if (!p_transition) p_transition = (0, _internal.create_bidirectional_transition)(p, _transitions.fadeTransition, {
        opacity: 1,
        y:
        /*y*/
        ctx[2],
        endX:
        /*x*/
        ctx[1],
        endY:
        /*y*/
        ctx[2]
      }, false);
      p_transition.run(0);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(p);
      (0, _internal.destroy_each)(each_blocks, detaching);
      if (detaching && p_transition) p_transition.end();
    }

  };
}

const random = (0, _Random.default)(); // we use inline style to conform to canvas text measuring
// and space character width

const fontSize = 18;
const letterSpacing = 0.5;
const fontStyle = "italic";
const fontWeight = 300;
const fontFamily = `"Enreal", sans-serif`;
const SPACE_WIDTH_DEFAULT = 5;
let spaceWidth = SPACE_WIDTH_DEFAULT;
document.fonts.ready.then(() => {
  computeSpaceWidth();
});

function computeSpaceWidth() {
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  context.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
  const w = context.measureText(" ").width;

  if (w != null && w > 0 && isFinite(w)) {
    spaceWidth = w + letterSpacing;
  }
}

function instance($$self, $$props, $$invalidate) {
  const dispatcher = (0, _svelte.createEventDispatcher)();
  let {
    text = ""
  } = $$props;
  let {
    delay = 0
  } = $$props;
  let {
    duration = null
  } = $$props;
  let {
    x = 0
  } = $$props;
  let {
    y = 0
  } = $$props;
  const tmpPos = [];
  let killTimer;
  let children = [];

  if (duration != null) {
    killTimer = setTimeout(() => {
      dispatcher("kill");
    }, duration);
  }

  (0, _svelte.onMount)(() => {
    return () => {
      clearTimeout(killTimer);
    };
  });

  function update(value = "") {
    const constantInDuration = 2000; // milliseconds

    const count = value.length;
    const delayStagger = constantInDuration / count;
    const jitter = 0.05;
    const jitterAngle = MathUtil.degToRad(0);
    return value.split("").map((n, i) => {
      const whitespace = /\s/.test(n); // const offset = 10;

      const [x, y] = random.insideCircle(10, tmpPos);
      return {
        value: whitespace ? " " : n,
        whitespace,
        angle: random.gaussian(0, MathUtil.degToRad(2)),
        delay: i * delayStagger + random.gaussian(0, 1),
        duration: random.range(1500, 2000),
        x,
        y
      }; // x: random.gaussian(0, offset),
      // y: random.gaussian(0, offset),
    }); // endX: random.gaussian(0, jitter) * 0.01,
    // endY: random.gaussian(0, jitter),
    // endAngle: random.gaussian(0, jitterAngle),
  }

  $$self.$$set = $$props => {
    if ("text" in $$props) $$invalidate(4, text = $$props.text);
    if ("delay" in $$props) $$invalidate(0, delay = $$props.delay);
    if ("duration" in $$props) $$invalidate(5, duration = $$props.duration);
    if ("x" in $$props) $$invalidate(1, x = $$props.x);
    if ("y" in $$props) $$invalidate(2, y = $$props.y);
  };

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*text*/
    16) {
      $: $$invalidate(3, children = update(text));
    }
  };

  return [delay, x, y, children, text, duration];
}

class AnimatedTextSpan extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      text: 4,
      delay: 0,
      duration: 5,
      x: 1,
      y: 2
    });
  }

}

var _default = AnimatedTextSpan;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","../util/math":"src/util/math.js","../util/Random":"src/util/Random.js","../animations/transitions":"src/animations/transitions.js","svelte":"node_modules/svelte/index.mjs"}],"src/overlays/TransitionOverlay.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _transition = require("svelte/transition");

var _svelte = require("svelte");

var _alecSvelte = require("../alec-svelte");

var Tags = _interopRequireWildcard(require("../tags"));

var _config = _interopRequireDefault(require("../config"));

var _AnimatedTextSpan = _interopRequireDefault(require("../components/AnimatedTextSpan.svelte"));

var _transitions = require("../animations/transitions");

var _LeafVideo = _interopRequireDefault(require("../components/LeafVideo.svelte"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* overlays/TransitionOverlay.svelte generated by Svelte v3.31.0 */
// import GameProgress from "../components/GameProgress.svelte";
// import videoSrc from "../assets/video/transition.mp4";
function create_fragment(ctx) {
  let div;
  let leafvideo;
  let div_intro;
  let div_outro;
  let current;
  leafvideo = new _LeafVideo.default({
    props: {
      fadeInOptions: {
        delay: 0,
        duration: 500
      },
      fadeOutOptions: {
        delay: 0,
        duration: 500
      }
    }
  });
  return {
    c() {
      div = (0, _internal.element)("div");
      (0, _internal.create_component)(leafvideo.$$.fragment);
      (0, _internal.attr)(div, "class", "container svelte-xjm3ff");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.mount_component)(leafvideo, div, null);
      current = true;
    },

    p: _internal.noop,

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(leafvideo.$$.fragment, local);
      (0, _internal.add_render_callback)(() => {
        if (div_outro) div_outro.end(1);
        if (!div_intro) div_intro = (0, _internal.create_in_transition)(div, _transitions.fadeInTransition, {
          y: 0,
          delay: 0,
          duration: 1000
        });
        div_intro.start();
      });
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(leafvideo.$$.fragment, local);
      if (div_intro) div_intro.invalidate();
      div_outro = (0, _internal.create_out_transition)(div, _transitions.fadeInTransition, {
        y: 0,
        delay: 0,
        duration: 1000
      });
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      (0, _internal.destroy_component)(leafvideo);
      if (detaching && div_outro) div_outro.end();
    }

  };
}

const delay = 0;

function instance($$self) {
  let swapWorldsTimeout; // let video;

  (0, _svelte.onMount)(() => {
    // video.play();
    return () => {}; // if (video) video.pause();
  });
  (0, _svelte.onMount)(() => {
    console.log("mount transition!");
    swapWorldsTimeout = setTimeout(() => {
      console.log("do world swap!");
      const e = world.findEntity(Tags.TransitionToNextBiome);

      if (e && !(0, _config.default)().demo) {
        e.add(Tags.SafeToSwapBiomes);
      }
    }, 1250);
  });
  return [];
}

class TransitionOverlay extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {});
  }

}

var _default = TransitionOverlay;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","svelte/transition":"node_modules/svelte/transition/index.mjs","svelte":"node_modules/svelte/index.mjs","../alec-svelte":"src/alec-svelte/index.js","../tags":"src/tags/index.js","../config":"src/config.js","../components/AnimatedTextSpan.svelte":"src/components/AnimatedTextSpan.svelte.js","../animations/transitions":"src/animations/transitions.js","../components/LeafVideo.svelte":"src/components/LeafVideo.svelte.js"}],"src/overlays/GamePages.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _GamePageLanding = _interopRequireDefault(require("./GamePageLanding.svelte"));

var _About = _interopRequireDefault(require("./About.svelte"));

var _config = _interopRequireDefault(require("../config"));

var _HaikuPopup = _interopRequireDefault(require("./HaikuPopup.svelte"));

var _PoemCollectionOverlay = _interopRequireDefault(require("./PoemCollectionOverlay.svelte"));

var _SimpleHintOverlay = _interopRequireDefault(require("./SimpleHintOverlay.svelte"));

var _GameHUD = _interopRequireDefault(require("./GameHUD.svelte"));

var _GameUIIntro = _interopRequireDefault(require("./GameUIIntro.svelte"));

var _svelte = require("svelte");

var _TransitionOverlay = _interopRequireDefault(require("./TransitionOverlay.svelte"));

var _three = require("three");

var _nfb = require("../nfb");

var _alecSvelte = require("../alec-svelte");

var Tags = _interopRequireWildcard(require("../tags"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* overlays/GamePages.svelte generated by Svelte v3.31.0 */
function create_if_block_8(ctx) {
  let gamehud;
  let current;
  gamehud = new _GameHUD.default({
    props: {
      moving:
      /*moving*/
      ctx[11],
      canCollectTokens:
      /*canCollectTokens*/
      ctx[10],
      finishedHaikus:
      /*finishedHaikus*/
      ctx[8],
      store:
      /*store*/
      ctx[0],
      currentHaiku:
      /*currentHaiku*/
      ctx[2]
    }
  });
  gamehud.$on("journal",
  /*journal_handler*/
  ctx[16]);
  gamehud.$on("pause",
  /*pause_handler*/
  ctx[17]);
  return {
    c() {
      (0, _internal.create_component)(gamehud.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(gamehud, target, anchor);
      current = true;
    },

    p(ctx, dirty) {
      const gamehud_changes = {};
      if (dirty &
      /*moving*/
      2048) gamehud_changes.moving =
      /*moving*/
      ctx[11];
      if (dirty &
      /*canCollectTokens*/
      1024) gamehud_changes.canCollectTokens =
      /*canCollectTokens*/
      ctx[10];
      if (dirty &
      /*finishedHaikus*/
      256) gamehud_changes.finishedHaikus =
      /*finishedHaikus*/
      ctx[8];
      if (dirty &
      /*store*/
      1) gamehud_changes.store =
      /*store*/
      ctx[0];
      if (dirty &
      /*currentHaiku*/
      4) gamehud_changes.currentHaiku =
      /*currentHaiku*/
      ctx[2];
      gamehud.$set(gamehud_changes);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(gamehud.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(gamehud.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(gamehud, detaching);
    }

  };
} // (192:24) 


function create_if_block_6(ctx) {
  let if_block_anchor;
  let current;
  let if_block =
  /*currentHaiku*/
  ctx[2] && create_if_block_7(ctx);
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = (0, _internal.empty)();
    },

    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      (0, _internal.insert)(target, if_block_anchor, anchor);
      current = true;
    },

    p(ctx, dirty) {
      if (
      /*currentHaiku*/
      ctx[2]) {
        if (if_block) {
          if_block.p(ctx, dirty);

          if (dirty &
          /*currentHaiku*/
          4) {
            (0, _internal.transition_in)(if_block, 1);
          }
        } else {
          if_block = create_if_block_7(ctx);
          if_block.c();
          (0, _internal.transition_in)(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_block, 1, 1, () => {
          if_block = null;
        });
        (0, _internal.check_outros)();
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(if_block);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(if_block);
      current = false;
    },

    d(detaching) {
      if (if_block) if_block.d(detaching);
      if (detaching) (0, _internal.detach)(if_block_anchor);
    }

  };
} // (190:30) 


function create_if_block_5(ctx) {
  let poemcollection;
  let current;
  poemcollection = new _PoemCollectionOverlay.default({
    props: {
      poems:
      /*finishedHaikus*/
      ctx[8]
    }
  });
  poemcollection.$on("close",
  /*close_handler*/
  ctx[22]);
  return {
    c() {
      (0, _internal.create_component)(poemcollection.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(poemcollection, target, anchor);
      current = true;
    },

    p(ctx, dirty) {
      const poemcollection_changes = {};
      if (dirty &
      /*finishedHaikus*/
      256) poemcollection_changes.poems =
      /*finishedHaikus*/
      ctx[8];
      poemcollection.$set(poemcollection_changes);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(poemcollection.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(poemcollection.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(poemcollection, detaching);
    }

  };
} // (143:51) 


function create_if_block_3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4, create_else_block];
  const if_blocks = [];

  function select_block_type_1(ctx, dirty) {
    if (
    /*showIntro*/
    ctx[13]) return 0;
    return 1;
  }

  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = (0, _internal.empty)();
    },

    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      (0, _internal.insert)(target, if_block_anchor, anchor);
      current = true;
    },

    p(ctx, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx, dirty);

      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        (0, _internal.check_outros)();
        if_block = if_blocks[current_block_type_index];

        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }

        (0, _internal.transition_in)(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(if_block);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(if_block);
      current = false;
    },

    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching) (0, _internal.detach)(if_block_anchor);
    }

  };
} // (141:28) 


function create_if_block_2(ctx) {
  let transitionoverlay;
  let current;
  transitionoverlay = new _TransitionOverlay.default({});
  return {
    c() {
      (0, _internal.create_component)(transitionoverlay.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(transitionoverlay, target, anchor);
      current = true;
    },

    p: _internal.noop,

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(transitionoverlay.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(transitionoverlay.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(transitionoverlay, detaching);
    }

  };
} // (139:0) {#if embed}


function create_if_block_1(ctx) {
  let div;
  return {
    c() {
      div = (0, _internal.element)("div");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
    },

    p: _internal.noop,
    i: _internal.noop,
    o: _internal.noop,

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
    }

  };
} // (193:2) {#if currentHaiku}


function create_if_block_7(ctx) {
  let haikupopup;
  let current;
  haikupopup = new _HaikuPopup.default({
    props: {
      store:
      /*store*/
      ctx[0],
      lines:
      /*currentHaiku*/
      ctx[2].lines,
      tokens:
      /*currentHaiku*/
      ctx[2].tokens
    }
  });
  haikupopup.$on("close",
  /*closeHaikuPopup*/
  ctx[14]);
  return {
    c() {
      (0, _internal.create_component)(haikupopup.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(haikupopup, target, anchor);
      current = true;
    },

    p(ctx, dirty) {
      const haikupopup_changes = {};
      if (dirty &
      /*store*/
      1) haikupopup_changes.store =
      /*store*/
      ctx[0];
      if (dirty &
      /*currentHaiku*/
      4) haikupopup_changes.lines =
      /*currentHaiku*/
      ctx[2].lines;
      if (dirty &
      /*currentHaiku*/
      4) haikupopup_changes.tokens =
      /*currentHaiku*/
      ctx[2].tokens;
      haikupopup.$set(haikupopup_changes);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(haikupopup.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(haikupopup.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(haikupopup, detaching);
    }

  };
} // (153:2) {:else}


function create_else_block(ctx) {
  let gamepagelanding;
  let current;
  gamepagelanding = new _GamePageLanding.default({
    props: {
      start: !
      /*pause*/
      ctx[5],
      endState:
      /*endState*/
      ctx[6],
      introTitle:
      /*introTitle*/
      ctx[12],
      poems:
      /*finishedHaikus*/
      ctx[8]
    }
  });
  gamepagelanding.$on("play",
  /*play_handler*/
  ctx[20]);
  gamepagelanding.$on("journal", journal_handler_1);
  gamepagelanding.$on("about",
  /*about_handler*/
  ctx[21]);
  return {
    c() {
      (0, _internal.create_component)(gamepagelanding.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(gamepagelanding, target, anchor);
      current = true;
    },

    p(ctx, dirty) {
      const gamepagelanding_changes = {};
      if (dirty &
      /*pause*/
      32) gamepagelanding_changes.start = !
      /*pause*/
      ctx[5];
      if (dirty &
      /*endState*/
      64) gamepagelanding_changes.endState =
      /*endState*/
      ctx[6];
      if (dirty &
      /*introTitle*/
      4096) gamepagelanding_changes.introTitle =
      /*introTitle*/
      ctx[12];
      if (dirty &
      /*finishedHaikus*/
      256) gamepagelanding_changes.poems =
      /*finishedHaikus*/
      ctx[8];
      gamepagelanding.$set(gamepagelanding_changes);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(gamepagelanding.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(gamepagelanding.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(gamepagelanding, detaching);
    }

  };
} // (144:2) {#if showIntro}


function create_if_block_4(ctx) {
  let gameuiintro;
  let current;
  gameuiintro = new _GameUIIntro.default({});
  gameuiintro.$on("inbetween",
  /*inbetween_handler*/
  ctx[18]);
  gameuiintro.$on("end",
  /*end_handler*/
  ctx[19]);
  return {
    c() {
      (0, _internal.create_component)(gameuiintro.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(gameuiintro, target, anchor);
      current = true;
    },

    p: _internal.noop,

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(gameuiintro.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(gameuiintro.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(gameuiintro, detaching);
    }

  };
} // (203:0) {#if state === "about"}


function create_if_block(ctx) {
  let about;
  let current;
  about = new _About.default({});
  about.$on("close",
  /*close_handler_1*/
  ctx[23]);
  return {
    c() {
      (0, _internal.create_component)(about.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(about, target, anchor);
      current = true;
    },

    p: _internal.noop,

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(about.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(about.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(about, detaching);
    }

  };
}

function create_fragment(ctx) {
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = !
  /*embed*/
  ctx[1] && !
  /*hideHUD*/
  ctx[9] && !
  /*resolving*/
  ctx[3] && !
  /*transitionOverlay*/
  ctx[7] && !
  /*state*/
  ctx[4] && create_if_block_8(ctx);
  const if_block_creators = [create_if_block_1, create_if_block_2, create_if_block_3, create_if_block_5, create_if_block_6];
  const if_blocks = [];

  function select_block_type(ctx, dirty) {
    if (
    /*embed*/
    ctx[1]) return 0;
    if (
    /*transitionOverlay*/
    ctx[7]) return 1;
    if (
    /*state*/
    ctx[4] === "landing" ||
    /*state*/
    ctx[4] === "about") return 2;
    if (
    /*state*/
    ctx[4] === "journal") return 3;
    if (
    /*state*/
    ctx[4] == null) return 4;
    return -1;
  }

  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }

  let if_block2 =
  /*state*/
  ctx[4] === "about" && create_if_block(ctx);
  return {
    c() {
      if (if_block0) if_block0.c();
      t0 = (0, _internal.space)();
      if (if_block1) if_block1.c();
      t1 = (0, _internal.space)();
      if (if_block2) if_block2.c();
      if_block2_anchor = (0, _internal.empty)();
    },

    m(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      (0, _internal.insert)(target, t0, anchor);

      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }

      (0, _internal.insert)(target, t1, anchor);
      if (if_block2) if_block2.m(target, anchor);
      (0, _internal.insert)(target, if_block2_anchor, anchor);
      current = true;
    },

    p(ctx, [dirty]) {
      if (!
      /*embed*/
      ctx[1] && !
      /*hideHUD*/
      ctx[9] && !
      /*resolving*/
      ctx[3] && !
      /*transitionOverlay*/
      ctx[7] && !
      /*state*/
      ctx[4]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);

          if (dirty &
          /*embed, hideHUD, resolving, transitionOverlay, state*/
          666) {
            (0, _internal.transition_in)(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8(ctx);
          if_block0.c();
          (0, _internal.transition_in)(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        (0, _internal.check_outros)();
      }

      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);

      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        }
      } else {
        if (if_block1) {
          (0, _internal.group_outros)();
          (0, _internal.transition_out)(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          (0, _internal.check_outros)();
        }

        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];

          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block1.c();
          } else {
            if_block1.p(ctx, dirty);
          }

          (0, _internal.transition_in)(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        } else {
          if_block1 = null;
        }
      }

      if (
      /*state*/
      ctx[4] === "about") {
        if (if_block2) {
          if_block2.p(ctx, dirty);

          if (dirty &
          /*state*/
          16) {
            (0, _internal.transition_in)(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block(ctx);
          if_block2.c();
          (0, _internal.transition_in)(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        (0, _internal.check_outros)();
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(if_block0);
      (0, _internal.transition_in)(if_block1);
      (0, _internal.transition_in)(if_block2);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(if_block0);
      (0, _internal.transition_out)(if_block1);
      (0, _internal.transition_out)(if_block2);
      current = false;
    },

    d(detaching) {
      if (if_block0) if_block0.d(detaching);
      if (detaching) (0, _internal.detach)(t0);

      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }

      if (detaching) (0, _internal.detach)(t1);
      if (if_block2) if_block2.d(detaching);
      if (detaching) (0, _internal.detach)(if_block2_anchor);
    }

  };
}

const haikuCardDuration = 10000;
const transitionDuration = 3500;

const journal_handler_1 = () => {}; // sendAnalytics({
// pageview: "journal",


function instance($$self, $$props, $$invalidate) {
  let {
    store
  } = $$props;
  const {
    entity
  } = (0, _alecSvelte.context)();
  let embed;
  let currentHaiku;
  let transitionTimer; // let hintTimer;

  let resolving; // const hintDuration = 4000;

  let state, pause, endState, transitionOverlay, finishedHaikus, currentHint, hoverState, hideHUD, canCollectTokens, moving;
  let introTitle = false;
  let showIntro = false;
  const unmount = store.subscribe(v => {
    $$invalidate(1, embed = v.embed);
    $$invalidate(13, showIntro = v.intro);
    $$invalidate(12, introTitle = v.introTitle);
    $$invalidate(4, state = v.state);
    $$invalidate(5, pause = v.pause);
    $$invalidate(6, endState = v.endState);
    hoverState = v.isButtonHovered;
    $$invalidate(3, resolving = v.resolving);
    $$invalidate(8, finishedHaikus = v.finishedHaikus);
    $$invalidate(10, canCollectTokens = v.canCollectTokens);
    $$invalidate(9, hideHUD = v.hideHUD);
    $$invalidate(11, moving = v.moving);
    const oldHint = currentHint;

    if (v.moving && currentHint) {
      // clearTimeout(hintTimer);
      store.update(d => ({ ...d,
        hint: null
      }));
    }

    if (!state && introTitle) {
      // after we change state, no longer make the title slow
      store.update(d => ({ ...d,
        introTitle: false
      }));
    }

    currentHint = v.hint; // if (currentHint !== oldHint && currentHint) {
    //   clearTimeout(hintTimer);
    //   hintTimer = setTimeout(() => {
    //     store.update((d) => ({ ...d, hint: null }));
    //   }, hintDuration);
    // } else if (currentHint !== oldHint && !currentHint) {
    //   clearTimeout(hintTimer);
    // }

    const oldTransition = transitionOverlay;
    $$invalidate(7, transitionOverlay = v.transitionOverlay);

    if (oldTransition !== transitionOverlay && transitionOverlay) {
      if (!(0, _config.default)().demo) {
        clearTimeout(transitionTimer);
        transitionTimer = setTimeout(() => {
          store.update(d => ({ ...d,
            transitionOverlay: false
          }));
        }, transitionDuration);
      }
    }

    const oldHaiku = currentHaiku;
    $$invalidate(2, currentHaiku = v.newlyCollectedHaiku);

    if (resolving) {
      $$invalidate(2, currentHaiku = null);
    }

    const isGameActive = !state; // const isActive = !state && !v.transitionOverlay;

    if (isGameActive !== v.active) {
      store.update(d => ({ ...d,
        active: isGameActive
      }));
    }
  });
  (0, _svelte.onDestroy)(() => {
    unmount();
    clearTimeout(transitionTimer);
  });

  function closeHaikuPopup() {
    (0, _nfb.sendAnalytics)({
      event: "poem_collect",
      eventLabel: "poem_collect"
    });
    store.update(d => ({ ...d,
      playing: true,
      newlyCollectedHaiku: null
    }));
  }

  function setState(state, opts = {}) {
    store.update(d => ({ ...d,
      ...opts,
      state
    }));
  }

  const journal_handler = () => {
    setState("journal");
  };

  const pause_handler = () => {
    setState("landing", {
      pause: true
    });
  };

  const inbetween_handler = () => {
    store.update(d => ({ ...d,
      initGame: true
    }));
  };

  const end_handler = () => {
    store.update(d => ({ ...d,
      introTitle: true,
      intro: false
    }));
  };

  const play_handler = () => {
    (0, _nfb.hideHeader)();
    setState(null);
    store.update(d => ({ ...d,
      playing: true
    }));
  }; // entity.tagOff(Tags.ButtonClick);
  // entity.tagOn(Tags.ButtonClick);


  const about_handler = () => {
    (0, _nfb.sendAnalytics)({
      pageview: "about"
    });
    setState("about");
  }; // entity.tagOff(Tags.ButtonClick);
  // entity.tagOn(Tags.ButtonClick);


  const close_handler = () => setState(null);

  const close_handler_1 = () => {
    setState("landing");
  };

  $$self.$$set = $$props => {
    if ("store" in $$props) $$invalidate(0, store = $$props.store);
  };

  return [store, embed, currentHaiku, resolving, state, pause, endState, transitionOverlay, finishedHaikus, hideHUD, canCollectTokens, moving, introTitle, showIntro, closeHaikuPopup, setState, journal_handler, pause_handler, inbetween_handler, end_handler, play_handler, about_handler, close_handler, close_handler_1];
}

class GamePages extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      store: 0
    });
  }

}

var _default = GamePages;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","./GamePageLanding.svelte":"src/overlays/GamePageLanding.svelte.js","./About.svelte":"src/overlays/About.svelte.js","../config":"src/config.js","./HaikuPopup.svelte":"src/overlays/HaikuPopup.svelte.js","./PoemCollectionOverlay.svelte":"src/overlays/PoemCollectionOverlay.svelte.js","./SimpleHintOverlay.svelte":"src/overlays/SimpleHintOverlay.svelte.js","./GameHUD.svelte":"src/overlays/GameHUD.svelte.js","./GameUIIntro.svelte":"src/overlays/GameUIIntro.svelte.js","svelte":"node_modules/svelte/index.mjs","./TransitionOverlay.svelte":"src/overlays/TransitionOverlay.svelte.js","three":"src/vendor/three.module.js","../nfb":"src/nfb.js","../alec-svelte":"src/alec-svelte/index.js","../tags":"src/tags/index.js"}],"src/systems/GameUISystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = GameUISystem;

var _GamePages = _interopRequireDefault(require("../overlays/GamePages.svelte"));

var Tags = _interopRequireWildcard(require("../tags"));

var _store = require("svelte/store");

var _queryString = _interopRequireDefault(require("../util/query-string"));

var _config = _interopRequireDefault(require("../config"));

var _nfb = require("../nfb");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function GameUISystem(world, opts = {}) {
  const {
    readyToInitialize,
    readyToShowEngine
  } = opts;
  const showLanding = !_queryString.default.nolanding;
  const showHaikuCard = !_queryString.default.nocard; // console.log("SHOW CARD", showHaikuCard);

  const landing = showLanding ? "landing" : null;
  const embed = (0, _config.default)().embed;
  const initialPage = embed ? null : _queryString.default.initial ? _queryString.default.initial : landing;
  const showIntro = !_queryString.default.nointro;
  const letterboxView = world.view(Tags.LetterboxBars);
  const onOutroEvent = world.listen([Tags.EndGameState, Tags.ResetToCameraDrift]);
  let canCollectTokens = null;
  const store = (0, _store.writable)({
    initGame: showIntro && !embed ? false : true,
    state: initialPage,
    active: true,
    embed,
    // if pause, then we show the restart/resume, otherwise we show initial
    pause: false,
    hint: null,
    notifyHaiku: false,
    endState: false,
    moving: false,
    letterboxes: false,
    isButtonHovered: false,
    isButtonClicked: false,
    canCollectTokens,
    tokensCollected: [],
    finishedHaikus: [],
    poem: [],
    playing: false,
    haikusCollected: 0,
    haikusTotal: 3,
    newlyCollectedHaiku: null,
    transitionOverlay: null,
    transitionCurrentBiome: null,
    resolving: false,
    hideHUD: true,
    intro: showIntro && !embed
  });
  world.tag(Tags.GameUIStore, store);

  window.setUIData = v => {
    store.update(d => ({ ...d,
      ...v
    }));
  };

  window.toggleOpenJournal = function () {
    store.update(t => {
      if (t.state != "journal") {
        t.state = "journal";
      } else {
        t.state = null;
      }

      return t;
    });
  };

  window.setPoemText = function (lineOne, lineTwo, lineThree) {
    store.update(p => {
      p.poem = [lineOne, lineTwo, lineThree];
      p.tokensCollected = ["sun", "rain", "snow"];
      return p;
    });
  };

  const pages = world.entity().add(Tags.ViewLayer, {
    id: "game-pages",
    component: _GamePages.default,
    props: {
      store
    }
  });
  const uiEntity = world.entity();
  let isActive = false;
  let wasActive = null;
  let visited = false;
  let wasIntro = null;
  let didInitGame = false;
  let wasLetterboxes = false;
  let wasHideHUD = true;
  let hasHaikuPopup = false;
  const haikuCardEntity = world.entity();
  const lazyMergeCallbacks = [];
  store.subscribe(v => {
    // console.log("PLAYSTATE", v.playing);
    isActive = Boolean(v.active);

    if (!v.state && !visited) {
      visited = true;

      if (!uiEntity.has(Tags.GameStarted)) {
        uiEntity.add(Tags.GameStarted);
        uiEntity.add(Tags.ClearInputPress);
        (0, _nfb.startButtonTracking)();
        (0, _nfb.sendAnalytics)({
          event: "main",
          eventLabel: "start"
        });
        (0, _nfb.sendTrackingPixel)();
      }

      store.update(d => ({ ...d,
        // hint: "move",
        initGame: true,
        intro: false
      }));
    }

    if (isActive !== wasActive) {
      wasActive = isActive;

      if (isActive) {
        // console.log("GAME ACTIVE, TURN OFF STOP");
        pages.tagOff(Tags.CameraStopUserMovement);
        pages.tagOff(Tags.LetterboxBars);
        pages.tagOff(Tags.CameraZoomOut);
        store.update(d => ({ ...d,
          playing: true
        }));
      } else {
        // console.log("GAME INACTIVE, TURN ON STOP");
        pages.tagOn(Tags.CameraStopUserMovement);
        pages.tagOn(Tags.LetterboxBars);
        pages.tagOn(Tags.CameraZoomOut);
        store.update(d => ({ ...d,
          playing: false
        }));
      }
    }

    if (v.playing) pages.tagOff(Tags.IsGameUIActive);else pages.tagOn(Tags.IsGameUIActive); // Page state

    const isJournalOpen = v.state === "journal";
    const wasJournalOpen = uiEntity.has(Tags.JournalOpen);

    if (isJournalOpen !== wasJournalOpen) {
      if (!uiEntity.has(Tags.JournalOpen)) uiEntity.add(Tags.JournalOpen);else uiEntity.remove(Tags.JournalOpen);
    }

    const isPaused = Boolean(v.state);
    const wasPaused = pages.has(Tags.PauseOpen);

    if (isPaused !== wasPaused) {
      if (!pages.has(Tags.PauseOpen)) pages.add(Tags.PauseOpen);else pages.remove(Tags.PauseOpen);
    } // Button state


    if (v.isButtonHovered) pages.add(Tags.ButtonHover);else pages.remove(Tags.ButtonHover); // if (v.isButtonClicked) {
    //   pages.add(Tags.ButtonClick);
    //   store.update((d) => ({ ...d, isButtonClicked: false }));
    //   pages.remove(Tags.ButtonClick);
    // }

    if (v.initGame && !didInitGame) {
      didInitGame = true;
      if (readyToInitialize) readyToInitialize();
    }

    if (v.intro !== wasIntro && !v.intro) {
      wasIntro = v.intro;

      if (readyToShowEngine) {
        readyToShowEngine();
      }
    }

    if (hasHaikuPopup !== v.newlyCollectedHaiku) {
      let wasVisible = hasHaikuPopup;
      hasHaikuPopup = v.newlyCollectedHaiku;

      if (hasHaikuPopup) {
        haikuCardEntity.tagOn(Tags.BlockUserMove);
        haikuCardEntity.tagOn(Tags.LetterboxBars);
        haikuCardEntity.tagOn(Tags.CameraZoomOut);
      } else {
        haikuCardEntity.tagOff(Tags.BlockUserMove);
        haikuCardEntity.tagOff(Tags.LetterboxBars);
        haikuCardEntity.tagOff(Tags.CameraZoomOut);
      }

      if (showHaikuCard) {
        // card is being shown or not
        if (hasHaikuPopup && !wasVisible) {
          haikuCardEntity.tagOn(Tags.HaikuCardShown);
        } else {
          haikuCardEntity.tagOff(Tags.HaikuCardShown);
        } // card is being saved or not


        if (!hasHaikuPopup && wasVisible) {
          if (v.onNotifyHaiku) v.onNotifyHaiku();
          haikuCardEntity.tagOn(Tags.HaikuCardSaved);
        } else {
          haikuCardEntity.tagOff(Tags.HaikuCardSaved);
        }
      }
    }

    wasLetterboxes = v.letterboxes;
    wasHideHUD = v.hideHUD;
  });
  const envEvents = world.listen([Tags.EnvironmentState, Tags.ActiveEnvironmentState]);
  const envView = world.view([Tags.EnvironmentState, Tags.ActiveEnvironmentState]);
  const collectedTokenView = world.view(Tags.CollectedToken);
  const collectedTokenEvents = world.listen(Tags.CollectedToken);
  const finishedPoemView = world.view(Tags.FinishedPoem);
  const collectedHaikuEvents = world.listen([Tags.FinishedPoem, Tags.HaikuInInventory]);
  const allFinishedHaikuEvents = world.listen(Tags.FinishedPoem);
  const allFinishedHaikus = world.view(Tags.FinishedPoem);
  const collectedHaikuView = world.view(Tags.HaikuInInventory);
  let wasMoving = null;
  let wasTransition = false;
  let wasResolving = false;
  return function uiSystem(dt) {
    if (!world.findTag(Tags.AppState).ready) {}

    if (onOutroEvent.added.length > 0) {
      store.update(d => ({ ...d,
        pause: true,
        endState: true,
        state: "landing"
      }));
    }

    const target = world.findTag(Tags.UserTarget);
    const newMoving = target && target.forceApplied;

    if (newMoving !== wasMoving) {
      store.update(d => ({ ...d,
        moving: newMoving
      }));
      wasMoving = newMoving;
    }

    const hasLetterboxes = letterboxView.length > 0;

    if (wasLetterboxes !== hasLetterboxes) {
      store.update(d => ({ ...d,
        letterboxes: hasLetterboxes
      }));
      wasLetterboxes = hasLetterboxes;
    }

    const isHideHUD = uiEntity.has(Tags.GameStarted) ? Boolean(world.findTag(Tags.HideHUD)) : true;

    if (wasHideHUD !== isHideHUD) {
      store.update(d => ({ ...d,
        hideHUD: isHideHUD
      }));
      wasHideHUD = isHideHUD;
    }

    if (envEvents.changed) {
      if (envView.length > 0) {
        const active = envView[0].get(Tags.EnvironmentState);
        store.update(d => ({ ...d,
          haikusTotal: active.haikusTotal
        }));
      }
    }

    if (collectedTokenEvents.changed) {
      const tokensCollected = collectedTokenEvents.query.entities.map(e => e.get(Tags.CollectedToken).type); // console.log("tokens", tokensCollected);

      store.update(d => ({ ...d,
        tokensCollected
      }));
    }

    const isDirectingToOrigin = Boolean(world.findTag(Tags.DirectUserToOrigin));
    const isCameraStopped = Boolean(world.findTag(Tags.CameraStopUserMovement));
    const blockTokens = Boolean(world.findTag(Tags.BlockTokenCollection));
    const newCanCollectTokens = !isCameraStopped && !isDirectingToOrigin && !blockTokens;

    if (newCanCollectTokens !== canCollectTokens) {
      canCollectTokens = newCanCollectTokens;
      store.update(d => ({ ...d,
        canCollectTokens
      }));
    }

    const isResolving = Boolean(world.findTag(Tags.ShowBiomeResolution));

    if (isResolving !== wasResolving) {
      store.update(d => ({ ...d,
        resolving: isResolving
      }));
      wasResolving = isResolving;
    }

    const isTransition = Boolean(world.findTag(Tags.TransitionToNextBiome));

    if (isTransition !== wasTransition) {
      const curEnv = envView.length ? envView[0].get(Tags.EnvironmentState).name : null;

      if (isTransition && curEnv !== "tundra") {
        store.update(d => ({ ...d,
          transitionOverlay: true,
          transitionCurrentBiome: curEnv
        }));
      }

      wasTransition = isTransition;
    }

    if (collectedHaikuEvents.changed && collectedHaikuEvents.added.length > 0) {
      const poem = collectedHaikuEvents.added[0].get(Tags.FinishedPoem);
      const collected = collectedHaikuEvents.query.entities.map(e => {
        const poem = e.get(Tags.FinishedPoem);
        return {
          tokens: poem.tokens.slice(),
          lines: poem.lines.slice()
        };
      });
      store.update(d => {
        return { ...d,
          newlyCollectedHaiku: showHaikuCard ? {
            tokens: poem.tokens.slice(),
            lines: poem.lines.slice()
          } : false
        };
      });
    }

    if (allFinishedHaikuEvents.changed) {
      const finished = allFinishedHaikus.map(e => {
        const poem = e.get(Tags.FinishedPoem);
        return {
          tokens: poem.tokens.slice(),
          lines: poem.lines.slice()
        };
      });
      store.update(d => {
        return { ...d,
          finishedHaikus: finished
        };
      });
    }

    if (collectedHaikuEvents.changed) {
      // let { haikusCollected, haikusTotal } = get(store);
      // const newCards = collectedHaikuEvents.added.length;
      // const newHaikusCollected = Math.min(
      //   haikusTotal,
      //   haikusCollected + newCards
      // );
      store.update(d => ({ ...d,
        haikusCollected: collectedHaikuView.length
      }));
    }
  };
}
},{"../overlays/GamePages.svelte":"src/overlays/GamePages.svelte.js","../tags":"src/tags/index.js","svelte/store":"node_modules/svelte/store/index.mjs","../util/query-string":"src/util/query-string.js","../config":"src/config.js","../nfb":"src/nfb.js"}],"src/util/Stats.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @author mrdoob / http://mrdoob.com/
 */
var Stats = function () {
  var mode = 0;
  var container = document.createElement("div");
  container.style.cssText = "position:absolute;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";
  container.addEventListener("click", function (event) {
    event.preventDefault();
    showPanel(++mode % container.children.length);
  }, false); //

  function addPanel(panel) {
    container.appendChild(panel.dom);
    return panel;
  }

  function showPanel(id) {
    for (var i = 0; i < container.children.length; i++) {
      container.children[i].style.display = i === id ? "block" : "none";
    }

    mode = id;
  } //


  var beginTime = (performance || Date).now(),
      prevTime = beginTime,
      frames = 0;
  var fpsPanel = addPanel(new Stats.Panel("FPS", "#0ff", "#002"));
  var msPanel = addPanel(new Stats.Panel("MS", "#0f0", "#020")); // if ( self.performance && self.performance.memory ) {
  // 	var memPanel = addPanel( new Stats.Panel( 'MB', '#f08', '#201' ) );
  // }

  showPanel(0);
  return {
    REVISION: 16,
    dom: container,
    addPanel: addPanel,
    showPanel: showPanel,
    begin: function () {
      beginTime = (performance || Date).now();
    },
    end: function () {
      frames++;
      var time = (performance || Date).now();
      msPanel.update(time - beginTime, 200);

      if (time >= prevTime + 1000) {
        fpsPanel.update(frames * 1000 / (time - prevTime), 100);
        prevTime = time;
        frames = 0; // if (memPanel) {
        //   var memory = performance.memory;
        //   memPanel.update(
        //     memory.usedJSHeapSize / 1048576,
        //     memory.jsHeapSizeLimit / 1048576
        //   );
        // }
      }

      return time;
    },
    update: function () {
      beginTime = this.end();
    },
    // Backwards Compatibility
    domElement: container,
    setMode: showPanel
  };
};

Stats.Panel = function (name, fg, bg) {
  var min = Infinity,
      max = 0,
      round = Math.round;
  var PR = round(window.devicePixelRatio || 1);
  var WIDTH = 80 * PR,
      HEIGHT = 48 * PR,
      TEXT_X = 3 * PR,
      TEXT_Y = 2 * PR,
      GRAPH_X = 3 * PR,
      GRAPH_Y = 15 * PR,
      GRAPH_WIDTH = 74 * PR,
      GRAPH_HEIGHT = 30 * PR;
  var canvas = document.createElement("canvas");
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
  canvas.style.cssText = "width:80px;height:48px";
  var context = canvas.getContext("2d");
  context.font = "bold " + 9 * PR + "px Helvetica,Arial,sans-serif";
  context.textBaseline = "top";
  context.fillStyle = bg;
  context.fillRect(0, 0, WIDTH, HEIGHT);
  context.fillStyle = fg;
  context.fillText(name, TEXT_X, TEXT_Y);
  context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
  context.fillStyle = bg;
  context.globalAlpha = 0.9;
  context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
  return {
    dom: canvas,
    update: function (value, maxValue) {
      min = Math.min(min, value);
      max = Math.max(max, value);
      context.fillStyle = bg;
      context.globalAlpha = 1;
      context.fillRect(0, 0, WIDTH, GRAPH_Y);
      context.fillStyle = fg;
      context.fillText(round(value) + " " + name + " (" + round(min) + "-" + round(max) + ")", TEXT_X, TEXT_Y);
      context.drawImage(canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT);
      context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT);
      context.fillStyle = bg;
      context.globalAlpha = 0.9;
      context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round((1 - value / maxValue) * GRAPH_HEIGHT));
    }
  };
};

var _default = Stats;
exports.default = _default;
},{}],"src/components/Canvas.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _svelte = require("svelte");

/* components/Canvas.svelte generated by Svelte v3.31.0 */
function create_if_block(ctx) {
  let div1;
  return {
    c() {
      div1 = (0, _internal.element)("div");
      div1.innerHTML = `<div class="test"></div>`;
      (0, _internal.attr)(div1, "class", "canvas-container svelte-146xou4");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div1, anchor);
      /*div1_binding*/

      ctx[6](div1);
    },

    p: _internal.noop,

    d(detaching) {
      if (detaching) (0, _internal.detach)(div1);
      /*div1_binding*/

      ctx[6](null);
    }

  };
}

function create_fragment(ctx) {
  let if_block_anchor;
  let if_block = !
  /*parent*/
  ctx[0] && create_if_block(ctx);
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = (0, _internal.empty)();
    },

    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      (0, _internal.insert)(target, if_block_anchor, anchor);
    },

    p(ctx, [dirty]) {
      if (!
      /*parent*/
      ctx[0]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },

    i: _internal.noop,
    o: _internal.noop,

    d(detaching) {
      if (if_block) if_block.d(detaching);
      if (detaching) (0, _internal.detach)(if_block_anchor);
    }

  };
}

function instance($$self, $$props, $$invalidate) {
  let {
    canvas
  } = $$props;
  let {
    resize
  } = $$props;
  let {
    stats
  } = $$props;
  let {
    parent
  } = $$props;
  let {
    embed = false
  } = $$props;
  let container;
  if (parent) container = parent;
  let resizeObserver;

  if (typeof window.ResizeObserver !== "undefined") {
    resizeObserver = new window.ResizeObserver(entries => {
      onResize();
    });
  }

  const isIOS = /(iOS|iPhone|iPad|iPod)/i.test(navigator.userAgent);

  if (isIOS) {
    document.onselectstart = function () {
      return false;
    };

    document.addEventListener("touchmove", function (event) {
      if (event.scale !== 1) {
        event.preventDefault();
      }
    }, {
      passive: false
    });
  }

  (0, _svelte.afterUpdate)(() => {});
  (0, _svelte.onMount)(() => {
    if (canvas) {
      if (!embed || !canvas.parentElement) container.appendChild(canvas);
    }

    if (stats) {
      container.appendChild(stats);
    }

    if (isIOS) {
      onOrientationChange();
      setTimeout(() => {
        onOrientationChange();
      }, 500);
    } // canvas.addEventListener(
    //   "touchstart",
    //   function (event) {
    //     const computed = document.documentElement.getBoundingClientRect();
    //     if (computed.height !== window.innerHeight) {
    //       // alert("gonna fix!");
    //       // document.documentElement.style.height = `${window.innerHeight}px`;
    //       // window.scrollTo(0, 0);
    //     }
    //   },
    //   { passive: false }
    // );


    onResize();
    if (resizeObserver) resizeObserver.observe(container);
    window.addEventListener("resize", onWindowChanged, {
      passive: true
    }); // window.scrollTo(0, 0);

    window.addEventListener("orientationchange", onOrientationChange, {
      passive: true
    });
    return () => {
      if (canvas && canvas.parentElement === container) {
        canvas.parentElement.removeChild(canvas);
      }

      if (resizeObserver) resizeObserver.unobserve(container);
      window.removeEventListener("resize", onResize);
      window.removeEventListener("orientationchange", onOrientationChange);
    };
  });

  function onOrientationChange() {
    if (isIOS) {
      setTimeout(() => {
        window.scrollTo(0, 0);
        document.documentElement.style.height = `${window.innerHeight}px`;
        onResize();
        setTimeout(() => {
          document.documentElement.style.height = `100%`;
          onResize();
        }, 500);
      }, 500);
    } // setTimeout(() => {
    //   const computed = document.documentElement.getBoundingClientRect();
    //   if (computed.height !== window.innerHeight) {
    //     document.documentElement.style.height = `${window.innerHeight}px`;
    //     document.documentElement.style.height = `100%`;
    //     window.scrollTo(0, 0);
    //   }
    // }, 500);


    onResize();
  }

  function onWindowChanged() {
    // window.scrollTo(0, 0);
    // setTimeout(() => window.scrollTo(0, 0), 350);
    // setTimeout(() => window.scrollTo(0, 0), 100);
    // setTimeout(() => {
    // document.body.style.height = `100vh`;
    //   document.documentElement.style.height = `100vh`;
    // document.documentElement.style.height = `${window.innerHeight}px`;
    // }, 350);
    document.documentElement.style.height = `${window.innerHeight}px`;
    window.scrollTo(0, 0);
    onResize();
  }

  function onResize() {
    if (typeof resize === "function") {
      const r = embed ? container.getBoundingClientRect() : null;
      const w = embed ? r.width : window.innerWidth;
      const h = embed ? r.height : window.innerHeight; // const h = window.innerHeight;

      resize(Math.round(w), Math.round(h));
    }
  }

  function div1_binding($$value) {
    _internal.binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(1, container);
    });
  }

  $$self.$$set = $$props => {
    if ("canvas" in $$props) $$invalidate(2, canvas = $$props.canvas);
    if ("resize" in $$props) $$invalidate(3, resize = $$props.resize);
    if ("stats" in $$props) $$invalidate(4, stats = $$props.stats);
    if ("parent" in $$props) $$invalidate(0, parent = $$props.parent);
    if ("embed" in $$props) $$invalidate(5, embed = $$props.embed);
  };

  return [parent, container, canvas, resize, stats, embed, div1_binding];
}

class Canvas extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      canvas: 2,
      resize: 3,
      stats: 4,
      parent: 0,
      embed: 5
    });
  }

}

var _default = Canvas;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","svelte":"node_modules/svelte/index.mjs"}],"src/util/frame-sequence.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SequenceExporter;

async function SequenceExporter() {
  let dir;

  try {
    dir = await window.showDirectoryPicker();
  } catch (err) {
    console.error(err);

    if (err.code === 20 || err.name === "AbortError") {
      // don't warn on abort
      return null;
    } else {
      throw err;
    }
  }

  return async (canvas, frameIndex, totalFrames) => {
    const url = canvas.toDataURL("image/png");
    const extension = ".png";
    const prefix = "";
    const type = "image/png";
    const frameDigitCount = String(totalFrames).length;
    const curFrameName = String(frameIndex).padStart(frameDigitCount, "0");
    const curFrameFile = `${prefix}${curFrameName}${extension}`;
    const fh = await dir.getFileHandle(curFrameFile, {
      create: true
    });
    const fw = await fh.createWritable();
    let blob = createBlobFromDataURL(url);
    await fw.write(blob);
    await fw.close();
  };
}

function createBlobFromDataURL(dataURL) {
  const splitIndex = dataURL.indexOf(",");

  if (splitIndex === -1) {
    return new Blob();
  }

  const base64 = dataURL.slice(splitIndex + 1);
  const byteString = atob(base64);
  const type = dataURL.slice(0, splitIndex);
  const mimeMatch = /data:([^;]+)/.exec(type);
  const mime = (mimeMatch ? mimeMatch[1] : "") || undefined;
  const ab = new ArrayBuffer(byteString.length);
  const ia = new Uint8Array(ab);

  for (var i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }

  return new Blob([ab], {
    type: mime
  });
}
},{}],"src/systems/CanvasSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = CanvasSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _Stats = _interopRequireDefault(require("../util/Stats.js"));

var _documentVisibility = _interopRequireDefault(require("../util/documentVisibility"));

var _Canvas = _interopRequireDefault(require("../components/Canvas.svelte"));

var _config = _interopRequireDefault(require("../config"));

var _rightNow = _interopRequireDefault(require("right-now"));

var _frameSequence = _interopRequireDefault(require("../util/frame-sequence"));

var _addFrameTasks = require("../util/addFrameTasks");

var _queryString = _interopRequireDefault(require("../util/query-string"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function patchTextureClone(renderer) {
  THREE.Texture.prototype.clone = function (recursive) {
    const tex = new this.constructor().copy(this);
    const previousProperties = renderer.properties.get(this);
    const newProperties = renderer.properties.get(tex);
    Object.assign(newProperties, previousProperties);
    return tex;
  };
}

function CanvasSystem(world, {
  context
}) {
  world.system.info({
    hidden: true
  });

  if (!context) {
    // return window.alert("No WebGL context!");
    console.error("Could not load context");
  }

  console.log("[renderer] Creating WebGL");
  const renderer = new THREE.WebGLRenderer({
    canvas: context ? context.canvas : undefined,
    context
  });
  const config = (0, _config.default)();
  const canvas = renderer.domElement; // canvas.style.visibility = "hidden";

  const promoFPS = _queryString.default.fps || 30; // renderer.setClearColor("#000");

  renderer.setClearColor("#130904");
  const debugShaders = "development" === "development" || _queryString.default.debug;
  renderer.debug.checkShaderErrors = debugShaders;
  patchTextureClone(renderer); // renderer.outputEncoding = THREE.LinearEncoding;

  let stats;

  if ("development" === "development") {
    if (_queryString.default.debug) stats = new _Stats.default();
  } // renderer.sortObjects = false;
  // const gl = renderer.getContext();
  // gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
  // gl.enable(gl.SAMPLE_COVERAGE);
  // console.log(gl.getParameter(gl.SAMPLES));


  const scene = new THREE.Scene();
  scene.name = "MainScene";
  const camera = new THREE.PerspectiveCamera(30, 1, 0.1, 500);
  camera.name = "MainCamera";
  camera.position.set(2, 2, -2);
  camera.lookAt(new THREE.Vector3());
  let shouldDownload = false;

  const download = canvas => {
    const url = canvas.toDataURL("image/png");
    const a = document.createElement("a");
    a.download = Date.now() + ".png";
    a.href = url;
    a.click();
  };

  if (_queryString.default.promo) {
    const doSequence = async () => {
      const fps = 24;
      const duration = 5;
      const totalFrames = Math.ceil(fps * duration);
      const fpsInterval = 1 / fps;
      let sequence = await (0, _frameSequence.default)();
      const frameList = Array(totalFrames).fill().map((_, frame) => frame);

      for (let frame of frameList) {
        step(fpsInterval);
        console.log("Frame %d / %d", frame + 1, totalFrames);
        await sequence(canvas, frame, totalFrames);
        await new Promise(resolve => requestAnimationFrame(resolve));
      }

      console.log("Done");
      start();
    };

    window.drift = function drift() {
      const endEntity = world.entity();
      endEntity.tagOn(Tags.GameLandingCameraDrift); // endEntity.tagOn(Tags.CameraZoomOut);

      endEntity.tagOn(Tags.BlockTokenCollection);
      endEntity.tagOn(Tags.HideCharacter);
      endEntity.tagOn(Tags.HideHUD);
      endEntity.tagOn(Tags.BlockUserMove);
      endEntity.tagOn(Tags.CameraStopUserMovement);
      endEntity.tagOn(Tags.ModalStoppingUserMovement);
    };

    window.addEventListener("keydown", ev => {
      if (ev.key.toLowerCase() === "s" && (ev.metaKey || ev.ctrlKey)) {
        ev.preventDefault();
        shouldDownload = true;
      } else if (ev.key.toLowerCase() === "k" && (ev.metaKey || ev.ctrlKey)) {
        ev.preventDefault();
        stop();
        doSequence();
      }
    });
  }

  let lastTime = (0, _rightNow.default)();
  let lastSecond = (0, _rightNow.default)();
  let frameCountPerSecond = 0;
  const uiEvents = world.listen(Tags.IsGameUIActive);
  const transitionView = world.view(Tags.TransitionToNextBiome);
  const resolveView = world.view(Tags.ShowBiomeResolution);
  const gameStartedView = world.view(Tags.GameStarted);
  const transitionEvents = world.listen(Tags.TransitionToNextBiome);
  const driftView = world.view(Tags.GameLandingCameraDrift);
  const driftEvents = world.listen(Tags.GameLandingCameraDrift);
  const activeEnvEvents = world.listen(Tags.ActiveEnvironmentState);
  const gameStartEvents = world.listen(Tags.GameStarted); // every N seconds, check how many dropped frames we have

  let frameDropDelayInterval = 2.5;
  const maxDPR = _queryString.default.lowbattery ? 1 : 2;
  const maxDensity = Math.min(maxDPR, window.devicePixelRatio);
  const densityList = [...new Set(maxDensity <= 1 ? [maxDensity] : [maxDensity, // maxDensity * (7 / 8),
  maxDensity * (3 / 4), maxDensity * (2 / 3), maxDensity * (5 / 8), 1].filter(d => d >= 1))];
  let curDensityIndex = 0;
  scene.add(camera);
  const e = world.entity("CanvasComponent").add(Tags.ViewLayer, {
    id: "canvas",
    component: _Canvas.default,
    props: {
      embed: config.embed,
      parent: config.container,
      canvas,
      resize,
      stats: stats ? stats.dom : null
    }
  }).add(Tags.Canvas, canvas).add(Tags.Renderer, renderer).add(Tags.MainScene, scene).add(Tags.MainCamera, camera).add(Tags.AppState);
  const appState = e.get(Tags.AppState);
  let width, height, pixelRatio, canvasWidth, canvasHeight;
  let needsResize = true;
  let hidden = true;
  let maxArea = 2;
  let raf;
  let playing = false;
  let running = false;
  let lowBattery = Boolean(_queryString.default.lowbattery);
  let densityTimer = null,
      resettingDensity = false;

  const resetDensity = (delay = frameDropDelayInterval) => {
    resettingDensity = true;
    if (densityTimer != null) clearTimeout(densityTimer);
    densityTimer = setTimeout(() => {
      resettingDensity = false;
      frameCountPerSecond = 0;
      lastSecond = (0, _rightNow.default)();
    }, frameDropDelayInterval * 1000);
  };

  (0, _documentVisibility.default)(visible => {
    if (visible) start();else stop();
  });
  return {
    get running() {
      return running;
    },

    set running(v) {
      running = v;
    },

    process(dt) {
      if (activeEnvEvents.changed) {
        if (curDensityIndex > 0 && curDensityIndex > densityList.length / 2) {
          // give the game a chance to try and increase resolution at start of biome
          curDensityIndex--;
          resize(width, height);
        }

        resetDensity();
      }

      if (uiEvents.changed || driftEvents.changed || transitionEvents.changed) {
        resetDensity();
      }

      if (gameStartEvents.changed) {
        curDensityIndex = 0;
        resize(width, height); // clear density timer when UI appears / disappears

        resetDensity();
      }
    },

    show,
    step,

    dispose() {
      stop(); // renderer.setAnimationLoop(null);

      e.kill();
    }

  };

  function updateAppState() {
    if (needsResize) {
      triggerResize();
    }

    appState.width = width;
    appState.height = height;
    appState.pixelRatio = pixelRatio;
    appState.canvasWidth = canvasWidth;
    appState.canvasHeight = canvasHeight;
  }

  function resize(w, h) {
    const hasSizeChanged = w !== width || h !== height;

    if (hasSizeChanged) {
      const oldArea = width * height;
      const newArea = w * h;
      maxArea = Math.max(maxArea, newArea);

      if (newArea <= maxArea * 0.5) {
        curDensityIndex = 0;
      } else if (newArea < oldArea) {
        // curDensityIndex = 0;
        if (curDensityIndex > densityList.length / 2) {
          curDensityIndex--;
        }
      } // reset density to ignore FPS drops that happen on resize


      resetDensity();
    }

    const newDPR = _queryString.default.pixelRatio != null ? _queryString.default.pixelRatio : densityList[curDensityIndex];
    const hasDPRChanged = newDPR !== pixelRatio;

    if (hasDPRChanged && !hasSizeChanged) {
      resetDensity(0.5);
    }

    if (hasDPRChanged) {
      console.log("[resize] New density", newDPR);
    }

    if (hasSizeChanged || hasDPRChanged) {
      width = w;
      height = h; // let dpr = 2;
      // if (!queryString.promo) {
      //   const size = width * height;
      //   const maxPhoneSize = 411 * 823; // based on Pixel XL2
      //   const maxTabletSize = 1024 * 768; // based on iPad
      //   if (size > maxTabletSize) dpr = Math.min(dpr, 1.25);
      //   else if (size > maxPhoneSize) dpr = Math.min(dpr, 1.25);
      //   if (lowBattery) dpr = 1;
      // }
      // dpr = 1.25;
      // console.log("PIXEL RATIO", dpr);
      // const dpr = width * height > 600000 ? 1.25 : 1.5;
      // pixelRatio = 1; //Math.min(dpr, window.devicePixelRatio);

      pixelRatio = newDPR;
      canvasWidth = Math.floor(width * pixelRatio);
      canvasHeight = Math.floor(height * pixelRatio);

      if (running && !hidden) {
        needsResize = true;
      } else {
        triggerResize();
      }
    }
  }

  function start() {
    if (!playing) {
      playing = true;
      lastTime = (0, _rightNow.default)();
      raf = window.requestAnimationFrame(animate);
    }
  }

  function stop() {
    if (raf != null) {
      window.cancelAnimationFrame(raf);
      raf = null;
    }

    if (playing) {
      playing = false;
    }
  }

  function triggerResize() {
    renderer.setPixelRatio(pixelRatio);
    renderer.setSize(width, height);
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    needsResize = false;
  }

  function step(delta) {
    let resizing = needsResize;
    updateAppState();

    if (appState.running || resizing) {
      // clamp delta time for long frames
      if (!_queryString.default.promo) {
        delta = Math.min(delta, 1 / 10);
      } // Let's assume frame tasks should always happen


      const task = (0, _addFrameTasks.nextFrameTask)();
      if (task) task(delta);

      if (running) {
        world.root.process(delta);
        if (stats) stats.update();

        if (shouldDownload) {
          shouldDownload = false;
          download(canvas);
        }
      }
    }
  }

  function animate(time) {
    if (!playing) return;
    raf = window.requestAnimationFrame(animate); // let now = rightNow();

    let delta = (time - lastTime) / 1000;
    let deltaFrame = (time - lastSecond) / 1000;

    if (!resettingDensity) {
      frameCountPerSecond++;

      if (deltaFrame >= frameDropDelayInterval) {
        const drops = frameDropDelayInterval * 60 - frameCountPerSecond;
        const avgFPS = frameCountPerSecond / frameDropDelayInterval; // console.log("New second", avgFPS, drops);

        lastSecond = time;
        frameCountPerSecond = 0;
        const inGame = gameStartedView.length > 0 || driftView.length > 0;
        const isTransitioning = transitionView.length > 0 || resolveView.length > 0;

        if ((avgFPS <= 55 || drops >= 10) && inGame && !isTransitioning) {
          const oldDPR = densityList[curDensityIndex];
          curDensityIndex++;

          if (curDensityIndex > densityList.length - 1) {
            curDensityIndex = densityList.length - 1;
          }

          const newDPR = densityList[curDensityIndex];

          if (oldDPR !== newDPR) {
            resize(width, height);
          }
        }
      }
    }

    lastTime = time;
    step(delta);
  }

  function show() {
    canvas.style.display = "";
    hidden = false;
    appState.ready = true;
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/Stats.js":"src/util/Stats.js","../util/documentVisibility":"src/util/documentVisibility.js","../components/Canvas.svelte":"src/components/Canvas.svelte.js","../config":"src/config.js","right-now":"node_modules/right-now/browser.js","../util/frame-sequence":"src/util/frame-sequence.js","../util/addFrameTasks":"src/util/addFrameTasks.js","../util/query-string":"src/util/query-string.js"}],"node_modules/simplex-noise/simplex-noise.js":[function(require,module,exports) {
var define;
/*
 * A fast javascript implementation of simplex noise by Jonas Wagner

Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.
Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).
With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
Better rank ordering method by Stefan Gustavson in 2012.


 Copyright (c) 2018 Jonas Wagner

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
(function() {
  'use strict';

  var F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
  var G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
  var F3 = 1.0 / 3.0;
  var G3 = 1.0 / 6.0;
  var F4 = (Math.sqrt(5.0) - 1.0) / 4.0;
  var G4 = (5.0 - Math.sqrt(5.0)) / 20.0;

  function SimplexNoise(randomOrSeed) {
    var random;
    if (typeof randomOrSeed == 'function') {
      random = randomOrSeed;
    }
    else if (randomOrSeed) {
      random = alea(randomOrSeed);
    } else {
      random = Math.random;
    }
    this.p = buildPermutationTable(random);
    this.perm = new Uint8Array(512);
    this.permMod12 = new Uint8Array(512);
    for (var i = 0; i < 512; i++) {
      this.perm[i] = this.p[i & 255];
      this.permMod12[i] = this.perm[i] % 12;
    }

  }
  SimplexNoise.prototype = {
    grad3: new Float32Array([1, 1, 0,
      -1, 1, 0,
      1, -1, 0,

      -1, -1, 0,
      1, 0, 1,
      -1, 0, 1,

      1, 0, -1,
      -1, 0, -1,
      0, 1, 1,

      0, -1, 1,
      0, 1, -1,
      0, -1, -1]),
    grad4: new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1,
      0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1,
      1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1,
      -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1,
      1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1,
      -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1,
      1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0,
      -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]),
    noise2D: function(xin, yin) {
      var permMod12 = this.permMod12;
      var perm = this.perm;
      var grad3 = this.grad3;
      var n0 = 0; // Noise contributions from the three corners
      var n1 = 0;
      var n2 = 0;
      // Skew the input space to determine which simplex cell we're in
      var s = (xin + yin) * F2; // Hairy factor for 2D
      var i = Math.floor(xin + s);
      var j = Math.floor(yin + s);
      var t = (i + j) * G2;
      var X0 = i - t; // Unskew the cell origin back to (x,y) space
      var Y0 = j - t;
      var x0 = xin - X0; // The x,y distances from the cell origin
      var y0 = yin - Y0;
      // For the 2D case, the simplex shape is an equilateral triangle.
      // Determine which simplex we are in.
      var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
      if (x0 > y0) {
        i1 = 1;
        j1 = 0;
      } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
      else {
        i1 = 0;
        j1 = 1;
      } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
      // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
      // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
      // c = (3-sqrt(3))/6
      var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
      var y1 = y0 - j1 + G2;
      var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
      var y2 = y0 - 1.0 + 2.0 * G2;
      // Work out the hashed gradient indices of the three simplex corners
      var ii = i & 255;
      var jj = j & 255;
      // Calculate the contribution from the three corners
      var t0 = 0.5 - x0 * x0 - y0 * y0;
      if (t0 >= 0) {
        var gi0 = permMod12[ii + perm[jj]] * 3;
        t0 *= t0;
        n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient
      }
      var t1 = 0.5 - x1 * x1 - y1 * y1;
      if (t1 >= 0) {
        var gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;
        t1 *= t1;
        n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);
      }
      var t2 = 0.5 - x2 * x2 - y2 * y2;
      if (t2 >= 0) {
        var gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;
        t2 *= t2;
        n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);
      }
      // Add contributions from each corner to get the final noise value.
      // The result is scaled to return values in the interval [-1,1].
      return 70.0 * (n0 + n1 + n2);
    },
    // 3D simplex noise
    noise3D: function(xin, yin, zin) {
      var permMod12 = this.permMod12;
      var perm = this.perm;
      var grad3 = this.grad3;
      var n0, n1, n2, n3; // Noise contributions from the four corners
      // Skew the input space to determine which simplex cell we're in
      var s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D
      var i = Math.floor(xin + s);
      var j = Math.floor(yin + s);
      var k = Math.floor(zin + s);
      var t = (i + j + k) * G3;
      var X0 = i - t; // Unskew the cell origin back to (x,y,z) space
      var Y0 = j - t;
      var Z0 = k - t;
      var x0 = xin - X0; // The x,y,z distances from the cell origin
      var y0 = yin - Y0;
      var z0 = zin - Z0;
      // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
      // Determine which simplex we are in.
      var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
      var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
      if (x0 >= y0) {
        if (y0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        } // X Y Z order
        else if (x0 >= z0) {
          i1 = 1;
          j1 = 0;
          k1 = 0;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        } // X Z Y order
        else {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 1;
          j2 = 0;
          k2 = 1;
        } // Z X Y order
      }
      else { // x0<y0
        if (y0 < z0) {
          i1 = 0;
          j1 = 0;
          k1 = 1;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } // Z Y X order
        else if (x0 < z0) {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 0;
          j2 = 1;
          k2 = 1;
        } // Y Z X order
        else {
          i1 = 0;
          j1 = 1;
          k1 = 0;
          i2 = 1;
          j2 = 1;
          k2 = 0;
        } // Y X Z order
      }
      // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
      // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
      // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
      // c = 1/6.
      var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
      var y1 = y0 - j1 + G3;
      var z1 = z0 - k1 + G3;
      var x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
      var y2 = y0 - j2 + 2.0 * G3;
      var z2 = z0 - k2 + 2.0 * G3;
      var x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
      var y3 = y0 - 1.0 + 3.0 * G3;
      var z3 = z0 - 1.0 + 3.0 * G3;
      // Work out the hashed gradient indices of the four simplex corners
      var ii = i & 255;
      var jj = j & 255;
      var kk = k & 255;
      // Calculate the contribution from the four corners
      var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
      if (t0 < 0) n0 = 0.0;
      else {
        var gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;
        t0 *= t0;
        n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0);
      }
      var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
      if (t1 < 0) n1 = 0.0;
      else {
        var gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;
        t1 *= t1;
        n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1);
      }
      var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
      if (t2 < 0) n2 = 0.0;
      else {
        var gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;
        t2 *= t2;
        n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2);
      }
      var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
      if (t3 < 0) n3 = 0.0;
      else {
        var gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;
        t3 *= t3;
        n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3);
      }
      // Add contributions from each corner to get the final noise value.
      // The result is scaled to stay just inside [-1,1]
      return 32.0 * (n0 + n1 + n2 + n3);
    },
    // 4D simplex noise, better simplex rank ordering method 2012-03-09
    noise4D: function(x, y, z, w) {
      var perm = this.perm;
      var grad4 = this.grad4;

      var n0, n1, n2, n3, n4; // Noise contributions from the five corners
      // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
      var s = (x + y + z + w) * F4; // Factor for 4D skewing
      var i = Math.floor(x + s);
      var j = Math.floor(y + s);
      var k = Math.floor(z + s);
      var l = Math.floor(w + s);
      var t = (i + j + k + l) * G4; // Factor for 4D unskewing
      var X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
      var Y0 = j - t;
      var Z0 = k - t;
      var W0 = l - t;
      var x0 = x - X0; // The x,y,z,w distances from the cell origin
      var y0 = y - Y0;
      var z0 = z - Z0;
      var w0 = w - W0;
      // For the 4D case, the simplex is a 4D shape I won't even try to describe.
      // To find out which of the 24 possible simplices we're in, we need to
      // determine the magnitude ordering of x0, y0, z0 and w0.
      // Six pair-wise comparisons are performed between each possible pair
      // of the four coordinates, and the results are used to rank the numbers.
      var rankx = 0;
      var ranky = 0;
      var rankz = 0;
      var rankw = 0;
      if (x0 > y0) rankx++;
      else ranky++;
      if (x0 > z0) rankx++;
      else rankz++;
      if (x0 > w0) rankx++;
      else rankw++;
      if (y0 > z0) ranky++;
      else rankz++;
      if (y0 > w0) ranky++;
      else rankw++;
      if (z0 > w0) rankz++;
      else rankw++;
      var i1, j1, k1, l1; // The integer offsets for the second simplex corner
      var i2, j2, k2, l2; // The integer offsets for the third simplex corner
      var i3, j3, k3, l3; // The integer offsets for the fourth simplex corner
      // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
      // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
      // impossible. Only the 24 indices which have non-zero entries make any sense.
      // We use a thresholding to set the coordinates in turn from the largest magnitude.
      // Rank 3 denotes the largest coordinate.
      i1 = rankx >= 3 ? 1 : 0;
      j1 = ranky >= 3 ? 1 : 0;
      k1 = rankz >= 3 ? 1 : 0;
      l1 = rankw >= 3 ? 1 : 0;
      // Rank 2 denotes the second largest coordinate.
      i2 = rankx >= 2 ? 1 : 0;
      j2 = ranky >= 2 ? 1 : 0;
      k2 = rankz >= 2 ? 1 : 0;
      l2 = rankw >= 2 ? 1 : 0;
      // Rank 1 denotes the second smallest coordinate.
      i3 = rankx >= 1 ? 1 : 0;
      j3 = ranky >= 1 ? 1 : 0;
      k3 = rankz >= 1 ? 1 : 0;
      l3 = rankw >= 1 ? 1 : 0;
      // The fifth corner has all coordinate offsets = 1, so no need to compute that.
      var x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
      var y1 = y0 - j1 + G4;
      var z1 = z0 - k1 + G4;
      var w1 = w0 - l1 + G4;
      var x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
      var y2 = y0 - j2 + 2.0 * G4;
      var z2 = z0 - k2 + 2.0 * G4;
      var w2 = w0 - l2 + 2.0 * G4;
      var x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
      var y3 = y0 - j3 + 3.0 * G4;
      var z3 = z0 - k3 + 3.0 * G4;
      var w3 = w0 - l3 + 3.0 * G4;
      var x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
      var y4 = y0 - 1.0 + 4.0 * G4;
      var z4 = z0 - 1.0 + 4.0 * G4;
      var w4 = w0 - 1.0 + 4.0 * G4;
      // Work out the hashed gradient indices of the five simplex corners
      var ii = i & 255;
      var jj = j & 255;
      var kk = k & 255;
      var ll = l & 255;
      // Calculate the contribution from the five corners
      var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
      if (t0 < 0) n0 = 0.0;
      else {
        var gi0 = (perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32) * 4;
        t0 *= t0;
        n0 = t0 * t0 * (grad4[gi0] * x0 + grad4[gi0 + 1] * y0 + grad4[gi0 + 2] * z0 + grad4[gi0 + 3] * w0);
      }
      var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
      if (t1 < 0) n1 = 0.0;
      else {
        var gi1 = (perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32) * 4;
        t1 *= t1;
        n1 = t1 * t1 * (grad4[gi1] * x1 + grad4[gi1 + 1] * y1 + grad4[gi1 + 2] * z1 + grad4[gi1 + 3] * w1);
      }
      var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
      if (t2 < 0) n2 = 0.0;
      else {
        var gi2 = (perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32) * 4;
        t2 *= t2;
        n2 = t2 * t2 * (grad4[gi2] * x2 + grad4[gi2 + 1] * y2 + grad4[gi2 + 2] * z2 + grad4[gi2 + 3] * w2);
      }
      var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
      if (t3 < 0) n3 = 0.0;
      else {
        var gi3 = (perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32) * 4;
        t3 *= t3;
        n3 = t3 * t3 * (grad4[gi3] * x3 + grad4[gi3 + 1] * y3 + grad4[gi3 + 2] * z3 + grad4[gi3 + 3] * w3);
      }
      var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
      if (t4 < 0) n4 = 0.0;
      else {
        var gi4 = (perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32) * 4;
        t4 *= t4;
        n4 = t4 * t4 * (grad4[gi4] * x4 + grad4[gi4 + 1] * y4 + grad4[gi4 + 2] * z4 + grad4[gi4 + 3] * w4);
      }
      // Sum up and scale the result to cover the range [-1,1]
      return 27.0 * (n0 + n1 + n2 + n3 + n4);
    }
  };

  function buildPermutationTable(random) {
    var i;
    var p = new Uint8Array(256);
    for (i = 0; i < 256; i++) {
      p[i] = i;
    }
    for (i = 0; i < 255; i++) {
      var r = i + ~~(random() * (256 - i));
      var aux = p[i];
      p[i] = p[r];
      p[r] = aux;
    }
    return p;
  }
  SimplexNoise._buildPermutationTable = buildPermutationTable;

  function alea() {
    // Johannes Baagøe <baagoe@baagoe.com>, 2010
    var s0 = 0;
    var s1 = 0;
    var s2 = 0;
    var c = 1;

    var mash = masher();
    s0 = mash(' ');
    s1 = mash(' ');
    s2 = mash(' ');

    for (var i = 0; i < arguments.length; i++) {
      s0 -= mash(arguments[i]);
      if (s0 < 0) {
        s0 += 1;
      }
      s1 -= mash(arguments[i]);
      if (s1 < 0) {
        s1 += 1;
      }
      s2 -= mash(arguments[i]);
      if (s2 < 0) {
        s2 += 1;
      }
    }
    mash = null;
    return function() {
      var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32
      s0 = s1;
      s1 = s2;
      return s2 = t - (c = t | 0);
    };
  }
  function masher() {
    var n = 0xefc8249d;
    return function(data) {
      data = data.toString();
      for (var i = 0; i < data.length; i++) {
        n += data.charCodeAt(i);
        var h = 0.02519603282416938 * n;
        n = h >>> 0;
        h -= n;
        h *= n;
        n = h >>> 0;
        h -= n;
        n += h * 0x100000000; // 2^32
      }
      return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
    };
  }

  // amd
  if (typeof define !== 'undefined' && define.amd) define(function() {return SimplexNoise;});
  // common js
  if (typeof exports !== 'undefined') exports.SimplexNoise = SimplexNoise;
  // browser
  else if (typeof window !== 'undefined') window.SimplexNoise = SimplexNoise;
  // nodejs
  if (typeof module !== 'undefined') {
    module.exports = SimplexNoise;
  }

})();

},{}],"src/systems/TokenPaperFollowSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = TokenPaperFollowSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _tokens = require("../util/tokens");

var _Assets = _interopRequireDefault(require("../util/Assets"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _simplexNoise = _interopRequireDefault(require("simplex-noise"));

var ShaderManager = _interopRequireWildcard(require("../util/ShaderManager"));

var _AnimationSystem = require("./AnimationSystem");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function TokenPaperFollowSystem(world) {
  const cardSavedEvents = world.listen(Tags.HaikuCardSaved);
  const collectedEvents = world.listen(Tags.HaikuInInventory);
  const waitingForPaperView = world.view(Tags.WaitingForTokenPaper);
  const floatingTokens = world.view([Tags.Object3D, Tags.FloatingToken]);
  const renderer = world.findTag(Tags.Renderer);
  const planeGeo = new THREE.PlaneGeometry(1, 1, 4, 4);
  const tmpPos3D = new THREE.Vector3();
  const tmpUserPos2D = new THREE.Vector2();
  const tmpPos2DB = new THREE.Vector2();
  const tmpOutArray3D = [0, 0, 0];
  const springDistanceThreshold = 5;
  const collisionDistanceThreshold = 2;
  const collisionDistanceThresholdSq = collisionDistanceThreshold * collisionDistanceThreshold;
  const random = (0, _Random.default)();
  const noise = new _simplexNoise.default(random.value);

  const floatingPaperMapPromise = _Assets.default.createGPUTexture(renderer, "image/data/floating-paper");

  const floatingPaperLinesPromise = _Assets.default.createGPUTexture(renderer, "image/data/floating-paper-lines");

  const springDistanceThresholdSq = springDistanceThreshold * springDistanceThreshold;
  const tmpCenterPos2D = new THREE.Vector2(0, 0);
  const distFromCenter = 20;
  const distFromCenterSq = distFromCenter * distFromCenter;
  const envStateEvents = world.listen([Tags.EnvironmentState, Tags.ActiveEnvironmentState]);
  let globalScaleTween = {
    value: 1
  };
  const finalBiomeEvents = world.listen(Tags.FinalBiomeResolution);
  const onOutroEvent = world.listen([Tags.EndGameState, Tags.ResetToCameraDrift]);
  return function tokenPaperSystem(dt) {
    const userTarget = world.findTag(Tags.UserTarget);
    const userPos = world.findTag(Tags.UserCharacter).position;
    tmpUserPos2D.set(userPos.x, userPos.z);

    if (finalBiomeEvents.added.length > 0) {
      (0, _AnimationSystem.tweenTo)(world, globalScaleTween, "value", 0, 1, "sineOut", 2);
    }

    if (onOutroEvent.added.length > 0) {
      floatingTokens.forEach(e => e.kill());
    }

    if (envStateEvents.changed) {
      floatingTokens.forEach(e => {
        if (e.has(Tags.FloatingTokenShouldTargetTree)) {
          e.tagOff(Tags.FloatingTokenShouldTargetTree);
          e.tagOff(Tags.FloatingTokenTargetUser);
        }
      });
    }

    collectedEvents.added.forEach(e => {
      world.entity().add(Tags.WaitingForTokenPaper);
    });
    cardSavedEvents.added.forEach(() => {
      Promise.all([floatingPaperMapPromise, floatingPaperLinesPromise]).then(([bgMap, fgMap]) => {
        waitingForPaperView.forEach(e => {
          e.remove(Tags.WaitingForTokenPaper); // const d = e.get(Tags.FinishedPoem);

          const icon = ""; //d.type;
          // const stanza = d.stanzaIndex;

          const url = _tokens.InvertedTokenURLs[icon];

          const id = _Assets.default.urlToID(url);

          const child = e.add(Tags.FloatingToken);
          const t = child.get(Tags.FloatingToken);
          child.tagOn(Tags.FloatingTokenTargetUser);
          t.type = icon;
          t.map = fgMap;
          const mesh = createPaperSprite(child, bgMap, t);
          mesh.position.copy(userPos);
          t.position2D.set(mesh.position.x, mesh.position.z);
          t.offsetHeight = random.range(1, 3);
          t.offset3D.fromArray(random.insideSphere(0.1, tmpOutArray3D));
          t.rotationAxis.fromArray(random.insideSphere(1, tmpOutArray3D));
          t.rotationSpeed = 1;
          t.scale = 0.45;
          t.speed = random.range(0.5, 1.5);
          t.rotationAngleOffset = random.range(-1, 1) * Math.PI * 2;
        });
      });
    });
    var Cd = 0.47; // Dimensionless

    var rho = 1.22; // kg / m^3

    var radius = 15;
    var A = Math.PI * radius * radius / 10000; // m^2

    var ag = 9.81; // m / s^2

    var mass = 0.1;
    var restitution = -0.7;
    var maxVel = 7;
    const canTargetTree = world.findTag(Tags.WaitingForBiomeResolution) || world.findTag(Tags.ShowBiomeResolution);
    floatingTokens.forEach(e => {
      const d = e.get(Tags.FloatingToken);
      let targetUser = e.has(Tags.FloatingTokenTargetUser) && !e.has(Tags.FloatingTokenShouldTargetTree);
      const mesh = e.get(Tags.Object3D);
      d.time += dt; // const friction = 0.99;

      if (targetUser && d.started && canTargetTree && !e.has(Tags.FloatingTokenShouldTargetTree)) {
        const lenSq = tmpUserPos2D.lengthSq();

        if (lenSq <= distFromCenterSq) {
          e.tagOn(Tags.FloatingTokenShouldTargetTree);
        }
      }

      tmpCenterPos2D.set(0, 0);
      const targetPos = targetUser ? tmpUserPos2D : tmpCenterPos2D;
      const distSq = d.position2D.distanceToSquared(targetPos);
      const pull = noise.noise4D(d.position2D.x, d.position2D.y, d.time, d.rotationAngleOffset);
      tmpPos2DB.copy(targetPos).sub(d.position2D);
      const RK = Math.sqrt(tmpPos2DB.dot(tmpPos2DB));
      const dist = Math.sqrt(distSq);
      const restingDistance = targetUser ? MathUtil.clamp(dist, 1, 2) : MathUtil.clamp(dist, 1, 2);
      const restingRatio = RK === 0 ? restingDistance : (restingDistance - RK) / RK;
      const p1mass = 1;
      const p2mass = 1;
      const im1 = 1.0 / p1mass;
      const im2 = 1.0 / p2mass;
      const stiffness = 0.075 + pull * 0.01;
      const scalarP1 = 0;
      const scalarP2 = stiffness; // d.velocity2D.addScaledVector(tmpPos2DB, scalarP1 * restingRatio);

      d.velocity2D.addScaledVector(tmpPos2DB, -scalarP2 * restingRatio * (targetUser ? d.speed : 1));
      const windAngle = d.time * 0.1; //MathUtil.degToRad(45);

      const ft = 0.5;
      const fpos = 0.25;
      const windAmp = 0.1;
      const windRadius = windAmp * noise.noise3D(d.position2D.x * fpos, d.position2D.y * fpos, d.time * ft);
      d.velocity2D.x += Math.cos(windAngle) * windRadius;
      d.velocity2D.y += Math.sin(windAngle) * windRadius;
      floatingTokens.forEach(other => {
        if (other === e) return;
        const d2 = other.get(Tags.FloatingToken);
        const distSq = d.position2D.distanceToSquared(d2.position2D);

        if (distSq <= collisionDistanceThresholdSq) {
          const dist = Math.sqrt(distSq);
          const alpha = 1 - MathUtil.clamp01(dist / collisionDistanceThreshold); // N dot pos

          tmpPos2DB.copy(d2.position2D).sub(d.position2D).normalize().multiplyScalar(alpha); // tmpPos2DB.copy(d2.velocity2D).normalize();
          // const D = tmpPos2DB.dot(d.position2D);
          // tmpPos2DB.multiplyScalar(-2 * D);

          d.velocity2D.addScaledVector(tmpPos2DB, -0.2);
        }
      });
      const curMax = targetUser ? maxVel : maxVel * 2;
      d.velocity2D.x = MathUtil.clamp(d.velocity2D.x, -curMax, curMax);
      d.velocity2D.y = MathUtil.clamp(d.velocity2D.y, -curMax, curMax);
      var vx = d.velocity2D.x;
      var vy = d.velocity2D.y;
      var Fx = -0.5 * Cd * A * rho * vx * vx * vx / Math.abs(vx);
      var Fy = -0.5 * Cd * A * rho * vy * vy * vy / Math.abs(vy);
      Fx = isNaN(Fx) ? 0 : Fx;
      Fy = isNaN(Fy) ? 0 : Fy; // Calculate acceleration ( F = ma )

      var ax = Fx / mass;
      var ay = Fy / mass; // ay += ag;
      // Integrate to get velocity

      d.velocity2D.x += ax * dt;
      d.velocity2D.y += ay * dt; // Integrate to get position

      const speed = 0.75;
      d.position2D.x += d.velocity2D.x * dt * speed;
      d.position2D.y += d.velocity2D.y * dt * speed; // d.acceleration2D.addScaledVector(d.velocity2D, -friction);
      // tmpPos2DB.copy(d.acceleration2D).multiplyScalar(0.5 * (dt * dt));
      // tmpPos2DB.addScaledVector(d.velocity2D, dt);
      // d.position2D.add(tmpPos2DB);
      // d.velocity2D.addScaledVector(d.acceleration2D, dt);

      const curSpeed = 1 + MathUtil.clamp01(d.velocity2D.length() / (maxVel / 4));
      const tf = 0.1;

      if (!targetUser) {
        d.animateToTreeTime += dt;
        const curTime = Math.max(0, d.animateToTreeTime - d.animateToTreeDelay);
        const alpha = MathUtil.clamp01(curTime / d.animateToTreeDuration);
        d.offsetY = alpha * 2;
      } else {
        d.offsetY = 0;
      } //0.5 * noise.noise2D(d.position2D.x * tf, d.position2D.y * tf);


      mesh.position.set(d.position2D.x, d.offsetHeight + d.offsetY, d.position2D.y);
      mesh.material.uniforms.time.value += dt * curSpeed;
      mesh.material.uniforms.timeOffset.value = d.rotationAngleOffset;
      mesh.position.addScaledVector(d.offset3D, 1);
      tmpPos2DB.copy(d.velocity2D).normalize();
      tmpPos2DB.set(-tmpPos2DB.y, tmpPos2DB.x);
      mesh.rotateOnWorldAxis(d.rotationAxis, curSpeed * d.rotationSpeed * dt);
      const f = 0.1;
      const a = 1;
      const xoff = a * noise.noise4D(mesh.position.x * f, mesh.position.y * f, mesh.position.z * f, 1);
      const yoff = a * noise.noise4D(mesh.position.x * f, mesh.position.y * f, mesh.position.z * f, d.rotationAngleOffset);
      tmpPos3D.set(tmpPos2DB.x, 0, tmpPos2DB.y); // mesh.position.addScaledVector(tmpPos3D, xoff);
      // const scl = MathUtil.lerp(
      //   0.25,
      //   1,
      //   Math.sin(time * 0.5 + d.rotationAngleOffset) * 0.5 + 0.5
      // );

      const delay = 0.0;
      const curTime = Math.max(0, d.time - delay);

      if (curTime >= 0 && !d.started) {
        d.started = true;
        d.position2D.copy(tmpUserPos2D);
        d.velocity2D.set(0, 0);
      }

      const scl = MathUtil.clamp01(curTime / 2);
      mesh.scale.setScalar(Math.max(1e-5, d.scale * scl * globalScaleTween.value));
      mesh.visible = scl > 1e-5;
      mesh.position.y += yoff; // d.position2D.add(d.velocity2D);
      // d.velocity2D.multiplyScalar(0.99);
      // tmpPos2DB.set(mesh.position.x, mesh.position.z);
      // if (
      //   tmpUserPos2D.distanceToSquared(tmpPos2DB) >= springDistanceThresholdSq
      // ) {
      //   tmpPos3D.copy(userPos);
      //   tmpPos3D.y = mesh.position.y;
      //   dampVector(mesh.position, tmpPos3D, 1, dt, mesh.position);
      // }
    });
  };

  function createPaperSprite(entity, bgMap, data) {
    const bloom = 0.1;
    const base = 1.0;
    const planeMat = ShaderManager.create({
      name: "TokenPaper",
      uniforms: {
        color: {
          value: new THREE.Color(base + bloom, base + bloom, base + bloom)
        },
        map: {
          value: data.map
        },
        backgroundMap: {
          value: bgMap
        },
        mapScale: {
          value: 1.25
        },
        time: {
          value: 0
        },
        opacity: {
          value: 1
        },
        timeOffset: {
          value: 1
        }
      },
      side: THREE.DoubleSide,
      blending: THREE.CustomBlending,
      blendEquation: THREE.AddEquation,
      blendSrc: THREE.OneFactor,
      blendDst: THREE.OneMinusSrcAlphaFactor,
      transparent: true,
      vertexShader:
      /*glsl*/
      `
        varying vec2 vUv;
        uniform float mapScale;
        uniform float timeOffset;
        uniform float time;

        mat3 rotation3dY(float angle) {
        	float s = sin(angle);
        	float c = cos(angle);

        	return mat3(
        		c, 0.0, -s,
        		0.0, 1.0, 0.0,
        		s, 0.0, c
        	);
        }

        void main () {
          vec2 nuv = uv * 2.0 - 1.0;
          nuv *= mapScale;
          vUv = nuv * 0.5 + 0.5;
          vec3 transformed = position.xyz;
          float angle = sin(time + timeOffset + position.x);
          transformed *= rotation3dY(angle);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
        }
      `,
      fragmentShader:
      /*glsl*/
      `
        varying vec2 vUv;
        uniform sampler2D map;
        uniform sampler2D backgroundMap;
        uniform float opacity;
        uniform vec3 color;

        vec4 blend(vec4 background, vec4 foreground) {
            return (foreground.rgba * foreground.a) + background.rgba * (1.0 - foreground.a);
        }

        void main () {
          vec3 curColor = vec3(color);

          vec4 outColor = texture2D(backgroundMap, vUv) * vec4(color, 1.0);
          // vec4 outColor = vec4(color, 1.0);
          vec4 fgColor = texture2D(map, vUv);
          
          // outColor.rgb *= 1.0 - fgColor.a;
          // outColor = blend(outColor, fgColor);
          gl_FragColor = vec4(outColor);
          gl_FragColor.a *= opacity;
          // if (gl_FragColor.a <= 0.1) discard;
        }
      `
    });
    const mesh = new THREE.Mesh(planeGeo, planeMat);
    mesh.scale.setScalar(1);
    entity.add(Tags.Object3D, mesh);
    return mesh;
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/tokens":"src/util/tokens.js","../util/Assets":"src/util/Assets.js","../util/math":"src/util/math.js","../util/Random":"src/util/Random.js","simplex-noise":"node_modules/simplex-noise/simplex-noise.js","../util/ShaderManager":"src/util/ShaderManager.js","./AnimationSystem":"src/systems/AnimationSystem.js"}],"src/systems/SceneSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SceneSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _threeUtil = require("../util/three-util");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function SceneSystem(world) {
  world.system.info({
    hidden: true
  });
  const events = world.listen(Tags.Object3D);
  const MainScene = world.query(Tags.MainScene);
  return function sceneSystem() {
    const scene = world.findTag(MainScene);
    if (!scene || !events.changed) return;
    events.added.forEach(e => {
      if (!e.has(Tags.Object3D)) return;
      const obj = e.get(Tags.Object3D);

      if (obj && !obj.parent) {
        scene.add(obj);
        obj.updateMatrixWorld();
      }
    });
    events.removing.forEach(e => {
      if (!e.has(Tags.Object3D)) return;
      const obj = e.get(Tags.Object3D);

      if (obj && !e.has(Tags.Object3DKeepAlive)) {
        (0, _threeUtil.detachObject)(obj);
      }
    });
  };
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/three-util":"src/util/three-util.js"}],"src/systems/InputSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = InputSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _array = require("../util/array");

var _tinyEvent = _interopRequireDefault(require("../util/tiny-event"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function InputSystem(world, opts = {}) {
  const canvas = world.findTag(Tags.Canvas);
  let currentTouchID = null;
  let currentTouches = [];
  let hasTouchEvents = false;
  const emitter = new _tinyEvent.default(); // const POINTER = document.body.appendChild(document.createElement("div"));
  // Object.assign(POINTER.style, {
  //   position: "fixed",
  //   top: "0px",
  //   pointerEvents: "none",
  //   left: "0px",
  //   transform: "translate(-25px, -25px)",
  //   width: "50px",
  //   height: "50px",
  //   borderRadius: "100%",
  //   background: "red",
  //   zIndex: "200000000",
  // });

  const e = world.entity("InputEntity").add(Tags.InputState);
  const appState = world.findTag(Tags.AppState);
  const inputState = e.get(Tags.InputState);
  const rawState = {
    x: window.innerWidth / 2,
    y: window.innerHeight / 2,
    multitouch: null,
    interacted: false,
    ctrlKey: false,
    metaKey: false,
    shiftKey: false,
    pressed: false
  };

  const keydown = ev => _copyKeys(ev, rawState);

  const keyup = ev => _copyKeys(ev, rawState);

  const passive = {
    passive: true
  };
  window.addEventListener("keydown", keydown, passive);
  window.addEventListener("keyup", keyup, passive);
  window.addEventListener("mousemove", mousemove, passive);
  window.addEventListener("mouseup", mouseup, passive);
  canvas.addEventListener("mousedown", mousedown, passive);
  canvas.addEventListener("touchstart", touchstart, {
    passive: false
  });
  window.addEventListener("touchend", touchend, passive);
  window.addEventListener("touchmove", touchmove);
  canvas.addEventListener("contextmenu", contextmenu);
  world.entity().add(Tags.InputGestureEmitter, emitter);

  const tapper = ev => emitter.emit("tap", ev);

  window.addEventListener("touchend", tapper, passive);
  window.addEventListener("click", tapper, passive);
  canvas.addEventListener("mousedown", tapper, passive); // window.addEventListener("touchend", ev => {
  //   rawState.pressed = false;
  // }, passive);

  const gestureEntity = world.entity();
  const clearInputPressTags = world.view(Tags.ClearInputPress);
  return {
    process(dt) {
      inputState.position.x = rawState.x;
      inputState.position.y = rawState.y;
      inputState.positionNormalized.x = rawState.x / appState.width;
      inputState.positionNormalized.y = rawState.y / appState.height;
      inputState.pressed = rawState.pressed;
      inputState.metaKey = rawState.metaKey;
      inputState.ctrlKey = rawState.ctrlKey;
      inputState.shiftKey = rawState.shiftKey;
      inputState.interacted = rawState.interacted;
      inputState.multitouch = rawState.multitouch;

      if (!gestureEntity.has(Tags.UserInitiatedGesture) && inputState.pressed) {
        gestureEntity.add(Tags.UserInitiatedGesture);
      } // console.log(inputState.pressed);


      const uiActive = world.findTag(Tags.IsGameUIActive);
      const clearPress = clearInputPressTags.length > 0;

      if (uiActive || clearPress) {
        inputState.pressed = false;
        rawState.pressed = false; // if (clearPress) {

        inputState.interacted = false;
        rawState.interacted = false;
        clearInputPressTags.forEach(e => {
          e.tagOff(Tags.ClearInputPress);
        }); // }
      } // Object.assign(POINTER.style, {
      //   backgroundColor: inputState.pressed ? "green" : "red",
      //   top: `${inputState.position.y}px`,
      //   left: `${inputState.position.x}px`,
      // });

    },

    dispose() {
      canvas.removeEventListener("contextmenu", contextmenu);
      window.removeEventListener("mousedown", mousedown);
      window.removeEventListener("mousemove", mousemove);
      canvas.removeEventListener("touchstart", touchstart);
      window.removeEventListener("touchend", touchend);
      window.removeEventListener("touchmove", touchmove);
      window.removeEventListener("keydown", keydown);
      window.removeEventListener("keyup", keyup);
      window.removeEventListener("touchend", tapper);
      window.removeEventListener("click", tapper);
      window.removeEventListener("mousedown", tapper);
    }

  };

  function contextmenu(ev) {
    if ("development" !== "development") {
      ev.preventDefault();
      return false;
    }
  }

  function findEarliestTouch(ev) {
    const id = earliestTouchID();
    return findTouchByID(ev, id) || ev.changedTouches[0];
  }

  function findTouchByID(ev, id) {
    let touch;

    if (id != null) {
      for (let i = 0; i < ev.touches.length; i++) {
        if (ev.touches[i].identifier === id) return ev.touches[i];
      }
    }

    return null;
  }

  function earliestTouchID() {
    let minId = Infinity;

    for (let i = 0; i < currentTouches.length; i++) {
      const id = currentTouches[i];

      if (id < minId) {
        minId = id;
      }
    }

    return isFinite(minId) ? minId : null;
  }

  function touchstart(ev) {
    hasTouchEvents = true;
    const shouldIgnore = shouldIgnoreTap();
    if (shouldIgnore) return;
    let touch;

    if (currentTouchID == null) {
      // no ID yet assigned
      touch = ev.changedTouches[0];
      currentTouchID = touch.identifier; // trigger event start

      ev.preventDefault();
      rawState.pressed = true;

      _copyEvent(ev, rawState);

      _copyClientXY(touch, rawState);
    }

    rawState.multitouch = ev.touches.length > 1;
  }

  function touchend(ev) {
    const shouldIgnore = shouldIgnoreTap();
    if (shouldIgnore) return;
    const prevID = currentTouchID;

    if (currentTouchID) {
      // first check if the touch still exists
      const t = findTouchByID(currentTouchID);
      if (!t) currentTouchID = null;
    } // now see if the changed touch matches our ID


    if (currentTouchID != null) {
      for (let i = 0; i < ev.changedTouches.length; i++) {
        const t = ev.changedTouches[i];

        if (t.identifier === currentTouchID) {
          // console.log("press1copy!");
          _copyClientXY(t, rawState);

          currentTouchID = null;
          break;
        }
      }
    } // we've lost our touch, see if there's another one we should pick up


    if (!currentTouchID) {
      for (let i = 0; i < ev.touches.length; i++) {
        const t = ev.touches[i];

        if (t.identifier !== prevID) {
          currentTouchID = t.identifier;
          rawState.pressed = true; // console.log("press2!");

          _copyClientXY(t, rawState);

          break;
        }
      }
    } // still none... just take first


    if (!currentTouchID && ev.touches.length >= 1) {
      const t = ev.touches[0];
      currentTouchID = t.identifier;
      rawState.pressed = true; // console.log("press3!");

      _copyClientXY(t, rawState);
    }

    if (!currentTouchID) {
      rawState.pressed = false;
    }

    _copyEvent(ev, rawState);

    rawState.multitouch = ev.touches.length > 1;
  }

  function touchmove(ev) {
    const shouldIgnore = shouldIgnoreTap();
    if (shouldIgnore) return;

    if (currentTouchID == null) {
      // odd case here, we have no touch registered, find the first one...
      currentTouchID = ev.changedTouches[0].identifier;
    }

    for (let i = 0; i < ev.changedTouches.length; i++) {
      const t = ev.changedTouches[i];

      if (t.identifier === currentTouchID) {
        rawState.pressed = true; // ev.preventDefault();

        _copyClientXY(t, rawState);

        _copyEvent(ev, rawState);

        break;
      }
    }

    rawState.multitouch = ev.touches.length > 1;
  }

  function mousedown(ev) {
    if (ev.button !== 0) return;
    if (shouldIgnoreTap()) return;

    _copyEvent(ev, rawState);

    _copyClientXY(ev, rawState);

    rawState.pressed = true;
    gestureEntity.add(Tags.TriggerMovementGesture);
    gestureEntity.remove(Tags.TriggerMovementGesture);
  }

  function mouseup(ev) {
    if (ev.button !== 0) return;
    if (shouldIgnoreTap()) return; // if (hasTouchEvents && rawState.pressed) {
    //   return;
    // }

    _copyEvent(ev, rawState);

    _copyClientXY(ev, rawState);

    rawState.pressed = false;
  }

  function mousemove(ev) {
    if (ev.button !== 0) return;
    if (shouldIgnoreTap()) return; // if (hasTouchEvents && rawState.pressed) {
    //   return;
    // }
    // console.log(ev);

    _copyEvent(ev, rawState);

    _copyClientXY(ev, rawState);
  }

  function _copyKeys(ev, state) {
    if (ev.shiftKey != null) state.shiftKey = ev.shiftKey;
    if (ev.metaKey != null) state.metaKey = ev.metaKey;
    if (ev.ctrlKey != null) state.ctrlKey = ev.ctrlKey;
  }

  function shouldIgnoreTap() {
    // const uiActive = world.findTag(Tags.IsGameUIActive);
    // return uiActive;
    return false;
  }

  function _copyClientXY(ev, state) {
    state.x = ev.clientX;
    state.y = ev.clientY;
    inputState.x = state.x;
    inputState.y = state.y; // console.log("new copy", state.x, state.y);
  }

  function _copyEvent(ev, state) {
    state.interacted = true;

    _copyKeys(ev, state);
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/array":"src/util/array.js","../util/tiny-event":"src/util/tiny-event.js"}],"src/shaders/sprite.frag.js":[function(require,module,exports) {
module.exports = "#define GLSLIFY 1\nvarying vec2 originalUv;\nvarying vec2 vUv;\nvarying float vYGradient;\nvarying vec2 vGroundUv;\nuniform sampler2D map;\nuniform sampler2D noiseMap;\nuniform float time;\nuniform bool useMapDiscard;\nvarying vec3 vObjectCoord;\nvarying vec2 vScreenScale;\nuniform vec3 color;\nuniform float aspect;\nuniform float spriteHeight;\nvarying vec3 vWorldPosition;\nvarying vec3 vGroundColor;\nvarying float vDataScale;\nvarying vec3 vBaseWorldPosition;\nvarying vec3 vCenterWorldPos;\nuniform sampler2D groundMap;\nuniform bool silhouette;\nuniform vec3 tintColor;\nuniform vec3 shadowColor;\n// varying float vSpin;\n\n// void main () {\n//   gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n//   gl_FragColor += texture2D(map, vUv);\n// }\n\nvoid main () {\n  gl_FragColor = texture2D(map, vUv);\n  gl_FragColor.rgb *= tintColor;\n  // gl_FragColor.a = 1.0;\n  float alphaMap = gl_FragColor.a;\n  if (alphaMap < 0.5) discard;\n  if (silhouette) {\n    // float vYGrad0 = 1.0 - pow(clamp(vYGradient / 1.0, 0.0, 1.0), 1.0);\n    // gl_FragColor.a *= 1.0 - clamp(distance(vCenterWorldPos, vWorldPosition) / 1.0, 0.0, 0.5);\n    \n    float falloff = 1.0 - clamp(pow(vWorldPosition.y / 1.0, 1.0), 0.0, 1.0);\n    // float falloff = 1.0 - clamp(pow(distance(vCenterWorldPos, vWorldPosition) / 2.75, 1.0), 0.0, 1.0);\n    float shadowOpacity = 0.25;\n    gl_FragColor.rgb = mix(vec3(1.0), shadowColor, alphaMap * falloff * shadowOpacity);\n    gl_FragColor.a = 1.0;\n    // gl_FragColor.rgb = vec3(shadowColor);\n    // gl_FragColor.a *= ;\n    // gl_FragColor.rgb *= gl_FragColor.a;\n    // gl_FragColor.a = 1.0;\n    // gl_FragColor.a *= vUv.y;\n  } \n\n  // else {\n    // vec3 fogColor = texture2D(groundMap, vGroundUv).rgb;\n    // vec3 fogColor = vGroundColor;\n    // gl_FragColor.rgb *= color;\n    // gl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor, 0.2);\n    // gl_FragColor.rgb = gl_FragColor.rgb + fogColor * 0.1;\n    // gl_FragColor.rgb = mix(gl_FragColor.rgb, gl_FragColor.rgb + fogColor, 0.2);\n\n    // float vFog0 = 1.0 - pow(clamp(vWorldPosition.y / 0.5, 0.0, 1.0), 0.25);\n    // float yoff = sin(time + fract(vCenterWorldPos.x * 100.0 + vCenterWorldPos.z * 100.0));\n    // float ypos = max(0.0, vWorldPosition.y + yoff * 0.0);\n    // float vFog1 = 1.0 - pow(clamp(ypos / 4.0, 0.0, 1.0), 0.5);\n    // gl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor, vFog0);\n    // float vStr = 0.33;\n    // gl_FragColor.rgb = mix(gl_FragColor.rgb, fogColor + 0.1, vFog1 * vStr);\n  // }\n\n  // TODO: Screen door\n  // Will have to be done with another render target perhaps? render character\n  // and other key features (tokens) to it as black/white mask, then texture fetch\n  // the mask in this shader to see if we need to do transparency or not\n  // screenDoor(0.65);\n\n}\n";
},{}],"src/shaders/sprite.vert.js":[function(require,module,exports) {
module.exports = "#define GLSLIFY 1\n#define PI 3.1415926538\n\nuniform float rotation;\nuniform vec2 repeat;\nuniform vec2 offset;\nuniform float flip;\nuniform float time;\n\nuniform sampler2D worldDataMap;\nuniform mat4 worldDataProjection;\nuniform mat4 worldDataView;\nuniform float spriteHeight;\nuniform bool silhouette;\n\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\n\nvoid main () {\n  vUv = uv;\n  vUv *= repeat;\n  vUv += offset;\n\n  vec3 centerWorldPos = (modelMatrix * vec4(vec3(0.0), 1.0)).xyz;\n  vec3 camRightWorld = vec3(viewMatrix[0].x, viewMatrix[1].x, viewMatrix[2].x);\n  vec3 camUpWorld = vec3(viewMatrix[0].y, viewMatrix[1].y, viewMatrix[2].y);\n  \n  vec2 scale;\n  scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n  scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n  scale.x *= flip;\n\n  vec4 vDataUvPos4 = worldDataProjection * worldDataView * vec4(centerWorldPos.xz, 0.0, 1.0);\n  vec2 vDataScreen = vDataUvPos4.xy / vDataUvPos4.w;\n  vec2 vDataUv = vDataScreen.xy * 0.5 + 0.5;\n  vec3 dCol = texture2D(worldDataMap, vDataUv).rgb;\n\n  vec3 offsetPos = position.xyz;\n  vec3 vertexWorldPos = centerWorldPos\n    + camRightWorld * offsetPos.x * scale.x\n    + camUpWorld * offsetPos.y * scale.y;\n\n  vec3 realVertexWorldPos = vertexWorldPos;\n\n  vec3 vertexWorldBasePos = centerWorldPos;\n  vec2 curDirection2D = vec2(dCol.gb) * 2.0 - 1.0;\n  vec3 curDirection = vec3(curDirection2D.x, 0.0, curDirection2D.y);\n  float gradientY = clamp(vertexWorldPos.y / 0.25, 0.0, 1.0);\n  // vertexWorldPos += 0.05 * scale.y * camRightWorld * sin(time*7.0) * pow(dCol.r, 2.0) * gradientY;\n  vertexWorldPos += 0.05 * position.y * spriteHeight * camRightWorld * sin(time*7.0) * curDirection * pow(dCol.r, 2.0) * gradientY;\n\n  if (silhouette) {\n    float xSkew = -60.0 * (PI/180.0);\n    float ySkew = 0.0;\n\n    // Create a transform that will skew our texture coords\n    // mat3 trans = mat3(\n    //   1.0       , tan(xSkew), 0.0,\n    //   tan(ySkew), 1.0,        0.0,\n    //   0.0       , 0.0,        1.0\n    // );\n    vertexWorldPos.y *= 0.25;\n    vertexWorldPos.xyz -= camRightWorld * realVertexWorldPos.y * 0.5;\n    vertexWorldPos.z += -0.15;\n    // vertexWorldPos.x += -0.05;\n    // vertexWorldPos.xyz += vYGradient * camRightWorld * -0.5;\n    // vertexWorldPos.y *= 1.0;\n    // vertexWorldPos.xyz -= centerWorldPos;\n    // // vertexWorldPos.xyz *= rotation3dX(PI / -4.0);\n    // vertexWorldPos *= rotationMatrix(camRightWorld, PI / 2.0);\n    // vertexWorldPos.xyz += centerWorldPos;\n    // vertexWorldPos += vYGradient * camRightWorld * -0.5;\n    // vertexWorldPos *= offsetPos.y * camRightWorld * -2.0;\n    // vertexWorldPos.z *= 0.5;\n  }\n\n  vWorldPosition = vertexWorldPos;\n  gl_Position = projectionMatrix * viewMatrix * vec4(vertexWorldPos, 1.0);\n}\n";
},{}],"src/shaders/toon.frag.js":[function(require,module,exports) {
module.exports = "#define GLSLIFY 1\n#ifdef HAS_INTENSITY\nvarying float vIntensity;\n#endif\n\n#ifdef HAS_VERTEX_COLORS\nvarying vec3 vVertexColor;\n#endif\n\nuniform bool ignoreGround;\nvarying vec2 vUv;\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\nvarying vec2 vBillboardUV;\n\nuniform float alphaTest;\n\nuniform vec3 cameraDirection;\nuniform vec3 lightDirection;\nuniform vec3 lightPosition;\nuniform mat3 normalMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform sampler2D map;\nuniform sampler2D overlayMap;\nuniform vec3 color;\nuniform vec3 colorA;\nuniform vec3 colorB;\nuniform vec3 minBounds;\nuniform vec3 maxBounds;\nuniform vec3 overlayColor;\nuniform vec2 resolution;\nuniform float groundBounceStrength;\nuniform float groundBounceLow;\nuniform float groundBounceHigh;\nuniform bool groundBounce;\n\nvarying vec2 vGroundUv;\nuniform sampler2D groundTexture;\nuniform bool groundTextureEnabled;\n\n// uniform sampler2D noiseMap;\nuniform sampler2D normalMap;\n\nuniform bool flipNormalY;\nuniform bool debugNormals;\nuniform bool useNormalMap;\nuniform bool diffuseShading;\nuniform bool celShading;\nuniform bool darkShading;\nuniform bool vertexColors;\nuniform bool useOverlayMap;\nuniform bool useDiffuseMap;\n\nfloat range(float vmin, float vmax, float value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nvec2 range(vec2 vmin, vec2 vmax, vec2 value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nvec3 range(vec3 vmin, vec3 vmax, vec3 value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nvec4 range(vec4 vmin, vec4 vmax, vec4 value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendOverlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_0 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_0;\n  vec3 i1 = min( g_0.xyz, l.zxy );\n  vec3 i2 = max( g_0.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n\nfloat dither4x4_0(vec2 position, float brightness) {\n  int x = int(mod(position.x, 4.0));\n  int y = int(mod(position.y, 4.0));\n  int index = x + y * 4;\n  float limit = 0.0;\n\n  if (x < 8) {\n    if (index == 0) limit = 0.0625;\n    if (index == 1) limit = 0.5625;\n    if (index == 2) limit = 0.1875;\n    if (index == 3) limit = 0.6875;\n    if (index == 4) limit = 0.8125;\n    if (index == 5) limit = 0.3125;\n    if (index == 6) limit = 0.9375;\n    if (index == 7) limit = 0.4375;\n    if (index == 8) limit = 0.25;\n    if (index == 9) limit = 0.75;\n    if (index == 10) limit = 0.125;\n    if (index == 11) limit = 0.625;\n    if (index == 12) limit = 1.0;\n    if (index == 13) limit = 0.5;\n    if (index == 14) limit = 0.875;\n    if (index == 15) limit = 0.375;\n  }\n\n  return brightness < limit ? 0.0 : 1.0;\n}\n\nvec3 dither4x4_0(vec2 position, vec3 color) {\n  return color * dither4x4_0(position, luma(color));\n}\n\nvec4 dither4x4_0(vec2 position, vec4 color) {\n  return vec4(color.rgb * dither4x4_0(position, luma(color)), 1.0);\n}\n\nvec3 faceNormals(vec3 pos) {\n  vec3 fdx = dFdx(pos);\n  vec3 fdy = dFdy(pos);\n  return normalize(cross(fdx, fdy));\n}\n\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\n  // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n  vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n  vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n  vec2 st0 = dFdx( vUv.st );\n  vec2 st1 = dFdy( vUv.st );\n\n  float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n  vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n  vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n  vec3 N = normalize( surf_norm );\n\n  mat3 tsn = mat3( S, T, N );\n\n  mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n  return normalize( tsn * mapN );\n\n}\nfloat aastep(float threshold, float value) {\n  float change = fwidth(value) * 0.5;\n  float lo = threshold - change;\n  float hi = threshold + change;\n  return smoothstep(threshold - change, threshold + change, value);\n}\n\nfloat aastep1(float threshold, float value) {\n  float change = fwidth(value) * 0.5;\n  float lo = threshold - change;\n  float hi = threshold + change;\n  return clamp((value - lo) / (hi - lo), 0.0, 1.0);\n}\n// float aastep(float threshold, float value) {\n//   float change = fwidth(value) * 0.5;\n//   // float change = fwidth(value) * 0.5;\n//   // float change = fwidth(value) * 0.5;\n//   // float change = 0.1;\n//   float lo = threshold - change;\n//   float hi = threshold + change;\n//   return clamp((value - lo) / (hi - lo), 0.0, 1.0);\n// }\n\nvec4 blend(vec4 background, vec4 foreground) {\n    return (foreground.rgba * foreground.a) + background.rgba * (1.0 - foreground.a);\n}\n\nfloat roundf (float f) {\n  return floor(f + 0.5);\n}\n\n// float fastnoise3D(vec3 p)\n// {\n//   p.z = fract(p.z)*256.0;\n//   float iz = floor(p.z);\n//   float fz = fract(p.z);\n//   vec2 a_off = vec2(23.0, 29.0)*(iz)/256.0;\n//   vec2 b_off = vec2(23.0, 29.0)*(iz+1.0)/256.0;\n//   float a = texture2D(noiseMap, p.xy + a_off).r;\n//   float b = texture2D(noiseMap, p.xy + b_off).r;\n//   return mix(a, b, fz);\n// }\n\nfloat dither4x4(vec2 position, float brightness) {\n  int x = int(mod(position.x, 4.0));\n  int y = int(mod(position.y, 4.0));\n  int index = x + y * 4;\n  float limit = 0.0;\n\n  if (x < 8) {\n    if (index == 0) limit = 0.0625;\n    if (index == 1) limit = 0.5625;\n    if (index == 2) limit = 0.1875;\n    if (index == 3) limit = 0.6875;\n    if (index == 4) limit = 0.8125;\n    if (index == 5) limit = 0.3125;\n    if (index == 6) limit = 0.9375;\n    if (index == 7) limit = 0.4375;\n    if (index == 8) limit = 0.25;\n    if (index == 9) limit = 0.75;\n    if (index == 10) limit = 0.125;\n    if (index == 11) limit = 0.625;\n    if (index == 12) limit = 1.0;\n    if (index == 13) limit = 0.5;\n    if (index == 14) limit = 0.875;\n    if (index == 15) limit = 0.375;\n  }\n\n  return brightness < limit ? 0.0 : 1.0;\n}\n\nfloat fcos( float x )\n{\n  float w = fwidth(x);\n  // return cos(x) * smoothstep( 3.14*2.0, 0.0, w );\n  return cos(x) * smoothstep(3.14*2.0, 0.0, w);\n}\nfloat hash(vec3 p) {\n  // return fract(sin(p.x * 1e2 + p.y) * 1e5 + sin(p.y * 1e3) * 1e3 + sin(p.x * 735. + p.y * 11.1) * 1.5e2);\n  float a = 0.0;\n  a += 0.25 * cos(p.x * 10.0 + 20.0);\n  a += 0.5 * cos(p.y * 10.0 + 40.0);\n  // a += 0.33 * cos(p.z * 10.0 + 60.0);\n  return a;\n}\n\n// GLSL smootherstep [smthrstp] from http://graphicscodex.com for reference\nfloat smootherstep(float start, float end, float t) {\n   t = max(0.0, min(1.0, (t - start) / (end - start)));\n   return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat Value3D( vec3 P )\n{\n  //  https://github.com/BrianSharpe/Wombat/blob/master/Value3D.glsl\n  // establish our grid cell and unit position\n  vec3 Pi = floor(P);\n  vec3 Pf = P - Pi;\n  vec3 Pf_min1 = Pf - 1.0;\n\n  // clamp the domain\n  Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n  vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n  // calculate the hash\n  vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n  Pt *= Pt;\n  Pt = Pt.xzxz * Pt.yyww;\n  vec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n  vec4 hash_lowz = fract( Pt * hash_mod.xxxx );\n  vec4 hash_highz = fract( Pt * hash_mod.yyyy );\n\n  // blend the results and return\n  vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n  vec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n  vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n  return dot( res0, blend2.zxzx * blend2.wwyy ) * 2.0 - 1.0;\n}\n// void main () {\n//   gl_FragColor = vec4(1.0);\n// }\n\nvoid main () {\n  #ifdef HAS_INTENSITY\n  float intensity = vIntensity;\n  #else\n  float intensity = 1.0;\n  #endif\n\n  vec3 vLightDir = -lightDirection;\n  vec3 L = normalize(vLightDir);\n  vec3 V = normalize(vViewPosition);\n  vec3 N = vNormal;\n  vec4 diffuseColorRGBA = texture2D(map, vUv).rgba;\n  vec3 diffuseColor = diffuseColorRGBA.rgb;\n  float H = hash(vWorldPosition.xyz);\n\n  vec3 mapN = texture2D(normalMap, vUv).xyz;\n  if (flipNormalY) mapN.y = 1.0 - mapN.y;\n  mapN = mapN * 2.0 - 1.0;\n\n  vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\t// N = normalize( cross( fdx, fdy ) );\n\n  if (useNormalMap) {\n    N = normalize(perturbNormal2Arb( -vViewPosition, N, mapN ));\n  }\n\n  // vec3 normalized = range(minBounds, maxBounds, vWorldPosition);\n\n  vec3 minGrounded = minBounds;\n  minGrounded.y = max(0.0, minGrounded.y);\n  vec3 maxGrounded = maxBounds;\n  maxGrounded.y = max(0.0, maxGrounded.y);\n  vec3 normalized = range(minGrounded, maxGrounded, vWorldPosition);\n\n  float diffuse = (0.5 * dot(N, L)) + 0.5;\n  \n  // vec3 randomNoise3 = vec3(texture2D(noiseMap, vBillboardUV)).xyz * 2.0 - 1.0;\n  vec3 randomNoise3 = vec3(0.0);\n  float randomNoise = randomNoise3.x * 0.01;\n\n  \n  float hNoise = Value3D(vWorldPosition.xyz * 30.0);\n\n  float diffuseStep = 0.0;\n  // diffuseStep *= aastep(0.25, diffuse);\n  // diffuseStep = mix(diffuseStep, 0.5, aastep(0.5, diffuse));\n  // diffuseStep = aastep(0.75, diffuse + diffuseColor.r * 0.02);\n  // diffuseStep += aastep(0.25, diffuse + diffuseColor.g * 0.02) * 0.5;\n  // diffuseStep = min(diffuseStep, 1.0);\n\n  // diffuseStep = aastep(0.25, diffuse);\n\n  // diffuseStep *= dither(vPosition.xz * 10.0, diffuse);\n\n  // if (diffuse <= 0.2) {\n  //   diffuseStep = 0.0;\n  // } else if (diffuse <= 0.25) {\n  //   diffuseStep = 1.0;\n  // }\n\n  // float highlightLow = 0.5;\n  // float highlightHigh = 0.75;\n  // float diffuseStepHigh = aastep(0.5, smoothstep(\n  //   0.5, 0.75, diffuse\n  // ));\n  // float diffuseStepLow = aastep(0.5, smoothstep(\n  //   0.0, 0.25, diffuse\n  // ));\n\n  vec3 camUpWorld = vec3(viewMatrix[0].y, viewMatrix[1].y, viewMatrix[2].y);\n  vec3 VC = normalize(camUpWorld);\n  // vec3 VC = normalize(cross(camRightWorld, camUpWorld));\n  // vec3 VC = normalize(cameraDirection);\n  float vDotN = 1.0 - clamp(dot(V, N), 0.0, 1.0);\n  float rim = aastep(0.5, vDotN + hNoise * 0.05);\n\n  // float gradient = pow(clamp(vWorldPosition.y / 2.0, 0.0, 1.0), 1.0);\n\n  // float ramp = intensity;\n  // if (diffuseShading) {\n  //   ramp = diffuse;\n  // } else {\n  //   ramp = diffuseStep;\n  //   // if (celShading) ramp = mix(intensity * 0.75, 1.0, diffuseStep);\n  //   // if (darkShading) ramp = mix(0.0, ramp, rim);\n  // }\n\n  vec3 gtex = texture2D(groundTexture, vGroundUv).rgb;\n\n// gl_FragColor.rgb = mix(gl_FragColor.rgb, gl_FragColor.rgb * diffuse, 0.5);\n\n  float highCut = 0.75;\n  float lowCut = 0.15;\n  // float midRangeOpacity = 0.33;\n  // float lowRangeOpacity = 0.5;\n  // gl_FragColor.rgb = mix(gl_FragColor.rgb, gl_FragColor.rgb * (aastep(highCut, diffuse)), midRangeOpacity);\n  // gl_FragColor.rgb = mix(gl_FragColor.rgb, gl_FragColor.rgb * rim, lowRangeOpacity);\n  // gl_FragColor.rgb = mix(gl_FragColor.rgb, gl_FragColor.rgb * (aastep(lowCut, diffuse)), lowRangeOpacity);\n\n  gl_FragColor.rgb = vec3(1.0);\n  // gl_FragColor.rgb = diffuseShading ? vec3(diffuse) : vec3(1.0);\n  // gl_FragColor.rgb = diffuseShading ? vec3(diffuse) : vec3(1.0);\n  if (useDiffuseMap) gl_FragColor.rgb *= diffuseColor.rgb;\n  // float highCutStep = smoothstep(0.75, 1.0, diffuse);\n  float bounce = 0.75;\n  float bounceCut = smoothstep(0.5, 0.25, diffuse);\n\n  // float lowCutStep = 1.0 - rim;\n  float lowCutStep = 1.0 - smoothstep(groundBounceLow, groundBounceHigh, diffuse + hNoise * 0.01);\n  // float lowCutStep = 1.0 - aastep(0.1, diffuse + hNoise * 0.01);\n  // float highCutStep = aastep(0.75, diffuse + hNoise * 0.01);\n  // float bounceCut = 1.0-aastep(0.25, diffuse);\n\n  // if (groundBounce) gl_FragColor.rgb = mix(gl_FragColor.rgb, gl_FragColor.rgb * gtex.rgb, lowCutStep * groundBounceStrength);\n  // gl_FragColor.rgb = mix(gl_FragColor.rgb, gl_FragColor.rgb * gtex.rgb * 0.35, (1.0 - rim) * 1.0);\n\n  // float overlay = texture2D(overlayMap, vUv).r;\n  // if (useDiffuseMap) {\n  //   gl_FragColor.rgb *= diffuseColor;\n  // }\n\n  // if (diffuseShading) gl_FragColor.rgb *= diffuse;\n  // else gl_FragColor.rgb = blendOverlay(gl_FragColor.rgb, mix(colorA, colorB, diffuseStep));\n\n  // if (useOverlayMap) {\n  //   vec4 overlayColor4 = vec4(vec3(overlayColor), (1.0 - overlay) * rim);\n  //   gl_FragColor = blend(gl_FragColor, overlayColor4);\n  // }\n\n  if (groundTextureEnabled && !ignoreGround) {\n    // float ny = normalized.y;\n    float ny = vWorldPosition.y / 0.75 + hNoise * 0.1;\n    // float ny = normalized.y + (useDiffuseMap ? -0.01*(diffuseColor.r) : 0.0);\n    float pv = smootherstep(0.0, 0.35, ny);\n    // float pv = aastep(0.5, smootherstep(0.05, 0.5, ny));\n    // gl_FragColor.rgb = vec3(pv);\n    gl_FragColor.rgb = mix(gtex, gl_FragColor.rgb, pv);\n  }\n\n  // gl_FragColor.rgb = vec3(hNoise);\n  if (debugNormals) gl_FragColor.rgb = N * 0.5 + 0.5;\n  \n  gl_FragColor.a = 1.0;\n  if (diffuseColorRGBA.a < alphaTest) discard;\n  // gl_FragColor.rgb = vec3(randomNoise3.x * 0.5 + 0.5);\n\n}\n\n// void mai2n () {\n//   float noff = 0.0;//noise(vec3(vPosition * 12.0));\n//   // float noff = noise(vec3(vPosition * 12.0));\n//   vec3 col = texture2D(map, vUv).rgb;\n//   // vec3 col = texture2D(map, vUv + vec2(0.0, noff * 0.03)).rgb;\n\n//   float y0, y1;\n//   // if (vUv.y <= (550.0/1024.0)) {\n//   //   y0 = 576.0/1024.0;\n//   //   y1 = 1.0;\n//   // } else {\n//   //   y0 = 64.0/1024.0;\n//   //   y1 = 512.0/1024.0;\n//   // }\n//   float py = vUv.y * 1024.0;\n//   float intensity = range(\n//     576.0,\n//     1024.0,\n//     py\n//   );\n\n//   // float intensity = vUv.y >= 0.5 ? 1.0 : 0.0;\n//   // intensity = 1.0;\n  \n//   #ifdef HAS_INTENSITY\n//     intensity = vIntensity;\n//   #endif\n//   intensity = pow(intensity, 1.0 / 2.2);\n\n//   vec3 vLightDir = -lightDirection;\n//   // vec3 vLightDir = (viewMatrix * vec4(lightDirection, 1.0)).xyz;\n//   // vec3 vLightDir = (viewMatrix * vec4(normalize(vec3(-2.0, 1.0, 2.0)), 1.0)).xyz;\n//   vec3 L = normalize(vLightDir);\n//   vec3 V = normalize(vViewPosition);\n\n//   vec3 normalized = range(minBounds, maxBounds, vWorldPosition);\n//   float cylindricalHeight = normalized.y;\n//   float theta = atan(normalized.z, normalized.x);\n//   float angle01 = range(-3.14, 3.14, theta);\n  \n//   // float n = normalized.y;\n//   // float n = texture2D(noise1DMap, vec2(0.0, normalized.y * 0.005 + sin(vWorldPosition.x) * 0.5)).r;\n//   // n = smoothstep(0.4, 0.45, n);\n//   // n = texture2D(noise1DMap, vec2(0.5, col.r + 1.0 / 512.0 * n)).r;\n\n//   vec3 N = vNormal;\n//   // vec3 N = normalize(colnorm * 2.0 - 1.0);\n\n//   // float n0 = texture2D(noise1DMap, vec2(0.5, normalized.y + vWorldPosition.y)).r;\n//   // float n1 = texture2D(noise1DMap, vec2(0.5, normalized.y + vWorldPosition.y + vWorldPosition.x)).r;\n\n//   float diffuse = (0.5 * dot(N, L)) + 0.5;\n//   float ndotl = diffuse;\n//   float i = 1.0;\n//   // if (diffuse >= 0.5) {\n//   //   i = 0.75;\n//   // } else {\n//   //   i = 0.25;\n//   // }\n//   // float doff = (n0 * 2.0 - 1.0) * 0.05;\n  \n//   // i = mix(0.25, 0.75, clamp(step(0.65, diffuse + doff), 0.0, 1.0));\n//   // diffuse = i;\n\n//   float ux = 0.5;\n  \n//   float dstep = aastep(0.5, smoothstep(0.5, 0.75, diffuse + noff * 0.025));\n//   // float dstep = aastep(0.5, diffuse + noff * 0.1);\n//   diffuse = mix(0.0, 1.0, dstep);\n//   // if (diffuse >= 0.66) {\n//   //   diffuse = 0.85;\n//   // } else {\n//   //   diffuse = 0.2;\n//   // }\n//   // if (diffuse >= 0.75) {\n//   //   diffuse = 0.8;\n//   // } else if (diffuse >= 0.5) {\n//   //   diffuse = 0.5;\n//   // } else {\n//   //   diffuse = 0.2;\n//   // }\n\n//   // diffuse += (n0 * 2.0 - 1.0) * 0.025 / 4.0;\n//   // diffuse += (n1 * 2.0 - 1.0) * 0.025 / 4.0;\n//   // if (diffuse >= 0.5) {\n//   //   // i = 1.0;\n//   //   i = step(0.75, diffuse + (n0 * 2.0 - 1.0) * 0.1);\n//   // } else if (diffuse >= 0.25) {\n//   //   i = step(0.5, diffuse + (n1 * 2.0 - 1.0) * 0.1);\n//   // } else {\n//   //   i = 0.25;\n//   // }\n//   // diffuse = i;\n\n//   // intensity += (n * 2.0 - 1.0) * 0.025;\n//   // if (intensity >= 0.5) {\n//   //   i = 1.0;\n//   // } else if (intensity >= 0.25) {\n//   //   i = 0.5;\n//   // } else {\n//   //   i = 0.25;\n//   // }\n//   // intensity = i;\n\n  // vec3 camRightWorld = vec3(viewMatrix[0].x, viewMatrix[1].x, viewMatrix[2].x);\n  // vec3 camUpWorld = vec3(viewMatrix[0].y, viewMatrix[1].y, viewMatrix[2].y);\n\n  // vec3 VC = normalize(camUpWorld);\n//   // vec3 VC = normalize(cross(camRightWorld, camUpWorld));\n//   // vec3 VC = normalize(cameraDirection);\n  // float vDotN = 1.0 - clamp(dot(VC, vNormal), 0.0, 1.0);\n//   float rim = aastep(0.5, vDotN + noff * 0.025);\n\n//   // float ink01 = 0.0;\n//   // ink01 += 0.5 * clamp(step(0.5, vDotN + (n0 * 2.0 - 1.0) * 0.05), 0.0, 1.0);\n//   // ink01 += 0.5 * clamp(step(0.5, vDotN + (n1 * 2.0 - 1.0) * 0.05), 0.0, 1.0);\n//   // ink01 += 0.33 * clamp(step(0.5, vDotN), 0.0, 1.0);\n\n//   // VC = normalize(camUpWorld);\n//   // vDotN = 1.0 - clamp(dot(VC, N), 0.0, 1.0);\n//   // float ink02 = step(0.5, vDotN);\n\n//   // diffuse += 1.0-n;\n//   // vec3 styleColor = blendSoftLight(vec3(intensity), vec3(diffuse), 1.0);\n//   float intensityAmount = 0.75;\n//   // vec3 styleColor = vec3(mix(diffuse, intensity, intensityAmount));\n//   vec3 solidColor = vec3(intensity);\n//   // vec3 styleColor = vec3(mix(intensity, 0.5, 0.5) + diffuse * 0.5);\n\n//   float gradient = pow(clamp(vWorldPosition.y / 2.0, 0.0, 1.0), 1.0);\n\n//   float dsteprim = aastep(0.5, smoothstep(0.1, 0.25, ndotl + noff * 0.025));\n//   // float dstep = aastep(0.5, diffuse + noff * 0.1);\n//   float drim = mix(0.0, 1.0, dsteprim);\n   \n\n//   float ramp = mix(intensity * 0.75, 1.0, diffuse);\n//   ramp = mix(0.0, ramp, rim);\n//   gl_FragColor.rgb = vec3(ramp);\n\n//   vec2 nuv = vec2(0.0);\n  \n//   float py2 = (576.0 / 1024.0) * 1024.0;\n//   // float nv = clamp(range(\n//   //   576.0,\n//   //   1024.0,\n//   //   py2 + 448.0 * ramp\n//   // ), 0.0, 1.0);\n//   // nuv.x = vUv.x;\n//   // nuv.y = nv;\n//   y1 = ((579.0 + 439.0) / 1024.0);\n//   y0 = 579.0 / 1024.0;\n//   vec3 color0 = texture2D(map, vec2(vUv.x, y0)).rgb;\n//   vec3 color1 = texture2D(map, vec2(vUv.x, y1)).rgb;\n//   gl_FragColor.rgb = mix(color0, color1, ramp);\n//   // gl_FragColor.rgb = color1;\n\n//   // vec3 solidFlat = color * 1.0;\n//   // gl_FragColor.rgb = mix(color * solidColor, solidFlat, diffuse);\n//   // gl_FragColor.rgb = mix(color * 0.5, gl_FragColor.rgb, gradient);\n\n//   // gl_FragColor.rgb = mix(\n//   //   vec3(22.0,29.0,40.0)/255.0,\n//   //   vec3(132.0,165.0,164.0)/255.0,\n//   //   gl_FragColor.r\n//   // );\n\n//   // gl_FragColor.rgb = mix(vec3(0.0), gl_FragColor.rgb, drim);\n  \n//   gl_FragColor.a = 1.0;\n\n//   // vec3 lineColor = vec3(1.0) * (1.0 - n);\n  \n//   // gl_FragColor.rgb = blendSoftLight(gl_FragColor.rgb, lineColor, 0.2);\n//   // gl_FragColor.rgba = blend(gl_FragColor.rgba, vec4(vec3(1.0), n));\n//   gl_FragColor.a = 1.0;\n//   gl_FragColor.rgb = vec3(vIntensity);\n//   // gl_FragColor.rgb = vec3(intensity);\n\n// }\n";
},{}],"src/shaders/toon.vert.js":[function(require,module,exports) {
module.exports = "#define GLSLIFY 1\n#ifdef HAS_INTENSITY\nattribute float intensity;\nvarying float vIntensity;\n#endif\n\n#ifdef HAS_VERTEX_COLORS\nattribute vec3 vertexColor;\nvarying vec3 vVertexColor;\n#endif\n\nvarying vec2 vGroundUv;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying vec3 vPosition;\nvarying vec3 vWorldPosition;\n\nvarying vec2 vBillboardUV;\nuniform vec3 minBounds;\nuniform mat4 groundProjectionMatrix;\nuniform vec3 maxBounds;\nuniform vec2 resolution;\n\nfloat range(float vmin, float vmax, float value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nvec2 range(vec2 vmin, vec2 vmax, vec2 value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nvec3 range(vec3 vmin, vec3 vmax, vec3 value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nvec4 range(vec4 vmin, vec4 vmax, vec4 value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\n// modified from http://graphics.cs.williams.edu/papers/HashedAlphaI3D17/\n// fixed4 tex2DConstScale(sampler2D tex, float texSize, float2 uv)\n// {\n//   // Find the discretized derivatives of our coordinates\n//   float maxDeriv = max( length(ddx(uv)), length(ddy(uv)) );\n//   float pixScale = 1.0 / (texSize * maxDeriv);\n//   // Find two nearest log-discretized noise scales\n//   float2 pixScales = float2(\n//       exp2(floor(log2(pixScale))),\n//       exp2( ceil(log2(pixScale)))\n//       );\n//   // Factor to interpolate lerp with\n//   float lerpFactor = frac( log2(pixScale) );\n\n//   return lerp(\n//       tex2D(tex, pixScales.x * uv),\n//       tex2D(tex, pixScales.y * uv),\n//       lerpFactor\n//       );\n// }\n\n// \n\nvec2 getScreenUV (vec2 clipPos, float uvScale) {\n  // vec3 boxCenter = (minBounds + maxBounds) * 0.5;\n  // vec4 SSobjectPosition = projectionMatrix * viewMatrix * vec4(boxCenter, 1.0);\n  vec4 SSobjectPosition = projectionMatrix * modelViewMatrix * vec4(vec3(0.0), 1.0);\n  vec2 screenUV = vec2(clipPos.xy);\n  float screenRatio = resolution.y/resolution.x;\n\n  screenUV.x -= SSobjectPosition.x/(SSobjectPosition.w);\n  screenUV.y -= SSobjectPosition.y/(SSobjectPosition.w);\n\n  screenUV.y *= screenRatio;\n\n  screenUV *= 1.0/uvScale;\n  screenUV *= SSobjectPosition.z; // or z\n  return screenUV; \n}\n\nvoid main () {\n  vUv = uv;\n  vec3 objectNormal = normal;\n  vec3 transformedNormal = objectNormal;\n  transformedNormal = normalMatrix * transformedNormal;\n  transformedNormal = normalize(transformedNormal);\n  vNormal = transformedNormal;\n  vec3 transformed = position.xyz;\n  // transformed += normal.xyz * 0.1;\n  vPosition = transformed.xyz;\n  vec4 worldPos = modelMatrix * vec4(transformed, 1.0);\n  vec4 mvPosition = viewMatrix * worldPos;\n  gl_Position = projectionMatrix * mvPosition;\n  \n  vViewPosition = -mvPosition.xyz;\n  vWorldPosition = worldPos.xyz;\n  #ifdef HAS_INTENSITY\n  vIntensity = intensity;\n  #endif\n  #ifdef HAS_VERTEX_COLORS\n  vVertexColor = vertexColor;\n  #endif\n\n  vec3 gPos = worldPos.xyz;\n  gPos.y *= 0.0;\n  vec4 baseClipPos = groundProjectionMatrix * viewMatrix * vec4(gPos, 1.0);\n  vGroundUv = baseClipPos.xy / baseClipPos.w * 0.5 + 0.5;\n\n  // vec3 bpoint = range()\n  // vec4 vpos = projectionMatrix * modelMatrix * vec4(transformed.xyz, 1.0);\n\n  // vec3 boxCenter = (minBounds + maxBounds) * 0.5;\n  // vec3 centerWorldPos = (modelMatrix * vec4(boxCenter, 1.0)).xyz;\n\n  // vec3 npos = transformed.xyz;\n  // vec4 clipCur = projectionMatrix * modelMatrix * vec4(npos, 1.0);\n  // vec4 clipCur = projectionMatrix * modelMatrix * vec4(position.xyz, 1.0);\n  // vec4 clipMin = projectionMatrix * modelViewMatrix * vec4(minBounds.xyz, 1.0);\n  // vec4 clipMax = projectionMatrix * modelViewMatrix * vec4(maxBounds.xyz, 1.0);\n  // vec4 clipCenter = (projectionMatrix * viewMatrix * vec4(centerWorldPos, 1.0));\n  // clipCur.xy -= clipCenter.xy / clipCenter.w;\n  // vec2 clipCur2D = clipCur.xy / clipCur.w * 0.5 + 0.5;\n  // clipCur2D.xy -= clipCenter.xy / clipCenter.w * 0.5 + 0.5;\n  // vec2 clipMin2D = clipMin.xy / clipMin.w;\n  // vec2 clipMax2D = clipMax.xy / clipMax.w;\n\n  // vBillboardUV = getScreenUV(gl_Position.xy / gl_Position.w, 40.0);\n  // vBillboardUV = mix(clipMin2D, clipMax2D, range(minBounds, maxBounds, position.xyz));\n\n  // vec3 bWorldPos = worldPos.xyz + boxCenter.xyz;\n  // vec4 bClipPos = projectionMatrix * viewMatrix * vec4(bWorldPos, 1.0);\n  // vBillboardUV = bClipPos.xy / bClipPos.w * 0.5 + 0.5;\n  \n  // vec3 camRightWorld = vec3(viewMatrix[0].x, viewMatrix[1].x, viewMatrix[2].x);\n  // vec3 camUpWorld = vec3(viewMatrix[0].y, viewMatrix[1].y, viewMatrix[2].y);\n\n  \n\n  // float billboardSize = 1.0 * globalSpriteScale * absScale;\n  // vec3 vertexWorldPos = boxCenter\n  //   + camRightWorld * position.x * billboardSize\n  //   + camUpWorld * position.y * billboardSize;\n\n}";
},{}],"src/util/materials.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEmptyTexture = getEmptyTexture;
exports.getSpriteGeometry = getSpriteGeometry;
exports.setSpriteToken = setSpriteToken;
exports.createTokenMaterial = createTokenMaterial;
exports.createSpriteMaterial = createSpriteMaterial;
exports.createMeshMaterial = createMeshMaterial;

var THREE = _interopRequireWildcard(require("three"));

var _sprite = _interopRequireDefault(require("../shaders/sprite.frag"));

var _sprite2 = _interopRequireDefault(require("../shaders/sprite.vert"));

var Tags = _interopRequireWildcard(require("../tags"));

var _toon = _interopRequireDefault(require("../shaders/toon.frag"));

var _toon2 = _interopRequireDefault(require("../shaders/toon.vert"));

var ShaderManager = _interopRequireWildcard(require("./ShaderManager"));

var _tokens = require("../util/tokens");

var _SpriteManager = _interopRequireDefault(require("./SpriteManager"));

var _Assets = _interopRequireDefault(require("./Assets"));

var _threeUtil = require("./three-util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const planeGeo = new THREE.PlaneGeometry(1, 1, 4, 4);
planeGeo.translate(0, 0.5, 0); // Assets.prepare(AllTokens.map((id) => `image/tokens/ico_${id}`));

let tex;

function getEmptyTexture() {
  if (!tex) {
    const data = new Uint8Array(2 * 2 * 3);
    tex = new THREE.DataTexture(data, 2, 2, THREE.RGBFormat);
    tex.needsUpdate = true;
  }

  return tex;
}

function getSpriteGeometry() {
  return planeGeo;
}

function setSpriteToken(renderer, sprite, type, height = null) {
  let map; // if (tokenTextureMap.has(type)) {
  //   map = tokenTextureMap.get(type);
  // } else {
  //   map = new THREE.Texture();
  //   tokenTextureMap.set(type, map);
  //   // queue loading this asset
  //   // Assets.loadGPUTexture(renderer, map, `image/tokens/ico_${type}`);
  // }

  (0, _tokens.getTokenSheet)().then(sheet => {
    const frame = sheet.map[`tokens/${type}`];

    if (frame) {
      (0, _threeUtil.shareAtlasTexture)(renderer, frame.atlas, frame.texture);
      sprite.material.uniforms.map.value = frame.texture;
      sprite.material.uniforms.repeat.value.copy(frame.repeat);
      sprite.material.uniforms.offset.value.copy(frame.offset);

      if (height != null) {
        const aspect = frame.width / frame.height;
        const width = height * aspect;
        sprite.scale.set(width, height, 1);
      }
    }
  });
}

function createTokenMaterial(bloom = 0.666, depthTested = true) {
  // TODO: force initialize all tokens upon startup?
  return ShaderManager.create({
    transparent: true,
    name: "token-material",
    uniforms: {
      // effect: { value: 0 },
      // noiseMap: { value: noiseMap },
      repeat: {
        value: new THREE.Vector2(1, 1)
      },
      offset: {
        value: new THREE.Vector2(0, 0)
      },
      map: {
        value: getEmptyTexture()
      },
      color: {
        value: new THREE.Color(1 + bloom, 1 + bloom, 1 + bloom)
      },
      opacity: {
        value: 1
      },
      time: {
        value: 0
      }
    },
    depthTest: depthTested,
    depthWrite: depthTested,
    vertexShader:
    /*glsl*/
    `
    varying vec2 vUv;
    uniform vec2 repeat;
    uniform vec2 offset;
    void main () {
      vUv = uv;
      vUv *= repeat;
      vUv += offset;

      vec3 centerWorldPos = (modelMatrix * vec4(vec3(0.0), 1.0)).xyz;
      vec3 camRightWorld = vec3(viewMatrix[0].x, viewMatrix[1].x, viewMatrix[2].x);
      vec3 camUpWorld = vec3(viewMatrix[0].y, viewMatrix[1].y, viewMatrix[2].y);

      vec2 scale;
      scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
      scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

      vec3 offsetPos = position.xyz;
      vec3 vertexWorldPos = centerWorldPos
        + camRightWorld * offsetPos.x * scale.x
        + camUpWorld * offsetPos.y * scale.y;

      // gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
      gl_Position = projectionMatrix * viewMatrix * vec4(vertexWorldPos, 1.0);
    }
    `,
    side: THREE.DoubleSide,
    fragmentShader:
    /*glsl*/
    `
    varying vec2 vUv;
    uniform sampler2D map;
    // uniform sampler2D noiseMap;
    uniform vec3 color;
    uniform float time;
    uniform float opacity;
    // uniform float effect;
    void main () {
      vec2 uv = vUv;

      // vec4 noiseLow = texture2D(noiseMap, vUv * 0.075 + vec2(time * 0.075, 0.0)) * 2.0 - 1.0;
      // vec4 noiseHigh = texture2D(noiseMap, (vUv * 0.25 + vec2(0.0, time * 0.075))) * 2.0 - 1.0;

      vec4 tcol = texture2D(map, vUv);
      // vec4 ecol = vec4(0.0);
      // ecol += texture2D(map, vUv + noiseLow.rg * 0.2) * 0.2;
      // ecol += texture2D(map, vUv + noiseLow.rg * 0.1) * 0.33;
      // ecol += texture2D(map, vUv + noiseHigh.rg * 0.05) * 0.33;
      // vec4 fcol = mix(tcol, ecol, effect);
      vec4 outColor = vec4(color, opacity) * tcol;
      gl_FragColor = vec4(outColor);
    }
    `
  });
}

function createSpriteMaterial(world) {
  const groundView = world.findTag(Tags.GroundPlaneView);
  const emptyTexture = getEmptyTexture(); // const fogTarget = world.findTag(Tags.GroundFogRenderTarget);

  const dataTarget = world.findTag(Tags.GroundDataRenderTarget);
  return ShaderManager.create({
    name: "WayfinderSpriteShader",
    extensions: {
      derivatives: true
    },
    // defines: {
    //   SILHOUETTE: true,
    // },
    transparent: true,
    // depthTest: false,
    // depthWrite: false,
    side: THREE.DoubleSide,
    fragmentShader: _sprite.default,
    vertexShader: _sprite2.default,
    uniforms: {
      // worldFogProjection: {
      //   value: fogTarget ? fogTarget.projection : new THREE.Matrix4(),
      // },
      // worldFogMap: {
      //   value: fogTarget ? fogTarget.target.texture : getEmptyTexture(),
      // },
      // worldDataSize: { value: 512 }, // TODO: fix hardcoding...
      shadowColor: {
        value: new THREE.Color("#280422")
      },
      groundMap: {
        value: groundView.target.texture
      },
      groundProjectionMatrix: {
        value: groundView.projectionMatrix
      },
      worldDataMap: {
        value: dataTarget ? dataTarget.target.texture : new THREE.Texture()
      },
      worldDataProjection: {
        value: dataTarget ? dataTarget.projection : new THREE.Matrix4()
      },
      worldDataView: {
        value: dataTarget ? dataTarget.view : new THREE.Matrix4()
      },
      map: {
        value: emptyTexture
      },
      // noiseMap: { value: noiseMap || new THREE.Texture() },
      flip: {
        value: 1
      },
      silhouette: {
        value: false,
        type: "b"
      },
      useMapDiscard: {
        value: false,
        type: "b"
      },
      color: {
        value: new THREE.Color("white")
      },
      time: {
        value: 0
      },
      spin: {
        value: 0
      },
      spriteHeight: {
        value: 1
      },
      aspect: {
        value: 1
      },
      repeat: {
        value: new THREE.Vector2(1, 1)
      },
      offset: {
        value: new THREE.Vector2(0, 0)
      },
      tintColor: {
        value: new THREE.Color("#ffffff")
      }
    }
  });
}

function createMeshMaterial(world, mesh, {
  map,
  ignoreGround = false
}) {
  const groundView = world.findTag(Tags.GroundPlaneView);
  const groundTexture = groundView.target.texture;
  const groundProjectionMatrix = groundView.projectionMatrix;
  mesh.updateMatrix();
  mesh.updateMatrixWorld();
  const bounds = new THREE.Box3().setFromObject(mesh);
  const oldMat = mesh.material;
  const alphaTest = oldMat.alphaTest || 0; // child.material.alphaTest = mat.alphaTest;
  // child.material.transparent = mat.transparent;

  return ShaderManager.create({
    transparent: Boolean(oldMat.transparent),
    name: "WayfinderMeshShader",
    defines: {
      HAS_INTENSITY: Boolean(false),
      HAS_VERTEX_COLORS: Boolean(false)
    },
    vertexShader: _toon2.default,
    fragmentShader: _toon.default,
    side: THREE.FrontSide,
    extensions: {
      derivatives: true
    },
    uniforms: {
      alphaTest: {
        value: alphaTest
      },
      ignoreGround: {
        value: Boolean(ignoreGround),
        type: "i"
      },
      normalMap: {
        value: new THREE.Texture()
      },
      groundTexture: {
        value: groundTexture || new THREE.Texture()
      },
      groundTextureEnabled: {
        type: "b",
        value: Boolean(groundTexture)
      },
      groundBounce: {
        type: "b",
        value: true
      },
      groundBounceLow: {
        value: 0.06
      },
      groundBounceHigh: {
        value: 0.25
      },
      groundBounceStrength: {
        value: 0.5
      },
      groundProjectionMatrix: {
        value: groundProjectionMatrix || new THREE.Matrix4()
      },
      useNormalMap: {
        type: "b",
        value: false
      },
      flipNormalY: {
        type: "b",
        value: false
      },
      diffuseShading: {
        type: "b",
        value: false
      },
      debugNormals: {
        type: "b",
        value: false
      },
      resolution: {
        value: new THREE.Vector2()
      },
      celShading: {
        type: "b",
        value: false
      },
      darkShading: {
        type: "b",
        value: false
      },
      vertexColors: {
        type: "b",
        value: false
      },
      useOverlayMap: {
        type: "b",
        value: false
      },
      useNoiseMap: {
        type: "b",
        value: false
      },
      useDiffuseMap: {
        type: "b",
        value: true
      },
      overlayColor: {
        value: new THREE.Color()
      },
      colorA: {
        value: new THREE.Color()
      },
      colorB: {
        value: new THREE.Color()
      },
      cameraDirection: {
        value: new THREE.Vector3()
      },
      minBounds: {
        value: bounds.min
      },
      maxBounds: {
        value: bounds.max
      },
      lightDirection: {
        value: new THREE.Vector3()
      },
      map: {
        value: map || new THREE.Texture()
      },
      noiseMap: {
        value: new THREE.Texture()
      },
      overlayMap: {
        value: new THREE.Texture()
      }
    }
  });
}
},{"three":"src/vendor/three.module.js","../shaders/sprite.frag":"src/shaders/sprite.frag.js","../shaders/sprite.vert":"src/shaders/sprite.vert.js","../tags":"src/tags/index.js","../shaders/toon.frag":"src/shaders/toon.frag.js","../shaders/toon.vert":"src/shaders/toon.vert.js","./ShaderManager":"src/util/ShaderManager.js","../util/tokens":"src/util/tokens.js","./SpriteManager":"src/util/SpriteManager.js","./Assets":"src/util/Assets.js","./three-util":"src/util/three-util.js"}],"src/systems/CompassSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = CompassSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var eases = _interopRequireWildcard(require("eases"));

var _locale = require("../util/locale");

var _AnimationSystem = require("./AnimationSystem");

var _materials = require("../util/materials");

var _Assets = _interopRequireDefault(require("../util/Assets"));

var ShaderManager = _interopRequireWildcard(require("../util/ShaderManager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function CompassSystem(world) {
  const container = new THREE.Group();
  container.name = "compass";
  world.entity().add(Tags.Object3D, container);
  const renderer = world.findTag(Tags.Renderer);
  const bloom = 0.5;
  const white = new THREE.Color(1, 1, 1);
  const shadowAlpha = 0.1;
  const shadowColorOpaque = new THREE.Color("#280422").lerp(white, 1 - shadowAlpha);
  const shadowColorTransparent = white;
  const radius = 1.25;
  const thick = 0.025;
  const ringGeo = new THREE.TorusGeometry(radius, thick, 6, 24);
  ringGeo.rotateX(-Math.PI / 2);
  ringGeo.translate(0, thick / 2, 0);

  const [compassRingMap] = _Assets.default.createGPUTextureTask(renderer, "image/data/compass-ring");

  const planeGeo = new THREE.PlaneBufferGeometry(1, 1, 1, 1);
  planeGeo.rotateX(-Math.PI / 2);
  const ringShader = ShaderManager.create({
    name: "CompassRingShader",
    vertexShader:
    /*glsl*/
    `
      varying vec2 vUv;
      void main () {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
        vUv = uv;
      }
    `,
    fragmentShader:
    /*glsl*/
    `
      varying vec2 vUv;
      uniform sampler2D map;
      uniform vec3 color;
      uniform float opacity;

      void main () {
        vec4 tColor = texture2D(map, vUv);
        if (tColor.a <= 0.5) discard;
        gl_FragColor = vec4(color * tColor.rgb, tColor.a * opacity);
        // gl_FragColor = vec3(vec3(0.5), tColor.a);
      }
    `,
    uniforms: {
      color: {
        value: new THREE.Color(1 + bloom, 1 + bloom, 1 + bloom)
      },
      opacity: {
        value: 1
      },
      map: {
        value: compassRingMap
      }
    },
    transparent: true
  }); // const ringMat = new THREE.MeshBasicMaterial({
  //   transparent: true,
  //   color: new THREE.Color(1 + bloom, 1 + bloom, 1 + bloom),
  //   map: compassRingMap,
  // });

  const ringMat = ringShader;
  const ringMesh = new THREE.Mesh(planeGeo, ringMat);
  const ringSpriteScale = radius * 2.25;
  container.add(ringMesh);
  const shadowMat = ringShader.clone();
  shadowMat.uniforms.color.value = shadowColorOpaque.clone();
  shadowMat.uniforms.map.value = compassRingMap;
  shadowMat.blending = THREE.MultiplyBlending;
  shadowMat.needsUpdate = true;
  const shadowMesh = new THREE.Mesh(planeGeo, shadowMat // new THREE.MeshBasicMaterial({
  //   transparent: true,
  //   alphaTest: 0.5,
  //   blending: THREE.MultiplyBlending,
  //   color: shadowColorOpaque.clone(),
  //   map: compassRingMap,
  // })
  );
  const layers = world.findTag(Tags.RenderLayers);
  container.add(shadowMesh);
  shadowMesh.layers.set(layers.shadow); // ringMesh.rotation.x = MathUtil.degToRad(-5);

  const arrowMat = new THREE.MeshBasicMaterial({
    transparent: true,
    // depthTest: false,
    // depthWrite: false,
    color: new THREE.Color(1 + bloom, 1 + bloom, 1 + bloom)
  });
  const dotContainer = new THREE.Group();
  const geoPointScale = 0.1;
  container.add(dotContainer);
  const dots = new Array(3).fill(null).map(() => {
    const mesh = new THREE.Mesh((0, _materials.getSpriteGeometry)(), (0, _materials.createTokenMaterial)());
    mesh.renderOrder = 10;
    mesh.name = "dot"; // const mesh = new THREE.Mesh(
    //   dotSphere,
    //   new THREE.MeshBasicMaterial({
    //     color: "white",
    //     transparent: true,
    //   })
    // );

    mesh.userData.currentAngle = null;
    mesh.userData.currentSize = 0;
    mesh.userData.lastToken = null;
    mesh.userData.lastTokenType = null;
    dotContainer.add(mesh);
    return mesh;
  });
  const arrows = new Array(4).fill().map((_, i) => {
    const arrowMesh = new THREE.Mesh(planeGeo, arrowMat);
    container.add(arrowMesh);
    arrowMesh.renderOrder = 1;
    arrowMesh.scale.setScalar(i <= 2 ? 0.5 : 1);
    arrowMesh.userData.currentAngle = null;
    arrowMesh.visible = false;
    return arrowMesh;
  });
  let arrowReady = false,
      hasInitArrow = false;

  const loadArrow = () => {
    hasInitArrow = true;

    _Assets.default.createGPUTexture(renderer, `image/data/compass-arrow3`).then(map => {
      arrowReady = true;
      arrowMat.map = map;
      arrowMat.needsUpdate = true;
      arrows.forEach(arrowMesh => {});
    });
  };

  const tokenView = world.view([Tags.GroundAsset, Tags.GroundAssetToken]);
  const envCells = world.view(Tags.EnvironmentCell);
  const tokensDiscovered = world.findTag(Tags.TokensDiscoveredSet);
  const envState = world.view([Tags.EnvironmentState, Tags.ActiveEnvironmentState]);
  const tokenStates = dots.map(() => ({
    distanceSq: Infinity,
    token: null,
    consumed: false
  }));
  const compass = world.entity();
  const opacityTween = {
    value: 0
  };
  const target = world.findTag(Tags.UserTarget);
  const char = world.findTag(Tags.UserCharacter);
  const activeLineView = world.view([Tags.WrittenStanzaLine, Tags.WrittenStanzaLineActive]);
  let wasShowCompass = false;
  const centerDistThreshold = 12.5;
  const centerDistThresholdSq = centerDistThreshold * centerDistThreshold;
  const distThreshold = 10;
  const distThresholdSq = distThreshold * distThreshold;
  const showCompassView = world.view(Tags.CompassVisible);
  const compassCurrentPosition = new THREE.Vector3();
  const messages = world.view(Tags.TutorialMessage);
  const showCompassEvents = world.listen(Tags.CompassVisible);
  return dt => {
    if (!envState.length) return;
    const activeEnv = envState[0];
    let triggerCompassRecompute = false;

    if (target && target.forceApplied) {
      showCompassView.forEach(e => {
        const vis = e.get(Tags.CompassVisible); // e.tagOff(Tags.CameraZoomOut);

        if (vis.position.distanceToSquared(target.position) >= distThresholdSq) {
          e.tagOff(Tags.CompassVisible);
        }
      });
    }

    if (showCompassView.length > 0) {
      const e = showCompassView[0];

      if (e.has(Tags.CompassVisible)) {
        triggerCompassRecompute = true;
        compassCurrentPosition.copy(e.get(Tags.CompassVisible).position);
      }
    }

    const introSeq = world.findTag(Tags.OriginTreeIntroSequence);
    const charVis = !world.findTag(Tags.HideCharacter);
    const directToOrigin = Boolean(world.findTag(Tags.DirectUserToOrigin));
    const tutorialState = world.findTag(Tags.TutorialState);
    const haikuCardShown = world.findTag(Tags.HaikuCardShown);
    const resolving = world.findTag(Tags.ShowBiomeResolution);
    const distFromCenterSq = char.position.lengthSq();
    const hintMode = showCompassView.length > 0;
    const showCompass = charVis && (directToOrigin && !resolving || hintMode && activeLineView.length === 0 && !haikuCardShown && !tutorialState && !introSeq && !resolving); //!newMoving;

    container.visible = opacityTween.value >= 1e-5;

    if (showCompassEvents.changed && !directToOrigin) {
      messages.forEach(e => {
        const msg = e.get(Tags.TutorialMessage);
        e.kill();
      });

      if (showCompassEvents.added.length) {
        const e = world.entity().add(Tags.TutorialMessage);
        const msg = e.get(Tags.TutorialMessage);
        msg.id = "comapss"; // if (directToOrigin) {
        //   msg.message = localize.get().tutorialResolve;
        //   msg.iconMode = "tree";
        // } else {
        // msg.message = "Collect tokens to recover nature’s lost memories";

        msg.message = _locale.localize.get().tutorialCollect;
        msg.iconMode = "token-random"; // }

        msg.delay = 0; // tokens: true,
        //     delay: 3,

        msg.duration = 6;
      }
    }

    if (wasShowCompass !== showCompass) {
      // if (showCompass) triggerCompassRecompute = showCompass;
      compass.tagOff(Tags.TargetKeyTween);
      (0, _AnimationSystem.setEntityTweenFromTo)(compass, opacityTween, "value", opacityTween.value, showCompass ? 1 : 0, showCompass ? 2 : 0.5, showCompass ? "sineOut" : "sineOut", 0);
      const tween = compass.get(Tags.TargetKeyTween);
      tween.killEntityOnFinish = false;
      tween.assignFromOnStart = true;
      wasShowCompass = showCompass;
    } // for (let i = 0; i < 4; i++) {
    //   arrows[i].visible = false;
    // }
    // container.position.copy(char.position);


    const distSq = container.position.distanceToSquared(char.position);

    if (distSq >= distThresholdSq) {
      container.position.copy(char.position);
    } else {
      MathUtil.dampVector(container.position, char.position, 10, dt, container.position);
    }

    shadowMesh.material.uniforms.color.value.copy(shadowColorTransparent).lerp(shadowColorOpaque, opacityTween.value);
    ringMesh.material.uniforms.opacity.value = opacityTween.value;
    const rScl = ringSpriteScale * MathUtil.lerp(1.15, 1, eases.sineInOut(opacityTween.value));
    ringMesh.scale.x = rScl;
    ringMesh.scale.z = rScl;
    arrowMat.opacity = opacityTween.value;
    dots.forEach(d => d.material.uniforms.opacity.value = opacityTween.value);
    ringMesh.position.y = 0.3;
    shadowMesh.position.y = 0.01;
    shadowMesh.scale.copy(ringMesh.scale);
    ringMesh.rotation.y += dt * 0.5;
    shadowMesh.rotation.y = ringMesh.rotation.y;
    const charX = char.position.x;
    const charZ = char.position.z;
    const tokens = activeEnv.get(Tags.EnvironmentState).tokens;
    const isDirectingToOrigin = Boolean(world.findTag(Tags.DirectUserToOrigin));
    const ignoreTokens = Boolean(world.findTag(Tags.BlockTokenCollection));
    const canCollect = !introSeq && !isDirectingToOrigin && !ignoreTokens;

    if (triggerCompassRecompute) {
      for (let i = 0; i < tokenStates.length; i++) {
        tokenStates[i].distanceSq = Infinity;
        tokenStates[i].token = null;
        tokenStates[i].consumed = false;
      } // const best = [];


      triggerCompassRecompute = false;

      for (let i = 0; i < tokens.length; i++) {
        const t = tokens[i];
        const canCollectType = !tokensDiscovered.has(t.type);
        const shouldShow = canCollect && canCollectType;
        if (!shouldShow) continue;
        const x = t.position[0];
        const z = t.position[1];
        const dx = x - compassCurrentPosition.x;
        const dz = z - compassCurrentPosition.z;
        const dSq = dx * dx + dz * dz; // best.push([dSq, t]);

        if (dSq <= tokenStates[0].distanceSq) {
          tokenStates[0].distanceSq = dSq;
          tokenStates[0].token = t;
        } else if (dSq <= tokenStates[1].distanceSq) {
          tokenStates[1].distanceSq = dSq;
          tokenStates[1].token = t;
        } else if (dSq <= tokenStates[2].distanceSq) {
          tokenStates[2].distanceSq = dSq;
          tokenStates[2].token = t;
        }
      } // best.sort((a, b) => a[0] - b[0]);
      // for (let i = 0; i < 3 && i < best.length; i++) {
      //   const b = best[i];
      //   tokenStates[i].distanceSq = b[0];
      //   tokenStates[i].token = b[1];
      // }

    } // console.log(tokenStates.filter((f) => f.token).length);
    //
    // if (directToOrigin) {
    //   if (!hasInitArrow) {
    //     loadArrow();
    //   }
    //   arrowMesh.material.opacity = opacityTween.value;
    //   if (arrowMesh.userData.currentAngle == null) {
    //     arrowMesh.userData.currentAngle = newAngle;
    //   }
    // }


    const arrowMesh = arrows[arrows.length - 1];
    let newArrowAngle = arrowMesh.userData.currentAngle;

    if (directToOrigin) {
      const dx = 0 - charX;
      const dz = 0 - charZ;
      newArrowAngle = Math.atan2(dz, dx);

      if (!hasInitArrow) {
        loadArrow();
      }

      arrowMesh.material.opacity = opacityTween.value;
    }

    arrowMesh.visible = arrowReady && directToOrigin;
    ringMesh.visible = opacityTween.value >= 1e-5; //!arrowMesh.visible;

    shadowMesh.visible = ringMesh.visible;

    if (newArrowAngle != null) {
      if (arrowMesh.userData.currentAngle == null) {
        arrowMesh.userData.currentAngle = newArrowAngle;
      }

      arrowMesh.userData.currentAngle = MathUtil.dampAngle(arrowMesh.userData.currentAngle, newArrowAngle, 10, dt);
      const angle = arrowMesh.userData.currentAngle;
      const u = Math.cos(angle);
      const v = Math.sin(angle);
      const scl = 0.5; //Math.max(0.25, size);

      const r = radius + 1 + scl * geoPointScale;
      const x = u * r;
      const z = v * r;
      arrowMesh.position.set(x, ringMesh.position.y, z);
      arrowMesh.rotation.y = Math.PI + Math.PI / 2 + -angle;
    }

    for (let i = 0; i < dots.length; i++) {
      const dot = dots[i];
      const curArrow = arrows[i];
      dot.visible = false;
      curArrow.visible = false;
      let newSize = 0;
      let newAngle = dot.userData.currentAngle;
      const st = nextTokenState(dot);

      if (st) {
        st.consumed = true;
        const t = st.token;
        dot.userData.lastToken = t;
        const dx = t.position[0] - charX;
        const dz = t.position[1] - charZ;
        const dist = Math.sqrt(dx * dx + dz * dz);
        const maxDist = 100;
        newAngle = Math.atan2(dz, dx);
        const scl = 1; //Math.pow(1 - MathUtil.clamp01(dist / maxDist), 1);

        newSize = scl;

        if (dot.userData.currentAngle == null) {
          dot.userData.currentAngle = newAngle;
        }
      } else {
        dot.userData.lastToken = null;
      }

      dot.userData.currentAngle = MathUtil.dampAngle(dot.userData.currentAngle, newAngle, 10, dt);
      dot.userData.currentSize = MathUtil.dampAngle(dot.userData.currentSize, newSize, 5, dt);
      const angle = dot.userData.currentAngle;

      if (angle != null) {
        const size = dot.userData.currentSize;
        const u = Math.cos(angle);
        const v = Math.sin(angle);
        const scl = 0.7; //Math.max(0.25, size);

        const r = radius + 0.75 + scl * geoPointScale;
        const x = u * r;
        const z = v * r;
        dot.position.set(x, ringMesh.position.y - 0.25, z);
        dot.scale.setScalar(scl); // dot.material.uniforms.opacity.value = opacityTween.value;

        dot.visible = size >= 1e-5 && !directToOrigin; // dot.material.uniforms.opacity.value = size * opacityTween.value;

        if (dot.visible && dot.userData.lastToken) {
          if (dot.userData.lastTokenType !== dot.userData.lastToken.type) {
            dot.userData.lastTokenType = dot.userData.lastToken.type;
            (0, _materials.setSpriteToken)(renderer, dot, dot.userData.lastTokenType);
          } // setSpriteToken

        }

        const r2 = r + 0.75;

        if (resolving || directToOrigin) {
          curArrow.visible = false;
        } else {
          curArrow.visible = true;
          curArrow.position.set(u * r2, ringMesh.position.y, v * r2);
          curArrow.rotation.y = Math.PI + Math.PI / 2 + -angle;

          if (!hasInitArrow) {
            loadArrow();
          }
        }
      } else {
        dot.visible = false;
        curArrow.visible = false;
      }
    }
  };

  function nextTokenState(dot) {
    const lastToken = dot.userData.lastToken;

    if (lastToken) {
      const state = tokenStates.find(f => f.token === lastToken);

      if (state && !state.consumed && state.token) {
        return state;
      }
    }

    const next = tokenStates.find(f => f.token && !f.consumed);
    return next;
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/math":"src/util/math.js","eases":"node_modules/eases/index.js","../util/locale":"src/util/locale.js","./AnimationSystem":"src/systems/AnimationSystem.js","../util/materials":"src/util/materials.js","../util/Assets":"src/util/Assets.js","../util/ShaderManager":"src/util/ShaderManager.js"}],"src/systems/ScreenCompassSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ScreenCompassSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _AnimationSystem = require("./AnimationSystem");

var _materials = require("../util/materials");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ScreenCompassSystem(world) {
  const container = new THREE.Group();
  container.name = "compass";
  world.entity().add(Tags.Object3D, container);
  const tokenView = world.view([Tags.GroundAsset, Tags.GroundAssetToken]);
  const envCells = world.view(Tags.EnvironmentCell);
  const tokensDiscovered = world.findTag(Tags.TokensDiscoveredSet);
  const envState = world.view([Tags.EnvironmentState, Tags.ActiveEnvironmentState]);
  const target = world.findTag(Tags.UserTarget);
  const char = world.findTag(Tags.UserCharacter);
  const tokenPointers = new Array(3).fill(null).map(() => {
    const mesh = new THREE.Mesh((0, _materials.getSpriteGeometry)(), (0, _materials.createTokenMaterial)());
    mesh.renderOrder = 10;
    mesh.name = "dot";
    mesh.userData.currentAngle = null;
    mesh.userData.currentSize = 0;
    mesh.userData.lastToken = null;
    mesh.userData.lastTokenType = null;
    container.add(mesh);
    return mesh;
  });
  return dt => {
    if (!envState.length) return;
    const activeEnv = envState[0];
    const tokens = activeEnv.get(Tags.EnvironmentState).tokens;
    const isDirectingToOrigin = Boolean(world.findTag(Tags.DirectUserToOrigin));
    const ignoreTokens = Boolean(world.findTag(Tags.BlockTokenCollection));
    const canCollect = !isDirectingToOrigin && !ignoreTokens;
    const closest = tokens.filter(t => {
      const canCollectType = !tokensDiscovered.has(t.type);
      return canCollect && canCollectType;
    }).map(t => {
      const x = t.position[0];
      const z = t.position[1];
      const dx = x - target.position.x;
      const dz = z - target.position.z;
      const dSq = dx * dx + dz * dz;
      return [dSq, t];
    });
    closest.sort((a, b) => a[0] - b[0]);
    const best = closest.slice(0, 3).map(s => s[1]);
  };
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/math":"src/util/math.js","./AnimationSystem":"src/systems/AnimationSystem.js","../util/materials":"src/util/materials.js"}],"src/util/resetPlayerPos.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = resetPlayerPos;
exports.setPlayerPos = setPlayerPos;
exports.playerStart = exports.standingNextToOriginTree = void 0;

var THREE = _interopRequireWildcard(require("three"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const standingNextToOriginTree = new THREE.Vector3(7, 0, 3);
exports.standingNextToOriginTree = standingNextToOriginTree;
const playerStart = new THREE.Vector3(7, 0, 3); // export const standingNextToOriginTree = new THREE.Vector3(34.19839943737152, 0, -18.377668713353398);
// export const playerStart = new THREE.Vector3(34.19839943737152, 0, -18.377668713353398);

exports.playerStart = playerStart;

function resetPlayerPos(world) {
  setPlayerPos(world, playerStart);
  world.findTag(Tags.UserTarget).position.set(0, 0, 0);
}

function setPlayerPos(world, position) {
  world.findTag(Tags.UserTarget).position.copy(position);
  const char = world.findTag(Tags.UserCharacter);
  if (char) char.position.copy(position);
}
},{"three":"src/vendor/three.module.js"}],"src/systems/UserMoveSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = UserMoveSystem;

var THREE = _interopRequireWildcard(require("three"));

var Tags = _interopRequireWildcard(require("../tags"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _resetPlayerPos = require("../util/resetPlayerPos");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function UserMoveSystem(world) {
  const normalizedMousePosition = new THREE.Vector2();
  const raycaster = new THREE.Raycaster();
  const mousePlane = new THREE.Plane(new THREE.Vector3(-0, -1, -0), -0);
  const mousePlaneTarget = new THREE.Vector3();
  const tmpPos3D = new THREE.Vector3();
  const random = (0, _Random.default)();
  const mouseDirection = new THREE.Vector3();
  const moveDirection = new THREE.Vector3();
  let speed = 0.0;
  let minSpeed = 0.0;
  let maxSpeed = 3;
  let boost = 0;
  let minBoost = 0;
  let maxBoost = 4.5;
  const speedFactor = 1;
  const speedPower = 4;
  let mouseDirectionAngle;
  let moveDirectionAngle;
  let driftSpeed = 0.5;
  let driftAngle = MathUtil.degToRad(random.pick([1, 3, 5, 7]) * 45);
  const tmpCenter = [0, 0];
  const tmpUserPos = [0, 0];
  const tmpNewUserPos = [0, 0];
  const tmpReflect = [0, 0];
  const maxDist = 100;
  const maxWorldSize = 512 * 0.95;
  const userTargetEntity = world.entity("UserTargetEntity").add(Tags.UserTarget);
  const InputState = world.query(Tags.InputState);
  const MainCamera = world.query(Tags.MainCamera);
  const UserTarget = world.query(Tags.UserTarget);
  const boosts = world.view(Tags.MovementBoost);
  const clearInputPressTags = world.view(Tags.ClearInputPress);
  let wasForceApplied = null;
  return function userMoveSystem(dt) {
    let isInputBlocked = Boolean(world.findTag(Tags.BlockUserMove));
    let isCameraDirecting = Boolean(world.findTag(Tags.CameraStopUserMovement));
    let isTransitioning = Boolean(world.findTag(Tags.TransitionToNextBiome)) || Boolean(world.findTag(Tags.ShowBiomeResolution)); // if (isCameraDirecting && !isTransitioning) return;

    const input = world.findTag(InputState);
    const camera = world.findTag(MainCamera);
    const user = world.findEntity(UserTarget);
    const userData = user.get(Tags.UserTarget);
    const userTargetPos = userData.position;
    normalizedMousePosition.set(input.positionNormalized.x * 2 - 1, -input.positionNormalized.y * 2 + 1);
    raycaster.setFromCamera(normalizedMousePosition, camera);
    const clearPress = clearInputPressTags.length > 0;
    const hit = clearPress ? false : raycaster.ray.intersectPlane(mousePlane, mousePlaneTarget); // if (isTransitioning) {
    //   mousePlaneTarget.copy(standingNextToOriginTree);
    // }

    let speedMultiplier = 1;
    let allowInput = isTransitioning || input.interacted && !isInputBlocked;

    if (hit && allowInput) {
      tmpPos3D.set(userTargetPos.x, 0, userTargetPos.z);
      const userPlayer = world.findTag(Tags.UserCharacter);

      if (userPlayer) {// mouseDirection.copy(userPlayer.target).sub(tmpPos3D).normalize();
        // const dist = maxDist;
        // const dist = Math.min(
        //   maxDist,
        //   Math.max(
        //     userPlayer.position.distanceTo(mousePlaneTarget),
        //     userTargetPos.distanceTo(mousePlaneTarget)
        //   )
        // );
        // if (dist < 3) speedMultiplier = Math.pow(dist / 3, 1 / 10);
        // mouseDirection.copy(mousePlaneTarget).sub(tmpPos3D).normalize();
        // mouseDirectionAngle = Math.atan2(mouseDirection.z, mouseDirection.x);
        // if (moveDirectionAngle == null)
        //   moveDirectionAngle = mouseDirectionAngle;
      }

      mouseDirection.copy(mousePlaneTarget).sub(tmpPos3D);
      const len = mouseDirection.length();
      if (len !== 0) mouseDirection.divideScalar(len);
      const smooth = MathUtil.clamp01(Math.pow(len / 4, 1 / 25));
      speedMultiplier *= smooth;
      mouseDirectionAngle = Math.atan2(mouseDirection.z, mouseDirection.x);
      if (moveDirectionAngle == null) moveDirectionAngle = mouseDirectionAngle;
    }

    if (moveDirectionAngle != null && mouseDirectionAngle != null) {
      moveDirectionAngle = MathUtil.dampAngle(moveDirectionAngle, mouseDirectionAngle, 7, dt);
      moveDirection.set(Math.cos(moveDirectionAngle), 0, Math.sin(moveDirectionAngle));
    }

    const uiActive = Boolean(world.findTag(Tags.IsGameUIActive));
    const canMove = !clearPress && !isCameraDirecting && allowInput && !uiActive && !Boolean(world.findTag(Tags.OriginTreeIntroSequence)) && !Boolean(world.findTag(Tags.ModalStoppingUserMovement));
    let forceApplied = false;

    if ((input.pressed || isTransitioning) && canMove) {
      forceApplied = true;
      speed = MathUtil.damp(speed, maxSpeed, 5, dt);
      boost = MathUtil.damp(boost, maxBoost, 2, dt);
    } else {
      speed = MathUtil.damp(speed, minSpeed, 2, dt);
      boost = MathUtil.damp(boost, minBoost, 5, dt);
    }

    if (forceApplied !== wasForceApplied) {
      if (forceApplied) userTargetEntity.tagOn(Tags.UserForceApplied);else userTargetEntity.tagOff(Tags.UserForceApplied);
      wasForceApplied = forceApplied;
    }

    speed *= speedMultiplier;
    boost *= speedMultiplier;
    let boostScale = 0.25;
    let totalSpeed = speed + boost; // let totalSpeed = speed * (1 - boostScale) + boost * boostScale;

    let outside = false;
    let totalBoost = 0;
    const boostFactor = 1;
    boosts.forEach(e => {
      const curBoost = e.get(Tags.MovementBoost);
      totalBoost += curBoost.value;
      curBoost.value = MathUtil.damp(curBoost.value, 0.0001, curBoost.frictionPower, dt);
      curBoost.elapsed += dt;

      if (curBoost.elapsed >= curBoost.duration) {
        e.kill();
      }
    });
    let directionIncrease = dt * totalSpeed * speedFactor + totalBoost * boostFactor * dt;

    if (canMove) {
      userTargetPos.addScaledVector(moveDirection, directionIncrease);
    }

    const drift = world.findTag(Tags.GameLandingCameraDrift);
    let newDriftSpeed = driftSpeed;

    if (input.interacted && allowInput) {
      const u = input.positionNormalized.x * 2 - 1;
      const v = input.positionNormalized.y * 2 - 1;
      const dist = MathUtil.clamp01(Math.sqrt(u * u + v * v));
      newDriftSpeed = MathUtil.lerp(0.1, 0.75, Math.pow(dist, 0.5));
    }

    if (drift && drift.fixed != null) {
      newDriftSpeed = drift.fixed;
    }

    const newDriftAngle = moveDirectionAngle != null ? moveDirectionAngle : driftAngle;
    driftAngle = MathUtil.dampAngle(driftAngle, newDriftAngle, 3, dt);
    driftSpeed = MathUtil.dampAngle(driftSpeed, newDriftSpeed, 5, dt);

    if (drift) {
      // tmpPos3D.set(u, 0, v).normalize();
      tmpPos3D.set(Math.cos(driftAngle), 0, Math.sin(driftAngle)); // const moveAngle = MathUtil.degToRad(u * 180);

      userTargetPos.addScaledVector(tmpPos3D, dt * driftSpeed); // userTargetPos.x += Math.cos(moveAngle) * dt;
      // userTargetPos.z += Math.sin(moveAngle) * dt;
    }

    userTargetPos.x = MathUtil.clamp(-maxWorldSize / 2, maxWorldSize / 2, userTargetPos.x);
    userTargetPos.z = MathUtil.clamp(-maxWorldSize / 2, maxWorldSize / 2, userTargetPos.z); // userTargetPos.y = 0.15;

    userData.forceApplied = forceApplied;
    userData.direction.copy(moveDirection);
    userData.totalBoost = totalBoost;
    userData.speedAlpha = MathUtil.inverseLerp(minSpeed, maxSpeed, speed);
    userData.boostAlpha = MathUtil.inverseLerp(minBoost, maxBoost, boost);
    userData.totalSpeedAlpha = MathUtil.inverseLerp(minSpeed + minBoost, maxSpeed + maxBoost, totalSpeed);
    userData.inputHitPlane = hit;
    if (hit) userData.inputPositionOnPlane.copy(mousePlaneTarget);

    if (user.has(Tags.Object3D)) {
      const object = user.get(Tags.Object3D);
      object.position.copy(userTargetPos);
    }
  };
}
},{"three":"src/vendor/three.module.js","../tags":"src/tags/index.js","../util/math":"src/util/math.js","../util/Random":"src/util/Random.js","../util/resetPlayerPos":"src/util/resetPlayerPos.js"}],"src/shaders/line-3d.vert.js":[function(require,module,exports) {
module.exports = "#define GLSLIFY 1\n// #define IS_CLOSED\nattribute float direction;\nattribute vec2 vertexDistance;\nattribute vec3 nextPosition;\nattribute vec3 previousPosition;\nattribute float vertexHasToken;\n\nuniform bool taper;\nuniform bool miter;\nuniform float time;\nuniform float totalDistance;\nuniform float miterLimit;\nuniform float thickness;\nuniform float draw;\nuniform bool drawing;\nuniform bool filling;\n\nuniform vec2 resolution;\n\nvarying float vToken;\nvarying vec2 vDist;\n\nvec4 screenSpaceLine (vec3 offset, float computedThickness) {\n  float aspect = resolution.x / resolution.y;\n  vec2 aspectVec = vec2(aspect, 1.0);\n  mat4 projViewModel = projectionMatrix * modelViewMatrix;\n  vec4 previousProjected = projViewModel * vec4(vec3(previousPosition.xyz) + offset, 1.0);\n  vec4 currentProjected = projViewModel * vec4(vec3(position.xyz) + offset, 1.0);\n  vec4 nextProjected = projViewModel * vec4(vec3(nextPosition.xyz) + offset, 1.0);\n\n  //get 2D screen space with W divide and aspect correction\n  vec2 currentScreen = currentProjected.xy / currentProjected.w * aspectVec;\n  vec2 previousScreen = previousProjected.xy / previousProjected.w * aspectVec;\n  vec2 nextScreen = nextProjected.xy / nextProjected.w * aspectVec;\n  \n  float len = computedThickness;\n  float orientation = direction;\n  vec2 dirA = normalize(currentScreen - previousScreen);\n\n  //starting point uses (next - current)\n  vec2 dir = vec2(0.0);\n  #ifndef IS_CLOSED\n  if (currentScreen == previousScreen) {\n    dir = normalize(nextScreen - currentScreen);\n  } \n  //ending point uses (current - previous)\n  else if (currentScreen == nextScreen) {\n    dir = normalize(currentScreen - previousScreen);\n  }\n  //somewhere in middle, needs a join\n  else {\n  #endif\n    //get directions from (C - B) and (B - A)\n    vec2 dirB = normalize(nextScreen - currentScreen);\n    if (miter) {\n      //now compute the miter join normal and length\n      vec2 tangent = normalize(dirA + dirB);\n      vec2 perp = vec2(-dirA.y, dirA.x);\n      vec2 miter = vec2(-tangent.y, tangent.x);\n      float miterDot = dot(miter, perp);\n      len = miterDot == 0.0 ? 0.0 : (computedThickness / miterDot);\n      len = clamp(len, 0.0, computedThickness * miterLimit);\n      dir = tangent;\n    } else {\n      dir = normalize(dirA + dirB);\n    }\n  #ifndef IS_CLOSED\n  }\n  #endif\n\n  vec2 normal = vec2(-dir.y, dir.x);\n\n  // convert pixel thickness to NDC space\n  vec2 normalLength = vec2(len / 2.0);\n  normalLength = normalLength * 2.0;\n\n  // scale normal to line thickness\n  normal *= normalLength;\n  normal.x /= aspect;\n\n  vec4 finalOffset = vec4(normal * orientation, 0.0, 0.0);\n  return currentProjected + finalOffset;\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n  x = abs(x - c);\n  if( x>w ) return 0.0;\n  x /= w;\n  return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat parabola( float x, float k )\n{\n    return pow( 4.0*x*(1.0-x), k );\n}\n\nvoid main () {\n  float computedThickness = thickness;\n  // computedThickness *= mix(0.5, 1.0, vertexHasToken);\n  if (taper) computedThickness *= sin(3.14 * vertexDistance.x);\n\n  if (drawing) {\n    computedThickness *= smoothstep(1.0, 1.0-0.05, vertexDistance.x);\n    computedThickness *= smoothstep(0.0, 0.05, vertexDistance.x);\n    // computedThickness *= smoothstep(draw - smoothness, draw + smoothness, vertexDistance.x);\n\n    float e = 0.25;\n    float t = draw;\n\n    // computedThickness *= parabola(vertexDistance.x, 1.0);\n    float m = mix(-e, 1.0 + e, t);\n    float d = 1.0 - min(1.0, abs(vertexDistance.x - m) / e);\n    // computedThickness *= step(t, vertexDistance.x);\n\n    // float d = smoothstep(m + e, m - e, vertexDistance.x);\n    computedThickness *= cubicPulse(m, e, vertexDistance.x);\n    // computedThickness *= smoothstep(totalDistance, totalDistance / 2.0, vertexDistance.y);\n  } else if (filling) {\n    computedThickness *= step(vertexDistance.x, draw);\n  }\n  // computedThickness *= abs(vertexDistance.y / )\n  float yoff = sin(time + vertexDistance.x * 4.0) * 0.1;\n  vec3 offset = vec3(0.0, 0.0, 0.0);\n  // offset.y += 2.0 + sin(position.y * 4.0) * 2.0;\n  gl_Position = screenSpaceLine(offset, computedThickness);\n  vDist = vertexDistance;\n  vToken = vertexHasToken;\n}";
},{}],"src/shaders/line-3d.frag.js":[function(require,module,exports) {
module.exports = "#define GLSLIFY 1\nuniform vec3 color;\nuniform float opacity;\nuniform float time;\nuniform float totalDistance;\nuniform float dottedFill;\nuniform bool dotted;\n\nvarying vec2 vDist;\nvarying float vToken;\n\nfloat aastep(float threshold, float value) {\n  #ifdef GL_OES_standard_derivatives\n    float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n  #else\n    return step(threshold, value);\n  #endif  \n}\n\nvoid main() {\n  float d = vDist.y / totalDistance;\n\n  gl_FragColor = vec4(color, opacity);\n\n  if (dotted) {  \n    // float dotted = vToken > 0.5 ? 1.0 : step(0.5, fract(-time * 0.2 + vDist.y / 1.0));\n    float dotted = fract(-time * 0.2 + vDist.y / 0.5);\n    dotted = mix(dotted, 1.0, step(vDist.x, dottedFill));\n    gl_FragColor.a *= aastep(0.5, dotted);\n  }\n  // if (gl_FragColor.a < 0.5) discard;\n  // gl_FragColor = vec4(mix(vec3(1.0), vec3(1.0,0.0,0.0), vToken) * vec3(d), opacity);\n}\n";
},{}],"src/shaders/post-process.frag.js":[function(require,module,exports) {
module.exports = "#define GLSLIFY 1\nuniform highp sampler2D map;\nuniform sampler2D noiseMap;\nuniform sampler2D lutMap;\nuniform sampler2D glowMap;\nuniform float fadeToBlack;\nuniform vec3 fadeToBlackColor;\nuniform vec2 resolution;\nuniform vec3 rampColor0;\nuniform vec3 rampColor1;\n\nuniform float time;\nuniform float rampStrength;\nuniform float lightColor;\n\nvarying vec2 vUv;\n\n// uniform vec3 colorGradientA;\n\n// vec3 texGlowMap(vec2 uv);\n\n// #pragma glslify: blur = require('glsl-hash-blur', sample=texGlowMap, iterations=20)\n\n// vec3 texGlowMap(vec2 uv) {\n//   return texture2D(glowMap, uv).rgb;\n// }\n\nfloat blendOverlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n// #define LUT_FLIP_Y\n\nhighp vec3 colorLUT(in highp vec3 textureColor, in highp sampler2D lookupTable) {\n  textureColor = clamp(textureColor, 0.0, 1.0);\n  highp float blueColor = textureColor.b * 63.0;\n\n  highp vec2 quad1;\n  quad1.y = floor(floor(blueColor) / 8.0);\n  quad1.x = floor(blueColor) - (quad1.y * 8.0);\n\n  highp vec2 quad2;\n  quad2.y = floor(ceil(blueColor) / 8.0);\n  quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n\n  highp vec2 texPos1;\n  texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n  texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n\n  // #ifdef LUT_FLIP_Y\n  texPos1.y = 1.0-texPos1.y;\n  // #endif\n\n  highp vec2 texPos2;\n  texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n  texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n\n  // #ifdef LUT_FLIP_Y\n  texPos2.y = 1.0-texPos2.y;\n  // #endif\n\n  highp vec3 newColor1 = texture2D(lookupTable, texPos1).rgb;\n  highp vec3 newColor2 = texture2D(lookupTable, texPos2).rgb;\n\n  highp vec3 newColor = mix(newColor1, newColor2, fract(blueColor));\n  return newColor;\n}\n\n/**\nBasic FXAA implementation based on the code on geeks3d.com with the\nmodification that the texture2DLod stuff was removed since it's\nunsupported by WebGL.\n\n--\n\nFrom:\nhttps://github.com/mitsuhiko/webgl-meincraft\n\nCopyright (c) 2011 by Armin Ronacher.\n\nSome rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef FXAA_REDUCE_MIN\n    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n    #define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent \n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n            vec2 v_rgbNW, vec2 v_rgbNE, \n            vec2 v_rgbSW, vec2 v_rgbSE, \n            vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n    \n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    \n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * inverseVP;\n    \n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\n//To save 9 dependent texture reads, you can compute\n//these in the vertex shader and use the optimized\n//frag.glsl function in your frag shader. \n\n//This is best suited for mobile devices, like iOS.\n\nvoid texcoords(vec2 fragCoord, vec2 resolution,\n\t\t\tout vec2 v_rgbNW, out vec2 v_rgbNE,\n\t\t\tout vec2 v_rgbSW, out vec2 v_rgbSE,\n\t\t\tout vec2 v_rgbM) {\n\tvec2 inverseVP = 1.0 / resolution.xy;\n\tv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n\tv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n\tv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n\tv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n\tv_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvec4 apply(sampler2D tex, vec2 fragCoord, vec2 resolution) {\n\tmediump vec2 v_rgbNW;\n\tmediump vec2 v_rgbNE;\n\tmediump vec2 v_rgbSW;\n\tmediump vec2 v_rgbSE;\n\tmediump vec2 v_rgbM;\n\n\t//compute the texture coords\n\ttexcoords(fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\t\n\t//compute FXAA\n\treturn fxaa(tex, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n\n#define gamma 2.2\n\nvec2 rotateAround (vec2 vec, vec2 center, float angle) {\n  float c = cos( angle );\n  float s = sin( angle );\n\n  float x = vec.x - center.x;\n  float y = vec.y - center.y;\n\n  vec2 outVec;\n  outVec.x = x * c - y * s + center.x;\n  outVec.y = x * s + y * c + center.y;\n  return outVec;\n}\n\nfloat linearGradient (vec2 uv, vec2 start, vec2 end) {\n  vec2 gradientDirection = end - start;\n  float gradientLenSq = dot(gradientDirection, gradientDirection);\n  vec2 relCoords = uv - start;\n  float t = dot(relCoords, gradientDirection);\n  if (gradientLenSq != 0.0) t /= gradientLenSq;\n  return t;\n}\n\nvec4 texLinear (sampler2D image, vec2 uv) {\n  return texture2D(image, uv);\n  // return GammaToLinear(texture2D(image, uv), gamma);\n}\n\nvec4 chromatic (sampler2D image, vec2 uv, vec2 direction) {\n  vec4 col = vec4( 0.0 );\n  vec2 off = vec2( 1.3333333333333333 ) * direction;\n  col.a = 1.0;\n  col.r = texture2D( image, uv ).r;\n  col.g = texture2D( image, uv - ( off / resolution ) ).g;\n  col.b = texture2D( image, uv - 2.0 * ( off / resolution ) ).b;\n  return col;\n}\n\nvec3 linearToneMapping(vec3 color)\n{\n  float exposure = 1.;\n  color = clamp(exposure * color, 0., 1.);\n  color = pow(color, vec3(1. / gamma));\n  return color;\n}\n\nvec3 simpleReinhardToneMapping(vec3 color)\n{\n  float exposure = 1.5;\n  color *= exposure/(1. + color / exposure);\n  color = pow(color, vec3(1. / gamma));\n  return color;\n}\n\nvec3 lumaBasedReinhardToneMapping(vec3 color)\n{\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 whitePreservingLumaBasedReinhardToneMapping(vec3 color)\n{\n\tfloat white = 2.;\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma * (1. + luma / (white*white)) / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 RomBinDaHouseToneMapping(vec3 color)\n{\n    color = exp( -1.0 / ( 2.72*color + 0.15 ) );\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 filmicToneMapping(vec3 color)\n{\n\tcolor = max(vec3(0.), color - vec3(0.004));\n\tcolor = (color * (6.2 * color + .5)) / (color * (6.2 * color + 1.7) + 0.06);\n\treturn color;\n}\n\nvec4 sharpen(in sampler2D tex, in vec2 coords, in vec2 renderSize) {\n  float dx = 1.0 / renderSize.x;\n  float dy = 1.0 / renderSize.y;\n  vec4 sum = vec4(0.0);\n  sum += -1. * texture2D(tex, coords + vec2( -1.0 * dx , 0.0 * dy));\n  sum += -1. * texture2D(tex, coords + vec2( 0.0 * dx , -1.0 * dy));\n  sum += 5. * texture2D(tex, coords + vec2( 0.0 * dx , 0.0 * dy));\n  sum += -1. * texture2D(tex, coords + vec2( 0.0 * dx , 1.0 * dy));\n  sum += -1. * texture2D(tex, coords + vec2( 1.0 * dx , 0.0 * dy));\n  return sum;\n}\n\nvoid main2 () {\n  gl_FragColor = texture2D(map, vUv);\n}\n\nvoid main () {\n  vec2 nq = vUv / (20.0 / resolution.xy);\n  float aspect = resolution.x / resolution.y;\n  // if (aspect > 1.0) nq.x *= aspect;\n  // else nq.y /= aspect;\n  vec4 noise = texture2D(noiseMap, nq);\n\n  vec2 q = vUv - 0.5;\n  float d = length(q);\n\n  float caVig = smoothstep(0.3, 0.75, d);\n  vec2 direction = ( vUv - 0.5 ) * mix(0.5, 4.0, caVig) * noise.r * 1.0;\n  // vec2 direction = ( vUv - 0.5 ) * caVig * noise.r * 4.0;\n  // vec2 direction = ( vUv - 0.5 ) * 2.0 * noise.r;\n  // vec3 colorTex = mix(\n  //   chromatic(map, vUv, direction).rgb,\n  //   sharpen(map, vUv, resolution).rgb,\n  //   0.25\n  // );\n\n\tvec2 fragCoord = vUv * resolution;\n\t// vec3 colorTex = mix(\n  //   fxaa(map, fragCoord, resolution).rgb,\n  //   sharpen(map, vUv, resolution).rgb,\n  //   0.25\n  // );\n  // vec3 colorTex = fxaa(map, fragCoord, resolution).rgb;\n  vec3 colorTex = clamp(chromatic(map, vUv, direction).rgb, 0.0, 1.0);\n  // vec3 colorTex = texture2D(map, vUv).rgb;\n  // vec3 colorTex = mix(\n  //   chromatic(map, vUv, direction).rgb,\n  //   fxaa(map, fragCoord, resolution).rgb,\n  //   1.0-caVig\n  // );\n\n  // vec3 raw = colorTex;\n\n  vec2 corner = vec2(1.0, 1.0);\n  vec2 delta = vUv - corner;\n  if (aspect < 1.0) delta.x *= aspect;\n  else delta.y /= aspect;\n  float gradDist = clamp(1.0 - length(delta), 0.0, 1.0);\n\n  // colorTex.rgb += mix(rampColor0, rampColor1, vUv.y) * 0.1;\n  // colorTex.rgb = blendSoftLight(colorTex, colorTex + mix(rampColor0, rampColor1, vUv.y), 0.25);\n\n  // colorTex += gradDist * 0.1;\n  // colorTex = blendOverlay(colorTex, colorTex + gradDist , 0.05);\n  // colorTex += mix(rampColor0, rampColor1, vUv.y) * 0.05;\n  // colorTex.rgb = blendSoftLight(colorTex, mix(rampColor0, rampColor1, vUv.y), 0.1);\n\n  float vignetteStrength = 1.0;\n  float vignetteDarken = 0.2;\n\n  colorTex = blendSoftLight(colorTex, (noise.rgb*2.0-1.0), 0.05);\n\n  // colorTex.rgb = colorLUT(colorTex.rgb, lutMap);\n  colorTex = mix(colorTex, colorTex * smoothstep(1.0, 0.35, d), vignetteStrength * vignetteDarken);\n  colorTex = blendOverlay(colorTex, colorTex * 1.0, smoothstep(0.3, 1.0, d) * vignetteStrength);\n  colorTex = blendOverlay(colorTex, colorTex * 0.5, smoothstep(0.4, 0.9, d) * vignetteStrength);\n\n  gl_FragColor = vec4(vec3(colorTex), 1.0);\n\n  // color ramp\n  // vec3 colorRamp = mix(rampColor0, rampColor1, linearGradient(\n  //   vUv + noise.rg * 0.05,\n  //   vec2(1.0, 0.0),\n  //   vec2(0.0, 1.0)\n  // ));\n\n  // gl_FragColor.rgb = blendOverlay(gl_FragColor.rgb, colorRamp, rampStrength);\n  gl_FragColor.rgb = colorLUT(gl_FragColor.rgb, lutMap);\n  \n  // float lightRamp = linearGradient(\n  //   vUv + noise.ba * 0.05,\n  //   vec2(0.0, 0.0),\n  //   vec2(1.0, 1.0)\n  // );\n  // lightRamp = pow(lightRamp, 3.5);\n  // float sa = sin(vUv.x * 10.0 + vUv.y * -5.0 + 0.5);\n  // float sb = sin(vUv.x * 7.0 + vUv.y * -7.0 + time * 0.0);\n  // float str = 1.0;//. mix(0.0, 1.0, sin(time * 0.25 + vUv.x * 3.5)*0.5+0.5);\n  // float lightStr = lightRamp;\n  // float lightStr = step(0.5, ((sa * sb) * 0.5 + 0.5));\n  // lightRamp = smoothstep(0.5, 1.0, lightRamp);\n  // gl_FragColor.rgb = blendSoftLight(gl_FragColor.rgb, vec3(1.5), rampStrength * lightStr);\n  // gl_FragColor.rgb = blendSoftLight(gl_FragColor.rgb, vec3(1.0), rampStrength * lightStr * 0.1 * lightRamp);\n\n  #ifdef HAS_FLOAT\n  gl_FragColor.rgb += clamp(texture2D(glowMap, vUv).rgb, 0.0, 1.0);\n  #endif\n\n  // gl_FragColor.rgb += vec3(lightStr);\n\n  gl_FragColor.rgb = clamp(gl_FragColor.rgb, 0.0, 1.0);\n\n  gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(fadeToBlackColor), fadeToBlack);\n\n  // gl_FragColor.rgb = texture2D(glowMap, vUv).rgb;\n  // gl_FragColor.rgb += blur(vUv,10.0/resolution.x, 1.0);\n}\n\n//524b19\n// 47411A";
},{}],"src/shaders/post-process-bloom-glow.frag.js":[function(require,module,exports) {
module.exports = "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform sampler2D map;\nuniform vec2 direction;\nvarying vec2 vUv;\n\nvec4 blur13(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 off1 = vec2(1.411764705882353) * direction;\n  vec2 off2 = vec2(3.2941176470588234) * direction;\n  vec2 off3 = vec2(5.176470588235294) * direction;\n  color += texture2D(image, uv) * 0.1964825501511404;\n  color += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;\n  color += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;\n  color += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;\n  color += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;\n  color += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;\n  color += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;\n  return color;\n}\n\nvoid main() {\n  // gl_FragColor = texture2D(map, gl_FragCoord.xy /resolution.xy);\n  gl_FragColor = blur13(map, vUv, resolution.xy, direction);\n}";
},{}],"src/systems/SubmitFrameSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SubmitFrameSystem;
exports.GLOW_LAYER = void 0;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _postProcess = _interopRequireDefault(require("../shaders/post-process.frag"));

var _queryString = _interopRequireDefault(require("../util/query-string"));

var _load = require("../util/load");

var _postProcessBloomGlow = _interopRequireDefault(require("../shaders/post-process-bloom-glow.frag"));

var _AnimationSystem = require("./AnimationSystem");

var ShaderManager = _interopRequireWildcard(require("../util/ShaderManager"));

var _Assets = _interopRequireDefault(require("../util/Assets"));

var _addFrameTasks = require("../util/addFrameTasks");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import lutMapUrl from "../assets/textures/lut-post-process.png";
// import noiseMapUrl from "../assets/textures/HDR_RGBA_0.png";
const LUT_ID = "image/data/lut-forest";
const NOISE_ID = "image/data/bluenoise-0"; // pre-fetch these assets at startup as they are needed to render a frame
// Assets.prepare([NOISE_ID, LUT_ID]);

const GLOW_LAYER = 12;
exports.GLOW_LAYER = GLOW_LAYER;

function SubmitFrameSystem(world, opt = {}) {
  const {
    fade = 0
  } = opt;
  const renderer = world.findTag(Tags.Renderer);
  const supportsHalfFloat = renderer.capabilities.isWebGL2 || Boolean(renderer.extensions.get("OES_texture_half_float"));
  const supportsFullFloat = renderer.capabilities.isWebGL2 || Boolean(renderer.extensions.get("OES_texture_float"));
  let renderTarget, renderTargetGlow, renderTargetGlow1, renderTargetGlow2;
  let renderTargetGround;
  const glowWidth = 512;
  const glowBlurWidth = 512;
  const groundWidth = 768;
  const shouldDrawGround = _queryString.default.ground !== false;
  const shouldUseFloat = _queryString.default.float !== false;
  const shouldUsePost = _queryString.default.post !== false;
  const canUseFloat = shouldUseFloat && (supportsHalfFloat || supportsFullFloat);
  let currentLut = null;
  const lutMap = new THREE.Texture();
  lutMap.minFilter = lutMap.magFilter = THREE.LinearFilter;
  lutMap.generateMipmaps = false; // await Assets.createGPUTexture(renderer, LUT_ID, {
  //   minFilter: THREE.LinearFilter,
  //   magFilter: THREE.LinearFilter,
  //   generateMipmaps: false,
  // });

  const [noiseMap] = _Assets.default.createGPUTextureTask(renderer, NOISE_ID, {
    wrapS: THREE.RepeatWrapping,
    wrapT: THREE.RepeatWrapping
  });

  const shadowCasters = world.view([Tags.ShadowCaster, Tags.Object3D]);
  const postScene = new THREE.Scene();
  const postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
  const postGeometry = new THREE.BufferGeometry();
  postGeometry.setAttribute("position", new THREE.Float32BufferAttribute([-1, -1, -1, 4, 4, -1], 2));
  const plainVertexShader =
  /*glsl*/
  `
    varying vec2 vUv;
    void main () {
      vUv = position.xy * 0.5 + 0.5;
      gl_Position = vec4(position.xy, 0.0, 1.0);
    }
  `;
  const plainMaterial = new THREE.ShaderMaterial({
    name: "GlowPass1Material",
    depthWrite: true,
    depthTest: false,
    uniforms: {
      map: {
        value: new THREE.Texture()
      }
    },
    side: THREE.BackSide,
    vertexShader: plainVertexShader,
    fragmentShader:
    /*glsl*/
    `
      varying vec2 vUv;
      uniform sampler2D map;
      void main () {
        gl_FragColor = texture2D(map, vUv);
      }
    `
  });
  const glowPass0Material = new THREE.ShaderMaterial({
    name: "GlowPass0Material",
    depthWrite: false,
    depthTest: false,
    uniforms: {
      resolution: {
        value: new THREE.Vector2(0, 0)
      },
      map: {
        value: new THREE.Texture()
      }
    },
    defines: {
      HAS_FLOAT: canUseFloat
    },
    side: THREE.BackSide,
    vertexShader: plainVertexShader,
    fragmentShader:
    /*glsl*/
    `
      uniform highp sampler2D map;
      varying vec2 vUv;
      float luma(vec3 color) {
        return dot(color, vec3(0.299, 0.587, 0.114));
      }
      void main () {
        vec3 rgb = texture2D(map, vUv).rgb;
        
        #ifdef HAS_FLOAT
          vec3 col;
          col.r = rgb.r > 1.0 ? rgb.r : 0.0;
          col.g = rgb.g > 1.0 ? rgb.g : 0.0;
          col.b = rgb.b > 1.0 ? rgb.b : 0.0;
          col -= 1.0;
          col = max(col, 0.0);
          gl_FragColor = vec4(col, 1.0);
        #else
          float L = luma(rgb);
          gl_FragColor = vec4(vec3(smoothstep(0.75, 1.0, L)), 1.0);
        #endif
      }
    `
  });
  const glowPass1Material = new THREE.ShaderMaterial({
    name: "GlowPass1Material",
    depthWrite: false,
    depthTest: false,
    uniforms: {
      direction: {
        value: new THREE.Vector2(1, 0)
      },
      resolution: {
        value: new THREE.Vector2(0, 0)
      },
      map: {
        value: new THREE.Texture()
      }
    },
    side: THREE.BackSide,
    vertexShader: plainVertexShader,
    fragmentShader: _postProcessBloomGlow.default
  });
  const postMaterial = new THREE.ShaderMaterial({
    name: "PostMaterial",
    depthWrite: false,
    depthTest: false,
    defines: {
      HAS_FLOAT: canUseFloat
    },
    uniforms: {
      resolution: {
        value: new THREE.Vector2(0, 0)
      },
      noiseMap: {
        value: noiseMap
      },
      glowMap: {
        value: new THREE.Texture()
      },
      lutMap: {
        value: lutMap
      },
      rampColor0: {
        value: new THREE.Color("#57738f")
      },
      rampColor1: {
        value: new THREE.Color("#172a46")
      },
      rampStrength: {
        value: 1
      },
      time: {
        value: 0
      },
      map: {
        value: new THREE.Texture()
      },
      fadeToBlackColor: {
        value: new THREE.Color("#130904")
      },
      fadeToBlack: {
        value: fade
      }
    },
    side: THREE.BackSide,
    vertexShader: plainVertexShader,
    fragmentShader: _postProcess.default
  });
  const postQuad = new THREE.Mesh(postGeometry, postMaterial);
  postQuad.name = "post-process-quad";
  postQuad.frustumCulled = false;
  postScene.add(postQuad); // const groundTag = world.findTag(Tags.GroundPlaneView);
  // const shadowTag = world.findTag(Tags.SpriteBlobShadowView);
  // const grassTag = world.findTag(Tags.GrassPlaneView);

  const renderLayers = world.findTag(Tags.RenderLayers);
  const postProcess = world.entity().add(Tags.PostProcessEnabled, shouldUsePost);
  const faderEvents = world.listen(Tags.ScreenFade);
  const faderView = world.view(Tags.ScreenFade);
  const appState = world.findTag(Tags.AppState);
  const activeEnvView = world.view(Tags.ActiveEnvironmentState);
  const editableData = world.findTag(Tags.GroundMeshEditableData);
  let compiled = false;
  const lutIds = {
    forest: "forest",
    tundra: "tundra6",
    grasslands: "grasslands"
  };
  window.printStats = printStats;
  return function submitFrameSystem(dt) {
    if (activeEnvView.length > 0) {
      const state = activeEnvView[0].get(Tags.EnvironmentState);
      let newLut = lutIds[state.name];

      if (currentLut !== newLut) {
        currentLut = newLut; // dynamically swap LUT maps as needed

        _Assets.default.loadGPUTexture(renderer, lutMap, `image/data/lut-${currentLut}`); // postMaterial.uniforms.rampStrength.value =
        //   state.name === "tundra" ? 0 : 0;

      }
    }

    if (appState.rendering) {
      postMaterial.uniforms.time.value += dt;
      doRender(dt);
    }
  };

  function doRender(dt = 0) {
    const doPost = postProcess.get(Tags.PostProcessEnabled);
    const scene = world.findTag(Tags.MainScene);
    const camera = world.findTag(Tags.MainCamera);
    const canvas = renderer.domElement;
    const width = appState.canvasWidth;
    const height = appState.canvasHeight; // nothing to render

    if (!width || !height) return;
    const aspect = width / height;
    const atmospherics = world.findTag(Tags.Atmospherics);

    if (!renderTarget) {
      renderTarget = new THREE.WebGLRenderTarget(width, height);
      renderTarget.texture.generateMipmaps = false;
      renderTarget.texture.minFilter = THREE.LinearFilter;
      renderTarget.texture.magFilter = THREE.LinearFilter;

      if (canUseFloat) {
        renderTarget.texture.type = supportsHalfFloat ? THREE.HalfFloatType : THREE.FloatType;
      }

      postMaterial.uniforms.map.value = renderTarget.texture;
      postMaterial.uniforms.resolution.value.set(width, height);
    }

    if (width !== renderTarget.width || height !== renderTarget.height) {
      renderTarget.setSize(width, height);
      postMaterial.uniforms.resolution.value.set(width, height);
    } // const curGroundWidth = Math.min(groundWidth, width / 2);
    // const curGroundHeight = Math.round(curGroundWidth / aspect);
    // if (
    //   !renderTargetGround ||
    //   renderTargetGround.width !== curGroundWidth ||
    //   renderTargetGround.height !== curGroundHeight
    // ) {
    //   if (!renderTargetGround) {
    //     renderTargetGround = new THREE.WebGLRenderTarget(
    //       curGroundWidth,
    //       curGroundHeight
    //     );
    //     renderTargetGround.texture.generateMipmaps = false;
    //     renderTargetGround.texture.minFilter = THREE.LinearFilter;
    //     renderTargetGround.texture.magFilter = THREE.LinearFilter;
    //     renderTargetGround.depthBuffer = true;
    //   } else {
    //     renderTargetGround.setSize(curGroundWidth, curGroundHeight);
    //   }
    // }


    const gWidth = Math.min(glowWidth, width);
    const gHeight = Math.round(gWidth / aspect);

    if (!renderTargetGlow || renderTargetGlow.width !== gWidth || renderTargetGlow.height !== gHeight) {
      if (!renderTargetGlow) {
        renderTargetGlow = new THREE.WebGLRenderTarget(gWidth, gHeight);
        renderTargetGlow.depthBuffer = false;
        renderTargetGlow.texture.generateMipmaps = false;
        renderTargetGlow.texture.minFilter = THREE.LinearFilter;
        renderTargetGlow.texture.magFilter = THREE.LinearFilter;
      } else {
        renderTargetGlow.setSize(gWidth, gHeight);
      }
    }

    const g1Width = Math.min(width, glowBlurWidth);
    const g1Height = Math.round(g1Width / aspect);

    if (!renderTargetGlow1 || renderTargetGlow1.width !== g1Width || renderTargetGlow1.height !== g1Height) {
      if (!renderTargetGlow1) {
        renderTargetGlow1 = new THREE.WebGLRenderTarget(g1Width, g1Height);
        renderTargetGlow1.depthBuffer = false; // renderTargetGlow1.texture.type = THREE.HalfFloatType;

        renderTargetGlow1.texture.generateMipmaps = false;
        renderTargetGlow1.texture.minFilter = THREE.LinearFilter;
        renderTargetGlow1.texture.magFilter = THREE.LinearFilter;
        renderTargetGlow2 = renderTargetGlow1.clone();
      } else {
        renderTargetGlow1.setSize(g1Width, g1Height);
        renderTargetGlow2.setSize(g1Width, g1Height);
      }

      glowPass1Material.uniforms.resolution.value.set(g1Width, g1Height);
    }

    if (faderEvents.changed) {
      faderEvents.added.forEach(e => {
        const d = e.get(Tags.ScreenFade); // postMaterial.uniforms.fadeToBlack.value = d.from;

        (0, _AnimationSystem.setEntityTweenFromTo)(e, postMaterial.uniforms.fadeToBlack, "value", d.from, d.to, d.duration, d.ease, d.delay);
        const tween = e.get(Tags.TargetKeyTween);
        tween.assignFromOnStart = true;
        tween.callbackOnStart = d.callbackOnStart;
        tween.callbackOnFinish = d.callbackOnFinish;
      });
    }

    const wasAutoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.info.autoReset = false;
    scene.autoUpdate = false;
    scene.matrixAutoUpdate = false;
    scene.updateMatrix();
    scene.updateMatrixWorld();
    renderer.info.reset(); // initialize any pending shaders

    ShaderManager.initialize(renderer, 15);

    if (!compiled) {
      compiled = true;
      console.log("Compiling scene");
      renderer.compile(scene, camera);
    }

    (0, _addFrameTasks.preRender)(); // first render a down-sampled ground
    // renderer.setRenderTarget(renderTargetGround);
    // renderer.clear();
    // camera.layers.disableAll();
    // camera.layers.enable(renderLayers.ground);
    // renderer.render(scene, camera);

    if (doPost) renderer.setRenderTarget(renderTarget);else renderer.setRenderTarget(null); // draw main scene

    renderer.clear(); // postQuad.material = plainMaterial;
    // postQuad.material.uniforms.map.value = renderTargetGround.texture;
    // renderer.render(postScene, postCamera);

    camera.layers.disableAll();

    if (shouldDrawGround) {
      camera.layers.enable(renderLayers.grass);
      camera.layers.enable(renderLayers.ground);
    }

    camera.layers.enable(renderLayers.groundDepth);
    camera.layers.enable(renderLayers.water); // renderer.render(scene, camera);
    // camera.layers.disableAll();

    camera.layers.enable(renderLayers.shadow);
    drawShadows(scene, camera);
    camera.layers.enableAll(); // camera.layers.disable(GLOW_LAYER);

    camera.layers.disable(renderLayers.water);
    camera.layers.disable(renderLayers.shadow);
    camera.layers.disable(renderLayers.ground);
    camera.layers.disable(renderLayers.groundDepth);
    camera.layers.disable(renderLayers.atmospherics);
    camera.layers.disable(renderLayers.grass);
    renderer.render(scene, camera);

    if (doPost) {
      // downsample + threshold result
      if (canUseFloat) {
        renderer.setRenderTarget(renderTargetGlow); // renderer.clear();

        postQuad.material = glowPass0Material;
        glowPass0Material.uniforms.map.value = renderTarget.texture;
        glowPass0Material.uniforms.resolution.value.set(gWidth, gHeight);
        renderer.render(postScene, postCamera); // now do a horizontal pass

        renderer.setRenderTarget(renderTargetGlow1); // renderer.clear();

        postQuad.material = glowPass1Material;
        glowPass1Material.uniforms.map.value = renderTargetGlow.texture;
        glowPass1Material.uniforms.resolution.value.set(gWidth, gHeight);
        glowPass1Material.uniforms.direction.value.set(1, 0);
        renderer.render(postScene, postCamera); // vertical pass

        renderer.setRenderTarget(renderTargetGlow2); // renderer.clear();

        postQuad.material = glowPass1Material;
        glowPass1Material.uniforms.map.value = renderTargetGlow1.texture;
        glowPass1Material.uniforms.resolution.value.set(g1Width, g1Height);
        glowPass1Material.uniforms.direction.value.set(0, 1);
        renderer.render(postScene, postCamera);
      }

      renderer.setRenderTarget(null); // renderer.clear();

      postQuad.material = postMaterial;

      if (canUseFloat) {
        postMaterial.uniforms.glowMap.value = renderTargetGlow2.texture;
      }

      postMaterial.uniforms.lutMap.value = editableData.useCustomLUT ? editableData.lutMap : lutMap;
      renderer.render(postScene, postCamera);
    } // if (atmospherics) {
    //   renderer.render(atmospherics.scene, atmospherics.camera);
    // }


    renderer.autoClear = wasAutoClear;
    (0, _addFrameTasks.postRender)(); // camera.layers.enableAll();
    // renderer.render(scene, camera);
    // console.log(glowPass0Material.uniforms.resolution);
    // console.log(glowPass1Material.uniforms.resolution);
    // console.log(postMaterial.uniforms.resolution);
  }

  function printStats() {
    let sum = 0;
    world.findTag(Tags.MainScene).traverse(child => {
      if (child.isMesh) sum++;
    });
    console.log("Total Meshes", sum);
    console.log("Geometries", renderer.info.memory.geometries);
    console.log("Textures", renderer.info.memory.textures);
    console.log("Calls", renderer.info.render.calls);
    console.log("Triangles", renderer.info.render.triangles);
    console.log("Points", renderer.info.render.points);
    console.log("Programs", renderer.info.programs.map(p => p.name));
  }

  function drawShadows(scene, camera) {
    for (let i = 0; i < shadowCasters.length; i++) {
      const e = shadowCasters[i];
      const child = e.get(Tags.Object3D);

      if (child.visible && child.isMesh && child.userData.__shadowMaterial && child.userData.__shadowEnabled) {
        child.userData.__material = child.material;
        child.userData.__materialDepthTest = child.material.depthTest;
        child.userData.__materialDepthWrite = child.material.depthWrite;
        child.userData.__materialBlending = child.material.blending;
        child.userData.__materialTransparent = child.material.transparent;
        child.material = child.userData.__shadowMaterial;
        child.material.depthTest = true;
        child.material.depthWrite = false;
        child.material.transparent = true;
        child.material.blending = THREE.MultiplyBlending;

        if (child.material.uniforms && child.material.uniforms.silhouette) {
          child.material.uniforms.silhouette.value = true;
        }
      }
    }

    renderer.render(scene, camera);

    for (let i = 0; i < shadowCasters.length; i++) {
      const e = shadowCasters[i];
      const child = e.get(Tags.Object3D);

      if (child.visible && child.isMesh && child.userData.__material) {
        child.material = child.userData.__material;
        child.material.depthWrite = child.userData.__materialDepthTest;
        child.material.depthTest = child.userData.__materialDepthWrite;
        child.material.transparent = child.userData.__materialTransparent;
        child.material.blending = child.userData.__materialBlending;

        if (child.material.uniforms && child.material.uniforms.silhouette) {
          child.material.uniforms.silhouette.value = false;
        }
      }
    }
  }

  function setMaterial(mat, target) {
    postQuad.material = mat;
    const width = target.width;
    const height = target.height;

    if (mat.uniforms.resolution) {
      mat.uniforms.resolution.value.set(width, height);
    }
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../shaders/post-process.frag":"src/shaders/post-process.frag.js","../util/query-string":"src/util/query-string.js","../util/load":"src/util/load.js","../shaders/post-process-bloom-glow.frag":"src/shaders/post-process-bloom-glow.frag.js","./AnimationSystem":"src/systems/AnimationSystem.js","../util/ShaderManager":"src/util/ShaderManager.js","../util/Assets":"src/util/Assets.js","../util/addFrameTasks":"src/util/addFrameTasks.js"}],"src/systems/writing/Line3D.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var Tags = _interopRequireWildcard(require("../../tags"));

var THREE = _interopRequireWildcard(require("three"));

var MathUtils = _interopRequireWildcard(require("../../util/math"));

var _line3d = _interopRequireDefault(require("../../shaders/line-3d.vert"));

var _line3d2 = _interopRequireDefault(require("../../shaders/line-3d.frag"));

var _SubmitFrameSystem = require("../SubmitFrameSystem");

var ShaderManager = _interopRequireWildcard(require("../../util/ShaderManager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const tmpPos3D = new THREE.Vector3();
const tmpPos3DB = new THREE.Vector3();
const tmpArray3 = [0, 0, 0];

function getTempPosition(vertex, withData, isVector) {
  vertex = withData ? vertex.position : vertex;

  if (isVector) {
    tmpArray3[0] = vertex.x;
    tmpArray3[1] = vertex.y;
    tmpArray3[2] = vertex.z;
    return tmpArray3;
  } else {
    return vertex;
  }
}

class LineGeometry extends THREE.BufferGeometry {
  updatePath(line, withData, isVector) {
    const vertexCount = line.length; // TODO: interleave this data into a single buffer?

    const position = [];
    const previousPosition = [];
    const nextPosition = [];
    const direction = [];
    const vertexHasToken = [];
    const vertexDistance = [];
    let distSum = 0;

    for (let i = 0; i < vertexCount; i++) {
      const item = line[i];
      let d = getTempPosition(item, withData, isVector);
      const tokenVal = 1; // const tokenVal = d.token ? 1 : 0;
      // const dist = d.distance;

      const x = d[0];
      const y = d[1];
      const z = d[2];
      position.push(x, y, z, x, y, z);
      const pItem = i < 1 ? line[i] : line[i - 1];
      const pd = getTempPosition(pItem, withData, isVector);
      const px = pd[0];
      const py = pd[1];
      const pz = pd[2];
      previousPosition.push(px, py, pz, px, py, pz);
      let dist = 0;

      if (i > 0) {
        tmpPos3D.set(x, y, z);
        distSum += tmpPos3D.distanceTo(tmpPos3DB);
        dist = distSum;
      }

      tmpPos3DB.set(x, y, z);
      const nItem = i < line.length - 1 ? line[i + 1] : line[line.length - 1];
      const nd = getTempPosition(nItem, withData, isVector);
      const nx = nd[0];
      const ny = nd[1];
      const nz = nd[2];
      nextPosition.push(nx, ny, nz, nx, ny, nz);
      vertexHasToken.push(tokenVal, tokenVal);
      direction.push(-1, 1);
      const alpha = vertexCount <= 1 ? 0.5 : i / (vertexCount - 1);
      vertexDistance.push(alpha, dist, alpha, dist);
    }

    this.setAttribute("position", new THREE.Float32BufferAttribute(position, 3));
    this.setAttribute("nextPosition", new THREE.Float32BufferAttribute(nextPosition, 3));
    this.setAttribute("previousPosition", new THREE.Float32BufferAttribute(previousPosition, 3));
    this.setAttribute("direction", new THREE.Float32BufferAttribute(direction, 1));
    this.setAttribute("vertexHasToken", new THREE.Float32BufferAttribute(vertexHasToken, 1));
    this.setAttribute("vertexDistance", new THREE.Float32BufferAttribute(vertexDistance, 2));
    const indexUint16 = vertexCount >= 2 ? createIndices(vertexCount - 1) : new Uint16Array(0);
    this.setIndex(new THREE.BufferAttribute(indexUint16, 1));
    this.updateBounds();
    return distSum;
  }

  updateBounds() {
    const pos = this.attributes.position;
    if (!this.boundingBox) this.boundingBox = new THREE.Box3();
    if (!this.boundingSphere) this.boundingSphere = new THREE.Sphere();
    this.boundingBox.makeEmpty();

    for (let i = 0; i < pos.count; i += 2) {
      const x = pos.getX(i);
      const y = pos.getY(i);
      const z = pos.getZ(i);
      tmpPos3D.set(x, y, z);
      this.boundingBox.expandByPoint(tmpPos3D);
    }

    const maxY = Math.max(this.boundingBox.min.y, this.boundingBox.max.y);
    this.boundingBox.min.y = 0;
    this.boundingBox.max.y = maxY;
    this.boundingBox.getBoundingSphere(this.boundingSphere);
  }

}

class Line3D extends THREE.Group {
  constructor(world, opts = {}) {
    super();
    const {
      blending = THREE.NormalBlending,
      thickness = 0.5,
      opacity = 1,
      bloom = 1.5,
      draw = 1,
      geometry,
      depthWrite = true,
      depthTest = true
    } = opts;
    const color = new THREE.Color(opts.color || "white");
    color.r += bloom;
    color.g += bloom;
    color.b += bloom;
    this.thickness = thickness;
    this.geometry = geometry || new LineGeometry();
    this.material = ShaderManager.create({
      name: "Line3D",
      side: THREE.DoubleSide,
      transparent: true,
      blending,
      depthTest,
      depthWrite,
      vertexShader: _line3d.default,
      fragmentShader: _line3d2.default,
      extensions: {
        derivatives: true
      },
      uniforms: {
        dottedFill: {
          value: opts.dottedFill || 0
        },
        dotted: {
          value: Boolean(opts.dotted),
          type: "b"
        },
        opacity: {
          value: opacity
        },
        time: {
          value: 0
        },
        color: {
          value: color
        },
        resolution: {
          value: new THREE.Vector2()
        },
        thickness: {
          value: this.thickness
        },
        miterLimit: {
          value: 8
        },
        totalDistance: {
          value: 0
        },
        taper: {
          value: opts.taper !== false,
          type: "b"
        },
        draw: {
          value: draw
        },
        drawing: {
          value: Boolean(opts.false),
          type: "b"
        },
        filling: {
          value: Boolean(opts.filling),
          type: "b"
        },
        miter: {
          value: true,
          type: "b"
        }
      }
    });
    const entity = world.entity();
    entity.add(Tags.ShaderUniformResolution, {
      uniform: this.material.uniforms.resolution
    });
    entity.add(Tags.ShaderUniformTime, {
      uniform: this.material.uniforms.time
    });
    this.mesh = new THREE.Mesh(this.geometry, this.material);
    this.mesh.frustumCulled = true;
    this.mesh.renderOrder = 10; // this.mesh.layers.enable(GLOW_LAYER);

    this.add(this.mesh); // this._helper = world.entity().add(Tags.Object3D, new THREE.BoxHelper(this));

    this.userData = {
      entity
    };
  }

  setAlpha(alpha) {
    this.material.uniforms.opacity.value = alpha;
  }

  step(dt = 0) {// this.material.uniforms.time.value += dt;
  }

  updatePath(positions, withData, isVector) {
    const totalDist = this.geometry.updatePath(positions, withData, isVector);
    this.mesh.material.uniforms.totalDistance.value = totalDist; // this._helper.get(Tags.Object3D).update();
  }

} // counter-clockwise indices but prepared for duplicate vertices


exports.default = Line3D;

function createIndices(length) {
  let indices = new Uint16Array(length * 6);
  let c = 0;
  let index = 0;

  for (let j = 0; j < length; j++) {
    let i = index;
    indices[c++] = i + 0;
    indices[c++] = i + 1;
    indices[c++] = i + 2;
    indices[c++] = i + 2;
    indices[c++] = i + 1;
    indices[c++] = i + 3;
    index += 2;
  }

  return indices;
}
},{"../../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../../util/math":"src/util/math.js","../../shaders/line-3d.vert":"src/shaders/line-3d.vert.js","../../shaders/line-3d.frag":"src/shaders/line-3d.frag.js","../SubmitFrameSystem":"src/systems/SubmitFrameSystem.js","../../util/ShaderManager":"src/util/ShaderManager.js"}],"node_modules/parse-svg-path/index.js":[function(require,module,exports) {

module.exports = parse

/**
 * expected argument lengths
 * @type {Object}
 */

var length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}

/**
 * segment pattern
 * @type {RegExp}
 */

var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig

/**
 * parse an svg path data string. Generates an Array
 * of commands where each command is an Array of the
 * form `[command, arg1, arg2, ...]`
 *
 * @param {String} path
 * @return {Array}
 */

function parse(path) {
	var data = []
	path.replace(segment, function(_, command, args){
		var type = command.toLowerCase()
		args = parseValues(args)

		// overloaded moveTo
		if (type == 'm' && args.length > 2) {
			data.push([command].concat(args.splice(0, 2)))
			type = 'l'
			command = command == 'm' ? 'l' : 'L'
		}

		while (true) {
			if (args.length == length[type]) {
				args.unshift(command)
				return data.push(args)
			}
			if (args.length < length[type]) throw new Error('malformed path data')
			data.push([command].concat(args.splice(0, length[type])))
		}
	})
	return data
}

var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig

function parseValues(args) {
	var numbers = args.match(number)
	return numbers ? numbers.map(Number) : []
}

},{}],"node_modules/adaptive-bezier-curve/function.js":[function(require,module,exports) {
function clone(point) { //TODO: use gl-vec2 for this
    return [point[0], point[1]]
}

function vec2(x, y) {
    return [x, y]
}

module.exports = function createBezierBuilder(opt) {
    opt = opt||{}

    var RECURSION_LIMIT = typeof opt.recursion === 'number' ? opt.recursion : 8
    var FLT_EPSILON = typeof opt.epsilon === 'number' ? opt.epsilon : 1.19209290e-7
    var PATH_DISTANCE_EPSILON = typeof opt.pathEpsilon === 'number' ? opt.pathEpsilon : 1.0

    var curve_angle_tolerance_epsilon = typeof opt.angleEpsilon === 'number' ? opt.angleEpsilon : 0.01
    var m_angle_tolerance = opt.angleTolerance || 0
    var m_cusp_limit = opt.cuspLimit || 0

    return function bezierCurve(start, c1, c2, end, scale, points) {
        if (!points)
            points = []

        scale = typeof scale === 'number' ? scale : 1.0
        var distanceTolerance = PATH_DISTANCE_EPSILON / scale
        distanceTolerance *= distanceTolerance
        begin(start, c1, c2, end, points, distanceTolerance)
        return points
    }


    ////// Based on:
    ////// https://github.com/pelson/antigrain/blob/master/agg-2.4/src/agg_curves.cpp

    function begin(start, c1, c2, end, points, distanceTolerance) {
        points.push(clone(start))
        var x1 = start[0],
            y1 = start[1],
            x2 = c1[0],
            y2 = c1[1],
            x3 = c2[0],
            y3 = c2[1],
            x4 = end[0],
            y4 = end[1]
        recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, 0)
        points.push(clone(end))
    }

    function recursive(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level) {
        if(level > RECURSION_LIMIT) 
            return

        var pi = Math.PI

        // Calculate all the mid-points of the line segments
        //----------------------
        var x12   = (x1 + x2) / 2
        var y12   = (y1 + y2) / 2
        var x23   = (x2 + x3) / 2
        var y23   = (y2 + y3) / 2
        var x34   = (x3 + x4) / 2
        var y34   = (y3 + y4) / 2
        var x123  = (x12 + x23) / 2
        var y123  = (y12 + y23) / 2
        var x234  = (x23 + x34) / 2
        var y234  = (y23 + y34) / 2
        var x1234 = (x123 + x234) / 2
        var y1234 = (y123 + y234) / 2

        if(level > 0) { // Enforce subdivision first time
            // Try to approximate the full cubic curve by a single straight line
            //------------------
            var dx = x4-x1
            var dy = y4-y1

            var d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx)
            var d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx)

            var da1, da2

            if(d2 > FLT_EPSILON && d3 > FLT_EPSILON) {
                // Regular care
                //-----------------
                if((d2 + d3)*(d2 + d3) <= distanceTolerance * (dx*dx + dy*dy)) {
                    // If the curvature doesn't exceed the distanceTolerance value
                    // we tend to finish subdivisions.
                    //----------------------
                    if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                        points.push(vec2(x1234, y1234))
                        return
                    }

                    // Angle & Cusp Condition
                    //----------------------
                    var a23 = Math.atan2(y3 - y2, x3 - x2)
                    da1 = Math.abs(a23 - Math.atan2(y2 - y1, x2 - x1))
                    da2 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - a23)
                    if(da1 >= pi) da1 = 2*pi - da1
                    if(da2 >= pi) da2 = 2*pi - da2

                    if(da1 + da2 < m_angle_tolerance) {
                        // Finally we can stop the recursion
                        //----------------------
                        points.push(vec2(x1234, y1234))
                        return
                    }

                    if(m_cusp_limit !== 0.0) {
                        if(da1 > m_cusp_limit) {
                            points.push(vec2(x2, y2))
                            return
                        }

                        if(da2 > m_cusp_limit) {
                            points.push(vec2(x3, y3))
                            return
                        }
                    }
                }
            }
            else {
                if(d2 > FLT_EPSILON) {
                    // p1,p3,p4 are collinear, p2 is considerable
                    //----------------------
                    if(d2 * d2 <= distanceTolerance * (dx*dx + dy*dy)) {
                        if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                            points.push(vec2(x1234, y1234))
                            return
                        }

                        // Angle Condition
                        //----------------------
                        da1 = Math.abs(Math.atan2(y3 - y2, x3 - x2) - Math.atan2(y2 - y1, x2 - x1))
                        if(da1 >= pi) da1 = 2*pi - da1

                        if(da1 < m_angle_tolerance) {
                            points.push(vec2(x2, y2))
                            points.push(vec2(x3, y3))
                            return
                        }

                        if(m_cusp_limit !== 0.0) {
                            if(da1 > m_cusp_limit) {
                                points.push(vec2(x2, y2))
                                return
                            }
                        }
                    }
                }
                else if(d3 > FLT_EPSILON) {
                    // p1,p2,p4 are collinear, p3 is considerable
                    //----------------------
                    if(d3 * d3 <= distanceTolerance * (dx*dx + dy*dy)) {
                        if(m_angle_tolerance < curve_angle_tolerance_epsilon) {
                            points.push(vec2(x1234, y1234))
                            return
                        }

                        // Angle Condition
                        //----------------------
                        da1 = Math.abs(Math.atan2(y4 - y3, x4 - x3) - Math.atan2(y3 - y2, x3 - x2))
                        if(da1 >= pi) da1 = 2*pi - da1

                        if(da1 < m_angle_tolerance) {
                            points.push(vec2(x2, y2))
                            points.push(vec2(x3, y3))
                            return
                        }

                        if(m_cusp_limit !== 0.0) {
                            if(da1 > m_cusp_limit)
                            {
                                points.push(vec2(x3, y3))
                                return
                            }
                        }
                    }
                }
                else {
                    // Collinear case
                    //-----------------
                    dx = x1234 - (x1 + x4) / 2
                    dy = y1234 - (y1 + y4) / 2
                    if(dx*dx + dy*dy <= distanceTolerance) {
                        points.push(vec2(x1234, y1234))
                        return
                    }
                }
            }
        }

        // Continue subdivision
        //----------------------
        recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1) 
        recursive(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level + 1) 
    }
}

},{}],"node_modules/adaptive-bezier-curve/index.js":[function(require,module,exports) {
module.exports = require('./function')()
},{"./function":"node_modules/adaptive-bezier-curve/function.js"}],"node_modules/abs-svg-path/index.js":[function(require,module,exports) {

module.exports = absolutize

/**
 * redefine `path` with absolute coordinates
 *
 * @param {Array} path
 * @return {Array}
 */

function absolutize(path){
	var startX = 0
	var startY = 0
	var x = 0
	var y = 0

	return path.map(function(seg){
		seg = seg.slice()
		var type = seg[0]
		var command = type.toUpperCase()

		// is relative
		if (type != command) {
			seg[0] = command
			switch (type) {
				case 'a':
					seg[6] += x
					seg[7] += y
					break
				case 'v':
					seg[1] += y
					break
				case 'h':
					seg[1] += x
					break
				default:
					for (var i = 1; i < seg.length;) {
						seg[i++] += x
						seg[i++] += y
					}
			}
		}

		// update cursor state
		switch (command) {
			case 'Z':
				x = startX
				y = startY
				break
			case 'H':
				x = seg[1]
				break
			case 'V':
				y = seg[1]
				break
			case 'M':
				x = startX = seg[1]
				y = startY = seg[2]
				break
			default:
				x = seg[seg.length - 2]
				y = seg[seg.length - 1]
		}

		return seg
	})
}

},{}],"node_modules/svg-path-contours/node_modules/normalize-svg-path/index.js":[function(require,module,exports) {

var π = Math.PI
var _120 = radians(120)

module.exports = normalize

/**
 * describe `path` in terms of cubic bézier 
 * curves and move commands
 *
 * @param {Array} path
 * @return {Array}
 */

function normalize(path){
	// init state
	var prev
	var result = []
	var bezierX = 0
	var bezierY = 0
	var startX = 0
	var startY = 0
	var quadX = null
	var quadY = null
	var x = 0
	var y = 0

	for (var i = 0, len = path.length; i < len; i++) {
		var seg = path[i]
		var command = seg[0]
		switch (command) {
			case 'M':
				startX = seg[1]
				startY = seg[2]
				break
			case 'A':
				seg = arc(x, y,seg[1],seg[2],radians(seg[3]),seg[4],seg[5],seg[6],seg[7])
				// split multi part
				seg.unshift('C')
				if (seg.length > 7) {
					result.push(seg.splice(0, 7))
					seg.unshift('C')
				}
				break
			case 'S':
				// default control point
				var cx = x
				var cy = y
				if (prev == 'C' || prev == 'S') {
					cx += cx - bezierX // reflect the previous command's control
					cy += cy - bezierY // point relative to the current point
				}
				seg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]]
				break
			case 'T':
				if (prev == 'Q' || prev == 'T') {
					quadX = x * 2 - quadX // as with 'S' reflect previous control point
					quadY = y * 2 - quadY
				} else {
					quadX = x
					quadY = y
				}
				seg = quadratic(x, y, quadX, quadY, seg[1], seg[2])
				break
			case 'Q':
				quadX = seg[1]
				quadY = seg[2]
				seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4])
				break
			case 'L':
				seg = line(x, y, seg[1], seg[2])
				break
			case 'H':
				seg = line(x, y, seg[1], y)
				break
			case 'V':
				seg = line(x, y, x, seg[1])
				break
			case 'Z':
				seg = line(x, y, startX, startY)
				break
		}

		// update state
		prev = command
		x = seg[seg.length - 2]
		y = seg[seg.length - 1]
		if (seg.length > 4) {
			bezierX = seg[seg.length - 4]
			bezierY = seg[seg.length - 3]
		} else {
			bezierX = x
			bezierY = y
		}
		result.push(seg)
	}

	return result
}

function line(x1, y1, x2, y2){
	return ['C', x1, y1, x2, y2, x2, y2]
}

function quadratic(x1, y1, cx, cy, x2, y2){
	return [
		'C',
		x1/3 + (2/3) * cx,
		y1/3 + (2/3) * cy,
		x2/3 + (2/3) * cx,
		y2/3 + (2/3) * cy,
		x2,
		y2
	]
}

// This function is ripped from 
// github.com/DmitryBaranovskiy/raphael/blob/4d97d4/raphael.js#L2216-L2304 
// which references w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
// TODO: make it human readable

function arc(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
	if (!recursive) {
		var xy = rotate(x1, y1, -angle)
		x1 = xy.x
		y1 = xy.y
		xy = rotate(x2, y2, -angle)
		x2 = xy.x
		y2 = xy.y
		var x = (x1 - x2) / 2
		var y = (y1 - y2) / 2
		var h = (x * x) / (rx * rx) + (y * y) / (ry * ry)
		if (h > 1) {
			h = Math.sqrt(h)
			rx = h * rx
			ry = h * ry
		}
		var rx2 = rx * rx
		var ry2 = ry * ry
		var k = (large_arc_flag == sweep_flag ? -1 : 1)
			* Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)))
		if (k == Infinity) k = 1 // neutralize
		var cx = k * rx * y / ry + (x1 + x2) / 2
		var cy = k * -ry * x / rx + (y1 + y2) / 2
		var f1 = Math.asin(((y1 - cy) / ry).toFixed(9))
		var f2 = Math.asin(((y2 - cy) / ry).toFixed(9))

		f1 = x1 < cx ? π - f1 : f1
		f2 = x2 < cx ? π - f2 : f2
		if (f1 < 0) f1 = π * 2 + f1
		if (f2 < 0) f2 = π * 2 + f2
		if (sweep_flag && f1 > f2) f1 = f1 - π * 2
		if (!sweep_flag && f2 > f1) f2 = f2 - π * 2
	} else {
		f1 = recursive[0]
		f2 = recursive[1]
		cx = recursive[2]
		cy = recursive[3]
	}
	// greater than 120 degrees requires multiple segments
	if (Math.abs(f2 - f1) > _120) {
		var f2old = f2
		var x2old = x2
		var y2old = y2
		f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1)
		x2 = cx + rx * Math.cos(f2)
		y2 = cy + ry * Math.sin(f2)
		var res = arc(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy])
	}
	var t = Math.tan((f2 - f1) / 4)
	var hx = 4 / 3 * rx * t
	var hy = 4 / 3 * ry * t
	var curve = [
		2 * x1 - (x1 + hx * Math.sin(f1)),
		2 * y1 - (y1 - hy * Math.cos(f1)),
		x2 + hx * Math.sin(f2),
		y2 - hy * Math.cos(f2),
		x2,
		y2
	]
	if (recursive) return curve
	if (res) curve = curve.concat(res)
	for (var i = 0; i < curve.length;) {
		var rot = rotate(curve[i], curve[i+1], angle)
		curve[i++] = rot.x
		curve[i++] = rot.y
	}
	return curve
}

function rotate(x, y, rad){
	return {
		x: x * Math.cos(rad) - y * Math.sin(rad),
		y: x * Math.sin(rad) + y * Math.cos(rad)
	}
}

function radians(degress){
	return degress * (π / 180)
}

},{}],"node_modules/vec2-copy/index.js":[function(require,module,exports) {
module.exports = function vec2Copy(out, a) {
    out[0] = a[0]
    out[1] = a[1]
    return out
}
},{}],"node_modules/svg-path-contours/index.js":[function(require,module,exports) {
var bezier = require('adaptive-bezier-curve')
var abs = require('abs-svg-path')
var norm = require('normalize-svg-path')
var copy = require('vec2-copy')

function set(out, x, y) {
    out[0] = x
    out[1] = y
    return out
}

var tmp1 = [0,0],
    tmp2 = [0,0],
    tmp3 = [0,0]

function bezierTo(points, scale, start, seg) {
    bezier(start, 
        set(tmp1, seg[1], seg[2]), 
        set(tmp2, seg[3], seg[4]),
        set(tmp3, seg[5], seg[6]), scale, points)
}

module.exports = function contours(svg, scale) {
    var paths = []

    var points = []
    var pen = [0, 0]
    norm(abs(svg)).forEach(function(segment, i, self) {
        if (segment[0] === 'M') {
            copy(pen, segment.slice(1))
            if (points.length>0) {
                paths.push(points)
                points = []
            }
        } else if (segment[0] === 'C') {
            bezierTo(points, scale, pen, segment)
            set(pen, segment[5], segment[6])
        } else {
            throw new Error('illegal type in SVG: '+segment[0])
        }
    })
    if (points.length>0)
        paths.push(points)
    return paths
}
},{"adaptive-bezier-curve":"node_modules/adaptive-bezier-curve/index.js","abs-svg-path":"node_modules/abs-svg-path/index.js","normalize-svg-path":"node_modules/svg-path-contours/node_modules/normalize-svg-path/index.js","vec2-copy":"node_modules/vec2-copy/index.js"}],"node_modules/simplify-path/radial-distance.js":[function(require,module,exports) {
function getSqDist(p1, p2) {
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// basic distance-based simplification
module.exports = function simplifyRadialDist(points, tolerance) {
    if (points.length<=1)
        return points;
    tolerance = typeof tolerance === 'number' ? tolerance : 1;
    var sqTolerance = tolerance * tolerance;
    
    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}
},{}],"node_modules/simplify-path/douglas-peucker.js":[function(require,module,exports) {
// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    var maxSqDist = sqTolerance,
        index;

    for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
        }
    }

    if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
}

// simplification using Ramer-Douglas-Peucker algorithm
module.exports = function simplifyDouglasPeucker(points, tolerance) {
    if (points.length<=1)
        return points;
    tolerance = typeof tolerance === 'number' ? tolerance : 1;
    var sqTolerance = tolerance * tolerance;
    
    var last = points.length - 1;

    var simplified = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

},{}],"node_modules/simplify-path/index.js":[function(require,module,exports) {
var simplifyRadialDist = require('./radial-distance')
var simplifyDouglasPeucker = require('./douglas-peucker')

//simplifies using both algorithms
module.exports = function simplify(points, tolerance) {
    points = simplifyRadialDist(points, tolerance);
    points = simplifyDouglasPeucker(points, tolerance);
    return points;
}

module.exports.radialDistance = simplifyRadialDist;
module.exports.douglasPeucker = simplifyDouglasPeucker;
},{"./radial-distance":"node_modules/simplify-path/radial-distance.js","./douglas-peucker":"node_modules/simplify-path/douglas-peucker.js"}],"node_modules/bound-points/bounds.js":[function(require,module,exports) {
'use strict'

module.exports = findBounds

function findBounds(points) {
  var n = points.length
  if(n === 0) {
    return [[], []]
  }
  var d = points[0].length
  var lo = points[0].slice()
  var hi = points[0].slice()
  for(var i=1; i<n; ++i) {
    var p = points[i]
    for(var j=0; j<d; ++j) {
      var x = p[j]
      lo[j] = Math.min(lo[j], x)
      hi[j] = Math.max(hi[j], x)
    }
  }
  return [lo, hi]
}
},{}],"node_modules/unlerp/index.js":[function(require,module,exports) {
module.exports = function range(min, max, value) {
  return (value - min) / (max - min)
}
},{}],"node_modules/normalize-path-scale/index.js":[function(require,module,exports) {
var getBounds = require('bound-points')
var unlerp = require('unlerp')

module.exports = normalizePathScale
function normalizePathScale (positions, bounds) {
  if (!Array.isArray(positions)) {
    throw new TypeError('must specify positions as first argument')
  }
  if (!Array.isArray(bounds)) {
    bounds = getBounds(positions)
  }

  var min = bounds[0]
  var max = bounds[1]

  var width = max[0] - min[0]
  var height = max[1] - min[1]

  var aspectX = width > height ? 1 : (height / width)
  var aspectY = width > height ? (width / height) : 1

  if (max[0] - min[0] === 0 || max[1] - min[1] === 0) {
    return positions // div by zero; leave positions unchanged
  }

  for (var i = 0; i < positions.length; i++) {
    var pos = positions[i]
    pos[0] = (unlerp(min[0], max[0], pos[0]) * 2 - 1) / aspectX
    pos[1] = (unlerp(min[1], max[1], pos[1]) * 2 - 1) / aspectY
  }
  return positions
}
},{"bound-points":"node_modules/bound-points/bounds.js","unlerp":"node_modules/unlerp/index.js"}],"src/util/getPathFromSVG.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getPathFromSVG;

var _parseSvgPath = _interopRequireDefault(require("parse-svg-path"));

var _svgPathContours = _interopRequireDefault(require("svg-path-contours"));

var _absSvgPath = _interopRequireDefault(require("abs-svg-path"));

var _simplifyPath = _interopRequireDefault(require("simplify-path"));

var _normalizePathScale = _interopRequireDefault(require("normalize-path-scale"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getPathFromSVG(svgData) {
  const contours = (0, _svgPathContours.default)((0, _parseSvgPath.default)(svgData), 1);
  let path = (0, _normalizePathScale.default)(contours[0]);
  path = (0, _simplifyPath.default)(path, 0.01);
  return path;
}
},{"parse-svg-path":"node_modules/parse-svg-path/index.js","svg-path-contours":"node_modules/svg-path-contours/index.js","abs-svg-path":"node_modules/abs-svg-path/index.js","simplify-path":"node_modules/simplify-path/index.js","normalize-path-scale":"node_modules/normalize-path-scale/index.js"}],"src/systems/WindAtmosphereSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = WindAtmosphereSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _ObjectPool = _interopRequireDefault(require("../util/ObjectPool"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _Line3D = _interopRequireDefault(require("./writing/Line3D"));

var _getPathFromSVG = _interopRequireDefault(require("../util/getPathFromSVG"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function WindAtmosphereSystem(world) {
  const activeEnv = world.view(Tags.ActiveEnvironmentState);
  const random = (0, _Random.default)();
  const pathDatas = getPaths().map(svg => {
    const points = (0, _getPathFromSVG.default)(svg).map(p => {
      return new THREE.Vector3(p[0], 0, p[1]);
    });
    const curve = new THREE.CatmullRomCurve3(points, false, "catmullrom", 0.5);
    return curve.getSpacedPoints(100).map(p => p.toArray());
  });
  const pathLines = pathDatas.map(data => {
    const mesh = new _Line3D.default(world, {
      thickness: 0.2,
      bloom: 0,
      taper: false
    });
    mesh.updatePath(data); // const mesh = new THREE.Mesh(
    //   geo,
    //   new THREE.MeshBasicMaterial({ color: "red" })
    // );

    mesh.userData._entity = null;
    mesh.userData._lineThickness = 1;
    return mesh;
  }); // const geo = new THREE.BoxGeometry(1, 1, 1);
  // const pool = new ObjectPool({
  //   initialCapacity: 5,
  //   maxCapacity: 5,
  //   create() {
  //     return mesh;
  //   },
  // });

  let spawnTimer = 0;

  const newSpawnDelay = () => random.range(1, 2);

  let spawnDelay = newSpawnDelay();
  const tmp2DArr = [0, 0];
  const windLines = world.view(Tags.WindLine);
  return function processWind(dt) {
    const env = activeEnv.length ? activeEnv[0].get(Tags.EnvironmentState).name : null;

    if (!env || env !== "grasslands") {
      if (windLines.length > 0) {
        windLines.forEach(e => {
          const line = e.get(Tags.Object3D);
          line.userData._entity = null;
          e.kill();
        });
      }

      return;
    }

    spawnTimer += dt;

    if (spawnTimer >= spawnDelay) {
      spawnTimer %= spawnDelay;
      spawnDelay = newSpawnDelay();
      const target = world.findTag(Tags.UserTarget);
      spawn(target.position);
    }

    windLines.forEach(e => {
      const wind = e.get(Tags.WindLine);
      wind.time += dt;
      let anim = 0;

      if (wind.time <= wind.animateDuration) {
        anim = wind.time / wind.animateDuration;
      } else if (wind.time >= wind.duration - wind.animateDuration) {
        const el = Math.max(0, wind.time - (wind.duration - wind.animateDuration));
        const t = el / wind.animateDuration;
        anim = 1 - t;
      } else {
        anim = 1;
      }

      const line = e.get(Tags.Object3D);
      line.material.uniforms.thickness.value = line.userData._lineThickness * anim;
      line.material.uniforms.time.value += dt;
      line.material.uniforms.draw.value = wind.time / wind.duration;
      const totalDur = wind.duration;

      if (wind.time >= totalDur) {
        e.kill();
        line.userData._entity = null;
      }
    });
  };

  function nextAvailable(e) {
    return !e.userData._entity;
  }

  function nextRandomAvailable() {
    const start = random.rangeFloor(0, pathLines.length);

    for (let i = 0; i < pathLines.length; i++) {
      const k = (i + start) % pathLines.length;
      if (!pathLines[k].userData._entity) return pathLines[k];
    }

    return null;
  }

  function spawn(target) {
    const mesh = nextRandomAvailable();
    if (!mesh) return;
    random.onCircle(random.range(5, 10), tmp2DArr);
    const x = target.x + tmp2DArr[0];
    const z = target.z + tmp2DArr[1];
    mesh.userData._entity = world.entity().add(Tags.Object3D, mesh);
    mesh.position.set(x, random.range(2, 4), z);
    mesh.scale.setScalar(random.range(1, 6));
    mesh.rotation.y = THREE.MathUtils.degToRad(45);
    mesh.material.uniforms.drawing.value = true;
    mesh.material.uniforms.opacity.value = 0.5;
    mesh.userData._lineThickness = random.range(0.2, 0.2);

    mesh.userData._entity.add(Tags.WindLine);

    const wind = mesh.userData._entity.get(Tags.WindLine);

    wind.duration = random.range(3, 3);
  }
}

function getPaths() {
  return ["M1 73C48 80 154.8 89.8 206 73C270 52 259 19 238 7C217 -5 173 -1.90735e-06 176 26C179 52 191 76 277 80C363 84 421 67 444 65C467 63 530 73 561 73", "M1 13C50 16.3333 101 23 178 18C255 13 268 -0.999999 338 1C408 3 444 18 508 18", // "M1 39C20 37.3333 64.6 35 91 39C124 44 226 49 246 44C266 39 280 16 263 6C246 -4 227 0.999995 228 14",
  "M1 18C40.3333 12 129 0.199994 169 0.999994C219 1.99999 346 18 399 18C452 18 512 0.999994 526 0.999994", "M1 5.99999C69.3333 2.33332 217.8 -2.80001 265 5.99999C324 17 421 -2.00003 462 5.99999"];
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/math":"src/util/math.js","../util/ObjectPool":"src/util/ObjectPool.js","../util/Random":"src/util/Random.js","./writing/Line3D":"src/systems/writing/Line3D.js","../util/getPathFromSVG":"src/util/getPathFromSVG.js"}],"src/util/CapsuleBufferGeometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var THREE = _interopRequireWildcard(require("three"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

//https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js

/**
 * @author maximequiblier
 */
function CapsuleBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, capsTopSegments, capsBottomSegments, thetaStart, thetaLength) {
  THREE.BufferGeometry.call(this);
  this.type = "CapsuleBufferGeometry";
  this.parameters = {
    radiusTop: radiusTop,
    radiusBottom: radiusBottom,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  var scope = this;
  radiusTop = radiusTop !== undefined ? radiusTop : 1;
  radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
  height = height !== undefined ? height : 2;
  radialSegments = Math.floor(radialSegments) || 8;
  heightSegments = Math.floor(heightSegments) || 1;
  capsTopSegments = Math.floor(capsTopSegments) || 2;
  capsBottomSegments = Math.floor(capsBottomSegments) || 2;
  thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
  thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI; // Alpha is the angle such that Math.PI/2 - alpha is the cone part angle.

  var alpha = Math.acos((radiusBottom - radiusTop) / height);
  var eqRadii = radiusTop - radiusBottom === 0;
  var vertexCount = calculateVertexCount();
  var indexCount = calculateIndexCount(); // buffers

  var indices = new THREE.BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
  var vertices = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
  var normals = new THREE.BufferAttribute(new Float32Array(vertexCount * 3), 3);
  var uvs = new THREE.BufferAttribute(new Float32Array(vertexCount * 2), 2); // helper variables

  var index = 0,
      indexOffset = 0,
      indexArray = [],
      halfHeight = height / 2; // generate geometry

  generateTorso(); // build geometry

  this.setIndex(indices);
  this.setAttribute("position", vertices);
  this.setAttribute("normal", normals);
  this.setAttribute("uv", uvs); // helper functions

  function calculateVertexCount() {
    var count = (radialSegments + 1) * (heightSegments + 1 + capsBottomSegments + capsTopSegments);
    return count;
  }

  function calculateIndexCount() {
    var count = radialSegments * (heightSegments + capsBottomSegments + capsTopSegments) * 2 * 3;
    return count;
  }

  function generateTorso() {
    var x, y;
    var normal = new THREE.Vector3();
    var vertex = new THREE.Vector3();
    var cosAlpha = Math.cos(alpha);
    var sinAlpha = Math.sin(alpha);
    var cone_length = new THREE.Vector2(radiusTop * sinAlpha, halfHeight + radiusTop * cosAlpha).sub(new THREE.Vector2(radiusBottom * sinAlpha, -halfHeight + radiusBottom * cosAlpha)).length(); // Total length for v texture coord

    var vl = radiusTop * alpha + cone_length + radiusBottom * (Math.PI / 2 - alpha);
    var groupCount = 0; // generate vertices, normals and uvs

    var v = 0;

    for (y = 0; y <= capsTopSegments; y++) {
      var indexRow = [];
      var a = Math.PI / 2 - alpha * (y / capsTopSegments);
      v += radiusTop * alpha / capsTopSegments;
      var cosA = Math.cos(a);
      var sinA = Math.sin(a); // calculate the radius of the current row

      var radius = cosA * radiusTop;

      for (x = 0; x <= radialSegments; x++) {
        var u = x / radialSegments;
        var theta = u * thetaLength + thetaStart;
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta); // vertex

        vertex.x = radius * sinTheta;
        vertex.y = halfHeight + sinA * radiusTop;
        vertex.z = radius * cosTheta;
        vertices.setXYZ(index, vertex.x, vertex.y, vertex.z); // normal

        normal.set(cosA * sinTheta, sinA, cosA * cosTheta);
        normals.setXYZ(index, normal.x, normal.y, normal.z); // uv

        uvs.setXY(index, u, 1 - v / vl); // save index of vertex in respective row

        indexRow.push(index); // increase index

        index++;
      } // now save vertices of the row in our index array


      indexArray.push(indexRow);
    }

    var cone_height = height + cosAlpha * radiusTop - cosAlpha * radiusBottom;
    var slope = sinAlpha * (radiusBottom - radiusTop) / cone_height;

    for (y = 1; y <= heightSegments; y++) {
      var indexRow = [];
      v += cone_length / heightSegments; // calculate the radius of the current row

      var radius = sinAlpha * (y * (radiusBottom - radiusTop) / heightSegments + radiusTop);

      for (x = 0; x <= radialSegments; x++) {
        var u = x / radialSegments;
        var theta = u * thetaLength + thetaStart;
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta); // vertex

        vertex.x = radius * sinTheta;
        vertex.y = halfHeight + cosAlpha * radiusTop - y * cone_height / heightSegments;
        vertex.z = radius * cosTheta;
        vertices.setXYZ(index, vertex.x, vertex.y, vertex.z); // normal

        normal.set(sinTheta, slope, cosTheta).normalize();
        normals.setXYZ(index, normal.x, normal.y, normal.z); // uv

        uvs.setXY(index, u, 1 - v / vl); // save index of vertex in respective row

        indexRow.push(index); // increase index

        index++;
      } // now save vertices of the row in our index array


      indexArray.push(indexRow);
    }

    for (y = 1; y <= capsBottomSegments; y++) {
      var indexRow = [];
      var a = Math.PI / 2 - alpha - (Math.PI - alpha) * (y / capsBottomSegments);
      v += radiusBottom * alpha / capsBottomSegments;
      var cosA = Math.cos(a);
      var sinA = Math.sin(a); // calculate the radius of the current row

      var radius = cosA * radiusBottom;

      for (x = 0; x <= radialSegments; x++) {
        var u = x / radialSegments;
        var theta = u * thetaLength + thetaStart;
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta); // vertex

        vertex.x = radius * sinTheta;
        vertex.y = -halfHeight + sinA * radiusBottom;
        vertex.z = radius * cosTheta;
        vertices.setXYZ(index, vertex.x, vertex.y, vertex.z); // normal

        normal.set(cosA * sinTheta, sinA, cosA * cosTheta);
        normals.setXYZ(index, normal.x, normal.y, normal.z); // uv

        uvs.setXY(index, u, 1 - v / vl); // save index of vertex in respective row

        indexRow.push(index); // increase index

        index++;
      } // now save vertices of the row in our index array


      indexArray.push(indexRow);
    } // generate indices


    for (x = 0; x < radialSegments; x++) {
      for (y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y++) {
        // we use the index array to access the correct indices
        var i1 = indexArray[y][x];
        var i2 = indexArray[y + 1][x];
        var i3 = indexArray[y + 1][x + 1];
        var i4 = indexArray[y][x + 1]; // face one

        indices.setX(indexOffset, i1);
        indexOffset++;
        indices.setX(indexOffset, i2);
        indexOffset++;
        indices.setX(indexOffset, i4);
        indexOffset++; // face two

        indices.setX(indexOffset, i2);
        indexOffset++;
        indices.setX(indexOffset, i3);
        indexOffset++;
        indices.setX(indexOffset, i4);
        indexOffset++;
      }
    }
  }
}

CapsuleBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
CapsuleBufferGeometry.prototype.constructor = CapsuleBufferGeometry;
var _default = CapsuleBufferGeometry;
exports.default = _default;
},{"three":"src/vendor/three.module.js"}],"src/systems/RainAtmosphereSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = RainAtmosphereSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var eases = _interopRequireWildcard(require("eases"));

var _ObjectPool = _interopRequireDefault(require("../util/ObjectPool"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _Line3D = _interopRequireDefault(require("./writing/Line3D"));

var _getPathFromSVG = _interopRequireDefault(require("../util/getPathFromSVG"));

var _CapsuleBufferGeometry = _interopRequireDefault(require("../util/CapsuleBufferGeometry"));

var _threeUtil = require("../util/three-util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function RainAtmosphereSystem(world) {
  const random = (0, _Random.default)();
  const group = new THREE.Group();
  group.name = "rainparticles";
  const rainGroup = new THREE.Group();
  const splatterGroup = new THREE.Group();
  group.add(rainGroup);
  group.add(splatterGroup);
  world.entity().add(Tags.Object3D, group);
  const radius = 0.02;
  const baseLength = 0.25;
  const dummyGeometry = new THREE.BufferGeometry();
  const geometries = [baseLength, baseLength * 2].map(length => {
    const geometry = new _CapsuleBufferGeometry.default(radius, radius, length, 5, 1, 2, 2);
    geometry.userData.length = length;
    geometry.translate(0, -length / 2, 0);
    return geometry;
  });
  const white = new THREE.Color(1, 1, 1);
  const colors = MathUtil.linspace(10).map(t => {
    const color = new THREE.Color("#7dcdf2").offsetHSL(random.range(-1, 1) * (5 / 360), random.range(-1, 1) * (10 / 100), random.range(-1, 1) * (10 / 100));
    return color;
  });
  const pool = new _ObjectPool.default({
    maxCapacity: 50,
    initialCapacity: 50,

    create() {
      const mesh = new THREE.Mesh(dummyGeometry, new THREE.MeshBasicMaterial({
        name: "rain" // transparent: true,
        // opacity: 0.5,

      }));
      mesh.matrixAutoUpdate = false;
      mesh.userData._entity = null;
      mesh.frustumCulled = false;
      mesh.visible = false;
      return mesh;
    },

    release(m) {}

  }); // const splatterGeometry = new THREE.CircleGeometry(radius * 4, 12);

  const splatRadius = 0.03;
  const thick = splatRadius * 3;
  const splatterGeometry = new THREE.RingGeometry(splatRadius * 4, splatRadius * 4 + thick, 12, 1);
  splatterGeometry.rotateX(-Math.PI / 2);
  const splatterPool = new _ObjectPool.default({
    maxCapacity: 50,
    initialCapacity: 50,

    create() {
      const mesh = new THREE.Mesh(splatterGeometry, new THREE.MeshBasicMaterial({
        name: "splatter",
        transparent: true,
        opacity: 0.5 // depthTest: false,
        // depthWrite: false,
        // blending: THREE.MultiplyBlending,

      }));
      mesh.renderOrder = 5;
      mesh.matrixAutoUpdate = false;
      mesh.userData._entity = null;
      mesh.frustumCulled = false;
      mesh.visible = false;
      return mesh;
    }

  }); // const velocity = new THREE.Vector3(-0.0, -1.0, 0.0).normalize();

  const velocity = new THREE.Vector3(0.5, -1.0, 0.0).normalize();
  const tmpArr2D = [0, 0];
  const tmpVec3 = new THREE.Vector3();
  const hitPlane = new THREE.Plane(new THREE.Vector3(-0, -1, -0), -0);
  const ray = new THREE.Ray();
  const rayHitTarget = new THREE.Vector3();
  ray.direction.copy(velocity);
  const drops = world.view([Tags.RainDrop, Tags.Object3D]);
  const splatters = world.view([Tags.RainDropSplatter, Tags.Object3D]);
  const rainSize = 1;

  const newSpawnDelay = () => random.range(0.075, 0.2);

  let spawnTimer = 0;
  let spawnDelay = newSpawnDelay();
  const target = world.findTag(Tags.UserTarget);
  const activeEnv = world.view(Tags.ActiveEnvironmentState);
  const underPlayer = world.findTag(Tags.EnvironmentUnderPlayerState);
  const rainEntity = world.entity();
  let lastLake = null;
  let rainTime = 0;

  const newRainDuration = () => random.range(5, 10);

  let rainDuration = newRainDuration();
  let clearLake = false;
  return function processRain(dt) {
    const env = activeEnv.length ? activeEnv[0].get(Tags.EnvironmentState).name : null; // if (!world.findTag(Tags.GameStarted)) return;

    let canSpawn = env && env === "grasslands";

    if (canSpawn && underPlayer.water && underPlayer.lake) {
      if (!rainEntity.has(Tags.Raining)) {
        if (lastLake == null) {
          // no last lake, wait for next
          lastLake = underPlayer.lake;
        } else {
          // got a new lake, trigger & reset
          if (underPlayer.lake !== lastLake) {
            rainEntity.tagOn(Tags.Raining);
            rainDuration = newRainDuration();
            clearLake = true;
            rainTime = 0;
            lastLake = null;
          }
        }
      }
    }

    if (!underPlayer.water && clearLake) {
      clearLake = false;
      lastLake = null;
    }

    if (canSpawn && rainEntity.has(Tags.Raining)) {
      rainTime += dt;

      if (rainTime >= rainDuration) {
        rainEntity.tagOff(Tags.Raining);
      }
    }

    if (canSpawn && rainEntity.has(Tags.Raining)) {
      spawnTimer += dt;

      if (spawnTimer >= spawnDelay) {
        spawnTimer %= spawnDelay;
        spawnDelay = newSpawnDelay();
        const count = random.rangeFloor(1, 6);

        for (let i = 0; i < count; i++) {
          if (!spawn(target.position)) break;
        }
      }
    }

    for (let i = 0; i < drops.length; i++) {
      const e = drops[i];
      const drop = e.get(Tags.RainDrop);
      const mesh = e.get(Tags.Object3D);
      mesh.position.addScaledVector(velocity, dt * drop.speed);
      mesh.visible = true;
      drop.time += dt;
      let anim = 0;

      if (drop.time <= drop.animateDuration) {
        anim = drop.time / drop.animateDuration;
      } else {
        anim = 1;
      }

      mesh.scale.setScalar(anim * rainSize);
      mesh.updateMatrix(); // mesh.updateMatrixWorld();

      tmpVec3.set(0, 0, 0);
      tmpVec3.applyMatrix4(mesh.matrixWorld);

      if (tmpVec3.y <= 0 && !drop.splat) {
        drop.splat = true;
        splatter(drop.splatterSpawnPosition, mesh.material.color);
      }

      if (tmpVec3.y <= -(mesh.geometry.userData.length * rainSize)) {
        pool.release(mesh);
        mesh.userData._entity = null;
        mesh.visible = false;
        (0, _threeUtil.detachObject)(mesh);
        e.remove(Tags.RainDrop);
      }
    }

    for (let i = 0; i < splatters.length; i++) {
      const e = splatters[i];
      const splatter = e.get(Tags.RainDropSplatter);
      const mesh = e.get(Tags.Object3D);
      mesh.visible = true;
      splatter.time += dt;
      let anim = 0;

      if (splatter.time <= splatter.animateDuration) {
        anim = splatter.time / splatter.animateDuration;
      } else if (splatter.time >= splatter.duration - splatter.animateDuration) {
        const el = Math.max(0, splatter.time - (splatter.duration - splatter.animateDuration));
        const t = el / splatter.animateDuration;
        anim = 1 - t;
      } else {
        anim = 1;
      }

      anim = eases.sineInOut(anim);
      mesh.scale.setScalar(anim * rainSize);

      if (splatter.time >= splatter.duration) {
        splatterPool.release(mesh);
        mesh.userData._entity = null;
        mesh.visible = false;
        (0, _threeUtil.detachObject)(mesh);
        e.kill();
      } else {
        mesh.updateMatrix();
      }
    }
  };

  function splatter(position, color) {
    const mesh = splatterPool.next();
    if (!mesh) return false;
    splatterGroup.add(mesh);
    mesh.material.color.copy(color); //.lerp(white, 0.5);

    mesh.position.copy(position);
    mesh.position.y = 0.1;
    mesh.visible = false;
    mesh.userData._entity = world.entity().add(Tags.Object3D, mesh);

    mesh.userData._entity.add(Tags.RainDropSplatter);

    const rain = mesh.userData._entity.get(Tags.RainDropSplatter);
  }

  function spawn(origin) {
    const mesh = pool.next();
    if (!mesh) return false;
    random.onCircle(random.range(0, 20), tmpArr2D);
    const x = origin.x + tmpArr2D[0] - velocity.x * 10;
    const z = origin.z + tmpArr2D[1] - velocity.z * 0;
    rainGroup.add(mesh);
    mesh.geometry = random.pick(geometries);
    mesh.position.set(x, random.range(7.5, 15), z);
    mesh.material.color.copy(random.pick(colors));
    mesh.visible = false;
    mesh.userData._entity = world.entity().add(Tags.Object3D, mesh);

    mesh.userData._entity.add(Tags.RainDrop);

    MathUtil.quaternionFromNormal(velocity, mesh.quaternion);

    const rain = mesh.userData._entity.get(Tags.RainDrop);

    rain.speed = random.range(10, 10);
    mesh.updateMatrix();
    mesh.updateMatrixWorld();
    tmpVec3.set(0, baseLength, 0);
    tmpVec3.applyMatrix4(mesh.matrixWorld);
    ray.origin.copy(tmpVec3);
    const hit = ray.intersectPlane(hitPlane, rayHitTarget);

    if (!hit) {
      // unlikely to get here unless we mess up spawn position?
      rain.splat = true;
    } else {
      rain.splatterSpawnPosition.copy(rayHitTarget);
    }

    return true;
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/math":"src/util/math.js","eases":"node_modules/eases/index.js","../util/ObjectPool":"src/util/ObjectPool.js","../util/Random":"src/util/Random.js","./writing/Line3D":"src/systems/writing/Line3D.js","../util/getPathFromSVG":"src/util/getPathFromSVG.js","../util/CapsuleBufferGeometry":"src/util/CapsuleBufferGeometry.js","../util/three-util":"src/util/three-util.js"}],"node_modules/three-quaternion-from-normal/index.js":[function(require,module,exports) {
var THREE = require('three');
var axis = new THREE.Vector3();

module.exports = setDirection;
function setDirection (normal, quaternion) {
  quaternion = quaternion || new THREE.Quaternion();
  // vector is assumed to be normalized
  if (normal.y > 0.99999) {
    quaternion.set(0, 0, 0, 1);
  } else if (normal.y < -0.99999) {
    quaternion.set(1, 0, 0, 0);
  } else {
    axis.set(normal.z, 0, -normal.x).normalize();
    var radians = Math.acos(normal.y);
    quaternion.setFromAxisAngle(axis, radians);
  }
  return quaternion;
}

},{"three":"src/vendor/three.module.js"}],"node_modules/inherits/inherits_browser.js":[function(require,module,exports) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],"node_modules/lerp/index.js":[function(require,module,exports) {
function lerp(v0, v1, t) {
    return v0*(1-t)+v1*t
}
module.exports = lerp
},{}],"node_modules/lerp-array/index.js":[function(require,module,exports) {
var lerp = require('lerp')

module.exports = function lerpValues(value1, value2, t, out) {
    if (typeof value1 === 'number'
            && typeof value2 === 'number')
        return lerp(value1, value2, t)
    else { //assume array
        var len = Math.min(value1.length, value2.length)
        out = out||new Array(len)
        for (var i=0; i<len; i++) 
            out[i] = lerp(value1[i], value2[i], t)
        return out
    }
}
},{"lerp":"node_modules/lerp/index.js"}],"node_modules/events/events.js":[function(require,module,exports) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter;
module.exports.once = once; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });

    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }

      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
},{}],"node_modules/tween-base/index.js":[function(require,module,exports) {
var noop = function(){}
var linear = require('eases/linear')
var EventEmitter = require('events').EventEmitter
var inherits = require('inherits')

function BaseTween(opt) {
    EventEmitter.call(this)

    //users generally don't need to change these
    this.duration = (opt && opt.duration)||0
    this.delay = (opt && opt.delay)||0
    this.time = 0
    this.ease = opt && opt.ease
    this.active = true
    this.enabled = true
    this.cancelling = false
    this._started = false
}

inherits(BaseTween, EventEmitter)

BaseTween.prototype.lerp = noop
BaseTween.prototype.ready = noop

BaseTween.prototype.cancel = function() {
    this.cancelling = true
    return this
}

BaseTween.prototype.tick = function(dt, ease) {
    ease = typeof ease === 'function' ? ease : defaultEase

    if (this.cancelling && this.active) {
        this.active = false
        this.emit('cancelling', this)
        this.emit('complete', this)
    }

    if (!this.active || !this.enabled)
        return

    var last = this.time
    this.time += dt
            
    var alpha = (this.time-this.delay) / this.duration
    if (this.time-this.delay > 0) {
        if (!this._started) {
            this._started = true
            this.ready()
            this.emit('start', this)
        }

        if (alpha < 0)
            alpha = 0
        else if (alpha > 1)
            alpha = 1
        alpha = ease(this, alpha)
        this.lerp(alpha)
        this.emit('update', this)
    }

    if (this.time >= (this.duration+this.delay)) {
        this.active = false
        this.emit('complete', this)
    }
}

function defaultEase(tween, alpha) {
    if (typeof tween.ease === 'function')
        return tween.ease(alpha)
    return linear(alpha)
}

module.exports = BaseTween
},{"eases/linear":"node_modules/eases/linear.js","events":"node_modules/events/events.js","inherits":"node_modules/inherits/inherits_browser.js"}],"node_modules/an-array/index.js":[function(require,module,exports) {
var str = Object.prototype.toString

module.exports = anArray

function anArray(arr) {
  return (
       arr.BYTES_PER_ELEMENT
    && str.call(arr.buffer) === '[object ArrayBuffer]'
    || Array.isArray(arr)
  )
}

},{}],"node_modules/own-enumerable-keys/index.js":[function(require,module,exports) {
var propIsEnumerable = Object.prototype.propertyIsEnumerable

module.exports = ownEnumerableKeys
function ownEnumerableKeys (obj) {
  var keys = Object.getOwnPropertyNames(obj)

  if (Object.getOwnPropertySymbols) {
    keys = keys.concat(Object.getOwnPropertySymbols(obj))
  }

  return keys.filter(function (key) {
    return propIsEnumerable.call(obj, key)
  })
}

},{}],"node_modules/tween-objects/lib/end-target.js":[function(require,module,exports) {
var BaseTween = require('tween-base')
var isArray = require('an-array')
var ownKeys = require('own-enumerable-keys')
var ignores = ownKeys(new BaseTween())

module.exports = function getTargets(element, opt) {
    var targets = []
    var optKeys = ownKeys(opt)

    for (var k in opt) { 
        //copy properties as needed
        if (optKeys.indexOf(k) >= 0 &&
                k in element &&
                ignores.indexOf(k) === -1) {
            var startVal = element[k]
            var endVal = opt[k]
            if (typeof startVal === 'number'
                 && typeof endVal === 'number') {
                targets.push({ 
                    key: k, 
                    start: startVal, 
                    end: endVal 
                })
            }
            else if (isArray(startVal) && isArray(endVal)) {
                targets.push({ 
                    key: k, 
                    start: startVal.slice(), 
                    end: endVal.slice() 
                })
            }
        }
    }
    return targets
}
},{"tween-base":"node_modules/tween-base/index.js","an-array":"node_modules/an-array/index.js","own-enumerable-keys":"node_modules/own-enumerable-keys/index.js"}],"node_modules/tween-objects/lib/object.js":[function(require,module,exports) {
var inherits = require('inherits')
var lerp = require('lerp-array')
var BaseTween = require('tween-base')
var endTarget = require('./end-target')

function ObjectTween(target, opt) {
    BaseTween.call(this, opt)
    this.target = target
    this.endings = undefined
    this._options = opt
}

inherits(ObjectTween, BaseTween)

ObjectTween.prototype.ready = function() {
    this.endings = endTarget(this.target, this._options)
}

ObjectTween.prototype.lerp = function(alpha) {
    for (var i=0; i<this.endings.length; i++) {
        var t = this.endings[i]
        var k = t.key
        this.target[k] = lerp(t.start, t.end, alpha, this.target[k])
    }
}

module.exports = ObjectTween
},{"inherits":"node_modules/inherits/inherits_browser.js","lerp-array":"node_modules/lerp-array/index.js","tween-base":"node_modules/tween-base/index.js","./end-target":"node_modules/tween-objects/lib/end-target.js"}],"node_modules/tween-objects/lib/group.js":[function(require,module,exports) {
var inherits = require('inherits')
var lerp = require('lerp-array')
var BaseTween = require('tween-base')
var endTarget = require('./end-target')

function GroupTween(target, opt) {
    BaseTween.call(this, opt)
    this.target = target
    this.end = []
    this._options = opt
}

inherits(GroupTween, BaseTween)

GroupTween.prototype.ready = function() {
    this.end = this.target.map(function(t) {
        return endTarget(t, this._options)
    }, this)
}

GroupTween.prototype.lerp = function(alpha) {
    for (var j=0; j<this.end.length; j++)  {
        var endings = this.end[j]
        var target = this.target[j]
        for (var i=0; i<endings.length; i++) {
            var t = endings[i]
            var k = t.key
            target[k] = lerp(t.start, t.end, alpha, target[k])    
        }
    }
}

module.exports = GroupTween
},{"inherits":"node_modules/inherits/inherits_browser.js","lerp-array":"node_modules/lerp-array/index.js","tween-base":"node_modules/tween-base/index.js","./end-target":"node_modules/tween-objects/lib/end-target.js"}],"node_modules/tween-objects/index.js":[function(require,module,exports) {
var ObjectTween = require('./lib/object')
var GroupTween = require('./lib/group')

module.exports = function(element, opt) {
    var tween = Array.isArray(element) 
            ? new GroupTween(element, opt)
            : new ObjectTween(element, opt)
    return tween
}
},{"./lib/object":"node_modules/tween-objects/lib/object.js","./lib/group":"node_modules/tween-objects/lib/group.js"}],"node_modules/tween-ticker/index.js":[function(require,module,exports) {
var linear = require('eases/linear')
var createTween = require('tween-objects')
var BaseTween = require('tween-base')

function TweenTicker (opt) {
  if (!(this instanceof TweenTicker)) {
    return new TweenTicker(opt)
  }
  opt = opt || {}
  this.stack = []
  this.defaultEase = opt.defaultEase || linear
  this.eases = opt.eases || {}
  this._applyEase = this.ease.bind(this)
}

TweenTicker.prototype.cancel = function () {
  for (var i = 0; i < this.stack.length; i++) {
    var t = this.stack[i]
    // cancel each and force it to complete
    t.cancel()
    t.tick(0)
  }
  this.stack.length = 0
  return this
}

// no longer used, backward-compatible
TweenTicker.prototype.clear = TweenTicker.prototype.cancel

TweenTicker.prototype.to = function (element, opt) {
  var tween = element
  if (opt && typeof opt === 'object') {
    tween = createTween(element, opt)
  } else if (!element && !opt) {
    tween = new BaseTween()
  } else if (!isTween(tween)) { // to avoid programmer error
    throw new Error('must provide options or a tween object')
  }
  return this.push(tween)
}

TweenTicker.prototype.push = function (tween) {
  this.stack.push(tween)
  return tween
}

TweenTicker.prototype.tick = function (dt, ease) {
  ease = typeof ease === 'function' ? ease : this._applyEase
  dt = typeof dt === 'number' ? dt : 1 / 60

  // for all queued tweens, tick them forward (i.e. DOM read)
  for (var i = 0; i < this.stack.length; i++) {
    this.stack[i].tick(dt, ease)
  }

  // now sync their states (i.e. DOM write)
  sync(this.stack)

  // now kill any inactive tweens
  for (i = this.stack.length - 1; i >= 0; i--) {
    if (!this.stack[i].active) {
      this.stack.splice(i, 1)
    }
  }
}

// determines which easing function to use based on user options
TweenTicker.prototype.ease = function (tween, alpha) {
  var ease = tween.ease || this.defaultEase
  if (typeof ease === 'string') {
    ease = this.eases[ease]
  }
  if (typeof ease !== 'function') {
    ease = linear
  }
  return ease(alpha)
}

// mainly intended as a safeguard against potential user error
function isTween (tween) {
  return (typeof tween.tick === 'function' &&
  typeof tween.cancel === 'function')
}

function sync (tweens) {
  for (var i = 0; i < tweens.length; i++) {
    var tween = tweens[i]
    if (typeof tween.sync === 'function') {
      tween.sync()
    }
  }
}

module.exports = TweenTicker

},{"eases/linear":"node_modules/eases/linear.js","tween-objects":"node_modules/tween-objects/index.js","tween-base":"node_modules/tween-base/index.js"}],"src/util/tween-ticker.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = TweenTicker;

var _eases = _interopRequireDefault(require("eases"));

var _tweenTicker = _interopRequireDefault(require("tween-ticker"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const defaultOpts = {
  eases: _eases.default
};

function TweenTicker(opt = {}) {
  return (0, _tweenTicker.default)({ ...defaultOpts,
    ...opt
  });
}
},{"eases":"node_modules/eases/index.js","tween-ticker":"node_modules/tween-ticker/index.js"}],"src/util/FetchFileLoader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FetchFileLoader = FetchFileLoader;

var THREE = _interopRequireWildcard(require("three"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @author mrdoob / http://mrdoob.com/
 */
// import { Cache } from './Cache.js';
const Loader = THREE.Loader; // const Cache = THREE.Cache;

const loading = {};

function FetchFileLoader(manager) {
  Loader.call(this, manager);
}

FetchFileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
  constructor: FetchFileLoader,
  load: function (url, onLoad, onProgress, onError) {
    if (url === undefined) url = "";
    if (this.path !== undefined) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    window.fetch(url).then(resp => {
      return resp.arrayBuffer();
    }).then(buffer => {
      onLoad(buffer);
    }, err => {
      onError(err);
    });
  },
  setResponseType: function (value) {
    // this.responseType = value;
    return this;
  },
  setWithCredentials: function (value) {
    // this.withCredentials = value;
    return this;
  },
  setMimeType: function (value) {
    // this.mimeType = value;
    return this;
  }
});
},{"three":"src/vendor/three.module.js"}],"src/util/GLTFLoader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GLTFLoader = void 0;

var _FetchFileLoader = require("./FetchFileLoader");

var _three = require("three");

var _addFrameTasks = require("./addFrameTasks");

/**
 * @author Rich Tibbett / https://github.com/richtr
 * @author mrdoob / http://mrdoob.com/
 * @author Tony Parisi / http://www.tonyparisi.com/
 * @author Takahiro / https://github.com/takahirox
 * @author Don McCurdy / https://www.donmccurdy.com
 */
var GLTFLoader = function () {
  function GLTFLoader(manager) {
    _three.Loader.call(this, manager);

    this.dracoLoader = null;
    this.ddsLoader = null;
    this.pluginCallbacks = [];
    this.register(function (parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
  }

  GLTFLoader.prototype = Object.assign(Object.create(_three.Loader.prototype), {
    constructor: GLTFLoader,
    load: function (url, onLoad, onProgress, onError) {
      var scope = this;
      var resourcePath;

      if (this.resourcePath !== "") {
        resourcePath = this.resourcePath;
      } else if (this.path !== "") {
        resourcePath = this.path;
      } else {
        resourcePath = _three.LoaderUtils.extractUrlBase(url);
      } // Tells the LoadingManager to track an extra item, which resolves after
      // the model is fully loaded. This means the count of items loaded will
      // be incorrect, but ensures manager.onLoad() does not fire early.


      scope.manager.itemStart(url);

      var _onError = function (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }

        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }; // if (this.requestHeader) {
      //   console.log("REQ HEADER", this.requestHeader);
      // }
      // if (scope.crossOrigin) {
      //   console.log("CROSS ORIGIN", scope.crossOrigin);
      // }


      const uri = scope.manager.resolveURL(this.path + url); // console.log(uri);

      const isGLTF = false;
      new Promise(resolve => {
        (0, _addFrameTasks.addFrameTask)(resolve);
      }).then(() => {
        return window.fetch(uri);
      }).then(resp => {
        // return resp.json();
        return isGLTF ? resp.json() : resp.arrayBuffer();
      }).then(data => {
        try {
          scope.parse(data, resourcePath, function (gltf) {
            onLoad(gltf);
            scope.manager.itemEnd(url);
          }, _onError, isGLTF);
        } catch (e) {
          _onError(e);
        }
      }, _onError);
    },
    setDRACOLoader: function (dracoLoader) {
      this.dracoLoader = dracoLoader;
      return this;
    },
    setDDSLoader: function (ddsLoader) {
      this.ddsLoader = ddsLoader;
      return this;
    },
    register: function (callback) {
      if (this.pluginCallbacks.indexOf(callback) === -1) {
        this.pluginCallbacks.push(callback);
      }

      return this;
    },
    unregister: function (callback) {
      if (this.pluginCallbacks.indexOf(callback) !== -1) {
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
      }

      return this;
    },
    parse: function (data, path, onLoad, onError, isJSON) {
      var content;
      var extensions = {};
      var plugins = {};

      if (typeof data === "string" || isJSON) {
        content = data;
      } else if (!isJSON) {
        var magic = _three.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));

        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
          try {
            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
          } catch (error) {
            if (onError) onError(error);
            return;
          }

          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
        } else {
          content = _three.LoaderUtils.decodeText(new Uint8Array(data));
        }
      }

      var json = isJSON ? content : JSON.parse(content);

      if (json.asset === undefined || json.asset.version[0] < 2) {
        if (onError) onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
        return;
      }

      var parser = new GLTFParser(json, {
        path: path || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        manager: this.manager
      });
      parser.fileLoader.setRequestHeader(this.requestHeader);

      for (var i = 0; i < this.pluginCallbacks.length; i++) {
        var plugin = this.pluginCallbacks[i](parser);
        plugins[plugin.name] = plugin; // Workaround to avoid determining as unknown extension
        // in addUnknownExtensionsToUserData().
        // Remove this workaround if we move all the existing
        // extension handlers to plugin system

        extensions[plugin.name] = true;
      }

      if (json.extensionsUsed) {
        for (var i = 0; i < json.extensionsUsed.length; ++i) {
          var extensionName = json.extensionsUsed[i];
          var extensionsRequired = json.extensionsRequired || [];

          switch (extensionName) {
            case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:
              extensions[extensionName] = new GLTFLightsExtension(json);
              break;

            case EXTENSIONS.KHR_MATERIALS_UNLIT:
              extensions[extensionName] = new GLTFMaterialsUnlitExtension();
              break;

            case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
              extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
              break;

            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
              extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
              break;

            case EXTENSIONS.MSFT_TEXTURE_DDS:
              extensions[extensionName] = new GLTFTextureDDSExtension(this.ddsLoader);
              break;

            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
              extensions[extensionName] = new GLTFTextureTransformExtension();
              break;

            case EXTENSIONS.KHR_MESH_QUANTIZATION:
              extensions[extensionName] = new GLTFMeshQuantizationExtension();
              break;

            default:
              if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {
                console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
              }

          }
        }
      }

      parser.setExtensions(extensions);
      parser.setPlugins(plugins);
      parser.parse(onLoad, onError);
    }
  });
  /* GLTFREGISTRY */

  function GLTFRegistry() {
    var objects = {};
    return {
      get: function (key) {
        return objects[key];
      },
      add: function (key, object) {
        objects[key] = object;
      },
      remove: function (key) {
        delete objects[key];
      },
      removeAll: function () {
        objects = {};
      }
    };
  }
  /*********************************/

  /********** EXTENSIONS ***********/

  /*********************************/


  var EXTENSIONS = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    MSFT_TEXTURE_DDS: "MSFT_texture_dds"
  };
  /**
   * DDS Texture Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds
   *
   */

  function GLTFTextureDDSExtension(ddsLoader) {
    if (!ddsLoader) {
      throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader");
    }

    this.name = EXTENSIONS.MSFT_TEXTURE_DDS;
    this.ddsLoader = ddsLoader;
  }
  /**
   * Punctual Lights Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
   */


  function GLTFLightsExtension(json) {
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    var extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] || {};
    this.lightDefs = extension.lights || [];
  }

  GLTFLightsExtension.prototype.loadLight = function (lightIndex) {
    var lightDef = this.lightDefs[lightIndex];
    var lightNode;
    var color = new _three.Color(0xffffff);
    if (lightDef.color !== undefined) color.fromArray(lightDef.color);
    var range = lightDef.range !== undefined ? lightDef.range : 0;

    switch (lightDef.type) {
      case "directional":
        lightNode = new _three.DirectionalLight(color);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;

      case "point":
        lightNode = new _three.PointLight(color);
        lightNode.distance = range;
        break;

      case "spot":
        lightNode = new _three.SpotLight(color);
        lightNode.distance = range; // Handle spotlight properties.

        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;

      default:
        throw new Error('THREE.GLTFLoader: Unexpected light type, "' + lightDef.type + '".');
    } // Some lights (e.g. spot) default to a position other than the origin. Reset the position
    // here, because node-level parsing will only override position if explicitly specified.


    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;
    lightNode.name = lightDef.name || "light_" + lightIndex;
    return Promise.resolve(lightNode);
  };
  /**
   * Unlit Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
   */


  function GLTFMaterialsUnlitExtension() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }

  GLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {
    return _three.MeshBasicMaterial;
  };

  GLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, materialDef, parser) {
    var pending = [];
    materialParams.color = new _three.Color(1.0, 1.0, 1.0);
    materialParams.opacity = 1.0;
    var metallicRoughness = materialDef.pbrMetallicRoughness;

    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        var array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }

      if (metallicRoughness.baseColorTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
      }
    }

    return Promise.all(pending);
  };
  /**
   * Clearcoat Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
   */


  function GLTFMaterialsClearcoatExtension(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }

  GLTFMaterialsClearcoatExtension.prototype.getMaterialType = function ()
  /* materialIndex */
  {
    return _three.MeshPhysicalMaterial;
  };

  GLTFMaterialsClearcoatExtension.prototype.extendMaterialParams = function (materialIndex, materialParams) {
    var parser = this.parser;
    var materialDef = parser.json.materials[materialIndex];

    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }

    var pending = [];
    var extension = materialDef.extensions[this.name];

    if (extension.clearcoatFactor !== undefined) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }

    if (extension.clearcoatTexture !== undefined) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }

    if (extension.clearcoatRoughnessFactor !== undefined) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }

    if (extension.clearcoatRoughnessTexture !== undefined) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }

    if (extension.clearcoatNormalTexture !== undefined) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));

      if (extension.clearcoatNormalTexture.scale !== undefined) {
        var scale = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new _three.Vector2(scale, scale);
      }
    }

    return Promise.all(pending);
  };
  /* BINARY EXTENSION */


  var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
  var BINARY_EXTENSION_HEADER_LENGTH = 12;
  var BINARY_EXTENSION_CHUNK_TYPES = {
    JSON: 0x4e4f534a,
    BIN: 0x004e4942
  };

  function GLTFBinaryExtension(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    this.header = {
      magic: _three.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };

    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2.0) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }

    var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    var chunkIndex = 0;

    while (chunkIndex < chunkView.byteLength) {
      var chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      var chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;

      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = _three.LoaderUtils.decodeText(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      } // Clients must ignore chunks with unknown types.


      chunkIndex += chunkLength;
    }

    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
  /**
   * DRACO Mesh Compression Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
   */


  function GLTFDracoMeshCompressionExtension(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }

    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }

  GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {
    var json = this.json;
    var dracoLoader = this.dracoLoader;
    var bufferViewIndex = primitive.extensions[this.name].bufferView;
    var gltfAttributeMap = primitive.extensions[this.name].attributes;
    var threeAttributeMap = {};
    var attributeNormalizedMap = {};
    var attributeTypeMap = {};

    for (var attributeName in gltfAttributeMap) {
      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }

    for (attributeName in primitive.attributes) {
      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();

      if (gltfAttributeMap[attributeName] !== undefined) {
        var accessorDef = json.accessors[primitive.attributes[attributeName]];
        var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }

    return parser.getDependency("bufferView", bufferViewIndex).then(function (bufferView) {
      return new Promise(function (resolve) {
        dracoLoader.decodeDracoFile(bufferView, function (geometry) {
          for (var attributeName in geometry.attributes) {
            var attribute = geometry.attributes[attributeName];
            var normalized = attributeNormalizedMap[attributeName];
            if (normalized !== undefined) attribute.normalized = normalized;
          }

          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap);
      });
    });
  };
  /**
   * Texture Transform Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
   */


  function GLTFTextureTransformExtension() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }

  GLTFTextureTransformExtension.prototype.extendTexture = function (texture, transform) {
    texture = texture.clone();

    if (transform.offset !== undefined) {
      texture.offset.fromArray(transform.offset);
    }

    if (transform.rotation !== undefined) {
      texture.rotation = transform.rotation;
    }

    if (transform.scale !== undefined) {
      texture.repeat.fromArray(transform.scale);
    }

    if (transform.texCoord !== undefined) {
      console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
    }

    texture.needsUpdate = true;
    return texture;
  };
  /**
   * Specular-Glossiness Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
   */

  /**
   * A sub class of StandardMaterial with some of the functionality
   * changed via the `onBeforeCompile` callback
   * @pailhead
   */


  function GLTFMeshStandardSGMaterial(params) {
    _three.MeshStandardMaterial.call(this);

    this.isGLTFSpecularGlossinessMaterial = true; //various chunks that need replacing

    var specularMapParsFragmentChunk = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join("\n");
    var glossinessMapParsFragmentChunk = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join("\n");
    var specularMapFragmentChunk = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	texelSpecular = sRGBToLinear( texelSpecular );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join("\n");
    var glossinessMapFragmentChunk = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join("\n");
    var lightPhysicalFragmentChunk = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb;", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor.rgb;"].join("\n");
    var uniforms = {
      specular: {
        value: new _three.Color().setHex(0xffffff)
      },
      glossiness: {
        value: 1
      },
      specularMap: {
        value: null
      },
      glossinessMap: {
        value: null
      }
    };
    this._extraUniforms = uniforms; // please see #14031 or #13198 for an alternate approach

    this.onBeforeCompile = function (shader) {
      for (var uniformName in uniforms) {
        shader.uniforms[uniformName] = uniforms[uniformName];
      }

      shader.fragmentShader = shader.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;");
      shader.fragmentShader = shader.fragmentShader.replace("uniform float metalness;", "uniform float glossiness;");
      shader.fragmentShader = shader.fragmentShader.replace("#include <roughnessmap_pars_fragment>", specularMapParsFragmentChunk);
      shader.fragmentShader = shader.fragmentShader.replace("#include <metalnessmap_pars_fragment>", glossinessMapParsFragmentChunk);
      shader.fragmentShader = shader.fragmentShader.replace("#include <roughnessmap_fragment>", specularMapFragmentChunk);
      shader.fragmentShader = shader.fragmentShader.replace("#include <metalnessmap_fragment>", glossinessMapFragmentChunk);
      shader.fragmentShader = shader.fragmentShader.replace("#include <lights_physical_fragment>", lightPhysicalFragmentChunk);
    };
    /*eslint-disable*/


    Object.defineProperties(this, {
      specular: {
        get: function () {
          return uniforms.specular.value;
        },
        set: function (v) {
          uniforms.specular.value = v;
        }
      },
      specularMap: {
        get: function () {
          return uniforms.specularMap.value;
        },
        set: function (v) {
          uniforms.specularMap.value = v;
        }
      },
      glossiness: {
        get: function () {
          return uniforms.glossiness.value;
        },
        set: function (v) {
          uniforms.glossiness.value = v;
        }
      },
      glossinessMap: {
        get: function () {
          return uniforms.glossinessMap.value;
        },
        set: function (v) {
          uniforms.glossinessMap.value = v; //how about something like this - @pailhead

          if (v) {
            this.defines.USE_GLOSSINESSMAP = ""; // set USE_ROUGHNESSMAP to enable vUv

            this.defines.USE_ROUGHNESSMAP = "";
          } else {
            delete this.defines.USE_ROUGHNESSMAP;
            delete this.defines.USE_GLOSSINESSMAP;
          }
        }
      }
    });
    /*eslint-enable*/

    delete this.metalness;
    delete this.roughness;
    delete this.metalnessMap;
    delete this.roughnessMap;
    this.setValues(params);
  }

  GLTFMeshStandardSGMaterial.prototype = Object.create(_three.MeshStandardMaterial.prototype);
  GLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;

  GLTFMeshStandardSGMaterial.prototype.copy = function (source) {
    _three.MeshStandardMaterial.prototype.copy.call(this, source);

    this.specularMap = source.specularMap;
    this.specular.copy(source.specular);
    this.glossinessMap = source.glossinessMap;
    this.glossiness = source.glossiness;
    delete this.metalness;
    delete this.roughness;
    delete this.metalnessMap;
    delete this.roughnessMap;
    return this;
  };

  function GLTFMaterialsPbrSpecularGlossinessExtension() {
    return {
      name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
      specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"],
      getMaterialType: function () {
        return GLTFMeshStandardSGMaterial;
      },
      extendParams: function (materialParams, materialDef, parser) {
        var pbrSpecularGlossiness = materialDef.extensions[this.name];
        materialParams.color = new _three.Color(1.0, 1.0, 1.0);
        materialParams.opacity = 1.0;
        var pending = [];

        if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
          var array = pbrSpecularGlossiness.diffuseFactor;
          materialParams.color.fromArray(array);
          materialParams.opacity = array[3];
        }

        if (pbrSpecularGlossiness.diffuseTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, "map", pbrSpecularGlossiness.diffuseTexture));
        }

        materialParams.emissive = new _three.Color(0.0, 0.0, 0.0);
        materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
        materialParams.specular = new _three.Color(1.0, 1.0, 1.0);

        if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
          materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
        }

        if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {
          var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
          pending.push(parser.assignTexture(materialParams, "glossinessMap", specGlossMapDef));
          pending.push(parser.assignTexture(materialParams, "specularMap", specGlossMapDef));
        }

        return Promise.all(pending);
      },
      createMaterial: function (materialParams) {
        var material = new GLTFMeshStandardSGMaterial(materialParams);
        material.fog = true;
        material.color = materialParams.color;
        material.map = materialParams.map === undefined ? null : materialParams.map;
        material.lightMap = null;
        material.lightMapIntensity = 1.0;
        material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
        material.aoMapIntensity = 1.0;
        material.emissive = materialParams.emissive;
        material.emissiveIntensity = 1.0;
        material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;
        material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
        material.bumpScale = 1;
        material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
        material.normalMapType = _three.TangentSpaceNormalMap;
        if (materialParams.normalScale) material.normalScale = materialParams.normalScale;
        material.displacementMap = null;
        material.displacementScale = 1;
        material.displacementBias = 0;
        material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
        material.specular = materialParams.specular;
        material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
        material.glossiness = materialParams.glossiness;
        material.alphaMap = null;
        material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
        material.envMapIntensity = 1.0;
        material.refractionRatio = 0.98;
        return material;
      }
    };
  }
  /**
   * Mesh Quantization Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
   */


  function GLTFMeshQuantizationExtension() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
  /*********************************/

  /********** INTERPOLATION ********/

  /*********************************/
  // Spline Interpolation
  // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation


  function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    _three.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }

  GLTFCubicSplineInterpolant.prototype = Object.create(_three.Interpolant.prototype);
  GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;

  GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function (index) {
    // Copies a sample value to the result buffer. See description of glTF
    // CUBICSPLINE values layout in interpolate_() function below.
    var result = this.resultBuffer,
        values = this.sampleValues,
        valueSize = this.valueSize,
        offset = index * valueSize * 3 + valueSize;

    for (var i = 0; i !== valueSize; i++) {
      result[i] = values[offset + i];
    }

    return result;
  };

  GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
  GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

  GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
    var result = this.resultBuffer;
    var values = this.sampleValues;
    var stride = this.valueSize;
    var stride2 = stride * 2;
    var stride3 = stride * 3;
    var td = t1 - t0;
    var p = (t - t0) / td;
    var pp = p * p;
    var ppp = pp * p;
    var offset1 = i1 * stride3;
    var offset0 = offset1 - stride3;
    var s2 = -2 * ppp + 3 * pp;
    var s3 = ppp - pp;
    var s0 = 1 - s2;
    var s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:
    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]

    for (var i = 0; i !== stride; i++) {
      var p0 = values[offset0 + i + stride]; // splineVertex_k

      var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)

      var p1 = values[offset1 + i + stride]; // splineVertex_k+1

      var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)

      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }

    return result;
  };
  /*********************************/

  /********** INTERNALS ************/

  /*********************************/

  /* CONSTANTS */


  var WEBGL_CONSTANTS = {
    FLOAT: 5126,
    //FLOAT_MAT2: 35674,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
  };
  var WEBGL_COMPONENT_TYPES = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };
  var WEBGL_FILTERS = {
    9728: _three.NearestFilter,
    9729: _three.LinearFilter,
    9984: _three.NearestMipmapNearestFilter,
    9985: _three.LinearMipmapNearestFilter,
    9986: _three.NearestMipmapLinearFilter,
    9987: _three.LinearMipmapLinearFilter
  };
  var WEBGL_WRAPPINGS = {
    33071: _three.ClampToEdgeWrapping,
    33648: _three.MirroredRepeatWrapping,
    10497: _three.RepeatWrapping
  };
  var WEBGL_TYPE_SIZES = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
  };
  var ATTRIBUTES = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
  };
  var PATH_PROPERTIES = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
  };
  var INTERPOLATION = {
    CUBICSPLINE: undefined,
    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
    // keyframe track will be initialized with a default interpolation type, then modified.
    LINEAR: _three.InterpolateLinear,
    STEP: _three.InterpolateDiscrete
  };
  var ALPHA_MODES = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
  };
  var MIME_TYPE_FORMATS = {
    "image/png": _three.RGBAFormat,
    "image/jpeg": _three.RGBFormat
  };
  /* UTILITY FUNCTIONS */

  function resolveURL(url, path) {
    // Invalid URL
    if (typeof url !== "string" || url === "") return ""; // Host Relative URL

    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
    } // Absolute URL http://,https://,//


    if (/^(https?:)?\/\//i.test(url)) return url; // Data URI

    if (/^data:.*,.*$/i.test(url)) return url; // Blob URL

    if (/^blob:.*$/i.test(url)) return url; // Relative URL

    return path + url;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
   */


  function createDefaultMaterial(cache) {
    if (cache["DefaultMaterial"] === undefined) {
      cache["DefaultMaterial"] = new _three.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0x000000,
        metalness: 1,
        roughness: 1,
        transparent: false,
        depthTest: true,
        side: _three.FrontSide
      });
    }

    return cache["DefaultMaterial"];
  }

  function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
    // Add unknown glTF extensions to an object's userData.
    for (var name in objectDef.extensions) {
      if (knownExtensions[name] === undefined) {
        object.userData.gltfExtensions = object.userData.gltfExtensions || {};
        object.userData.gltfExtensions[name] = objectDef.extensions[name];
      }
    }
  }
  /**
   * @param {Object3D|Material|BufferGeometry} object
   * @param {GLTF.definition} gltfDef
   */


  function assignExtrasToUserData(object, gltfDef) {
    if (gltfDef.extras !== undefined) {
      if (typeof gltfDef.extras === "object") {
        Object.assign(object.userData, gltfDef.extras);
      } else {
        console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
      }
    }
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
   *
   * @param {BufferGeometry} geometry
   * @param {Array<GLTF.Target>} targets
   * @param {GLTFParser} parser
   * @return {Promise<BufferGeometry>}
   */


  function addMorphTargets(geometry, targets, parser) {
    var hasMorphPosition = false;
    var hasMorphNormal = false;

    for (var i = 0, il = targets.length; i < il; i++) {
      var target = targets[i];
      if (target.POSITION !== undefined) hasMorphPosition = true;
      if (target.NORMAL !== undefined) hasMorphNormal = true;
      if (hasMorphPosition && hasMorphNormal) break;
    }

    if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);
    var pendingPositionAccessors = [];
    var pendingNormalAccessors = [];

    for (var i = 0, il = targets.length; i < il; i++) {
      var target = targets[i];

      if (hasMorphPosition) {
        var pendingAccessor = target.POSITION !== undefined ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
        pendingPositionAccessors.push(pendingAccessor);
      }

      if (hasMorphNormal) {
        var pendingAccessor = target.NORMAL !== undefined ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
        pendingNormalAccessors.push(pendingAccessor);
      }
    }

    return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {
      var morphPositions = accessors[0];
      var morphNormals = accessors[1];
      if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
      if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
      geometry.morphTargetsRelative = true;
      return geometry;
    });
  }
  /**
   * @param {Mesh} mesh
   * @param {GLTF.Mesh} meshDef
   */


  function updateMorphTargets(mesh, meshDef) {
    mesh.updateMorphTargets();

    if (meshDef.weights !== undefined) {
      for (var i = 0, il = meshDef.weights.length; i < il; i++) {
        mesh.morphTargetInfluences[i] = meshDef.weights[i];
      }
    } // .extras has user-defined data, so check that .extras.targetNames is an array.


    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
      var targetNames = meshDef.extras.targetNames;

      if (mesh.morphTargetInfluences.length === targetNames.length) {
        mesh.morphTargetDictionary = {};

        for (var i = 0, il = targetNames.length; i < il; i++) {
          mesh.morphTargetDictionary[targetNames[i]] = i;
        }
      } else {
        console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
      }
    }
  }

  function createPrimitiveKey(primitiveDef) {
    var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
    var geometryKey;

    if (dracoExtension) {
      geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
    } else {
      geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
    }

    return geometryKey;
  }

  function createAttributesKey(attributes) {
    var attributesKey = "";
    var keys = Object.keys(attributes).sort();

    for (var i = 0, il = keys.length; i < il; i++) {
      attributesKey += keys[i] + ":" + attributes[keys[i]] + ";";
    }

    return attributesKey;
  }
  /* GLTF PARSER */


  function GLTFParser(json, options) {
    this.json = json || {};
    this.extensions = {};
    this.plugins = {};
    this.options = options || {}; // loader object cache

    this.cache = new GLTFRegistry(); // associations between Three.js objects and glTF elements

    this.associations = new Map(); // BufferGeometry caching

    this.primitiveCache = {}; // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
    // expensive work of uploading a texture to the GPU off the main thread.

    if (typeof createImageBitmap !== "undefined" && /Firefox/.test(navigator.userAgent) === false) {
      this.textureLoader = new _three.ImageBitmapLoader(this.options.manager);
    } else {
      this.textureLoader = new _three.TextureLoader(this.options.manager);
    }

    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.fileLoader = new _three.FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");

    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }

  GLTFParser.prototype.setExtensions = function (extensions) {
    this.extensions = extensions;
  };

  GLTFParser.prototype.setPlugins = function (plugins) {
    this.plugins = plugins;
  };

  GLTFParser.prototype.parse = function (onLoad, onError) {
    var parser = this;
    var json = this.json;
    var extensions = this.extensions; // Clear the loader cache

    this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse

    this.markDefs();
    Promise.all([this.getDependencies("scene"), this.getDependencies("animation"), this.getDependencies("camera")]).then(function (dependencies) {
      var result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser: parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      onLoad(result);
    }).catch(onError);
  };
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */


  GLTFParser.prototype.markDefs = function () {
    var nodeDefs = this.json.nodes || [];
    var skinDefs = this.json.skins || [];
    var meshDefs = this.json.meshes || [];
    var meshReferences = {};
    var meshUses = {}; // Nothing in the node definition indicates whether it is a Bone or an
    // Object3D. Use the skins' joint references to mark bones.

    for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      var joints = skinDefs[skinIndex].joints;

      for (var i = 0, il = joints.length; i < il; i++) {
        nodeDefs[joints[i]].isBone = true;
      }
    } // Meshes can (and should) be reused by multiple nodes in a glTF asset. To
    // avoid having more than one Mesh with the same name, count
    // references and rename instances below.
    //
    // Example: CesiumMilkTruck sample model reuses "Wheel" meshes.


    for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      var nodeDef = nodeDefs[nodeIndex];

      if (nodeDef.mesh !== undefined) {
        if (meshReferences[nodeDef.mesh] === undefined) {
          meshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;
        }

        meshReferences[nodeDef.mesh]++; // Nothing in the mesh definition indicates whether it is
        // a SkinnedMesh or Mesh. Use the node's mesh reference
        // to mark SkinnedMesh if node has skin.

        if (nodeDef.skin !== undefined) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
    }

    this.json.meshReferences = meshReferences;
    this.json.meshUses = meshUses;
  };

  GLTFParser.prototype._invokeOne = function (func) {
    var extensions = Object.values(this.plugins);
    extensions.push(this);

    for (var i = 0; i < extensions.length; i++) {
      var result = func(extensions[i]);
      if (result) return result;
    }
  };

  GLTFParser.prototype._invokeAll = function (func) {
    var extensions = Object.values(this.plugins);
    extensions.unshift(this);
    var pending = [];

    for (var i = 0; i < extensions.length; i++) {
      pending.push(func(extensions[i]));
    }

    return Promise.all(pending);
  };
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */


  GLTFParser.prototype.getDependency = function (type, index) {
    var cacheKey = type + ":" + index;
    var dependency = this.cache.get(cacheKey);

    if (!dependency) {
      switch (type) {
        case "scene":
          dependency = this.loadScene(index);
          break;

        case "node":
          dependency = this.loadNode(index);
          break;

        case "mesh":
          dependency = this._invokeOne(function (ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;

        case "accessor":
          dependency = this.loadAccessor(index);
          break;

        case "bufferView":
          dependency = this._invokeOne(function (ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;

        case "buffer":
          dependency = this.loadBuffer(index);
          break;

        case "material":
          dependency = this._invokeOne(function (ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;

        case "texture":
          dependency = this.loadTexture(index);
          break;

        case "skin":
          dependency = this.loadSkin(index);
          break;

        case "animation":
          dependency = this.loadAnimation(index);
          break;

        case "camera":
          dependency = this.loadCamera(index);
          break;

        case "light":
          dependency = this.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].loadLight(index);
          break;

        default:
          throw new Error("Unknown type: " + type);
      }

      this.cache.add(cacheKey, dependency);
    }

    return dependency;
  };
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */


  GLTFParser.prototype.getDependencies = function (type) {
    var dependencies = this.cache.get(type);

    if (!dependencies) {
      var parser = this;
      var defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs.map(function (def, index) {
        return parser.getDependency(type, index);
      }));
      this.cache.add(type, dependencies);
    }

    return dependencies;
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */


  GLTFParser.prototype.loadBuffer = function (bufferIndex) {
    var bufferDef = this.json.buffers[bufferIndex]; // var loader = this.fileLoader;

    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    } // If present, GLB container is required to be the first buffer.


    if (bufferDef.uri === undefined && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }

    var options = this.options;
    return new Promise(resolve => {
      (0, _addFrameTasks.addFrameTask)(resolve);
    }).then(() => {
      return window.fetch(resolveURL(bufferDef.uri, options.path));
    }).then(resp => {
      return resp.arrayBuffer();
    }); // return new Promise(function (resolve, reject) {
    //   loader.load(
    //     resolveURL(bufferDef.uri, options.path),
    //     resolve,
    //     undefined,
    //     function () {
    //       reject(
    //         new Error(
    //           'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'
    //         )
    //       );
    //     }
    //   );
    // });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */


  GLTFParser.prototype.loadBufferView = function (bufferViewIndex) {
    var bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function (buffer) {
      var byteLength = bufferViewDef.byteLength || 0;
      var byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice(byteOffset, byteOffset + byteLength);
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */


  GLTFParser.prototype.loadAccessor = function (accessorIndex) {
    var parser = this;
    var json = this.json;
    var accessorDef = this.json.accessors[accessorIndex];

    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {
      // Ignore empty accessors, which may be used to declare runtime
      // information about attributes coming from another source (e.g. Draco
      // compression extension).
      return Promise.resolve(null);
    }

    var pendingBufferViews = [];

    if (accessorDef.bufferView !== undefined) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }

    if (accessorDef.sparse !== undefined) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }

    return Promise.all(pendingBufferViews).then(function (bufferViews) {
      var bufferView = bufferViews[0];
      var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.

      var elementBytes = TypedArray.BYTES_PER_ELEMENT;
      var itemBytes = elementBytes * itemSize;
      var byteOffset = accessorDef.byteOffset || 0;
      var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;
      var normalized = accessorDef.normalized === true;
      var array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.

      if (byteStride && byteStride !== itemBytes) {
        // Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
        // This makes sure that IBA.count reflects accessor.count properly
        var ibSlice = Math.floor(byteOffset / byteStride);
        var ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        var ib = parser.cache.get(ibCacheKey);

        if (!ib) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes); // Integer parameters to IB/IBA are in array elements, not bytes.

          ib = new _three.InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }

        bufferAttribute = new _three.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }

        bufferAttribute = new _three.BufferAttribute(array, itemSize, normalized);
      } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors


      if (accessorDef.sparse !== undefined) {
        var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);

        if (bufferView !== null) {
          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
          bufferAttribute = new _three.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }

        for (var i = 0, il = sparseIndices.length; i < il; i++) {
          var index = sparseIndices[i];
          bufferAttribute.setX(index, sparseValues[i * itemSize]);
          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
          if (itemSize >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }

      return bufferAttribute;
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture>}
   */


  GLTFParser.prototype.loadTexture = function (textureIndex) {
    var parser = this;
    var json = this.json;
    var options = this.options;
    var textureLoader = this.textureLoader;
    var URL = self.URL || self.webkitURL;
    var textureDef = json.textures[textureIndex];
    var textureExtensions = textureDef.extensions || {};
    var source;

    if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {
      source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];
    } else {
      source = json.images[textureDef.source];
    }

    var sourceURI = source.uri;
    var isObjectURL = false;

    if (source.bufferView !== undefined) {
      // Load binary image data from bufferView, if provided.
      sourceURI = parser.getDependency("bufferView", source.bufferView).then(function (bufferView) {
        isObjectURL = true;
        var blob = new Blob([bufferView], {
          type: source.mimeType
        });
        sourceURI = URL.createObjectURL(blob);
        return sourceURI;
      });
    }

    return Promise.resolve(sourceURI).then(function (sourceURI) {
      // Load Texture resource.
      var loader = options.manager.getHandler(sourceURI);

      if (!loader) {
        loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : textureLoader;
      }

      return new Promise(function (resolve, reject) {
        var onLoad = resolve;

        if (loader.isImageBitmapLoader === true) {
          onLoad = function (imageBitmap) {
            resolve(new _three.CanvasTexture(imageBitmap));
          };
        }

        loader.load(resolveURL(sourceURI, options.path), onLoad, undefined, reject);
      });
    }).then(function (texture) {
      // Clean up resources and configure Texture.
      if (isObjectURL === true) {
        URL.revokeObjectURL(sourceURI);
      }

      texture.flipY = false;
      if (textureDef.name) texture.name = textureDef.name; // Ignore unknown mime types, like DDS files.

      if (source.mimeType in MIME_TYPE_FORMATS) {
        texture.format = MIME_TYPE_FORMATS[source.mimeType];
      }

      var samplers = json.samplers || {};
      var sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || _three.LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || _three.LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || _three.RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || _three.RepeatWrapping;
      parser.associations.set(texture, {
        type: "textures",
        index: textureIndex
      });
      return texture;
    });
  };
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise}
   */


  GLTFParser.prototype.assignTexture = function (materialParams, mapName, mapDef) {
    var parser = this;
    return this.getDependency("texture", mapDef.index).then(function (texture) {
      if (!texture.isCompressedTexture) {
        switch (mapName) {
          case "aoMap":
          case "emissiveMap":
          case "metalnessMap":
          case "normalMap":
          case "roughnessMap":
            texture.format = _three.RGBFormat;
            break;
        }
      } // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
      // However, we will copy UV set 0 to UV set 1 on demand for aoMap


      if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === "aoMap" && mapDef.texCoord == 1)) {
        console.warn("THREE.GLTFLoader: Custom UV set " + mapDef.texCoord + " for texture " + mapName + " not yet supported.");
      }

      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;

        if (transform) {
          var gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
          parser.associations.set(texture, gltfReference);
        }
      }

      materialParams[mapName] = texture;
    });
  };
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accomodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */


  GLTFParser.prototype.assignFinalMaterial = function (mesh) {
    var geometry = mesh.geometry;
    var material = mesh.material;
    var useVertexTangents = geometry.attributes.tangent !== undefined;
    var useVertexColors = geometry.attributes.color !== undefined;
    var useFlatShading = geometry.attributes.normal === undefined;
    var useSkinning = mesh.isSkinnedMesh === true;
    var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;
    var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;

    if (mesh.isPoints) {
      var cacheKey = "PointsMaterial:" + material.uuid;
      var pointsMaterial = this.cache.get(cacheKey);

      if (!pointsMaterial) {
        pointsMaterial = new _three.PointsMaterial();

        _three.Material.prototype.copy.call(pointsMaterial, material);

        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

        this.cache.add(cacheKey, pointsMaterial);
      }

      material = pointsMaterial;
    } else if (mesh.isLine) {
      var cacheKey = "LineBasicMaterial:" + material.uuid;
      var lineMaterial = this.cache.get(cacheKey);

      if (!lineMaterial) {
        lineMaterial = new _three.LineBasicMaterial();

        _three.Material.prototype.copy.call(lineMaterial, material);

        lineMaterial.color.copy(material.color);
        this.cache.add(cacheKey, lineMaterial);
      }

      material = lineMaterial;
    } // Clone the material if it will be modified


    if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {
      var cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (material.isGLTFSpecularGlossinessMaterial) cacheKey += "specular-glossiness:";
      if (useSkinning) cacheKey += "skinning:";
      if (useVertexTangents) cacheKey += "vertex-tangents:";
      if (useVertexColors) cacheKey += "vertex-colors:";
      if (useFlatShading) cacheKey += "flat-shading:";
      if (useMorphTargets) cacheKey += "morph-targets:";
      if (useMorphNormals) cacheKey += "morph-normals:";
      var cachedMaterial = this.cache.get(cacheKey);

      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useSkinning) cachedMaterial.skinning = true;
        if (useVertexTangents) cachedMaterial.vertexTangents = true;
        if (useVertexColors) cachedMaterial.vertexColors = true;
        if (useFlatShading) cachedMaterial.flatShading = true;
        if (useMorphTargets) cachedMaterial.morphTargets = true;
        if (useMorphNormals) cachedMaterial.morphNormals = true;
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }

      material = cachedMaterial;
    } // workarounds for mesh and geometry


    if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {
      geometry.setAttribute("uv2", geometry.attributes.uv);
    } // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995


    if (material.normalScale && !useVertexTangents) {
      material.normalScale.y = -material.normalScale.y;
    }

    if (material.clearcoatNormalScale && !useVertexTangents) {
      material.clearcoatNormalScale.y = -material.clearcoatNormalScale.y;
    }

    mesh.material = material;
  };

  GLTFParser.prototype.getMaterialType = function ()
  /* materialIndex */
  {
    return _three.MeshStandardMaterial;
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */


  GLTFParser.prototype.loadMaterial = function (materialIndex) {
    var parser = this;
    var json = this.json;
    var extensions = this.extensions;
    var materialDef = json.materials[materialIndex];
    var materialType;
    var materialParams = {};
    var materialExtensions = materialDef.extensions || {};
    var pending = [];

    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      materialType = sgExtension.getMaterialType();
      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      // Specification:
      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material
      var metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new _three.Color(1.0, 1.0, 1.0);
      materialParams.opacity = 1.0;

      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        var array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }

      if (metallicRoughness.baseColorTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
      }

      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
      materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

      if (metallicRoughness.metallicRoughnessTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }

      materialType = this._invokeOne(function (ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(this._invokeAll(function (ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      }));
    }

    if (materialDef.doubleSided === true) {
      materialParams.side = _three.DoubleSide;
    }

    var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true; // See: https://github.com/mrdoob/three.js/issues/17706

      materialParams.depthWrite = false;
    } else {
      materialParams.transparent = false;

      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;
      }
    }

    if (materialDef.normalTexture !== undefined && materialType !== _three.MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new _three.Vector2(1, 1);

      if (materialDef.normalTexture.scale !== undefined) {
        materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);
      }
    }

    if (materialDef.occlusionTexture !== undefined && materialType !== _three.MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));

      if (materialDef.occlusionTexture.strength !== undefined) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }

    if (materialDef.emissiveFactor !== undefined && materialType !== _three.MeshBasicMaterial) {
      materialParams.emissive = new _three.Color().fromArray(materialDef.emissiveFactor);
    }

    if (materialDef.emissiveTexture !== undefined && materialType !== _three.MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture));
    }

    return Promise.all(pending).then(function () {
      var material;

      if (materialType === GLTFMeshStandardSGMaterial) {
        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
      } else {
        material = new materialType(materialParams);
      }

      if (materialDef.name) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.

      if (material.map) material.map.encoding = _three.sRGBEncoding;
      if (material.emissiveMap) material.emissiveMap.encoding = _three.sRGBEncoding;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, {
        type: "materials",
        index: materialIndex
      });
      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  };
  /**
   * @param {BufferGeometry} geometry
   * @param {GLTF.Primitive} primitiveDef
   * @param {GLTFParser} parser
   */


  function computeBounds(geometry, primitiveDef, parser) {
    var attributes = primitiveDef.attributes;
    var box = new _three.Box3();

    if (attributes.POSITION !== undefined) {
      var accessor = parser.json.accessors[attributes.POSITION];
      var min = accessor.min;
      var max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

      if (min !== undefined && max !== undefined) {
        box.set(new _three.Vector3(min[0], min[1], min[2]), new _three.Vector3(max[0], max[1], max[2]));
      } else {
        console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        return;
      }
    } else {
      return;
    }

    var targets = primitiveDef.targets;

    if (targets !== undefined) {
      var maxDisplacement = new _three.Vector3();
      var vector = new _three.Vector3();

      for (var i = 0, il = targets.length; i < il; i++) {
        var target = targets[i];

        if (target.POSITION !== undefined) {
          var accessor = parser.json.accessors[target.POSITION];
          var min = accessor.min;
          var max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

          if (min !== undefined && max !== undefined) {
            // we need to get max of absolute components because target weight is [-1,1]
            vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
            vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
            vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2]))); // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
            // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
            // are used to implement key-frame animations and as such only two are active at a time - this results in very large
            // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.

            maxDisplacement.max(vector);
          } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
          }
        }
      } // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.


      box.expandByVector(maxDisplacement);
    }

    geometry.boundingBox = box;
    var sphere = new _three.Sphere();
    box.getCenter(sphere.center);
    sphere.radius = box.min.distanceTo(box.max) / 2;
    geometry.boundingSphere = sphere;
  }
  /**
   * @param {BufferGeometry} geometry
   * @param {GLTF.Primitive} primitiveDef
   * @param {GLTFParser} parser
   * @return {Promise<BufferGeometry>}
   */


  function addPrimitiveAttributes(geometry, primitiveDef, parser) {
    var attributes = primitiveDef.attributes;
    var pending = [];

    function assignAttributeAccessor(accessorIndex, attributeName) {
      return parser.getDependency("accessor", accessorIndex).then(function (accessor) {
        geometry.setAttribute(attributeName, accessor);
      });
    }

    for (var gltfAttributeName in attributes) {
      var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.

      if (threeAttributeName in geometry.attributes) continue;
      pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
    }

    if (primitiveDef.indices !== undefined && !geometry.index) {
      var accessor = parser.getDependency("accessor", primitiveDef.indices).then(function (accessor) {
        geometry.setIndex(accessor);
      });
      pending.push(accessor);
    }

    assignExtrasToUserData(geometry, primitiveDef);
    computeBounds(geometry, primitiveDef, parser);
    return Promise.all(pending).then(function () {
      return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
    });
  }
  /**
   * @param {BufferGeometry} geometry
   * @param {Number} drawMode
   * @return {BufferGeometry}
   */


  function toTrianglesDrawMode(geometry, drawMode) {
    var index = geometry.getIndex(); // generate index if not present

    if (index === null) {
      var indices = [];
      var position = geometry.getAttribute("position");

      if (position !== undefined) {
        for (var i = 0; i < position.count; i++) {
          indices.push(i);
        }

        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    } //


    var numberOfTriangles = index.count - 2;
    var newIndices = [];

    if (drawMode === _three.TriangleFanDrawMode) {
      // gl.TRIANGLE_FAN
      for (var i = 1; i <= numberOfTriangles; i++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(i));
        newIndices.push(index.getX(i + 1));
      }
    } else {
      // gl.TRIANGLE_STRIP
      for (var i = 0; i < numberOfTriangles; i++) {
        if (i % 2 === 0) {
          newIndices.push(index.getX(i));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i + 2));
        } else {
          newIndices.push(index.getX(i + 2));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i));
        }
      }
    }

    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    } // build final geometry


    var newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    return newGeometry;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */


  GLTFParser.prototype.loadGeometries = function (primitives) {
    var parser = this;
    var extensions = this.extensions;
    var cache = this.primitiveCache;

    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }

    var pending = [];

    for (var i = 0, il = primitives.length; i < il; i++) {
      var primitive = primitives[i];
      var cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry

      var cached = cache[cacheKey];

      if (cached) {
        // Use the cached geometry if it exists
        pending.push(cached.promise);
      } else {
        var geometryPromise;

        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          // Use DRACO geometry if available
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          // Otherwise create a new geometry
          geometryPromise = addPrimitiveAttributes(new _three.BufferGeometry(), primitive, parser);
        } // Cache this geometry


        cache[cacheKey] = {
          primitive: primitive,
          promise: geometryPromise
        };
        pending.push(geometryPromise);
      }
    }

    return Promise.all(pending);
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */


  GLTFParser.prototype.loadMesh = function (meshIndex) {
    var parser = this;
    var json = this.json;
    var meshDef = json.meshes[meshIndex];
    var primitives = meshDef.primitives;
    var pending = [];

    for (var i = 0, il = primitives.length; i < il; i++) {
      var material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i].material);
      pending.push(material);
    }

    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function (results) {
      var materials = results.slice(0, results.length - 1);
      var geometries = results[results.length - 1];
      var meshes = [];

      for (var i = 0, il = geometries.length; i < il; i++) {
        var geometry = geometries[i];
        var primitive = primitives[i]; // 1. create Mesh

        var mesh;
        var material = materials[i];

        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {
          // .isSkinnedMesh isn't in glTF spec. See .markDefs()
          mesh = meshDef.isSkinnedMesh === true ? new _three.SkinnedMesh(geometry, material) : new _three.Mesh(geometry, material);

          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
            // we normalize floating point skin weight array to fix malformed assets (see #15319)
            // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
            mesh.normalizeSkinWeights();
          }

          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, _three.TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, _three.TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new _three.LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new _three.Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new _three.LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new _three.Points(geometry, material);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }

        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }

        mesh.name = meshDef.name || "mesh_" + meshIndex;
        if (geometries.length > 1) mesh.name += "_" + i;
        assignExtrasToUserData(mesh, meshDef);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }

      if (meshes.length === 1) {
        return meshes[0];
      }

      var group = new _three.Group();

      for (var i = 0, il = meshes.length; i < il; i++) {
        group.add(meshes[i]);
      }

      return group;
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */


  GLTFParser.prototype.loadCamera = function (cameraIndex) {
    var camera;
    var cameraDef = this.json.cameras[cameraIndex];
    var params = cameraDef[cameraDef.type];

    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }

    if (cameraDef.type === "perspective") {
      camera = new _three.PerspectiveCamera(_three.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera = new _three.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }

    if (cameraDef.name) camera.name = cameraDef.name;
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Object>}
   */


  GLTFParser.prototype.loadSkin = function (skinIndex) {
    var skinDef = this.json.skins[skinIndex];
    var skinEntry = {
      joints: skinDef.joints
    };

    if (skinDef.inverseBindMatrices === undefined) {
      return Promise.resolve(skinEntry);
    }

    return this.getDependency("accessor", skinDef.inverseBindMatrices).then(function (accessor) {
      skinEntry.inverseBindMatrices = accessor;
      return skinEntry;
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */


  GLTFParser.prototype.loadAnimation = function (animationIndex) {
    var json = this.json;
    var animationDef = json.animations[animationIndex];
    var pendingNodes = [];
    var pendingInputAccessors = [];
    var pendingOutputAccessors = [];
    var pendingSamplers = [];
    var pendingTargets = [];

    for (var i = 0, il = animationDef.channels.length; i < il; i++) {
      var channel = animationDef.channels[i];
      var sampler = animationDef.samplers[channel.sampler];
      var target = channel.target;
      var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.

      var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;
      var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;
      pendingNodes.push(this.getDependency("node", name));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }

    return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {
      var nodes = dependencies[0];
      var inputAccessors = dependencies[1];
      var outputAccessors = dependencies[2];
      var samplers = dependencies[3];
      var targets = dependencies[4];
      var tracks = [];

      for (var i = 0, il = nodes.length; i < il; i++) {
        var node = nodes[i];
        var inputAccessor = inputAccessors[i];
        var outputAccessor = outputAccessors[i];
        var sampler = samplers[i];
        var target = targets[i];
        if (node === undefined) continue;
        node.updateMatrix();
        node.matrixAutoUpdate = true;
        var TypedKeyframeTrack;

        switch (PATH_PROPERTIES[target.path]) {
          case PATH_PROPERTIES.weights:
            TypedKeyframeTrack = _three.NumberKeyframeTrack;
            break;

          case PATH_PROPERTIES.rotation:
            TypedKeyframeTrack = _three.QuaternionKeyframeTrack;
            break;

          case PATH_PROPERTIES.position:
          case PATH_PROPERTIES.scale:
          default:
            TypedKeyframeTrack = _three.VectorKeyframeTrack;
            break;
        }

        var targetName = node.name ? node.name : node.uuid;
        var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : _three.InterpolateLinear;
        var targetNames = [];

        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
          // Node may be a Group (glTF mesh with several primitives) or a Mesh.
          node.traverse(function (object) {
            if (object.isMesh === true && object.morphTargetInfluences) {
              targetNames.push(object.name ? object.name : object.uuid);
            }
          });
        } else {
          targetNames.push(targetName);
        }

        var outputArray = outputAccessor.array;

        if (outputAccessor.normalized) {
          var scale;

          if (outputArray.constructor === Int8Array) {
            scale = 1 / 127;
          } else if (outputArray.constructor === Uint8Array) {
            scale = 1 / 255;
          } else if (outputArray.constructor == Int16Array) {
            scale = 1 / 32767;
          } else if (outputArray.constructor === Uint16Array) {
            scale = 1 / 65535;
          } else {
            throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");
          }

          var scaled = new Float32Array(outputArray.length);

          for (var j = 0, jl = outputArray.length; j < jl; j++) {
            scaled[j] = outputArray[j] * scale;
          }

          outputArray = scaled;
        }

        for (var j = 0, jl = targetNames.length; j < jl; j++) {
          var track = new TypedKeyframeTrack(targetNames[j] + "." + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation); // Override interpolation with custom factory method.

          if (sampler.interpolation === "CUBICSPLINE") {
            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
              // A CUBICSPLINE keyframe in glTF has three output values for each input value,
              // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
              // must be divided by three to get the interpolant's sampleSize argument.
              return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);
            }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.


            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
          }

          tracks.push(track);
        }
      }

      var name = animationDef.name ? animationDef.name : "animation_" + animationIndex;
      return new _three.AnimationClip(name, undefined, tracks);
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */


  GLTFParser.prototype.loadNode = function (nodeIndex) {
    var json = this.json;
    var extensions = this.extensions;
    var parser = this;
    var meshReferences = json.meshReferences;
    var meshUses = json.meshUses;
    var nodeDef = json.nodes[nodeIndex];
    return function () {
      var pending = [];

      if (nodeDef.mesh !== undefined) {
        pending.push(parser.getDependency("mesh", nodeDef.mesh).then(function (mesh) {
          var node;

          if (meshReferences[nodeDef.mesh] > 1) {
            var instanceNum = meshUses[nodeDef.mesh]++;
            node = mesh.clone();
            node.name += "_instance_" + instanceNum;
          } else {
            node = mesh;
          } // if weights are provided on the node, override weights on the mesh.


          if (nodeDef.weights !== undefined) {
            node.traverse(function (o) {
              if (!o.isMesh) return;

              for (var i = 0, il = nodeDef.weights.length; i < il; i++) {
                o.morphTargetInfluences[i] = nodeDef.weights[i];
              }
            });
          }

          return node;
        }));
      }

      if (nodeDef.camera !== undefined) {
        pending.push(parser.getDependency("camera", nodeDef.camera));
      }

      if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light !== undefined) {
        pending.push(parser.getDependency("light", nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light));
      }

      return Promise.all(pending);
    }().then(function (objects) {
      var node; // .isBone isn't in glTF spec. See .markDefs

      if (nodeDef.isBone === true) {
        node = new _three.Bone();
      } else if (objects.length > 1) {
        node = new _three.Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new _three.Object3D();
      }

      if (node !== objects[0]) {
        for (var i = 0, il = objects.length; i < il; i++) {
          node.add(objects[i]);
        }
      }

      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = _three.PropertyBinding.sanitizeNodeName(nodeDef.name);
      }

      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);

      if (nodeDef.matrix !== undefined) {
        var matrix = new _three.Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== undefined) {
          node.position.fromArray(nodeDef.translation);
        }

        if (nodeDef.rotation !== undefined) {
          node.quaternion.fromArray(nodeDef.rotation);
        }

        if (nodeDef.scale !== undefined) {
          node.scale.fromArray(nodeDef.scale);
        }
      }

      parser.associations.set(node, {
        type: "nodes",
        index: nodeIndex
      });
      return node;
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */


  GLTFParser.prototype.loadScene = function () {
    // scene node hierachy builder
    function buildNodeHierachy(nodeId, parentObject, json, parser) {
      var nodeDef = json.nodes[nodeId];
      return parser.getDependency("node", nodeId).then(function (node) {
        if (nodeDef.skin === undefined) return node; // build skeleton here as well

        var skinEntry;
        return parser.getDependency("skin", nodeDef.skin).then(function (skin) {
          skinEntry = skin;
          var pendingJoints = [];

          for (var i = 0, il = skinEntry.joints.length; i < il; i++) {
            pendingJoints.push(parser.getDependency("node", skinEntry.joints[i]));
          }

          return Promise.all(pendingJoints);
        }).then(function (jointNodes) {
          node.traverse(function (mesh) {
            if (!mesh.isMesh) return;
            var bones = [];
            var boneInverses = [];

            for (var j = 0, jl = jointNodes.length; j < jl; j++) {
              var jointNode = jointNodes[j];

              if (jointNode) {
                bones.push(jointNode);
                var mat = new _three.Matrix4();

                if (skinEntry.inverseBindMatrices !== undefined) {
                  mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
                }

                boneInverses.push(mat);
              } else {
                console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);
              }
            }

            mesh.bind(new _three.Skeleton(bones, boneInverses), mesh.matrixWorld);
          });
          return node;
        });
      }).then(function (node) {
        // build node hierachy
        parentObject.add(node);
        var pending = [];

        if (nodeDef.children) {
          var children = nodeDef.children;

          for (var i = 0, il = children.length; i < il; i++) {
            var child = children[i];
            pending.push(buildNodeHierachy(child, node, json, parser));
          }
        }

        return Promise.all(pending);
      });
    }

    return function loadScene(sceneIndex) {
      var json = this.json;
      var extensions = this.extensions;
      var sceneDef = this.json.scenes[sceneIndex];
      var parser = this; // Loader returns Group, not Scene.
      // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172

      var scene = new _three.Group();
      if (sceneDef.name) scene.name = sceneDef.name;
      assignExtrasToUserData(scene, sceneDef);
      if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
      var nodeIds = sceneDef.nodes || [];
      var pending = [];

      for (var i = 0, il = nodeIds.length; i < il; i++) {
        pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));
      }

      return Promise.all(pending).then(function () {
        return scene;
      });
    };
  }();

  return GLTFLoader;
}();

exports.GLTFLoader = GLTFLoader;

function fileLoad(url) {}
},{"./FetchFileLoader":"src/util/FetchFileLoader.js","three":"src/vendor/three.module.js","./addFrameTasks":"src/util/addFrameTasks.js"}],"src/systems/character/CharacterHead.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = CharacterHead;

var THREE = _interopRequireWildcard(require("three"));

var Tags = _interopRequireWildcard(require("../../tags"));

var _CapsuleBufferGeometry = _interopRequireDefault(require("../../util/CapsuleBufferGeometry"));

var MathUtil = _interopRequireWildcard(require("../../util/math"));

var ShaderManager = _interopRequireWildcard(require("../../util/ShaderManager"));

var _GLTFLoader = require("../../util/GLTFLoader");

var _math2 = require("canvas-sketch-util/math");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import hatTexUrl from "../../assets/textures/hat_color.jpg";
// import hatModelURL from "../../assets/gltf/hat.gltf";
const NOOP = () => {};

const texLoader = new THREE.TextureLoader();

function loadTexture(url) {
  return new Promise((resolve, reject) => {
    texLoader.load(url, // ok
    texture => {
      resolve(texture);
    }, // progress
    NOOP, // ko
    evt => {
      reject(evt);
    });
  });
}

function CharacterHead() {
  const group = new THREE.Group();
  const radius = 0.24;
  const gap = 0.2;
  const irisRadius = radius * 0.55;
  const pupilRadius = irisRadius * 0.95;
  const noseScale = 0.1 / radius;
  const noseThick = 0.5;
  const noseLen = 1;
  const capsule = new THREE.Geometry().fromBufferGeometry(new _CapsuleBufferGeometry.default(noseThick, noseThick, noseLen, 5, 5, 5, 5));
  capsule.mergeVertices();
  capsule.rotateX(Math.PI / 2);
  capsule.rotateY(Math.PI / 2);
  capsule.scale(noseScale, noseScale, noseScale);
  capsule.translate(noseLen / 2 + 1 / 2 - noseLen / 8, 0, -noseThick);
  const basic = new THREE.MeshBasicMaterial({
    color: "black"
  });
  const circleGeom = new THREE.CircleGeometry(1, 16);
  circleGeom.merge(capsule, new THREE.Matrix4(), 1);
  const faceShader = ShaderManager.create({
    // wireframe: true,
    vertexShader:
    /*glsl*/
    `
      varying vec2 vUv;
      void main () {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
      }
    `,
    name: "character-face",
    fragmentShader:
    /*glsl*/
    `
      varying vec2 vUv;
      void main () {
        vec2 q = vec2(vUv - 0.5);
        float d = length(q);
        float circ = 1.0 - step(0.25, d);
        vec2 q2 = q - vec2(0.25, 0.0);
        float d2 = length(q2);
        circ *= step(0.25, d2);
        gl_FragColor = vec4(vec3(circ), 1.0);
      }
    `
  });
  const noseMat = new THREE.MeshBasicMaterial({
    color: "black"
  });
  const circle = new THREE.Mesh(circleGeom, [faceShader, noseMat]);
  const iris = new THREE.Mesh(circleGeom, new THREE.MeshBasicMaterial({
    color: "white",
    transparent: true
  }));
  const pupil = new THREE.Mesh(circleGeom, new THREE.MeshBasicMaterial({
    color: "black",
    transparent: true
  }));
  circle.scale.setScalar(radius);
  iris.scale.setScalar(irisRadius);
  pupil.scale.setScalar(irisRadius);
  group.add(circle); // group.add(iris);
  // group.add(pupil);

  group.position.y = 1 + radius + gap;
  const dir = new THREE.Vector3();
  const nose = new THREE.Mesh(capsule, basic);
  const noseGroup = new THREE.Group(); // noseGroup.add(nose);
  // nose.position.x =
  //   (noseLen / 2) * noseScale + radius - (noseLen / 4) * noseScale;
  // nose.scale.setScalar(noseScale);
  // group.add(noseGroup);

  const coneScale = 0.1;
  const coneHeight = 0.75;
  const cone = new THREE.CylinderBufferGeometry(0.025, radius * 1.15, coneHeight, 16, 1);
  cone.translate(0, coneHeight / 2, 0);
  const hatAnchor = new THREE.Group();
  const hatMaterial = ShaderManager.create({
    name: "character-hat",
    uniforms: {
      color: {
        value: new THREE.Color("#de4d26")
      },
      tMap: {
        value: new THREE.Texture()
      }
    },
    vertexShader:
    /*glsl*/
    `
    varying vec2 vUv;
    varying vec3 vNormal;
    varying vec3 vViewPoisition;
    void main () {
      vUv = uv;
      vNormal = normalMatrix * normal;
      vec4 worldPos = modelMatrix * vec4(position.xyz, 1.0);
      vec4 vpos = viewMatrix * vec4(worldPos.xyz, 1.0);
      vViewPoisition = -vpos.xyz;
      gl_Position = projectionMatrix * vpos;
    }
  `,
    fragmentShader:
    /*glsl*/
    `
    varying vec2 vUv;
    varying vec3 vViewPoisition;
    varying vec3 vNormal;
    uniform vec3 color;
    uniform sampler2D tMap;
    void main () {
      float rim = clamp(dot(normalize(vViewPoisition), vNormal), 0.0, 1.0);
      // rim = step(0.5, rim);

      vec3 cMap = texture2D(tMap, vUv).rgb;

      vec3 outColor = color;
      // outColor = mix(color * 0.85, color, rim);
      gl_FragColor = vec4(outColor, 1.0);
    }
  `
  });
  const hat = new THREE.Mesh(cone, hatMaterial); // let hat = null
  // const manager = new THREE.LoadingManager();
  // const gltfLoader = new GLTFLoader(manager);
  // // const hatTex = await loadTexture(hatTexUrl)
  // // console.log(hatTex)
  // gltfLoader.load(hatModelURL, function (_gltf) {
  //   hat = _gltf.scene.children[0];
  //   hat.scale.setScalar(.265)
  //   // hat.position.x -= .12
  //   hat.position.y = .35
  //   hat.rotateY(Math.PI*.5)
  //   // hat.rotateZ(-Math.PI*.1)
  //   hat.material = hatMaterial
  //   loadTexture(hatTexUrl)
  //     .then( (tex) => {
  //       hatMaterial.uniforms.tMap.value = tex
  //     } )
  //   // // setup material
  //   // hat.scene.traverse((child) => {
  //   //   if (child.type == "Mesh") {
  //   //     console.log(child)
  //   //   }
  //   // });
  //   hatAnchor.add(hat);
  // });

  group.add(hatAnchor);
  hatAnchor.add(hat);
  const tmpMatA = new THREE.Matrix4();
  const tmpMatB = new THREE.Matrix4();
  return {
    group,

    getScarfAnchor(position) {
      group.localToWorld(position.set(0, -radius, 0));
      return position;
    },

    getHatTipPoint(position) {
      if (!hat) return hatAnchor.position;
      hat.localToWorld(position.set(0, coneHeight, 0));
      return position;
    },

    update(dt, camera, lookAngle, speed, up, right, forward) {
      dir.set(Math.cos(lookAngle), 0, Math.sin(lookAngle));
      circle.position.set(0, 0, 0).addScaledVector(dir, speed * 0.1); // hat.position.y += radius - 0.1;

      iris.position.copy(circle.position);
      iris.position.addScaledVector(forward, -irisRadius / 2);
      pupil.position.copy(iris.position);
      pupil.position.addScaledVector(forward, -irisRadius);
      const side = dir.dot(right) < 0 ? -1 : 1;
      pupil.position.addScaledVector(right, irisRadius * side);
      circle.quaternion.copy(camera.quaternion);
      circle.scale.x = radius * side;
      iris.quaternion.copy(circle.quaternion);
      pupil.quaternion.copy(circle.quaternion); // hat.position.copy(circle.position);

      const deg = MathUtil.lerp(5, 70, speed);
      const mat = tmpMatA.identity();
      mat.multiply(tmpMatB.makeTranslation(circle.position.x, circle.position.y + 0.0, circle.position.z));
      mat.multiply(tmpMatB.makeRotationY(lookAngle)); // mat.multiply(tmpMatB.makeTranslation(0, radius, 0));

      mat.multiply(tmpMatB.makeRotationZ(MathUtil.degToRad(deg)));
      mat.multiply(tmpMatB.makeTranslation(0, 0.075, 0));
      hatAnchor.matrixAutoUpdate = false;
      hatAnchor.matrix.identity();
      hatAnchor.applyMatrix4(mat);
      hatAnchor.matrixAutoUpdate = true; // if (hat) {
      //   // hat.position.x = mapRange(speed, 0, .7, -.12, -.08)
      //   hat.position.y = mapRange(speed, 0, .7, .35, .27)
      // }
      // hatAnchor.rotation.y = lookAngle;
      // hatAnchor.rotation.z = MathUtil.degToRad(deg);
      // const noff =
      //   (noseLen / 2) * noseScale + radius - (noseLen / 4) * noseScale;
      // nose.position.x = 0 + noff * side;
      // nose.position.addScaledVector(forward, -radius / 4);
      // noseGroup.rotation.y = lookAngle;
    }

  };
}
},{"three":"src/vendor/three.module.js","../../tags":"src/tags/index.js","../../util/CapsuleBufferGeometry":"src/util/CapsuleBufferGeometry.js","../../util/math":"src/util/math.js","../../util/ShaderManager":"src/util/ShaderManager.js","../../util/GLTFLoader":"src/util/GLTFLoader.js","canvas-sketch-util/math":"node_modules/canvas-sketch-util/math.js"}],"src/util/ModCylinderGeometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CylinderGeometry = CylinderGeometry;
exports.CylinderBufferGeometry = CylinderBufferGeometry;

var _three = require("three");

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */
// CylinderGeometry
function CylinderGeometry({
  radiusTop,
  radiusBottom,
  height,
  radialSegments,
  heightSegments,
  openBottom,
  openTop,
  thetaStart,
  thetaLength
}) {
  _three.Geometry.call(this);

  this.type = "CylinderGeometry";
  this.parameters = {
    radiusTop: radiusTop,
    radiusBottom: radiusBottom,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openTop: openTop,
    openBottom: openBottom,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  this.fromBufferGeometry(new CylinderBufferGeometry({
    radiusTop,
    radiusBottom,
    height,
    radialSegments,
    heightSegments,
    openTop,
    openBottom,
    thetaStart,
    thetaLength
  }));
  this.mergeVertices();
}

CylinderGeometry.prototype = Object.create(_three.Geometry.prototype);
CylinderGeometry.prototype.constructor = CylinderGeometry; // CylinderBufferGeometry

function CylinderBufferGeometry({
  radiusTop,
  radiusBottom,
  height,
  radialSegments,
  heightSegments,
  openTop,
  openBottom,
  thetaStart,
  thetaLength
}) {
  _three.BufferGeometry.call(this);

  this.type = "CylinderBufferGeometry";
  this.parameters = {
    radiusTop: radiusTop,
    radiusBottom: radiusBottom,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openBottom: openBottom,
    openTop: openTop,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };
  const scope = this;
  radiusTop = radiusTop !== undefined ? radiusTop : 1;
  radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
  height = height || 1;
  radialSegments = Math.floor(radialSegments) || 8;
  heightSegments = Math.floor(heightSegments) || 1;
  openTop = openTop !== undefined ? openTop : false;
  openBottom = openBottom !== undefined ? openBottom : false;
  thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2; // buffers

  const indices = [];
  const angles = [];
  const vertices = [];
  const normals = [];
  const uvs = [];
  const capState = []; // helper variables

  let index = 0;
  const indexArray = [];
  const halfHeight = height / 2;
  let groupStart = 0; // generate geometry

  generateTorso();
  if (openTop === false && radiusTop > 0) generateCap(true);
  if (openBottom === false && radiusBottom > 0) generateCap(false); // build geometry

  this.setIndex(indices);
  this.setAttribute("position", new _three.Float32BufferAttribute(vertices, 3));
  this.setAttribute("normal", new _three.Float32BufferAttribute(normals, 3));
  this.setAttribute("uv", new _three.Float32BufferAttribute(uvs, 2));
  this.setAttribute("capState", new _three.Float32BufferAttribute(capState, 1));
  this.setAttribute("vertexAngle", new _three.Float32BufferAttribute(angles, 1));

  function generateTorso() {
    const normal = new _three.Vector3();
    const vertex = new _three.Vector3();
    let groupCount = 0; // this will be used to calculate the normal

    const slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs

    for (let y = 0; y <= heightSegments; y++) {
      const indexRow = [];
      const v = y / heightSegments; // calculate the radius of the current row

      const radius = v * (radiusBottom - radiusTop) + radiusTop;

      for (let x = 0; x <= radialSegments; x++) {
        const u = x / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta); // vertex

        vertex.x = radius * sinTheta;
        vertex.y = -v * height + halfHeight;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z);
        angles.push(x / (radialSegments + 1) * thetaLength + thetaStart); // normal

        normal.set(sinTheta, slope, cosTheta).normalize();
        normals.push(normal.x, normal.y, normal.z); // uv

        uvs.push(u, 1 - v);
        capState.push(0); // save index of vertex in respective row

        indexRow.push(index++);
      } // now save vertices of the row in our index array


      indexArray.push(indexRow);
    } // generate indices


    for (let x = 0; x < radialSegments; x++) {
      for (let y = 0; y < heightSegments; y++) {
        // we use the index array to access the correct indices
        const a = indexArray[y][x];
        const b = indexArray[y + 1][x];
        const c = indexArray[y + 1][x + 1];
        const d = indexArray[y][x + 1]; // faces

        indices.push(a, b, d);
        indices.push(b, c, d); // update group counter

        groupCount += 6;
      }
    } // add a group to the geometry. this will ensure multi material support


    scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups

    groupStart += groupCount;
  }

  function generateCap(top) {
    let centerIndexStart, centerIndexEnd;
    const uv = new _three.Vector2();
    const vertex = new _three.Vector3();
    let groupCount = 0;
    const radius = top === true ? radiusTop : radiusBottom;
    const sign = top === true ? 1 : -1; // save the index of the first center vertex

    centerIndexStart = index; // first we generate the center vertex data of the cap.
    // because the geometry needs one set of uvs per face,
    // we must generate a center vertex per face/segment

    for (let x = 1; x <= radialSegments; x++) {
      // vertex
      vertices.push(0, halfHeight * sign, 0); // normal

      normals.push(0, sign, 0); // uv

      uvs.push(0.5, 0.5);
      capState.push(sign);
      angles.push(x / (radialSegments + 1) * thetaLength + thetaStart); // increase index

      index++;
    } // save the index of the last center vertex


    centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs

    for (let x = 0; x <= radialSegments; x++) {
      const u = x / radialSegments;
      const theta = u * thetaLength + thetaStart;
      const cosTheta = Math.cos(theta);
      const sinTheta = Math.sin(theta); // vertex

      vertex.x = radius * sinTheta;
      vertex.y = halfHeight * sign;
      vertex.z = radius * cosTheta;
      vertices.push(vertex.x, vertex.y, vertex.z); // normal

      normals.push(0, sign, 0); // uv

      uv.x = cosTheta * 0.5 + 0.5;
      uv.y = sinTheta * 0.5 * sign + 0.5;
      uvs.push(uv.x, uv.y);
      capState.push(sign);
      angles.push(x / (radialSegments + 1) * thetaLength + thetaStart); // increase index

      index++;
    } // generate indices


    for (let x = 0; x < radialSegments; x++) {
      const c = centerIndexStart + x;
      const i = centerIndexEnd + x;

      if (top === true) {
        // face top
        indices.push(i, i + 1, c);
      } else {
        // face bottom
        indices.push(i + 1, i, c);
      }

      groupCount += 3;
    } // add a group to the geometry. this will ensure multi material support


    scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups

    groupStart += groupCount;
  }
}

CylinderBufferGeometry.prototype = Object.create(_three.BufferGeometry.prototype);
CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
},{"three":"src/vendor/three.module.js"}],"src/systems/character/CapeMesh.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = CapeMesh;

var THREE = _interopRequireWildcard(require("three"));

var MathUtil = _interopRequireWildcard(require("../../util/math"));

var ShaderManager = _interopRequireWildcard(require("../../util/ShaderManager"));

var _AnimationSystem = require("../AnimationSystem");

var _tweenTicker = _interopRequireDefault(require("../../util/tween-ticker"));

var _ModCylinderGeometry = require("../../util/ModCylinderGeometry");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function CapeMesh(world, {
  map
}) {
  const radiusBottom = 0.8;
  const radiusTop = 0.15;
  const height = 1; // needs to be one !! for the shader

  const radialSegments = 32;
  const user = world.findTag(Tags.UserCharacter);
  const geometry = new _ModCylinderGeometry.CylinderBufferGeometry({
    radiusTop,
    radiusBottom,
    height,
    radialSegments,
    heightSegments: 8,
    openTop: false,
    openBottom: false
  }); // const geometry = new THREE.CylinderGeometry(
  //   radiusTop,
  //   radiusBottom,
  //   height,
  //   radialSegments,
  //   2
  // );

  geometry.translate(0, height / 2, 0); // const rot = new THREE.Matrix4().makeRotationZ(MathUtil.degToRad(45 / 4));
  // geometry.vertices.forEach((v) => {
  //   if (v.y > 0) {
  //     // v.applyMatrix4(rot);
  //   } else {
  //     // v.x -= 0.25;
  //   }
  // });

  const material = ShaderManager.create({
    // wireframe: true,
    uniforms: {
      cap: {
        value: true,
        type: "b"
      },
      color: {
        value: new THREE.Color("#de4d26")
      },
      overlayColor: {
        value: new THREE.Color("#f7eaaf")
      },
      opacity: {
        value: 1
      },
      ripple: {
        value: 0
      },
      rotationAngle: {
        value: 0
      },
      map: {
        value: map
      },
      mapScale: {
        value: new THREE.Vector2().setScalar(0.75)
      },
      mapOffset: {
        value: new THREE.Vector2(0.45, 0.5)
      },
      coneHeight: {
        value: height
      },
      tilt: {
        value: 0
      },
      magicalEffect: {
        value: 0
      },
      stroke: {
        value: false,
        type: "b"
      },
      elapsed: {
        value: 0
      },
      glowIntensity: {
        value: 1
      },
      glowIntensity2: {
        value: 1
      }
    },
    name: "cape-mesh",
    extensions: {
      derivatives: true
    },
    side: THREE.DoubleSide,
    // wireframe: true,
    fragmentShader:
    /*glsl*/
    `
      #include <common>
      uniform vec3 color;
      uniform vec3 overlayColor;
      uniform float opacity;
      uniform sampler2D map;
      uniform float magicalEffect;
      uniform float glowIntensity;
      uniform float glowIntensity2;
      varying float vConeY;
      varying vec2 vUv;
      varying vec3 vNormal;
      varying float vAngle;
      varying float vCap;
      varying vec2 vScreenUv;
      uniform bool stroke;
      varying vec3 vViewPoisition;

      vec4 tex2DConstScale(sampler2D tex, float texSize, vec2 uv)
      {
        // uv.x *= aspect;
        // uv.xy *= spriteHeight;
        vec2 offset = vec2(0.0, 0.0);
        // Find the discretized derivatives of our coordinates
        float maxDeriv = max(length(dFdx(uv)), length(dFdy(uv)));
        float pixScale = 1.0 / (texSize * maxDeriv);
        // Find two nearest log-discretized noise scales
        vec2 pixScales = vec2(
          exp2(floor(log2(pixScale))),
          exp2(ceil(log2(pixScale)))
        );
        // Factor to interpolate lerp with
        float lerpFactor = fract(log2(pixScale));

        float scale = 0.1;
        return mix(
          texture2D(tex, pixScales.x * scale * uv + offset),
          texture2D(tex, pixScales.y * scale * uv + offset),
          lerpFactor
        );
      }

      void main () {
        float L = texture2D(map, vUv).r * glowIntensity;

        float rim = clamp(dot(normalize(vViewPoisition), vNormal), 0.0, 1.0);
        rim = step(0.5, rim);
        vec3 curOverlay = overlayColor + 0.75;
        
        // float L = tex2DConstScale(map, 256.0, vUv).r;
        if (vCap > 0.5) {
          gl_FragColor = vec4(color, opacity);
        } else {
          float edges = step(0.045, vConeY);
          // float edges = clamp(step(0.05, vConeY) * step(vConeY, 1.0 - 0.05), 0.0, 1.0);

          vec3 outColor = mix(color, overlayColor, L) * glowIntensity2;
          outColor = mix(vec3(magicalEffect), outColor, edges);
          // outColor.rgb = mix(outColor * 0.85, outColor, vec3(rim));

          // outColor = mix(outColor, outColor * 0.75, pow(1.0 - vConeY, 1.5));


          // gl_FragColor = vec4(vec3(edges), 1.0);
          gl_FragColor = vec4(outColor, opacity);
        }
        if (stroke) {
          gl_FragColor.rgb = vec3(0.0);
        }
        // gl_FragColor.rgb += vCap;
        // gl_FragColor.a = 1.0;
      }
    `,
    vertexShader:
    /*glsl*/
    `
      #include <common>
      attribute float capState;
      attribute float vertexAngle;
      uniform float tilt;
      uniform float ripple;
      uniform bool stroke;
      uniform float elapsed;
      uniform float coneHeight;
      varying float vAngle;
      uniform vec2 mapScale;
      uniform vec2 mapOffset;
      uniform float rotationAngle;
      varying vec2 vScreenUv;
      varying vec2 vUv;
      varying vec3 vNormal;
      varying float vCap;
      varying float vConeY;
      varying vec3 vViewPoisition;

      void main () {
        vUv = mapOffset + uv * mapScale;
        vCap = capState;
        vec3 transformed = position.xyz;

        
        float rippleTime = 0.0;

        vec3 centerWorldPos = (modelMatrix * vec4(vec3(0.0), 1.0)).xyz;
        vec3 camRightWorld = vec3(viewMatrix[0].x, viewMatrix[1].x, viewMatrix[2].x);
        vec3 camUpWorld = vec3(viewMatrix[0].y, viewMatrix[1].y, viewMatrix[2].y);

        vec2 scale;
        scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
        scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

        vec3 vertexWorldPos = centerWorldPos;

        float coneYAlpha = position.y / coneHeight;
        vec2 norm = normalize(transformed.xz);
        float coneAngle = atan(norm.y, norm.x);
        float tAngle = (coneAngle + PI) / (PI * 2.0);
        vAngle = coneAngle;
        float coneYStrength = smoothstep(0.5, 0.0, coneYAlpha);

        vConeY = coneYAlpha;

        if (capState < 0.5) {
          vec3 targetPoint = vec3(0.0, coneHeight, 0.0);
          vec3 targetDir = normalize(position.xyz - targetPoint);

          float time = ripple * PI * 2.0;
          float rippleFreq = PI * 2.0 * 0.5;
          float rippleAmp = 0.1;
          transformed.xz += norm * cos(coneAngle * 5.0 + elapsed) * 0.1 * pow(1.0 - coneYAlpha, 5.0);
          transformed.xyz += targetDir * (sin(coneAngle * rippleFreq + time)) * rippleAmp * coneYStrength;
        }
        transformed.xyz += tilt * vec3(-1.0, 0.0, 0.0) * (1.0 - pow(coneYAlpha, 0.85));


        if (stroke) {
          // transformed.xyz *= 1.1;
          // transformed.xyz += normal.xyz * 0.2;
          // transformed.y -= 0.1;
        }
        
        // if (capState < -0.5) {
        //   transformed.y -= 0.1;
        // }
        vNormal = normalMatrix * normal;
        vec3 worldPos = (modelMatrix * vec4(transformed.xyz, 1.0)).xyz;
        // vec3 moveDir = vec3(cos(rotationAngle), 0.0, sin(rotationAngle));
        // worldPos -= moveDir * tilt * 4.0;
        vec4 vpos = viewMatrix * vec4(worldPos, 1.0);
        vViewPoisition = -vpos.xyz;

        gl_Position = projectionMatrix * vpos;
        vec4 spritePos = projectionMatrix * viewMatrix * vec4(vertexWorldPos, 1.0);
        vScreenUv = (gl_Position.xy / gl_Position.w * 0.5 + 0.5);
        vScreenUv.x -= spritePos.x / spritePos.w * 0.5 + 0.5;
        vScreenUv.y -= spritePos.y / spritePos.w * 0.5 + 0.5;
        vScreenUv = vScreenUv * 12.0;
        // vScreenUv.x -= rotationAngle;
      }
    `
  });
  const mesh = new THREE.Mesh(geometry, material); // mesh.scale.setScalar(0.6);
  // mesh.scale.y *= 1.4;
  // const stroke = mesh.clone();
  // stroke.material = stroke.material.clone();
  // stroke.material.uniforms = THREE.UniformsUtils.clone(
  //   stroke.material.uniforms
  // );
  // // stroke.material.depthTest = false;
  // // stroke.material.depthWrite = false;
  // stroke.material.uniforms.stroke.value = true;
  // // stroke.renderOrder = 1;
  // // mesh.renderOrder = 2;
  // stroke.material.side = THREE.BackSide;

  const anchor = new THREE.Group();
  anchor.add(mesh); // anchor.add(stroke);
  // const effects = world.listen(Tags.CapeMagicalEffect);
  // const effectsOff = world.listen(Tags.CapeMagicalEffectPersisted);
  // const effectInTween = world.entity();
  // const effectOutTween = world.entity();

  const effectView = world.view(Tags.CapeMagicalEffect);
  const autoRemoveEffects = world.view(Tags.AutoRemoveCapeMagicalEffect);
  const timeline = (0, _tweenTicker.default)();
  let magicState = {
    enabled: false,
    value: 0
  };
  const outroState = world.view(Tags.FinalBiomeResolution); // const animateOutMagic = (delay = 2) => {
  //   effectInTween.remove(Tags.TargetKeyTween);
  //   effectOutTween.remove(Tags.TargetKeyTween);
  //   setEntityTweenFromTo(
  //     effectOutTween,
  //     material.uniforms.magicalEffect,
  //     "value",
  //     material.uniforms.magicalEffect.value,
  //     0,
  //     2,
  //     "sineOut",
  //     delay
  //   );
  //   const t1 = effectOutTween.get(Tags.TargetKeyTween);
  //   t1.killEntityOnFinish = false;
  //   t1.assignFromOnStart = true;
  // };
  // const meshes = [mesh];

  return {
    group: anchor,

    update(dt, camera, lookAngle, speed) {
      timeline.tick(dt);
      autoRemoveEffects.forEach(e => {
        const d = e.get(Tags.AutoRemoveCapeMagicalEffect);
        d.elapsed += dt;

        if (d.elapsed >= d.delay) {
          e.tagOff(Tags.CapeMagicalEffect);
          e.tagOff(Tags.AutoRemoveCapeMagicalEffect);
        }
      }); // meshes.forEach((mesh) => {

      mesh.rotation.y = lookAngle; // const material = mesh.material;

      material.uniforms.tilt.value = speed * 1.15;
      material.uniforms.rotationAngle.value = lookAngle;
      material.uniforms.elapsed.value += dt;
      material.uniforms.glowIntensity.value = user.glowIntensity;
      material.uniforms.glowIntensity2.value = user.glowIntensity2;

      if (user.capeSpeed > 0) {
        material.uniforms.ripple.value += dt * user.capeSpeed;
      } else {
        material.uniforms.ripple.value += dt * MathUtil.lerp(0.2, 2, speed);
      } // });
      // if (effects.added.length > 0) {
      //   effectInTween.remove(Tags.TargetKeyTween);
      //   effectOutTween.remove(Tags.TargetKeyTween);
      //   setEntityTweenFromTo(
      //     effectInTween,
      //     material.uniforms.magicalEffect,
      //     "value",
      //     material.uniforms.magicalEffect.value,
      //     4,
      //     1,
      //     "sineOut",
      //     0
      //   );
      //   const t0 = effectInTween.get(Tags.TargetKeyTween);
      //   t0.killEntityOnFinish = false;
      //   t0.assignFromOnStart = true;
      //   const cur = effects.added[0];
      //   if (!cur.has(Tags.CapeMagicalEffectPersisted)) {
      //     animateOutMagic();
      //   }
      // } else if (effectsOff.removing.length > 0) {
      //   animateOutMagic(0);
      // }


      const hasMagic = outroState.length > 0 || effectView.length > 0 || world.findTag(Tags.DirectUserToOrigin);

      if (magicState.enabled !== hasMagic) {
        timeline.cancel().to(magicState, {
          value: hasMagic ? 4 : 0,
          duration: hasMagic ? 1 : 2,
          ease: "sineOut" // delay: hasMagic ? 0 : 2,

        });
        magicState.enabled = hasMagic;
      } // if (outroState.length > 0) {
      //   material.uniforms.magicalEffect.value = user.magicalEffect;
      // } else {


      material.uniforms.magicalEffect.value = magicState.value; // }
      // material.uniforms.magicalEffect.value = ;
    }

  };
}
},{"three":"src/vendor/three.module.js","../../util/math":"src/util/math.js","../../util/ShaderManager":"src/util/ShaderManager.js","../AnimationSystem":"src/systems/AnimationSystem.js","../../util/tween-ticker":"src/util/tween-ticker.js","../../util/ModCylinderGeometry":"src/util/ModCylinderGeometry.js"}],"src/systems/character/CharacterLegs.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = CharacterLegs;

var THREE = _interopRequireWildcard(require("three"));

var MathUtil = _interopRequireWildcard(require("../../util/math"));

var ShaderManager = _interopRequireWildcard(require("../../util/ShaderManager"));

var _ModCylinderGeometry = require("../../util/ModCylinderGeometry");

var _math2 = require("canvas-sketch-util/math");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function CharacterLegs() {
  const thickness = 0.75;
  const radiusBottom = 0.03 * thickness;
  const radiusTop = 0.15 * thickness;
  const height = 1; // needs to be one !! for the shader

  const radialSegments = 4;
  const geometry = new _ModCylinderGeometry.CylinderBufferGeometry({
    radiusTop,
    radiusBottom,
    height,
    radialSegments,
    heightSegments: 16,
    openTop: false,
    openBottom: false
  });
  geometry.translate(0, height / 2, 0);
  const material = ShaderManager.create({
    name: "legsShader",
    uniforms: {
      uTime: {
        value: 0
      },
      uTiltAngle: {
        value: 0
      },
      noiseScale: {
        value: 0
      },
      uBendScale: {
        value: 0
      }
    },
    vertexShader:
    /*glsl*/
    `
      uniform float uTime;
      uniform float uBendScale;
      uniform float uTiltAngle;
      uniform float noiseScale;
      varying vec2 vUv;
      mat3 rotation3dX(float angle) {
      	float s = sin(angle);
      	float c = cos(angle);

      	return mat3(
      		1.0, 0.0, 0.0,
      		0.0, c, s,
      		0.0, -s, c
      	);
      }
      mat3 rotation3dZ(float angle) {
      	float s = sin(angle);
      	float c = cos(angle);

      	return mat3(
      		c, s, 0.0,
      		-s, c, 0.0,
      		0.0, 0.0, 1.0
      	);
      }

      void main() {

        vec4 worldPos = modelViewMatrix * vec4(position, 1.0);

        float p = sin( uTime * 0.5 + worldPos.x * 1. ) * noiseScale;
        float bendScale = sin(uTime) * 0.5 + 0.5;
        float bendTgt = .3 + p;
        float bendInfluence = 1. - pow(1.0 - position.y, 4.);
        float bending = bendTgt * bendInfluence * uBendScale;


        vec3 bendPos = position.xyz;
        bendPos.y -= 1.0;
        bendPos.x -= bending;
        bendPos = rotation3dZ(uTiltAngle) * bendPos;
        bendPos.y += 1.0;

        // vec3 bendPos = vec3(position.x - bending, position.y, position.z);



        gl_Position = projectionMatrix * modelViewMatrix * vec4(bendPos, 1.0);

        vUv = uv;
      }
    `,
    fragmentShader:
    /*glsl*/
    `
      varying vec2 vUv;
      void main() {
        gl_FragColor = vec4(0., 0.,0.,1.);
      }
    `
  });
  const spaceBetweenLegs = 0.4;
  const meshLeft = new THREE.Mesh(geometry, material);
  const legRot = 0; // Math.PI * 0.2;

  const minShift = -0.2;
  const maxShift = -0.5;
  meshLeft.rotateY(Math.PI);
  meshLeft.rotateZ(legRot);
  meshLeft.position.z -= spaceBetweenLegs / 2;
  const meshRight = new THREE.Mesh(geometry, material);
  meshRight.rotateY(Math.PI);
  meshRight.rotateZ(legRot);
  meshRight.position.z += spaceBetweenLegs / 2;
  const anchor = new THREE.Group();
  const pivot = new THREE.Group();
  pivot.add(meshLeft);
  pivot.add(meshRight);
  anchor.add(pivot);
  anchor.scale.setScalar(1);
  const rotAxis = new THREE.Vector3(0, 1, 0);
  const zAxis = new THREE.Vector3(1, 0, 0);
  const meshes = [meshLeft, meshRight];
  return {
    group: anchor,

    update(dt, camera, lookAngle, speed) {
      meshes.forEach((mesh, idx) => {
        material.uniforms.uTime.value += dt;
        material.uniforms.noiseScale.value = (0, _math2.mapRange)(speed, 0, 0.7, 0.0, 0.2);
        material.uniforms.uTiltAngle.value = (0, _math2.mapRange)(speed, 0, 0.7, 0.0, 30 * Math.PI / 180);
        mesh.position.x = (0, _math2.mapRange)(speed, 0, 0.7, minShift, maxShift);
        material.uniforms.uBendScale.value = (0, _math2.mapRange)(speed, 0, 0.7, 0.1, 0.5);
      });
      anchor.setRotationFromAxisAngle(rotAxis, lookAngle);
    }

  };
}
},{"three":"src/vendor/three.module.js","../../util/math":"src/util/math.js","../../util/ShaderManager":"src/util/ShaderManager.js","../../util/ModCylinderGeometry":"src/util/ModCylinderGeometry.js","canvas-sketch-util/math":"node_modules/canvas-sketch-util/math.js"}],"src/systems/character/CharacterModel.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = CharacterModel;

var THREE = _interopRequireWildcard(require("three"));

var Tags = _interopRequireWildcard(require("../../tags"));

var _CapsuleBufferGeometry = _interopRequireDefault(require("../../util/CapsuleBufferGeometry"));

var MathUtil = _interopRequireWildcard(require("../../util/math"));

var ShaderManager = _interopRequireWildcard(require("../../util/ShaderManager"));

var _CharacterHead = _interopRequireDefault(require("./CharacterHead"));

var _CapeMesh = _interopRequireDefault(require("./CapeMesh"));

var _CharacterLegs = _interopRequireDefault(require("./CharacterLegs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function CharacterModel(world, {
  capeMap,
  blobShadowMap
}) {
  const renderLayers = world.findTag(Tags.RenderLayers);
  const char = world.findTag(Tags.UserCharacter);
  const group = new THREE.Group();
  const characterScale = 1.25;
  const container = new THREE.Group();
  group.add(container);
  const origin = new THREE.Vector3();
  const arrow = new THREE.ArrowHelper(new THREE.Vector3(), new THREE.Vector3()); // group.add(sphere);

  const tmpDir = new THREE.Vector3(0, 0, 1);
  const cape = (0, _CapeMesh.default)(world, {
    map: capeMap
  });
  const head = (0, _CharacterHead.default)();
  const legs = (0, _CharacterLegs.default)();
  const shadow = new THREE.Sprite(new THREE.SpriteMaterial({
    map: blobShadowMap,
    depthTest: false,
    depthWrite: false,
    // blending: THREE.MultiplyBlending,
    color: "hsl(0, 0%, 0%)",
    opacity: 0.15,
    transparent: true
  }));
  shadow.scale.set(2, 1, 1).multiplyScalar(1);
  shadow.layers.disableAll();
  shadow.layers.enable(renderLayers.shadow);
  const shadowContainer = new THREE.Group();
  shadowContainer.add(shadow);
  group.add(shadowContainer);
  container.add(cape.group);
  container.add(head.group);
  container.add(legs.group);
  arrow.setDirection(tmpDir);
  const legOffset = 0.8;
  cape.group.position.y += legOffset;
  head.group.position.y += legOffset;
  legs.group.position.y = 0.155;
  const capeOriginPosY = cape.group.position.y;
  const headOriginPosY = head.group.position.y;
  const legsOriginPosY = legs.group.position.y;
  container.scale.multiplyScalar(0.8); // 0.7
  // container.scale.y *= 1.4;
  // container.add(arrow);

  const camUpWorld = new THREE.Vector3();
  const camRightWorld = new THREE.Vector3();
  const camFrowardWorld = new THREE.Vector3();
  const camera = world.findTag(Tags.MainCamera);
  let lift = 0.5;
  let targetLift = 1;
  let time = 0;
  let float = 0;
  let capeAngle = null;
  let lastAngleTarget = null;
  return {
    scale: 1,

    getHatTipPoint(position) {
      return head.getHatTipPoint(position);
    },

    getScarfAnchor(position) {
      return head.getScarfAnchor(position);
    },

    group,

    update(dt, char, target, spring, moveToOrigin) {
      time += dt;
      const position = char.position;
      const velocity = char.velocity;
      const direction = char.direction;
      const velLength = velocity.length();
      const relVelLength = MathUtil.clamp01(velLength / 0.2);
      let capeAngleTarget = Math.atan2(direction.z, direction.x);

      if (capeAngle == null) {
        lastAngleTarget = capeAngleTarget;
        capeAngle = capeAngleTarget;
      }

      const lookRadiusThreshold = 15;
      const lookRadiusThresholdSq = lookRadiusThreshold * lookRadiusThreshold;

      if (moveToOrigin && position.lengthSq() <= lookRadiusThresholdSq) {
        const dx = -position.x;
        const dz = -position.z;
        capeAngleTarget = Math.atan2(dz, dx);
      }

      const distTurnThreshold = 0.5;
      const distTurnThresholdSq = distTurnThreshold * distTurnThreshold;
      const distToTargetSq = position.distanceToSquared(spring.target);
      let curAngleTarget = lastAngleTarget;

      if (distToTargetSq >= distTurnThresholdSq) {
        curAngleTarget = capeAngleTarget;
        lastAngleTarget = capeAngleTarget;
      } // curAngleTarget = capeAngleTarget;


      capeAngle = MathUtil.dampAngle(capeAngle, curAngleTarget, moveToOrigin ? 10 : 50, dt); // capeAngle = MathUtil.dampAngle(capeAngle, capeAngleTarget, 50, dt);
      // console.log(capeAngle, capeAngleTarget);

      tmpDir.set(Math.cos(capeAngle), 0, Math.sin(capeAngle));
      shadowContainer.position.set(0, 0, 0).addScaledVector(tmpDir, relVelLength * -1); // cape.setLookAngle(capeAngle);
      // cape.setTilt(relVelLength);

      const upX = camera.matrixWorldInverse.elements[4];
      const upY = camera.matrixWorldInverse.elements[5];
      const upZ = camera.matrixWorldInverse.elements[6];
      const rightX = camera.matrixWorldInverse.elements[0];
      const rightY = camera.matrixWorldInverse.elements[1];
      const rightZ = camera.matrixWorldInverse.elements[2];
      camUpWorld.set(upX, upY, upZ);
      camRightWorld.set(rightX, rightY, rightZ); // camFrowardWorld.crossVectors(camRightWorld, camUpWorld);

      camera.getWorldDirection(camFrowardWorld);
      cape.update(dt, camera, -capeAngle, relVelLength, camUpWorld, camRightWorld, camFrowardWorld);
      head.update(dt, camera, -capeAngle, relVelLength, camUpWorld, camRightWorld, camFrowardWorld);
      legs.update(dt, camera, -capeAngle, relVelLength, camUpWorld, camRightWorld, camFrowardWorld);
      group.position.copy(position); // const dir = new THREE.Vector3(0, )

      arrow.setDirection(tmpDir); // if (target.forceApplied) {
      //   targetLift = 1;
      // } else {
      //   targetLift = 0.25;
      // }

      targetLift = MathUtil.lerp(0.1, 0.75, relVelLength);
      lift = MathUtil.damp(lift, targetLift, 3, dt);
      float = Math.sin(time * 2) * 0.05;
      const totalLift = lift + float;
      container.position.y = totalLift;
      const shadowSize = 0.9 * MathUtil.lerp(1, 1.1, relVelLength);
      shadowContainer.scale.setScalar(shadowSize);
      group.scale.setScalar(characterScale * this.scale);
      cape.group.position.y = capeOriginPosY + char.yOffset;
      head.group.position.y = headOriginPosY + char.yOffset;
      legs.group.position.y = legsOriginPosY + char.yOffset; // const upX = camera.matrixWorldInverse.elements[4];
      // const upY = camera.matrixWorldInverse.elements[5];
      // const upZ = camera.matrixWorldInverse.elements[6];
      // const rightX = camera.matrixWorldInverse.elements[0];
      // const rightY = camera.matrixWorldInverse.elements[1];
      // const rightZ = camera.matrixWorldInverse.elements[2];
      // camUpWorld.set(upX, upY, upZ);
      // camRightWorld.set(rightX, rightY, rightZ);
      // const n = direction.dot(camRightWorld);
      // if (n < 0) {
      //   capeMap.offset.x = 1;
      //   capeMap.repeat.x = -1;
      // } else {
      //   capeMap.offset.x = 0;
      //   capeMap.repeat.x = 1;
      // }
    }

  };
}
},{"three":"src/vendor/three.module.js","../../tags":"src/tags/index.js","../../util/CapsuleBufferGeometry":"src/util/CapsuleBufferGeometry.js","../../util/math":"src/util/math.js","../../util/ShaderManager":"src/util/ShaderManager.js","./CharacterHead":"src/systems/character/CharacterHead.js","./CapeMesh":"src/systems/character/CapeMesh.js","./CharacterLegs":"src/systems/character/CharacterLegs.js"}],"src/systems/character/PhysicsSpring.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = PhysicsSpring;

var THREE = _interopRequireWildcard(require("three"));

var MathUtil = _interopRequireWildcard(require("../../util/math"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function PhysicsSpring() {
  var Cd = 0.47; // Dimensionless

  var rho = 1.22; // kg / m^3

  var radius = 20;
  var A = Math.PI * radius * radius / 10000; // m^2

  var gravity = -9.81 * 0.1; // m / s^2

  var mass = 0.05;
  var restitution = -0.7;
  var maxVel = 15;
  const speed = 1;
  const stiffness = 0.15;
  const restingDistance = 1;
  const EPSILON = 0.000001;
  const tmpVec3D = new THREE.Vector3(); // const moveDistThreshold = 11;
  // const moveDistThresholdSq = moveDistThreshold * moveDistThreshold;

  const rawVelocity = new THREE.Vector3();
  const velocity = new THREE.Vector3();
  const direction = new THREE.Vector3();
  const target = new THREE.Vector3();
  const position = new THREE.Vector3();
  let moveToTarget = false; // let continueMovingToTarget = false;

  return {
    maxVelocity: maxVel,
    lerpToTarget: false,

    get moveToTarget() {
      return moveToTarget;
    },

    set moveToTarget(v) {
      // let old = moveToTarget;
      moveToTarget = v; // if (old !== v) {
      //   continueMovingToTarget = v;
      // }
    },

    target,
    position,
    velocity: rawVelocity,
    direction,

    update(dt) {
      const distSq = target.distanceToSquared(position);
      const dist = Math.sqrt(distSq);

      if (moveToTarget) {
        // TODO: fix this drifting physics issue...
        if (dist >= restingDistance) {
          tmpVec3D.copy(target).sub(position);
          const RK = dist;
          const strength = MathUtil.clamp01(Math.pow(RK / 2.5, 1 / 5));
          const elastic = 0.1;
          rawVelocity.addScaledVector(tmpVec3D, strength * elastic); // rawVelocity.addScaledVector(tmpVec3D, -scalarP2 * restingRatio * 1);
        } else {}
      } // clamp rawVelocity


      rawVelocity.x = MathUtil.clamp(rawVelocity.x, -maxVel, maxVel);
      rawVelocity.y = MathUtil.clamp(rawVelocity.y, -maxVel, maxVel);
      rawVelocity.z = MathUtil.clamp(rawVelocity.z, -maxVel, maxVel);
      var vx = rawVelocity.x;
      var vy = rawVelocity.y;
      var vz = rawVelocity.z;
      var Fx = -0.5 * Cd * A * rho * vx * vx * vx / Math.abs(vx);
      var Fy = -0.5 * Cd * A * rho * vy * vy * vy / Math.abs(vy);
      var Fz = -0.5 * Cd * A * rho * vz * vz * vz / Math.abs(vz);
      Fx = isNaN(Fx) ? 0 : Fx;
      Fy = isNaN(Fy) ? 0 : Fy;
      Fz = isNaN(Fz) ? 0 : Fz; // Calculate acceleration ( F = ma )

      var ax = Fx / mass;
      var ay = Fy / mass;
      var az = Fz / mass; // Integrate to get rawVelocity

      rawVelocity.x += ax * dt;
      rawVelocity.y += ay * dt;
      rawVelocity.z += az * dt;

      if (this.lerpToTarget) {
        MathUtil.dampVector(position, target, 0.75, dt, position);
      } else {
        // Integrate to get position
        position.x += rawVelocity.x * dt * speed;
        position.y += rawVelocity.y * dt * speed;
        position.z += rawVelocity.z * dt * speed;
      }

      direction.copy(rawVelocity).normalize();
    }

  };
}
},{"three":"src/vendor/three.module.js","../../util/math":"src/util/math.js"}],"src/systems/character/ScarfMesh.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ScarfMesh;

var THREE = _interopRequireWildcard(require("three"));

var Tags = _interopRequireWildcard(require("../../tags"));

var _CapsuleBufferGeometry = _interopRequireDefault(require("../../util/CapsuleBufferGeometry"));

var MathUtil = _interopRequireWildcard(require("../../util/math"));

var ShaderManager = _interopRequireWildcard(require("../../util/ShaderManager"));

var _Line3D = _interopRequireDefault(require("../../systems/writing/Line3D"));

var _Random = _interopRequireDefault(require("../../util/Random"));

var _simplexNoise = _interopRequireDefault(require("simplex-noise"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const tmpVec3D = new THREE.Vector3();

function PhysicsSystem(opts = {}) {
  const {
    gravity = -9.81 * 0.1,
    // m / s^2 - with fudged world unit scaling
    mass = 0.05 // mass of all bodies for simpler code

  } = opts;
  return {
    update(dt, points) {
      for (let i = 0; i < points.length; i++) {
        updatePoint(dt, points[i]);
      }
    },

    updatePoint
  };

  function updatePoint(dt, point) {
    const velocity = point.velocity;
    const position = point.position;
    const maxVel = point.maxVelocity;
    const speed = point.speed;
    const radius = point.radius;
    const Cd = 0.47; // Dimensionless

    const rho = 1.22; // kg / m^3

    const A = Math.PI * radius * radius / 10000; // m^2
    // clamp velocity

    velocity.x = MathUtil.clamp(velocity.x, -maxVel, maxVel);
    velocity.y = MathUtil.clamp(velocity.y, -maxVel, maxVel);
    velocity.z = MathUtil.clamp(velocity.z, -maxVel, maxVel); // clamp velocity
    // let friction = 0.95;
    // velocity.x *= friction;
    // velocity.y *= friction;
    // velocity.z *= friction;

    if (!point.pinned) {
      var vx = velocity.x;
      var vy = velocity.y;
      var vz = velocity.z; // var avx = Math.abs(vx);
      // var avy = Math.abs(vy);
      // var avz = Math.abs(vz);

      var Fx = -0.5 * Cd * A * rho * vx * vx * vx / Math.abs(vx);
      var Fy = -0.5 * Cd * A * rho * vy * vy * vy / Math.abs(vy);
      var Fz = -0.5 * Cd * A * rho * vz * vz * vz / Math.abs(vz);
      Fx = isNaN(Fx) ? 0 : Fx;
      Fy = isNaN(Fy) ? 0 : Fy;
      Fz = isNaN(Fz) ? 0 : Fz; // Calculate acceleration ( F = ma )

      var ax = Fx / mass;
      var ay = Fy / mass;
      var az = Fz / mass; // Integrate to get velocity

      velocity.x += ax * dt;
      velocity.y += ay * dt;
      velocity.z += az * dt; // Integrate to get position

      position.x += velocity.x * dt * speed;
      position.y += velocity.y * dt * speed;
      position.z += velocity.z * dt * speed;
    }
  }
}

function PhysicsConstraint(pointA, pointB, opts = {}) {
  const {
    restingDistance = 1,
    stiffness = 1,
    strengths = [1, 1]
  } = opts;
  return {
    solve(dt = 1) {
      tmpVec3D.copy(pointA.position).sub(pointB.position);
      const dist = tmpVec3D.length();
      var restingRatio = dist === 0 ? restingDistance : (restingDistance - dist) / dist;
      let scalarP1, scalarP2;
      let p1mass = strengths[0];
      let p2mass = strengths[1]; //handle zero mass a little differently

      if (p1mass == 0 && p2mass == 0) {
        scalarP1 = 0;
        scalarP2 = 0;
      } else if (p1mass == 0 && p2mass > 0) {
        scalarP1 = 0;
        scalarP2 = stiffness;
      } else if (p1mass > 0 && p2mass == 0) {
        scalarP1 = stiffness;
        scalarP2 = 0;
      } else {
        //invert mass quantities
        var im1 = 1.0 / p1mass;
        var im2 = 1.0 / p2mass;
        scalarP1 = im1 / (im1 + im2) * stiffness;
        scalarP2 = stiffness - scalarP1;
      }

      MathUtil.dampVector(pointB.position, pointA.position, 1 + 15 * (1 - MathUtil.clamp01(dist / restingRatio)), dt, pointB.position); // pointA.velocity.addScaledVector(tmpVec3D, dt * scalarP1 * restingRatio);
      // pointB.velocity.addScaledVector(tmpVec3D, -dt * scalarP2 * restingRatio);
    }

  };
}

function PhysicsPoint(position, opts = {}) {
  const {
    radius = 20,
    maxVelocity = 15,
    speed = 1
  } = opts;
  const velocity = new THREE.Vector3(0, 0, 0);
  let pinned = Boolean(opts.pinned);
  return {
    get pinned() {
      return pinned;
    },

    set pinned(v) {
      pinned = v;
    },

    radius,
    maxVelocity,
    speed,
    position,
    velocity
  };
}

function ScarfMesh() {
  const group = new THREE.Group();
  const anchorPoint = new THREE.Vector3(0, 1.35, 0);
  const mass = 0.05;
  const radius = 50;
  const stiffness = 0.5;
  const maxVelocity = 40;
  const nodeCount = 6;
  const physics = PhysicsSystem({
    mass
  });
  const points = MathUtil.linspace(nodeCount).map((t, i) => {
    const x = t;
    const y = 0;
    const z = 0;
    const position = new THREE.Vector3(x, y, z).add(anchorPoint);
    return PhysicsPoint(position, {
      radius,
      maxVelocity,
      pinned: i === 0
    });
  });
  const constraints = [];

  for (let i = 0; i < points.length - 1; i++) {
    const a = points[i];
    const b = points[i + 1];
    const t = i / points.length;
    const restingDistance = a.position.distanceTo(b.position);
    constraints.push(PhysicsConstraint(a, b, {
      stiffness,
      restingDistance
    }));
  }

  const random = (0, _Random.default)();
  const noise = new _simplexNoise.default(random.value);
  const line = new _Line3D.default(world, {
    taper: false,
    thickness: 0.75
  });
  line.material.uniforms.color.value.set("#f6eaae");
  group.add(line);
  let fps = 30;
  let fpsInterval = 1 / fps;
  let time = 0;
  let elapsed = 0;
  return {
    group,

    update(dt, anchor) {
      elapsed += dt; // set pinned point

      points[0].position.copy(anchor);
      time += dt;

      if (time >= fpsInterval) {
        time %= fpsInterval;

        for (let i = 0; i < 1; i++) {
          constraints.forEach(c => c.solve(fpsInterval));
        }
      }

      points.forEach(p => {
        const f = 1;
        const a = 1;
        const n = a * noise.noise3D(p.position.x * f, elapsed, p.position.z * f);
        p.velocity.y += n;
      }); // integrate all points

      physics.update(dt, points); // update line with vectors

      line.updatePath(points, true, true);
    }

  };
}
},{"three":"src/vendor/three.module.js","../../tags":"src/tags/index.js","../../util/CapsuleBufferGeometry":"src/util/CapsuleBufferGeometry.js","../../util/math":"src/util/math.js","../../util/ShaderManager":"src/util/ShaderManager.js","../../systems/writing/Line3D":"src/systems/writing/Line3D.js","../../util/Random":"src/util/Random.js","simplex-noise":"node_modules/simplex-noise/simplex-noise.js"}],"src/systems/CharacterSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = CharacterSystem;

var THREE = _interopRequireWildcard(require("three"));

var Tags = _interopRequireWildcard(require("../tags"));

var _CapsuleBufferGeometry = _interopRequireDefault(require("../util/CapsuleBufferGeometry"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var ShaderManager = _interopRequireWildcard(require("../util/ShaderManager"));

var _threeQuaternionFromNormal = _interopRequireDefault(require("three-quaternion-from-normal"));

var _tweenTicker = _interopRequireDefault(require("../util/tween-ticker"));

var _Assets = _interopRequireDefault(require("../util/Assets"));

var _materials = require("../util/materials");

var _resetPlayerPos = require("../util/resetPlayerPos");

var _CharacterModel = _interopRequireDefault(require("./character/CharacterModel"));

var _PhysicsSpring = _interopRequireDefault(require("./character/PhysicsSpring"));

var _ScarfMesh = _interopRequireDefault(require("./character/ScarfMesh"));

var _AnimationSystem = require("./AnimationSystem");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function CharacterSystem(world) {
  const renderer = world.findTag(Tags.Renderer);
  const userCharacter = world.entity("CharacterEntity").add(Tags.UserCharacter);

  const [blobShadowMap] = _Assets.default.createGPUTextureTask(renderer, "image/data/soft-circle");

  const [capeMap] = _Assets.default.createGPUTextureTask(renderer, "image/data/cape-texture-landscape-1024", {
    generateMipmaps: false,
    minFilter: THREE.NearestFilter,
    wrapS: THREE.RepeatWrapping,
    wrapT: THREE.RepeatWrapping
  });

  const group = new THREE.Group();
  const model = (0, _CharacterModel.default)(world, {
    capeMap,
    blobShadowMap
  });
  model.group.name = "character-model";
  group.name = "character-container";
  group.add(model.group);
  userCharacter.add(Tags.Object3D, group);
  let scarf; // const scarf = ScarfMesh(world);
  // group.add(scarf.group);
  // scarf.group.name = "character-scarf";

  const maxRadialDist = 12; // or 20?

  const snapThreshold = maxRadialDist * 2;
  const maxRadialDistSq = maxRadialDist * maxRadialDist;
  const spring = (0, _PhysicsSpring.default)();
  const smoothTarget = new THREE.Vector3();
  let hasSmoothTarget = false;
  const distFromSmoothThreshold = 25;
  const distFromSmoothThresholdSq = distFromSmoothThreshold * distFromSmoothThreshold;
  const hatTipPoint = world.tag(Tags.HatTipPoint);
  const scarfAnchor = new THREE.Vector3();
  const animateInEvents = world.listen(Tags.AnimateInCharacter);
  const animateOutEvents = world.listen(Tags.AnimateOutCharacter);
  const animateTween = {
    value: 1
  };
  return function characterSystem(dt) {
    const hideChar = world.findTag(Tags.HideCharacter);
    const isIntroSequence = world.findTag(Tags.OriginTreeIntroSequence);
    const userTarget = world.findTag(Tags.UserTarget);
    const input = world.findTag(Tags.InputState);
    const char = userCharacter.get(Tags.UserCharacter);
    const isCameraDirecting = Boolean(world.findTag(Tags.CameraStopUserMovement));
    const allowInput = !Boolean(world.findTag(Tags.BlockUserMove));
    const canMove = !isIntroSequence && !isCameraDirecting && !Boolean(world.findTag(Tags.ModalStoppingUserMovement));
    let moveToOrigin = Boolean(world.findTag(Tags.MoveUserToOrigin));
    const snapThresholdSq = snapThreshold * snapThreshold;
    const distFromTargetSq = userTarget.position.distanceToSquared(char.position);
    let clearVelocity = hideChar;
    animateInEvents.added.forEach(e => {
      moveToOrigin = true;
      clearVelocity = true;
      animateTween.value = 0;
      spring.target.copy(_resetPlayerPos.standingNextToOriginTree);
      spring.position.copy(spring.target);
      char.position.copy(spring.target); // remove after use

      e.remove(Tags.AnimateInCharacter); // create a new tween

      const tweenAnim = (0, _AnimationSystem.tweenTo)(world, animateTween, "value", 1, 1, "quadOut", 0); // the tween will stop user movement
      // but the tween will get auto-killed once its

      tweenAnim.add(Tags.BlockUserMove);
    });
    animateOutEvents.added.forEach(e => {
      // moveToOrigin = true;
      // clearVelocity = true;
      // animateTween.value = 0;
      // spring.target.copy(standingNextToOriginTree);
      // spring.position.copy(spring.target);
      // char.position.copy(spring.target);
      // remove after use
      e.remove(Tags.AnimateOutCharacter); // create a new tween

      const tweenAnim = (0, _AnimationSystem.tweenTo)(world, animateTween, "value", 0, 0.01, "quadIn", 11); // the tween will stop user movement
      // but the tween will get auto-killed once its

      tweenAnim.add(Tags.BlockUserMove);
    });

    if (distFromTargetSq >= snapThresholdSq && !moveToOrigin) {
      char.position.copy(userTarget.position);
      spring.target.copy(userTarget.position);
      spring.position.copy(userTarget.position);
      clearVelocity = true;
    }

    if (clearVelocity) {
      char.velocity.set(0, 0);
      spring.velocity.set(0, 0, 0);
      spring.direction.set(1, 0, 0);
    }

    spring.lerpToTarget = false;

    if (moveToOrigin) {
      spring.target.copy(_resetPlayerPos.standingNextToOriginTree);
      spring.moveToTarget = true;
      spring.lerpToTarget = true;
    } else if (input.interacted && userTarget.inputHitPlane && canMove && allowInput) {
      // tmpVec3D.copy(userTarget.inputPositionOnPlane);
      // const distSq = tmpVec3D.distanceToSquared(userTarget.position);
      spring.moveToTarget = true;

      if (hasSmoothTarget) {
        // if we need to reset smoother
        const distFromSmoothSq = smoothTarget.distanceToSquared(userTarget.inputPositionOnPlane);

        if (distFromSmoothSq >= distFromSmoothThresholdSq) {
          hasSmoothTarget = false;
        }
      }

      if (!hasSmoothTarget) {
        hasSmoothTarget = true;
        smoothTarget.copy(userTarget.inputPositionOnPlane);
      } else {
        MathUtil.dampVector(smoothTarget, userTarget.inputPositionOnPlane, 50, dt, smoothTarget);
      }

      spring.target.copy(smoothTarget).sub(userTarget.position);
      const distSq = spring.target.lengthSq();

      if (distSq >= maxRadialDistSq) {
        const dist = Math.sqrt(distSq);

        if (dist !== 0) {
          // normalize vector
          spring.target.divideScalar(dist);
        }

        spring.target.multiplyScalar(maxRadialDist).add(userTarget.position);
      } else {
        spring.target.copy(smoothTarget);
      }
    } else {
      spring.moveToTarget = false;
    }

    spring.update(dt); // take the fudged-physical units in PhysicsSpring and
    // scale them to a more friendly world unit for our game...
    // the fudge is thick here.

    const maxOutVel = 0.2;
    char.velocity.copy(spring.velocity).multiplyScalar(maxOutVel / spring.maxVelocity);
    char.position.copy(spring.position);
    char.direction.copy(spring.direction);
    model.scale = animateTween.value;
    model.update(dt, char, userTarget, spring, moveToOrigin);
    model.getScarfAnchor(scarfAnchor);
    if (scarf) scarf.update(dt, scarfAnchor);
    model.getHatTipPoint(hatTipPoint);
    group.visible = !isIntroSequence && !hideChar;
  };
}
},{"three":"src/vendor/three.module.js","../tags":"src/tags/index.js","../util/CapsuleBufferGeometry":"src/util/CapsuleBufferGeometry.js","../util/math":"src/util/math.js","../util/ShaderManager":"src/util/ShaderManager.js","three-quaternion-from-normal":"node_modules/three-quaternion-from-normal/index.js","../util/tween-ticker":"src/util/tween-ticker.js","../util/Assets":"src/util/Assets.js","../util/materials":"src/util/materials.js","../util/resetPlayerPos":"src/util/resetPlayerPos.js","./character/CharacterModel":"src/systems/character/CharacterModel.js","./character/PhysicsSpring":"src/systems/character/PhysicsSpring.js","./character/ScarfMesh":"src/systems/character/ScarfMesh.js","./AnimationSystem":"src/systems/AnimationSystem.js"}],"src/systems/HatWindLineSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = HatWindLineSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _Line3D = _interopRequireDefault(require("./writing/Line3D"));

var _ObjectPool = _interopRequireDefault(require("../util/ObjectPool"));

var _Random = _interopRequireDefault(require("../util/Random"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class Sample {
  constructor() {
    this.position = [0, 0, 0];
    this.velocity = [0, 0, 0];
    this.index = 0;
  }

  reset() {
    this.index = 0;
    this.position[0] = 0;
    this.position[1] = 0;
    this.position[2] = 0;
    this.velocity[0] = 0;
    this.velocity[1] = 0;
    this.velocity[2] = 0;
  }

}

function HatWindLineSystem(world) {
  const samplePool = new _ObjectPool.default({
    name: "HatWindLineSamples",
    initialCapacity: 120,

    create() {
      return new Sample();
    },

    renew(s) {
      s.reset();
      return s;
    }

  });
  const pool = new _ObjectPool.default({
    name: "HatWindLines",
    initialCapacity: 3,

    create() {
      const m = new _Line3D.default(world, {
        taper: true,
        thickness: 0.1,
        bloom: 0
      });
      m.userData.path = [];
      m.userData.lastPosition = new THREE.Vector3();
      m.userData.velocity = new THREE.Vector3();
      m.userData.hasLastPosition = false;
      m.userData.entity = null;
      m.userData.time = 0;
      m.userData.delay = 0.25;
      m.userData.duration = 1; // m.material.uniforms.smoothen.value = true;

      m.name = "hat-tip-line";
      return m;
    },

    renew(m) {
      const entity = world.entity();
      entity.add(Tags.Object3D, m).add(Tags.HatTipWindLineTag);
      m.userData.entity = entity;
      m.userData.time = 0;
      m.userData.delay = 0.25;
      m.userData.duration = 1;
      m.userData.velocity.set(0, 0, 0);
      m.position.set(0, 0, 0);
      return m;
    },

    release(m) {
      if (m.userData.entity) {
        m.userData.entity.kill();
        m.userData.entity = null;
      }

      m.userData.hasLastPosition = false;
      m.userData.path.length = 0;
    }

  });
  const hatTipView = world.view(Tags.HatTipPoint);
  const windLineView = world.view(Tags.HatTipWindLineTag);
  const activeLineView = world.view(Tags.WrittenStanzaLineActive);
  let currentLine = null;
  let drawing = false;
  let turnSum = 0;
  let lastAngle = null;
  let windTime = 0;
  const random = (0, _Random.default)();

  const newDrawDuration = () => random.range(0.5, 1);

  const newDelayDuration = () => random.range(0.1, 0.1);

  let drawDuration = newDrawDuration();
  let timeDelay = newDelayDuration();
  let timer = 0;
  const zero3 = [0, 0, 0];
  const maxSamples = 50;
  let angleEnergyRollingAverage = 0;
  let lastPlanePosition = null;
  const currentEnvView = world.view(Tags.ActiveEnvironmentState);
  return function hatWindLineSystem(dt) {
    windTime += dt;
    const user = world.findTag(Tags.UserCharacter);
    const target = world.findTag(Tags.UserTarget);
    const angle = Math.atan2(user.direction.z, user.direction.x);
    const userVelLength = user.velocity.length();

    if (lastAngle != null) {
      const sumTheta = Math.abs(MathUtil.deltaAngle(angle, lastAngle));
      const sum = MathUtil.radToDeg(sumTheta);
      const N = 5;
      angleEnergyRollingAverage -= angleEnergyRollingAverage / N;
      angleEnergyRollingAverage += sum / N;

      if (drawing && angleEnergyRollingAverage < 1) {
        if (timer >= drawDuration / 2) {
          drawing = false;
          drawDuration = newDrawDuration();
          currentLine = null;
          timer = 0;
        }
      } else if (!drawing && angleEnergyRollingAverage > 4 && target.forceApplied && activeLineView.length === 0) {
        timer = 0;
        drawing = true;
      }
    }

    lastAngle = angle;

    if (drawing) {
      timer += dt;

      if (timer >= drawDuration) {
        timer %= drawDuration;
        currentLine = false;
        drawing = false;
        drawDuration = newDrawDuration();
        angleEnergyRollingAverage = 0;
      }
    }

    if (hatTipView.length > 0 && drawing) {
      const tip = hatTipView[0].get(Tags.HatTipPoint);

      if (!currentLine) {
        currentLine = pool.next();
        const currentEnv = currentEnvView.length > 0 ? currentEnvView[0].get(Tags.EnvironmentState).name : null;
        currentLine.userData.entity.add(Tags.HatTipWindLineSound, currentEnv);
      }

      const dist = 0.1;
      const distSq = dist * dist;
      const d = currentLine.userData;

      if (!d.hasLastPosition || d.lastPosition.distanceToSquared(tip) >= distSq) {
        d.hasLastPosition = true;
        if (d.path.length <= 0) d.velocity.copy(user.velocity); // const sample = new Sample(); //TODO pool

        const sample = samplePool.next();
        tip.toArray(sample.position);
        user.velocity.toArray(sample.velocity);

        if (d.path.length > 0) {
          sample.index = d.path[d.path.length - 1].index + 1;
        }

        if (d.path.length > maxSamples) {
          const oldSample = d.path.shift();
          samplePool.release(oldSample);
        }

        d.path.push(sample);
        if (d.path.length > 4) currentLine.updatePath(d.path, true);
        d.lastPosition.copy(tip);
      }

      currentLine.visible = d.path.length > 4;
    }

    windLineView.forEach(e => {
      const m = e.get(Tags.Object3D);

      if (currentLine !== m) {
        m.userData.time += dt;
      }

      const curTime = Math.max(0, m.userData.time - m.userData.delay);
      const alpha = 1 - curTime / m.userData.duration;
      m.material.uniforms.opacity.value = alpha * 0.5;

      if (curTime >= m.userData.duration) {
        m.userData.path.forEach(sample => samplePool.release(sample)); // m.userData.path.length = 0;
        // m.visible = false;

        pool.release(m);
      } else {
        const scl = 0.25;
        const gravity = -0.1; // m.position.x += m.userData.velocity.x * scl;
        // m.position.y += gravity * dt;
        // m.position.z += m.userData.velocity.z * scl;

        const spd = 10;
        m.userData.path.forEach((p, i, lst) => {
          const alpha = lst.length <= 1 ? 0.0 : i / (lst.length - 1);
          p.position[0] += p.velocity[0] * dt * spd * alpha;
          p.position[2] += p.velocity[2] * dt * spd * alpha; // p.velocity[0] *= 0.98;
          // p.velocity[2] *= 0.98;
          // MathUtil.dampVector(p.velocity, zero3, 10, dt, p.velocity);
          // p.position[1] += 0.1 * dt * Math.sin(p.index * 0.25 + windTime * 5);

          p.position[1] += dt * -0.5;
        });
        m.updatePath(m.userData.path, true);
      }
    });
  };
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/math":"src/util/math.js","./writing/Line3D":"src/systems/writing/Line3D.js","../util/ObjectPool":"src/util/ObjectPool.js","../util/Random":"src/util/Random.js"}],"src/systems/AtmosphericsSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AtmosphericsSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _Assets = _interopRequireDefault(require("../util/Assets"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function AtmosphericsSystem(world) {
  const scene = new THREE.Scene();
  const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, -10, 10);
  const atmospherics = world.tag(Tags.Atmospherics, {
    scene,
    camera
  });
  const renderer = world.findTag(Tags.Renderer);

  const [map] = _Assets.default.createGPUTextureTask(renderer, "image/data/lightray", {
    wrapS: THREE.RepeatWrapping,
    wrapT: THREE.RepeatWrapping
  });

  const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
    map,
    depthTest: false,
    depthWrite: false,
    transparent: true,
    opacity: 0.5,
    blending: THREE.AdditiveBlending,
    side: THREE.DoubleSide
  }));
  sprite.scale.setScalar(2);
  sprite.position.set(0.5, 0.5, 0);
  scene.add(sprite);
  return dt => {};
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/Assets":"src/util/Assets.js"}],"node_modules/fast-2d-poisson-disk-sampling/src/tiny-ndarray.js":[function(require,module,exports) {
"use strict";

function tinyNDArrayOfInteger (gridShape) {
    var dimensions = gridShape.length,
        totalLength = 1,
        stride = new Array(dimensions),
        dimension;

    for (dimension = dimensions; dimension > 0; dimension--) {
        stride[dimension - 1] = totalLength;
        totalLength = totalLength * gridShape[dimension - 1];
    }

    return {
        stride: stride,
        data: new Uint32Array(totalLength)
    };
}

module.exports = tinyNDArrayOfInteger;
},{}],"node_modules/fast-2d-poisson-disk-sampling/src/fast-poisson-disk-sampling.js":[function(require,module,exports) {
"use strict";

var tinyNDArray = require('./tiny-ndarray');

var epsilon = 2e-14;
var piDiv3 = Math.PI / 3;

var neighbourhood = [
    [ 0, 0 ],   [ 0, -1 ],  [ -1, 0 ],
    [ 1, 0 ],   [ 0, 1 ],   [ -1, -1 ],
    [ 1, -1 ],  [ -1, 1 ],  [ 1, 1 ],
    [ 0, -2 ],  [ -2, 0 ],  [ 2, 0 ],
    [ 0, 2 ],   [ -1, -2 ], [ 1, -2 ],
    [ -2, -1 ], [ 2, -1 ],  [ -2, 1 ],
    [ 2, 1 ],   [ -1, 2 ],  [ 1, 2 ]
];

var neighbourhoodLength = neighbourhood.length;

/**
 * FastPoissonDiskSampling constructor
 * @param {object} options Options
 * @param {Array} options.shape Shape of the space
 * @param {float} options.radius Minimum distance between each points
 * @param {int} [options.tries] Number of times the algorithm will try to place a point in the neighbourhood of another points, defaults to 30
 * @param {function|null} [rng] RNG function, defaults to Math.random
 * @constructor
 */
function FastPoissonDiskSampling (options, rng) {
    this.width = options.shape[0];
    this.height = options.shape[1];
    this.radius = options.radius || options.minDistance;
    this.maxTries = Math.max(3, Math.ceil(options.tries || 30));

    this.rng = rng || Math.random;

    this.squaredRadius = this.radius * this.radius;
    this.radiusPlusEpsilon = this.radius + epsilon;
    this.cellSize = this.radius * Math.SQRT1_2;

    this.angleIncrement = Math.PI * 2 / this.maxTries;
    this.angleIncrementOnSuccess = piDiv3 + epsilon;
    this.triesIncrementOnSuccess = Math.ceil(this.angleIncrementOnSuccess / this.angleIncrement);

    this.processList = [];
    this.samplePoints = [];

    // cache grid

    this.gridShape = [
        Math.ceil(this.width / this.cellSize),
        Math.ceil(this.height / this.cellSize)
    ];

    this.grid = tinyNDArray(this.gridShape); //will store references to samplePoints
}

FastPoissonDiskSampling.prototype.width = null;
FastPoissonDiskSampling.prototype.height = null;
FastPoissonDiskSampling.prototype.radius = null;
FastPoissonDiskSampling.prototype.radiusPlusEpsilon = null;
FastPoissonDiskSampling.prototype.squaredRadius = null;
FastPoissonDiskSampling.prototype.cellSize = null;

FastPoissonDiskSampling.prototype.angleIncrement = null;
FastPoissonDiskSampling.prototype.angleIncrementOnSuccess = null;
FastPoissonDiskSampling.prototype.triesIncrementOnSuccess = null;

FastPoissonDiskSampling.prototype.maxTries = null;
FastPoissonDiskSampling.prototype.rng = null;

FastPoissonDiskSampling.prototype.processList = null;
FastPoissonDiskSampling.prototype.samplePoints = null;
FastPoissonDiskSampling.prototype.gridShape = null;
FastPoissonDiskSampling.prototype.grid = null;

/**
 * Add a totally random point in the grid
 * @returns {Array} The point added to the grid
 */
FastPoissonDiskSampling.prototype.addRandomPoint = function () {
    return this.directAddPoint([
        this.rng() * this.width,
        this.rng() * this.height,
        this.rng() * Math.PI * 2,
        0
    ]);
};

/**
 * Add a given point to the grid
 * @param {Array} point Point
 * @returns {Array|null} The point added to the grid, null if the point is out of the bound or not of the correct dimension
 */
FastPoissonDiskSampling.prototype.addPoint = function (point) {
    var valid = point.length === 2 && point[0] >= 0 && point[0] < this.width && point[1] >= 0 && point[1] < this.height;

    return valid ? this.directAddPoint([
        point[0],
        point[1],
        this.rng() * Math.PI * 2,
        0
    ]) : null;
};

/**
 * Add a given point to the grid, without any check
 * @param {Array} point Point
 * @returns {Array} The point added to the grid
 * @protected
 */
FastPoissonDiskSampling.prototype.directAddPoint = function (point) {
    var coordsOnly = [point[0], point[1]];
    this.processList.push(point);
    this.samplePoints.push(coordsOnly);

    var internalArrayIndex = ((point[0] / this.cellSize) | 0) * this.grid.stride[0] + ((point[1] / this.cellSize) | 0);

    this.grid.data[internalArrayIndex] = this.samplePoints.length; // store the point reference

    return coordsOnly;
};

/**
 * Check whether a given point is in the neighbourhood of existing points
 * @param {Array} point Point
 * @returns {boolean} Whether the point is in the neighbourhood of another point
 * @protected
 */
FastPoissonDiskSampling.prototype.inNeighbourhood = function (point) {
    var dimensionNumber = 2,
        stride = this.grid.stride,
        neighbourIndex,
        internalArrayIndex,
        dimension,
        currentDimensionValue,
        existingPoint;

    for (neighbourIndex = 0; neighbourIndex < neighbourhoodLength; neighbourIndex++) {
        internalArrayIndex = 0;

        for (dimension = 0; dimension < dimensionNumber; dimension++) {
            currentDimensionValue = ((point[dimension] / this.cellSize) | 0) + neighbourhood[neighbourIndex][dimension];

            if (currentDimensionValue < 0 || currentDimensionValue >= this.gridShape[dimension]) {
                internalArrayIndex = -1;
                break;
            }

            internalArrayIndex += currentDimensionValue * stride[dimension];
        }

        if (internalArrayIndex !== -1 && this.grid.data[internalArrayIndex] !== 0) {
            existingPoint = this.samplePoints[this.grid.data[internalArrayIndex] - 1];

            if (Math.pow(point[0] - existingPoint[0], 2) + Math.pow(point[1] - existingPoint[1], 2) < this.squaredRadius) {
                return true;
            }
        }
    }

    return false;
};

/**
 * Try to generate a new point in the grid, returns null if it wasn't possible
 * @returns {Array|null} The added point or null
 */
FastPoissonDiskSampling.prototype.next = function () {
    var tries,
        currentPoint,
        currentAngle,
        newPoint;

    while (this.processList.length > 0) {
        var index = this.processList.length * this.rng() | 0;

        currentPoint = this.processList[index];
        currentAngle = currentPoint[2];
        tries = currentPoint[3];

        if (tries === 0) {
            currentAngle = currentAngle + (this.rng() - 0.5) * piDiv3 * 4;
        }

        for (; tries < this.maxTries; tries++) {
            newPoint = [
                currentPoint[0] + Math.cos(currentAngle) * this.radiusPlusEpsilon,
                currentPoint[1] + Math.sin(currentAngle) * this.radiusPlusEpsilon,
                currentAngle,
                0
            ];

            if (
                (newPoint[0] >= 0 && newPoint[0] < this.width) &&
                (newPoint[1] >= 0 && newPoint[1] < this.height) &&
                !this.inNeighbourhood(newPoint)
            ) {
                currentPoint[2] = currentAngle + this.angleIncrementOnSuccess + this.rng() * this.angleIncrement;
                currentPoint[3] = tries + this.triesIncrementOnSuccess;
                return this.directAddPoint(newPoint);
            }

            currentAngle = currentAngle + this.angleIncrement;
        }

        if (tries >= this.maxTries) {
            const r = this.processList.pop();
            if (index < this.processList.length) {
                this.processList[index] = r;
            }
        }
    }

    return null;
};

/**
 * Automatically fill the grid, adding a random point to start the process if needed.
 * Will block the thread, probably best to use it in a web worker or child process.
 * @returns {Array[]} Sample points
 */
FastPoissonDiskSampling.prototype.fill = function () {
    if (this.samplePoints.length === 0) {
        this.addRandomPoint();
    }

    while(this.next()) {}

    return this.samplePoints;
};

/**
 * Get all the points in the grid.
 * @returns {Array[]} Sample points
 */
FastPoissonDiskSampling.prototype.getAllPoints = function () {
    return this.samplePoints;
};

/**
 * Reinitialize the grid as well as the internal state
 */
FastPoissonDiskSampling.prototype.reset = function () {
    var gridData = this.grid.data,
        i;

    // reset the cache grid
    for (i = 0; i < gridData.length; i++) {
        gridData[i] = 0;
    }

    // new array for the samplePoints as it is passed by reference to the outside
    this.samplePoints = [];

    // reset the internal state
    this.processList.length = 0;
};

module.exports = FastPoissonDiskSampling;

},{"./tiny-ndarray":"node_modules/fast-2d-poisson-disk-sampling/src/tiny-ndarray.js"}],"src/systems/TallGrassSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = TallGrassSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _fast2dPoissonDiskSampling = _interopRequireDefault(require("fast-2d-poisson-disk-sampling"));

var _Random = _interopRequireDefault(require("../util/Random"));

var ShaderManager = _interopRequireWildcard(require("../util/ShaderManager"));

var _Assets = _interopRequireDefault(require("../util/Assets"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

async function TallGrassSystem(world) {
  const map = await _Assets.default.createGPUTexture(world.findTag(Tags.Renderer), "image/data/grass-1");
  const random = (0, _Random.default)();
  const baseGeometry = new THREE.BufferGeometry();
  const {
    position,
    uv,
    index
  } = createStaticBuffers(); // const positionArr = [];
  // const uvArr = [];
  // const indexArr = [];
  // let indexOffset = 0;
  // const matrix = new THREE.Matrix4();
  // const vec3D = new THREE.Vector3();
  // const vec2D = new THREE.Vector2();
  // for (let i = 0; i < 1; i++) {
  //   const [x, y] = random.insideCircle(1);
  //   matrix.identity();
  //   matrix.makeTranslation(x, 0, y);
  //   for (let i = 0; i < baseData.position.length / 2; i++) {
  //     const tx = baseData.position[i * 2 + 0];
  //     const tz = baseData.position[i * 2 + 1];
  //     vec3D.set(tx, 0, tz);
  //     vec3D.applyMatrix4(matrix);
  //     positionArr.push(vec3D.x, vec3D.y, vec3D.z);
  //   }
  //   for (let i = 0; i < baseData.uv.length; i++) {
  //     const n = baseData.uv[i];
  //     uvArr.push(n);
  //   }
  //   for (let i = 0; i < baseData.index.length; i++) {
  //     const idx = baseData.index[i];
  //     indexArr.push(idx + indexOffset);
  //   }
  //   indexOffset += baseData.position.length;
  // }

  const instancedGeometry = new THREE.InstancedBufferGeometry();
  instancedGeometry.setAttribute("position", position);
  instancedGeometry.setAttribute("uv", uv);
  instancedGeometry.setIndex(index);
  const size = 40;
  const samples = new _fast2dPoissonDiskSampling.default({
    shape: [size, size],
    radius: 1,
    tries: 10
  }, random.value).fill().map(s => {
    // const [tx, ty] = random.insideCircle(size);
    // s[0] += tx;
    // s[1] += ty;
    return [s[0] - size / 2, s[1] - size / 2];
  });
  const offsets = [];

  for (let i = 0; i < samples.length; i++) {
    const s = samples[i];
    const scl = 0.75;
    offsets.push(s[0], s[1], random.gaussian(scl, scl / 2));
  }

  console.log("Instances", samples.length);
  instancedGeometry.instanceCount = samples.length;
  const offsetAttr = new THREE.InstancedBufferAttribute(new Float32Array(offsets), 3);
  instancedGeometry.setAttribute("offset", offsetAttr);
  const material = ShaderManager.create({
    uniforms: {
      color: {
        value: new THREE.Color("#d8ab38")
      },
      colorGround: {
        value: new THREE.Color("#B88211")
      },
      map: {
        value: map
      },
      aspect: {
        value: map.image.width / map.image.height
      }
    },
    fragmentShader:
    /*glsl*/
    `
      uniform sampler2D map;
      uniform vec3 color;
      uniform vec3 colorGround;
      varying vec2 vUv;
      void main () {
        vec4 cData = texture2D(map, vUv);
        vec4 outColor = vec4(mix(colorGround, color, vUv.y), 1.0);
        // outColor.rgb += 0.1 * (cData.g * 2.0 - 1.0);
        float mask = 1.0 - cData.r;
        gl_FragColor = outColor;
        if (mask < 0.5) discard;
      }
    `,
    vertexShader:
    /*glsl*/
    `
      attribute vec3 offset;
      uniform float aspect;
      varying vec2 vUv;
      void main () {
        vUv = uv;
        float curScale = offset.z;
        vec3 centerWorldPos = (modelMatrix * vec4(vec3(0.0), 1.0)).xyz;
        vec3 camRightWorld = vec3(viewMatrix[0].x, viewMatrix[1].x, viewMatrix[2].x);
        vec3 camUpWorld = vec3(viewMatrix[0].y, viewMatrix[1].y, viewMatrix[2].y);

        vec2 scale;
        scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
        scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
        scale *= curScale;

        vec2 offsetPos = position.xy;
        vec3 vertexWorldPos = centerWorldPos
          + camRightWorld * offsetPos.x * scale.x * aspect 
          + camUpWorld * offsetPos.y * scale.y;

        vertexWorldPos.xz += offset.xy;

        // gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed.xyz, 1.0);
        gl_Position = projectionMatrix * viewMatrix * vec4(vertexWorldPos, 1.0);
      }
    `,
    side: THREE.DoubleSide
  });

  for (let i = 0; i < 9; i++) {
    const px = Math.floor(i % 3);
    const pz = Math.floor(i / 3);
    const mesh = new THREE.Mesh(instancedGeometry, material);
    world.entity().add(Tags.Object3D, mesh);
    mesh.frustumCulled = false;
    mesh.position.x = (px - 1.5) * size;
    mesh.position.z = (pz - 1.5) * size;
  } // const mesh2 = new THREE.Mesh(
  //   new THREE.SphereGeometry(1, 8, 8),
  //   new THREE.MeshBasicMaterial()
  // );
  // world.entity().add(Tags.Object3D, mesh2);


  return dt => {};
} // function createStaticArrayData() {
//   const planeBufferGeometry = new THREE.PlaneBufferGeometry(1, 1, 1, 3);
//   const attribs = planeBufferGeometry.attributes;
//   const vertCount = attribs.position.count;
//   const posArray = [];
//   const uvArray = [];
//   for (let i = 0; i < vertCount; i++) {
//     const x = attribs.position.getX(i);
//     const y = attribs.position.getY(i) + 0.5;
//     posArray.push(x, y);
//     const u = attribs.uv.getX(i);
//     const v = attribs.uv.getY(i);
//     uvArray.push(u, v);
//   }
//   const indexArray = planeBufferGeometry.getIndex().array;
//   planeBufferGeometry.dispose();
//   return { uv: uvArray, position: posArray, index: indexArray };
//   // const position = new THREE.BufferAttribute(new Float32Array(posArray), 2);
//   // const uv = new THREE.BufferAttribute(new Float32Array(uvArray), 2);
//   // const index = new THREE.BufferAttribute(
//   //   planeBufferGeometry.getIndex().array,
//   //   1
//   // );
//   // planeBufferGeometry.dispose();
//   // return {
//   //   position,
//   //   uv,
//   //   index,
//   // };
// }


function createStaticBuffers() {
  const planeBufferGeometry = new THREE.PlaneBufferGeometry(1, 1, 1, 3);
  const attribs = planeBufferGeometry.attributes;
  const vertCount = attribs.position.count;
  const posArray = [];
  const uvArray = [];

  for (let i = 0; i < vertCount; i++) {
    const x = attribs.position.getX(i);
    const y = attribs.position.getY(i) + 0.5;
    posArray.push(x, y);
    const u = attribs.uv.getX(i);
    const v = attribs.uv.getY(i);
    uvArray.push(u, v);
  }

  const position = new THREE.BufferAttribute(new Float32Array(posArray), 2);
  const uv = new THREE.BufferAttribute(new Float32Array(uvArray), 2);
  const index = new THREE.BufferAttribute(planeBufferGeometry.getIndex().array, 1);
  planeBufferGeometry.dispose();
  return {
    position,
    uv,
    index
  };
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","fast-2d-poisson-disk-sampling":"node_modules/fast-2d-poisson-disk-sampling/src/fast-poisson-disk-sampling.js","../util/Random":"src/util/Random.js","../util/ShaderManager":"src/util/ShaderManager.js","../util/Assets":"src/util/Assets.js"}],"src/util/ease-animate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = easeAnimate;

const linear = t => t;

function easeAnimate(elapsed = 0, duration = 1, delay = 0, animateDuration = 0.25, ease = linear) {
  const time = Math.max(0, elapsed - delay);
  let anim = 0;

  if (time <= animateDuration) {
    anim = time / animateDuration;
  } else if (isFinite(duration) && time >= duration - animateDuration) {
    const el = Math.max(0, time - (duration - animateDuration));
    const t = el / animateDuration;
    anim = 1 - t;
  } else {
    anim = 1;
  }

  anim = ease(anim);
  return anim;
}
},{}],"src/util/EditorWayfinderSprite.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setSpriteFlip = setSpriteFlip;
exports.setMeshToSprite = setMeshToSprite;
exports.createSprite = createSprite;
exports.traverseAndFixSprites = traverseAndFixSprites;
exports.changeToWayfinderSprite = changeToWayfinderSprite;
exports.default = exports.WayfinderSpriteMaterial = void 0;

var THREE = _interopRequireWildcard(require("three"));

var Tags = _interopRequireWildcard(require("../tags"));

var _materials = require("./materials");

var _defined = _interopRequireDefault(require("./defined"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const planeGeo = new THREE.PlaneGeometry(1, 1, 1, 1);
planeGeo.translate(0, 0.5, 0);

class WayfinderSpriteMaterial extends THREE.MeshBasicMaterial {
  constructor(opt = {}) {
    super({ ...opt,
      map: opt.map || new THREE.Texture()
    });
    this.name = this.name || "UntitledWayfinderSprite";
    this.userData.type = "WayfinderSpriteMaterial";
  }

  onBeforeCompile(shader) {
    const vertexShader =
    /*glsl*/
    `
    #include <common>
    varying vec2 vUv;
    uniform bool flipX;
    uniform bool silhouette;
    void main () {
      vUv = uv;
      if (flipX) vUv.x = 1.0 - vUv.x;

      vec3 centerWorldPos = (modelMatrix * vec4(vec3(0.0), 1.0)).xyz;
      vec3 camRightWorld = vec3(viewMatrix[0].x, viewMatrix[1].x, viewMatrix[2].x);
      vec3 camUpWorld = vec3(viewMatrix[0].y, viewMatrix[1].y, viewMatrix[2].y);

      vec2 scale;
      scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
      scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

      vec3 offsetPos = position.xyz;
      vec3 vertexWorldPos = centerWorldPos
        + camRightWorld * offsetPos.x * scale.x
        + camUpWorld * offsetPos.y * scale.y;

      if (silhouette) {
        float xSkew = -60.0 * (PI/180.0);
        float ySkew = 0.0;

        // Create a transform that will skew our texture coords
        mat3 trans = mat3(
          1.0       , tan(xSkew), 0.0,
          tan(ySkew), 1.0,        0.0,
          0.0       , 0.0,        1.0
        );
        float yPos = vertexWorldPos.y;
        vertexWorldPos.y *= 0.25;
        vertexWorldPos.xyz -= camRightWorld * yPos * 0.5;
        vertexWorldPos.z += -0.15;
      }
      gl_Position = projectionMatrix * viewMatrix * vec4(vertexWorldPos, 1.0);
    }`;
    const fragmentShader =
    /*glsl*/
    `
    uniform sampler2D map;
    uniform bool silhouette;
    // uniform vec3 color;
    varying vec2 vUv;
    void main () {
      gl_FragColor = texture2D(map, vUv);
      if (gl_FragColor.a < 0.5) discard;
    }
    `;
    shader.uniforms = shader.uniforms || {};
    const flipX = Boolean(this.userData.flipX);
    shader.uniforms.flipX = {
      value: flipX,
      type: "b"
    };
    shader.uniforms.silhouette = {
      value: false,
      type: "b"
    };
    shader.vertexShader = vertexShader;
    shader.fragmentShader = fragmentShader;
    this._currentShader = shader;
    this.userData.flipX = flipX;
  }

  getFlipX() {
    return Boolean(this.userData.flipX);
  }

  setFlipX(flipX) {
    flipX = Boolean(flipX);

    if (this._currentShader) {
      this._currentShader.uniforms.flipX.value = flipX;
    }

    this.userData.flipX = flipX;
  }

}

exports.WayfinderSpriteMaterial = WayfinderSpriteMaterial;

class WayfinderSprite extends THREE.Mesh {
  constructor() {
    super(planeGeo, createMaterial());
    this.userData.type = "WayfinderSprite";
    this.onBeforeRender = onBeforeRender.bind(this);
    this.__onImageUpdate = this.onBeforeRender;
  }

}

exports.default = WayfinderSprite;

function onBeforeRender() {
  let oldX = this.scale.x;
  const spriteHeight = this.scale.y;
  let aspect = 1;

  if (this.material && this.material.map && this.material.map.image) {
    const {
      width,
      height
    } = this.material.map.image;
    aspect = width / height;
    this.scale.x = spriteHeight * aspect;
  }

  if (oldX !== this.scale.x) {
    this.updateMatrix();
  }
}

function setSpriteData(world, child, map, maxY = Infinity, flipX = false) {
  const aspect = map && map.image ? map.image.width / map.image.height : 1;
  child.geometry = planeGeo;
  child.material = (0, _materials.createSpriteMaterial)(world);
  child.material.uniforms.map.value = map;
  child.material.uniforms.repeat.value.copy(map.repeat);
  child.material.uniforms.offset.value.copy(map.offset);
  child.material.uniforms.flip.value = flipX ? -1 : 1;
  child.material.side = flipX ? THREE.BackSide : THREE.FrontSide;
  child.material.uniforms.useMapDiscard.value = false; // child.scale.y = Math.min(child.scale.y, maxY);
  // child.scale.x = child.scale.y * aspect;

  child.material.uniforms.aspect.value = aspect;
  child.material.uniforms.spriteHeight.value = child.scale.y;
}

function setSpriteFlip(sprite, flipX) {
  sprite.material.uniforms.flip.value = flipX ? -1 : 1;
  sprite.material.side = flipX ? THREE.BackSide : THREE.FrontSide;
}

function setMeshToSprite(world, child, maxY = Infinity) {
  const map = child.material.uniforms && child.material.uniforms.map ? child.material.uniforms.map.value : child.material.map;
  const flipX = (0, _defined.default)(child.material.userData.flipX, child.userData.flipX);
  setSpriteData(world, child, map, maxY, flipX);
}

function createSprite(world, map, height = 1, maxY = Infinity, flipX = false) {
  const mesh = new THREE.Mesh();
  mesh.scale.y = height;
  setSpriteData(world, mesh, map, maxY, flipX);
  return mesh;
}

function traverseAndFixSprites(world, scene) {
  scene.traverse(child => {
    if (child && child.userData && child.userData.type === "WayfinderSprite") {
      // changeToWayfinderSprite(child);
      setMeshToSprite(world, child); // child.position.y = 0;
      // const e = world.entity();
      // e.add(Tags.Object3D, object);
      // e.add(Tags.ShadowCaster);
      // e.get(Tags.ShadowCaster).sprite = true;
      // e.add(Tags.ShaderUniformTime);
      // child.scale.y =
    }
  });
}

function changeToWayfinderSprite(mesh) {
  mesh.geometry = planeGeo;
  const texture = new THREE.Texture();

  if (mesh.material.map) {
    texture.image = mesh.material.map.image;
    texture.needsUpdate = true;
  }

  const materialUserData = { ...mesh.material.userData
  };
  mesh.material = createMaterial(texture);
  Object.assign(mesh.material.userData, materialUserData);
  mesh.onBeforeRender = onBeforeRender.bind(mesh);
  mesh.__onImageUpdate = mesh.onBeforeRender;
}

function createMaterial(map) {
  return new WayfinderSpriteMaterial({
    map: map || new THREE.Texture()
  });
}
},{"three":"src/vendor/three.module.js","../tags":"src/tags/index.js","./materials":"src/util/materials.js","./defined":"src/util/defined.js"}],"node_modules/euclidean-distance/squared.js":[function(require,module,exports) {
module.exports = function (a, b) {
  var sum = 0
  var n
  for (n = 0; n < a.length; n++) {
    sum += Math.pow(a[n] - b[n], 2)
  }
  return sum
}

},{}],"src/util/geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.boundsToEdges = boundsToEdges;
exports.boundsIntersect = boundsIntersect;
exports.boundsInsideOther = boundsInsideOther;
exports.getBoundingCircle = getBoundingCircle;
exports.circlesIntersect = circlesIntersect;
exports.point2DInsideBounds = point2DInsideBounds;
exports.circleInsideBounds = circleInsideBounds;
exports.vertsToEdges = vertsToEdges;
exports.boundsToVerts = boundsToVerts;
exports.intersectLineSegmentLineSegment = intersectLineSegmentLineSegment;

var _math = require("./math");

var _boundPoints = _interopRequireDefault(require("bound-points"));

var _squared = _interopRequireDefault(require("euclidean-distance/squared"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function boundsToEdges(bounds) {
  const [min, max] = bounds; // const w = max[0] - min[0];
  // const h = max[1] - min[1];

  const verts = [[min[0], min[1]], [max[0], min[1]], [max[0], max[1]], [min[0], max[1]]];
  const edges = [];

  for (let i = 0; i < verts.length; i++) {
    const a = verts[i];
    const b = verts[(i + 1) % verts.length];
    edges.push([a, b]);
  }

  return edges;
}

function boundsIntersect(boundsA, boundsB) {
  const [minA, maxA] = boundsA;
  const [minB, maxB] = boundsB;
  const [aMinX, aMinY] = minA;
  const [aMaxX, aMaxY] = maxA;
  const [bMinX, bMinY] = minB;
  const [bMaxX, bMaxY] = maxB;
  const noOverlap = aMinX > bMaxX || bMinX > aMaxX || aMinY > bMaxY || bMinY > aMaxY;
  return !noOverlap;
}

function boundsInsideOther(boundsA, boundsB) {
  const [minA, maxA] = boundsA;
  const [minB, maxB] = boundsB;
  const width = maxA[0] - minA[0];
  const height = maxA[1] - minA[1];
  const x = minA[0];
  const y = minA[1];
  const owidth = maxB[0] - minB[0];
  const oheight = maxB[1] - minB[1];
  const ox = minB[0];
  const oy = minB[1];
  return width > 0 && height > 0 && owidth > 0 && oheight > 0 && ox >= x && ox + owidth <= x + width && oy >= y && oy + oheight <= y + height;
}

function getBoundingCircle(points, bounds = null) {
  if (!bounds) bounds = (0, _boundPoints.default)(points);
  const center = (0, _math.lerpArray)(bounds[0], bounds[1], 0.5);
  let maxRadiusSq = 0;

  for (let i = 0; i < points.length; i++) {
    maxRadiusSq = Math.max(maxRadiusSq, (0, _squared.default)(points[i], center));
  }

  const radius = Math.sqrt(maxRadiusSq);
  return {
    center,
    radius
  };
}

function circlesIntersect(positionA, radiusA, positionB, radiusB) {
  const dx = positionA[0] - positionB[0];
  const dy = positionA[1] - positionB[1];
  const dsq = dx * dx + dy * dy;
  const r = radiusA + radiusB;
  const rsq = r * r;
  return dsq <= rsq;
}

function point2DInsideBounds(p, bounds) {
  const [x, y] = p;
  const [min, max] = bounds;
  return x >= min[0] && x < max[0] && y >= min[1] && y < max[1];
}

function circleInsideBounds(p, radius, bounds) {
  const [x, y] = p;
  const [min, max] = bounds;
  return x - radius >= min[0] && x + radius < max[0] && y - radius >= min[1] && y + radius < max[1];
}

function vertsToEdges(verts) {
  const e = [];

  for (let i = 0; i < 4; i++) {
    const a = verts[i];
    const b = verts[(i + 1) % verts.length];
    e.push([a, b]);
  }

  return e;
}

function boundsToVerts(bounds) {
  const [min, max] = bounds;
  const [nx, ny] = min;
  const nw = max[0] - min[0];
  const nh = max[1] - min[1];
  return [[nx, ny], [nx + nw, ny], [nx + nw, ny + nh], [nx, ny + nh]];
}

function intersectLineSegmentLineSegment(p1, p2, p3, p4) {
  // Reference:
  // https://github.com/evil-mad/EggBot/blob/master/inkscape_driver/eggbot_hatch.py
  const d21x = p2[0] - p1[0];
  const d21y = p2[1] - p1[1];
  const d43x = p4[0] - p3[0];
  const d43y = p4[1] - p3[1]; // denominator

  const d = d21x * d43y - d21y * d43x;
  if (d === 0) return -1;
  const nb = (p1[1] - p3[1]) * d21x - (p1[0] - p3[0]) * d21y;
  const sb = nb / d;
  if (sb < 0 || sb > 1) return -1;
  const na = (p1[1] - p3[1]) * d43x - (p1[0] - p3[0]) * d43y;
  const sa = na / d;
  if (sa < 0 || sa > 1) return -1;
  return sa;
}
},{"./math":"src/util/math.js","bound-points":"node_modules/bound-points/bounds.js","euclidean-distance/squared":"node_modules/euclidean-distance/squared.js"}],"node_modules/point-in-polygon/flat.js":[function(require,module,exports) {
module.exports = function pointInPolygonFlat (point, vs, start, end) {
    var x = point[0], y = point[1];
    var inside = false;
    if (start === undefined) start = 0;
    if (end === undefined) end = vs.length;
    var len = (end-start)/2;
    for (var i = 0, j = len - 1; i < len; j = i++) {
        var xi = vs[start+i*2+0], yi = vs[start+i*2+1];
        var xj = vs[start+j*2+0], yj = vs[start+j*2+1];
        var intersect = ((yi > y) !== (yj > y))
            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }
    return inside;
};

},{}],"node_modules/point-in-polygon/nested.js":[function(require,module,exports) {
// ray-casting algorithm based on
// https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html

module.exports = function pointInPolygonNested (point, vs, start, end) {
    var x = point[0], y = point[1];
    var inside = false;
    if (start === undefined) start = 0;
    if (end === undefined) end = vs.length;
    var len = end - start;
    for (var i = 0, j = len - 1; i < len; j = i++) {
        var xi = vs[i+start][0], yi = vs[i+start][1];
        var xj = vs[j+start][0], yj = vs[j+start][1];
        var intersect = ((yi > y) !== (yj > y))
            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }
    return inside;
};

},{}],"node_modules/point-in-polygon/index.js":[function(require,module,exports) {
var pointInPolygonFlat = require('./flat.js')
var pointInPolygonNested = require('./nested.js')

module.exports = function pointInPolygon (point, vs, start, end) {
    if (vs.length > 0 && Array.isArray(vs[0])) {
        return pointInPolygonNested(point, vs, start, end);
    } else {
        return pointInPolygonFlat(point, vs, start, end);
    }
}
module.exports.nested = pointInPolygonNested
module.exports.flat = pointInPolygonFlat

},{"./flat.js":"node_modules/point-in-polygon/flat.js","./nested.js":"node_modules/point-in-polygon/nested.js"}],"src/util/water-util.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.insideWaterPolys = insideWaterPolys;
exports.getLakeObject = getLakeObject;

var _geometry = require("./geometry");

var _pointInPolygon = _interopRequireDefault(require("point-in-polygon"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function insideWaterPolys(state, point) {
  if (!state.hasLakes) return false;

  for (let i = 0; i < state.lakes.length; i++) {
    const lake = state.lakes[i];

    if ((0, _geometry.point2DInsideBounds)(point, lake.bounds) && (0, _pointInPolygon.default)(point, lake.polygon)) {
      return true;
    }
  }

  return false;
}

function getLakeObject(state, point) {
  if (!state.hasLakes) return null;

  for (let i = 0; i < state.lakes.length; i++) {
    const lake = state.lakes[i];

    if ((0, _geometry.point2DInsideBounds)(point, lake.bounds) && (0, _pointInPolygon.default)(point, lake.polygon)) {
      return lake;
    }
  }

  return null;
}
},{"./geometry":"src/util/geometry.js","point-in-polygon":"node_modules/point-in-polygon/index.js"}],"src/systems/HaikuFloraSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = HaikuFloraSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _ObjectPool = _interopRequireDefault(require("../util/ObjectPool"));

var _threeUtil = require("../util/three-util");

var _fast2dPoissonDiskSampling = _interopRequireDefault(require("fast-2d-poisson-disk-sampling"));

var _easeAnimate = _interopRequireDefault(require("../util/ease-animate"));

var _materials = require("../util/materials");

var _EditorWayfinderSprite = require("../util/EditorWayfinderSprite");

var _load = require("../util/load");

var _AnimationSystem = require("./AnimationSystem");

var _Random = _interopRequireDefault(require("../util/Random"));

var _Assets = _interopRequireDefault(require("../util/Assets"));

var _rightNow = _interopRequireDefault(require("right-now"));

var _eases = require("eases");

var _waterUtil = require("../util/water-util");

var _queryString = _interopRequireDefault(require("../util/query-string"));

var _SpriteManager = _interopRequireDefault(require("../util/SpriteManager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function HaikuFloraSystem(world) {
  const haikuInventoryView = world.view(Tags.HaikuInInventory);
  const renderer = world.findTag(Tags.Renderer);
  const random = (0, _Random.default)();
  const spriteOpt = {
    sprite: true
  };
  const container = new THREE.Group();
  container.name = "haiku-flora";
  world.entity().add(Tags.Object3D, container);
  let spriteSheet;
  let types;
  (0, _SpriteManager.default)("spritesheets/ground-flowers", renderer).then(sheet => {
    spriteSheet = sheet;
    types = {
      forest: ["flower-05", "flower-04", "flower-01"].map(f => spriteSheet.frames.find(frame => frame.name === f)),
      grasslands: ["grasslands1", "grasslands2", "grasslands3"].map(f => spriteSheet.frames.find(frame => frame.name === f)),
      tundra: ["tundra1", "tundra3", "tundra2"].map(f => spriteSheet.frames.find(frame => frame.name === f)),
      grasslandsWater: spriteSheet.frames.filter(frame => /lily/i.test(frame.name))
    };
  });
  const scales = {
    forest: 1,
    grasslands: 1,
    tundra: 1
  };
  const tmpPos = new THREE.Vector3();
  const tmpArr2D = [0, 0]; // const textures = ids.map((id) => {
  //   const [tex] = Assets.createGPUTextureTask(renderer, id);
  //   return tex;
  // });

  const char = world.findTag(Tags.UserCharacter);
  const assetView = world.view(Tags.SpawnedFlora);
  let lastPosition = new THREE.Vector3();
  let hasLastPosition = false;
  const pool = new _ObjectPool.default({
    maxCapacity: 100,

    create() {
      // const sprite = createSprite(world, getEmptyTexture(), 1);
      const sprite = new THREE.Mesh((0, _materials.getSpriteGeometry)(), (0, _materials.createSpriteMaterial)(world));
      sprite.material.userData.flipX = random.boolean();
      (0, _EditorWayfinderSprite.setMeshToSprite)(world, sprite, 1);
      sprite.userData._entity = null; // sprite.scale.y = 0;

      return sprite;
    }

  });
  let time = 0;

  const getNewDelay = () => random.range(0.1, 0.2);

  let delay = getNewDelay();
  let readyToSpawn = false;
  let hasMovedFarEnough = false;
  const threshold = 1;
  const thresholdSq = threshold * threshold;
  const activeEnv = world.view(Tags.ActiveEnvironmentState);
  const papers = world.view([Tags.FloatingToken, Tags.FloatingTokenTargetUser]);
  const centerLength = 10;
  const centerLengthSq = centerLength * centerLength;
  const finalResolution = world.listen(Tags.FinalBiomeResolution);
  const finalResolutionView = world.view(Tags.FinalBiomeResolution);
  const tmpVec2D = new THREE.Vector2();
  const radius = 3;
  const size = 25; // const samples = new FastPoissonDiskSampling(
  //   {
  //     shape: [size, size],
  //     tries: 10,
  //     radius,
  //   },
  //   random.value
  // );

  let doFill = true;
  return dt => {
    const activeLine = world.findTag(Tags.WrittenStanzaLineActive);
    const state = activeEnv.length ? activeEnv[0].get(Tags.EnvironmentState) : null;
    if (!state) return;
    const isResolving = finalResolutionView.length > 0;
    let target;
    let targetIndex;

    if (papers.length && !isResolving) {
      target = random.pick(papers).get(Tags.FloatingToken);
    }

    if (finalResolution.added.length > 0) {
      if (doFill) {
        doFill = false; // const p = samples.fill();

        pool.maxCapacity = Infinity;

        for (let i = 0; i < 150; i++) {
          const angle = -60 * Math.PI / 180 + random.range(0, 300 * Math.PI / 180) + random.gaussian(0, 1 * Math.PI / 180);
          const u = Math.cos(angle);
          const v = Math.sin(angle);
          const rd = 6 + Math.abs(random.gaussian(0, 3));
          const x = u * rd;
          const y = v * rd;
          const len = Math.sqrt(x * x + y * y); // if (len > size * 0.5) return;
          // if (len > size * 0.4 && random.gaussian() > 0) return;

          const delay = 3.5 + len / (size / 2) * 2 + random.range(0, 1);
          spawn(tmpVec2D.set(x, y), "grasslands", false, false, delay, 0); // const m = new THREE.Mesh(
          //   new THREE.BoxGeometry(1, 1, 1),
          //   new THREE.MeshBasicMaterial({ color: "red" })
          // );
          // m.position.set(x, 0, y);
          // world.entity().add(Tags.Object3D, m);
        }
      }
    }

    if (target && haikuInventoryView.length > 0 && !activeLine) {
      time += dt;

      if (time >= delay) {
        time %= delay;
        delay = getNewDelay();
        readyToSpawn = true;
      }

      if (hasLastPosition) {
        let dx = target.position2D.x - lastPosition.x;
        let dz = target.position2D.y - lastPosition.z;
        let dstSq = dx * dx + dz * dz;

        if (dstSq >= thresholdSq) {
          hasMovedFarEnough = true;
        }
      }

      if (readyToSpawn && (hasMovedFarEnough || !hasLastPosition) && target.position2D.lengthSq() > centerLengthSq) {
        target.position2D.toArray(tmpArr2D);
        const insideWater = state ? (0, _waterUtil.insideWaterPolys)(state, tmpArr2D) : false;
        hasMovedFarEnough = false;
        readyToSpawn = false; // const count =
        //   insideWater || state.name === "grasslands"
        //     ? 1
        //     : random.rangeFloor(1, 5);

        const count = papers.length;

        for (let i = 0; i < count; i++) spawn(target.position2D, state.name, insideWater);

        lastPosition.x = target.position2D.x;
        lastPosition.y = 0;
        lastPosition.z = target.position2D.y;
        hasLastPosition = true;
      }
    }

    const biomeScale = 1;

    for (let i = 0; i < assetView.length; i++) {
      const e = assetView[i];
      const flora = e.get(Tags.SpawnedFlora);
      flora.time += dt;
      const curTime = Math.max(0, flora.time - flora.delay);
      const t = (0, _easeAnimate.default)(flora.time, flora.duration, flora.delay, flora.animateDuration, _eases.sineOut);
      const obj = e.get(Tags.Object3D);
      const height = flora.height * t;
      obj.scale.y = height * biomeScale;
      obj.scale.x = height * flora.aspect * biomeScale;
      obj.visible = obj.scale.x >= 1e-5;

      if (isFinite(flora.duration) && curTime >= flora.duration) {
        (0, _threeUtil.detachObject)(obj);
        e.kill();
        obj.userData._entity = null;
        pool.release(obj);
      }
    }
  }; // function killOldest

  function spawn(pos, stateName, inWater, autoKill = true, delay = 0, rad = 1) {
    // const tex = random.pick(textures);
    // if (haikuInventoryView.length === 1) {
    // return;
    // }
    if (!types) return; // not yet loaded

    if (inWater && stateName !== "grasslands") return;
    let mesh = pool.next();

    if (!mesh) {
      return; // killOldest;
    } // const x = pos.x;
    // const z = pos.z;


    mesh.userData._entity = world.entity(); // mesh.position.set(x, 0, z);

    const len = Math.abs(random.gaussian(0, 1)); // tmpPos.copy(char.position).addScaledVector(char.direction, -1 * len);

    tmpPos.set(pos.x, 0, pos.y);
    random.onCircle(random.gaussian(2, 0.35) * rad, tmpArr2D);
    mesh.position.x = tmpArr2D[0] + tmpPos.x;
    mesh.position.z = tmpArr2D[1] + tmpPos.z;
    mesh.position.y = inWater ? 0.05 : 0; // mesh.material.uniforms.flipX.value = random.boolean();

    container.add(mesh);

    mesh.userData._entity.add(Tags.Object3D, mesh).add(Tags.SpawnedFlora).add(Tags.ShaderUniformTime, {
      uniform: mesh.material.uniforms.time
    });

    if (!inWater) mesh.userData._entity.add(Tags.ShadowCaster, spriteOpt);

    const flora = mesh.userData._entity.get(Tags.SpawnedFlora);

    const scalar = inWater ? 0.35 : stateName === "grasslands" ? 1.1 : 1;
    const height = Math.min(1.25, random.gaussian(0.85, 0.5)) * scalar; // mesh.material.uniforms.map.value = tex;

    mesh.visible = false; // const aspect = tex.image.width / tex.image.height;

    flora.height = height; // flora.aspect = aspect;

    let frame;

    if (stateName === "grasslands" && inWater) {
      frame = random.pick(inWater ? types.grasslandsWater : types[stateName]);
    } else {
      const typeArray = types[stateName];
      const N = random.rangeFloor(Math.min(typeArray.length, papers.length));
      frame = typeArray[N];
    }

    mesh.material.uniforms.map.value = frame.texture;
    (0, _threeUtil.shareAtlasTexture)(renderer, spriteSheet.atlases[0], frame.texture);
    mesh.material.uniforms.offset.value.copy(frame.offset);
    mesh.material.uniforms.repeat.value.copy(frame.repeat);
    const aspect = frame.width / frame.height;
    flora.aspect = aspect;
    flora.delay = delay;
    flora.duration = autoKill ? random.range(2, 5) : Infinity;
    flora.spawnTime = (0, _rightNow.default)();
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/ObjectPool":"src/util/ObjectPool.js","../util/three-util":"src/util/three-util.js","fast-2d-poisson-disk-sampling":"node_modules/fast-2d-poisson-disk-sampling/src/fast-poisson-disk-sampling.js","../util/ease-animate":"src/util/ease-animate.js","../util/materials":"src/util/materials.js","../util/EditorWayfinderSprite":"src/util/EditorWayfinderSprite.js","../util/load":"src/util/load.js","./AnimationSystem":"src/systems/AnimationSystem.js","../util/Random":"src/util/Random.js","../util/Assets":"src/util/Assets.js","right-now":"node_modules/right-now/browser.js","eases":"node_modules/eases/index.js","../util/water-util":"src/util/water-util.js","../util/query-string":"src/util/query-string.js","../util/SpriteManager":"src/util/SpriteManager.js"}],"node_modules/parse-unit/index.js":[function(require,module,exports) {
module.exports = function parseUnit(str, out) {
    if (!out)
        out = [ 0, '' ]

    str = String(str)
    var num = parseFloat(str, 10)
    out[0] = num
    out[1] = str.match(/[\d.\-\+]*\s*(.*)/)[1] || ''
    return out
}
},{}],"node_modules/to-px/browser.js":[function(require,module,exports) {
'use strict'

var parseUnit = require('parse-unit')

module.exports = toPX

var PIXELS_PER_INCH = getSizeBrutal('in', document.body) // 96


function getPropertyInPX(element, prop) {
  var parts = parseUnit(getComputedStyle(element).getPropertyValue(prop))
  return parts[0] * toPX(parts[1], element)
}

//This brutal hack is needed
function getSizeBrutal(unit, element) {
  var testDIV = document.createElement('div')
  testDIV.style['height'] = '128' + unit
  element.appendChild(testDIV)
  var size = getPropertyInPX(testDIV, 'height') / 128
  element.removeChild(testDIV)
  return size
}

function toPX(str, element) {
  if (!str) return null

  element = element || document.body
  str = (str + '' || 'px').trim().toLowerCase()
  if(element === window || element === document) {
    element = document.body
  }

  switch(str) {
    case '%':  //Ambiguous, not sure if we should use width or height
      return element.clientHeight / 100.0
    case 'ch':
    case 'ex':
      return getSizeBrutal(str, element)
    case 'em':
      return getPropertyInPX(element, 'font-size')
    case 'rem':
      return getPropertyInPX(document.body, 'font-size')
    case 'vw':
      return window.innerWidth/100
    case 'vh':
      return window.innerHeight/100
    case 'vmin':
      return Math.min(window.innerWidth, window.innerHeight) / 100
    case 'vmax':
      return Math.max(window.innerWidth, window.innerHeight) / 100
    case 'in':
      return PIXELS_PER_INCH
    case 'cm':
      return PIXELS_PER_INCH / 2.54
    case 'mm':
      return PIXELS_PER_INCH / 25.4
    case 'pt':
      return PIXELS_PER_INCH / 72
    case 'pc':
      return PIXELS_PER_INCH / 6
    case 'px':
      return 1
  }

  // detect number of units
  var parts = parseUnit(str)
  if (!isNaN(parts[0]) && parts[1]) {
    var px = toPX(parts[1], element)
    return typeof px === 'number' ? parts[0] * px : null
  }

  return null
}

},{"parse-unit":"node_modules/parse-unit/index.js"}],"node_modules/mouse-wheel/wheel.js":[function(require,module,exports) {
'use strict'

var toPX = require('to-px')

module.exports = mouseWheelListen

function mouseWheelListen(element, callback, noScroll) {
  if(typeof element === 'function') {
    noScroll = !!callback
    callback = element
    element = window
  }
  var lineHeight = toPX('ex', element)
  var listener = function(ev) {
    if(noScroll) {
      ev.preventDefault()
    }
    var dx = ev.deltaX || 0
    var dy = ev.deltaY || 0
    var dz = ev.deltaZ || 0
    var mode = ev.deltaMode
    var scale = 1
    switch(mode) {
      case 1:
        scale = lineHeight
      break
      case 2:
        scale = window.innerHeight
      break
    }
    dx *= scale
    dy *= scale
    dz *= scale
    if(dx || dy || dz) {
      return callback(dx, dy, dz, ev)
    }
  }
  element.addEventListener('wheel', listener)
  return listener
}

},{"to-px":"node_modules/to-px/browser.js"}],"src/systems/UserZoomSystem.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = UserZoomSystem;

var THREE = _interopRequireWildcard(require("three"));

var Tags = _interopRequireWildcard(require("../tags"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _mouseWheel = _interopRequireDefault(require("mouse-wheel"));

var _queryString = _interopRequireDefault(require("../util/query-string"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function UserZoomSystem(world, props) {
  const e = world.entity("UserZoomEntity").add(Tags.UserZoom, props);
  let y = 0;
  let listener;

  if (_queryString.default.zoom) {
    listener = (0, _mouseWheel.default)(world.findTag(Tags.Canvas), (dx, dy, dz, ev) => {
      y += dy;
    }, true);
  }

  return {
    dispose() {
      if (listener) window.removeEventListener("wheel", listener);
    },

    process
  };

  function process(dt) {
    const userZoom = e.get(Tags.UserZoom);
    const {
      allowMouseZoom,
      distance,
      zoomPowFactor,
      zoomPixelsToWorld,
      zoomPowTarget,
      minDistance,
      maxDistance
    } = userZoom;
    if (allowMouseZoom) userZoom.currentWheelOffset += y;
    y = 0;
    const zoomFactor = Math.pow(distance / zoomPowTarget, zoomPowFactor);
    userZoom.distance += userZoom.currentWheelOffset * zoomPixelsToWorld * zoomFactor;
    userZoom.currentWheelOffset = 0;
    userZoom.distance = MathUtil.clamp(userZoom.distance, minDistance, maxDistance);
  }
}
},{"three":"src/vendor/three.module.js","../tags":"src/tags/index.js","../util/math":"src/util/math.js","mouse-wheel":"node_modules/mouse-wheel/wheel.js","../util/query-string":"src/util/query-string.js","process":"node_modules/process/browser.js"}],"src/systems/RenderDebugTargetsSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = RenderDebugTargetsSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _threeUtil = require("../util/three-util");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function RenderDebugTargetsSystem(world) {
  const renderer = world.findTag(Tags.Renderer);
  const debugs = world.view(Tags.DebugRenderTarget);
  const debugEvents = world.listen(Tags.DebugRenderTarget);
  const orthoCam = new THREE.OrthographicCamera();
  const orthoScene = new THREE.Scene();
  const planeGeo = new THREE.PlaneGeometry(1, 1);
  planeGeo.translate(0.5, 0.5, 0);
  return dt => {
    const size = renderer.getSize(new THREE.Vector2());
    orthoCam.left = 0;
    orthoCam.right = size.x;
    orthoCam.top = 0;
    orthoCam.bottom = size.y;
    orthoCam.near = -10;
    orthoCam.far = 10;
    orthoCam.updateProjectionMatrix();
    (0, _threeUtil.clearGroup)(orthoScene);
    const rHeight = 150;
    let offsetY = 25;
    debugs.forEach((e, i) => {
      const {
        target,
        visible
      } = e.get(Tags.DebugRenderTarget);
      if (visible === false) return;
      const aspect = target.width / target.height;
      const h = rHeight;
      const w = h * aspect;
      const x = 25;
      const y = offsetY;
      offsetY += rHeight + 25;
      const mesh = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({
        depthTest: false,
        depthWrite: false,
        map: target.texture,
        side: THREE.DoubleSide
      }));
      mesh.frustumCulled = false;
      mesh.scale.set(w, -h, 1);
      mesh.position.set(x, y + h, 0);
      orthoScene.add(mesh);
    });
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    renderer.render(orthoScene, orthoCam);
    renderer.autoClear = autoClear;
  };
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/three-util":"src/util/three-util.js"}],"node_modules/bezier-easing/src/index.js":[function(require,module,exports) {
/**
 * https://github.com/gre/bezier-easing
 * BezierEasing - use bezier curve for transition easing function
 * by Gaëtan Renaudeau 2014 - 2015 – MIT License
 */

// These values are established by empiricism with tests (tradeoff: performance VS precision)
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;

var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

var float32ArraySupported = typeof Float32Array === 'function';

function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
function C (aA1)      { return 3.0 * aA1; }

// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
function calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }

// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
function getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }

function binarySubdivide (aX, aA, aB, mX1, mX2) {
  var currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2.0;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0.0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
}

function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
 for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
   var currentSlope = getSlope(aGuessT, mX1, mX2);
   if (currentSlope === 0.0) {
     return aGuessT;
   }
   var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
   aGuessT -= currentX / currentSlope;
 }
 return aGuessT;
}

function LinearEasing (x) {
  return x;
}

module.exports = function bezier (mX1, mY1, mX2, mY2) {
  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
    throw new Error('bezier x values must be in [0, 1] range');
  }

  if (mX1 === mY1 && mX2 === mY2) {
    return LinearEasing;
  }

  // Precompute samples table
  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  for (var i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }

  function getTForX (aX) {
    var intervalStart = 0.0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;

    // Interpolate to provide an initial guess for t
    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;

    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }

  return function BezierEasing (x) {
    // Because JavaScript number are imprecise, we should guarantee the extremes are right.
    if (x === 0) {
      return 0;
    }
    if (x === 1) {
      return 1;
    }
    return calcBezier(getTForX(x), mY1, mY2);
  };
};

},{}],"src/systems/UserFollowSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = UserFollowSystem;

var _simplexNoise = _interopRequireDefault(require("simplex-noise"));

var THREE = _interopRequireWildcard(require("three"));

var Tags = _interopRequireWildcard(require("../tags"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _tweenTicker = _interopRequireDefault(require("../util/tween-ticker"));

var _bezierEasing = _interopRequireDefault(require("bezier-easing"));

var _queryString = _interopRequireDefault(require("../util/query-string"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import CameraEditor from "../editor/CameraEditor";
window.zoomLevel = 1;
const noise = new _simplexNoise.default(0);

function UserFollowSystem(world) {
  const entity = world.entity("UserFollowEntity").add(Tags.UserFollow);
  const easeToTarget = (0, _bezierEasing.default)(0.37, 0.08, 0, 1.01);
  const easeToPlayer = (0, _bezierEasing.default)(0.39, 0.21, 0.05, 1.04);
  const cinematicTimeline = (0, _tweenTicker.default)();
  const currentTarget = new THREE.Vector3();
  const cinematicTween = {
    animatingToTarget: false,
    animatingToPlayer: false,
    positionStart: new THREE.Vector3(),
    positionEnd: new THREE.Vector3(),
    value: 0,
    zoom: 0
  };
  const cinematicMoments = world.listen(Tags.CinematicCameraMoment);
  const camFocusOnTarget = world.view(Tags.CameraFocusOnTarget);
  const camFocusOnTargetEvent = world.listen(Tags.CameraFocusOnTarget);
  let first = true;
  const angle = MathUtil.degToRad(45 * -1);
  const r = 1;
  const offset = new THREE.Vector3(1, 1, 1);
  offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle); // const offset = new THREE.Vector3(
  //   Math.cos(angle) * r,
  //   r * 1.0,
  //   Math.sin(angle) * r
  // );

  const postOffset = new THREE.Vector3(); // let zoom = 6.2;
  // let fov = 5;

  const cinematicTweenZoom = 1;
  let presets = [{
    zoom: 2.5,
    fov: 15,
    near: 30,
    far: 150
  }, {
    zoom: 2,
    fov: 20,
    near: 30,
    far: 100
  }, {
    zoom: 1.75,
    fov: 25,
    near: 20,
    far: 100
  }, {
    zoom: 1.33,
    fov: 30,
    near: 1,
    far: 1500
  }];
  let curPreset = presets[0];

  if (_queryString.default.zoom) {
    window.addEventListener("keydown", ev => {
      const c = ev.key;
      const idx = parseInt(c, 10) - 1;

      if (idx >= 0 && idx < presets.length) {
        const userZoom = world.findTag(Tags.UserZoom);
        if (idx === 0) userZoom.distance = userZoom.defaultDistance;
        curPreset = presets[idx];
      }
    });
  }

  const zoomEntity = world.entity();
  const poemZoomView = world.view(Tags.UserInPoemArea);
  const poemCompletingView = world.view(Tags.UserCompletingPoem);
  const cameraStopper = world.entity();
  const frustum = new THREE.Frustum();
  const projScreenMatrix = new THREE.Matrix4();
  const cameraFrustumEntity = world.entity().add(Tags.MainCameraFrustum, frustum);
  let currentUIZoom = 0;
  const cameraZoomOutRadius = 15;
  const cameraZoomOutRadiusSq = cameraZoomOutRadius * cameraZoomOutRadius;
  const appState = world.findTag(Tags.AppState);
  return function userFollowSystem(dt) {
    const userFollow = entity.get(Tags.UserFollow);
    const userZoom = world.findTag(Tags.UserZoom);
    const userZoomDistance = userZoom ? userZoom.distance : 10;
    const camera = world.findTag(Tags.MainCamera);
    const user = world.findEntity(Tags.UserTarget);
    const playerData = user.get(Tags.UserTarget);
    userFollow.shakeTime += dt * userFollow.shakeSpeed; // userFollow.speedZoomDistance * playerData.boostAlpha
    // TODO: decide if we should pull out camera whenever user is near?
    // if (playerData.position.lengthSq() < cameraZoomOutRadiusSq) {
    //   zoomEntity.tagOn(Tags.CameraZoomOut);
    // } else {
    //   zoomEntity.tagOff(Tags.CameraZoomOut);
    // }

    if (playerData.forceApplied) {
      userFollow.speedZoomDistance = MathUtil.damp(userFollow.speedZoomDistance, userFollow.maxSpeedZoomDistance, userFollow.speedZoomSpringIn, dt);
    } else {
      userFollow.speedZoomDistance = MathUtil.damp(userFollow.speedZoomDistance, userFollow.minSpeedZoomDistance, userFollow.speedZoomSpringOut, dt);
    }

    if (first) {
      userFollow.currentDistance = userZoomDistance + userFollow.speedZoomDistance;
      first = false;
    } // cinematicMoments.added.forEach((e) => {
    //   const c = e.get(Tags.CinematicCameraMoment);
    // cinematicTween.value = 0;
    // if (c.copyStart) {
    //   playerData.position.set(c.target.x, 0, c.target.z);
    // }
    // cinematicTween.positionStart.copy(playerData.position);
    // cinematicTween.positionEnd.copy(c.target);
    // cinematicTween.animatingToTarget = true;
    // cameraStopper.add(Tags.CameraStopUserMovement);
    // cinematicTimeline.cancel();
    // cinematicTimeline
    //   .to(cinematicTween, {
    //     value: 1,
    //     duration: c.copyStart ? 2 : 2,
    //     ease: "sineOut",
    //   })
    //   .on("complete", (ev) => {
    //     if (!ev.cancelling) {
    //       cinematicTween.animatingToTarget = false;
    //       cinematicTween.animatingToPlayer = true;
    //       cinematicTween.positionStart.copy(playerData.position);
    //       cinematicTimeline.cancel();
    //       cinematicTimeline
    //         .to(cinematicTween, {
    //           value: 0,
    //           duration: 2,
    //           delay: 1,
    //           ease: "sineIn",
    //         })
    //         .on("complete", (ev) => {
    //           if (ev.cancelling) return;
    //           cameraStopper.remove(Tags.CameraStopUserMovement);
    //           cinematicTween.animatingToTarget = false;
    //           cinematicTween.animatingToPlayer = false;
    //           e.kill();
    //         });
    //     }
    //   });
    // });


    camFocusOnTargetEvent.added.forEach(e => {
      const c = e.get(Tags.CameraFocusOnTarget);
      cinematicTween.value = 0;
      cinematicTween.positionStart.copy(playerData.position);
      cinematicTween.positionEnd.copy(c.target);
      cinematicTween.animatingToTarget = true;
      cinematicTimeline.cancel();
      cinematicTimeline.to(cinematicTween, {
        value: 1,
        duration: 2,
        ease: "sineInOut"
      }).on("complete", ev => {
        if (!ev.cancelling) {
          cinematicTween.animatingToTarget = false;
          cinematicTween.animatingToPlayer = false;
        }
      });
    });
    cinematicTimeline.tick(dt); // if (cinematicTween.animatingToTarget) {
    //   currentTarget
    //     .copy(cinematicTween.positionStart)
    //     .lerp(cinematicTween.positionEnd, cinematicTween.value);
    // } else if (cinematicTween.animatingToPlayer) {
    //   currentTarget
    //     .copy(cinematicTween.positionEnd)
    //     .lerp(playerData.position, 1 - cinematicTween.value);
    // } else {
    //   currentTarget.copy(playerData.position);
    // }

    if (camFocusOnTarget.length) {
      const t = camFocusOnTarget[0].get(Tags.CameraFocusOnTarget).target;
      currentTarget.copy(cinematicTween.positionStart).lerp(cinematicTween.positionEnd, cinematicTween.value);
    } else {
      currentTarget.copy(playerData.position);
    } // cinematicTween.zoom = cinematicTween.value * cinematicTweenZoom;


    const cameraZoomOut = Boolean(world.findTag(Tags.CameraZoomOut));
    const uiZoom = cameraZoomOut ? 2 : 0;
    currentUIZoom = MathUtil.damp(currentUIZoom, uiZoom, 2, dt);
    userFollow.currentDistance = MathUtil.damp(userFollow.currentDistance, userZoomDistance + userFollow.speedZoomDistance + // cinematicTween.zoom +
    currentUIZoom + playerData.totalBoost * 0.1, userFollow.distanceSpring, dt); // console.log(offset, zoom, userFollow.currentDistance);

    camera.position.copy(currentTarget);
    camera.position.addScaledVector(offset, curPreset.zoom * userFollow.currentDistance);
    userFollow.currentTarget.copy(currentTarget);
    camera.lookAt(currentTarget);
    camera.position.add(postOffset);
    camera.fov = curPreset.fov;
    camera.near = curPreset.near;
    camera.far = curPreset.far;
    camera.matrixAutoUpdate = false; // cam shake

    const ampl = userFollow.shake;
    const shakeTime = userFollow.shakeTime;
    camera.position.x += noise.noise3D(shakeTime, camera.position.y, camera.position.z) * ampl;
    camera.position.y += noise.noise3D(camera.position.x, shakeTime, camera.position.z) * ampl;
    camera.position.z += noise.noise3D(camera.position.x, camera.position.y, shakeTime) * ampl;
    let cameraZoom = 1; // if (aspect > 1) cameraZoom *= aspect;
    // else cameraZoom = 1;

    const targetAspect = 1440 / 900;
    const targetZoomAtAspect = 0.9;
    const minZoom = 0.85;
    const maxZoom = 1.5;
    const currentAspect = appState.width / appState.height;
    const targetFactor = currentAspect / targetAspect;
    const constantZoomFactor = 0.9;
    cameraZoom = MathUtil.clamp(targetZoomAtAspect * targetFactor, minZoom, maxZoom) * constantZoomFactor; // aspect <= 0.7 = 0.8 level zoom
    // aspect <= 2 = 0.8

    camera.zoom = cameraZoom;
    camera.updateMatrix();
    camera.updateMatrixWorld();
    camera.updateProjectionMatrix();
    projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    frustum.setFromProjectionMatrix(projScreenMatrix);
  };
}
},{"simplex-noise":"node_modules/simplex-noise/simplex-noise.js","three":"src/vendor/three.module.js","../tags":"src/tags/index.js","../util/math":"src/util/math.js","../util/tween-ticker":"src/util/tween-ticker.js","bezier-easing":"node_modules/bezier-easing/src/index.js","../util/query-string":"src/util/query-string.js"}],"src/systems/ShaderUniformSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ShaderUniformSystem;

var THREE = _interopRequireWildcard(require("three"));

var Tags = _interopRequireWildcard(require("../tags"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ShaderUniformSystem(world) {
  world.system.info({
    hidden: true
  });
  const resolutions = world.view(Tags.ShaderUniformResolution);
  const timeUniforms = world.view(Tags.ShaderUniformTime);
  const userTargetPositions = world.view(Tags.ShaderUniformUserTargetPosition);
  const userCharacterPositions = world.view(Tags.ShaderUniformUserCharacterPosition);
  const sizeVec = new THREE.Vector2();
  const renderer = world.findTag(Tags.Renderer);
  const appState = world.findTag(Tags.AppState);
  return function shaderUniformSystem(dt) {
    sizeVec.x = appState.width;
    sizeVec.y = appState.height;
    resolutions.forEach(e => {
      const d = e.get(Tags.ShaderUniformResolution);

      if (d.uniform) {
        d.uniform.value.set(sizeVec.x, sizeVec.y);
      }
    });
    timeUniforms.forEach(e => {
      const u = e.get(Tags.ShaderUniformTime);
      u.elapsed += dt;

      if (u.uniform) {
        u.uniform.value = u.elapsed;
      }
    });
    const target = world.findTag(Tags.UserTarget).position;
    const character = world.findTag(Tags.UserCharacter).position;
    userTargetPositions.forEach(e => {
      const u = e.get(Tags.ShaderUniformUserTargetPosition);

      if (u.uniform) {
        u.uniform.value.copy(target);
      }
    });
    userCharacterPositions.forEach(e => {
      const u = e.get(Tags.ShaderUniformUserCharacterPosition);

      if (u.uniform) {
        u.uniform.value.copy(character);
      }
    });
  };
}
},{"three":"src/vendor/three.module.js","../tags":"src/tags/index.js"}],"node_modules/deep-clone/lib/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = deepClone;
exports.formatKeys = formatKeys;
function deepClone(obj, format) {
  var refs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();

  var cloned = refs.get(obj);
  if (cloned) return cloned;
  if (Array.isArray(obj)) {
    var _clone = [];
    refs.set(obj, _clone);
    for (var i = 0; i < obj.length; i++) {
      _clone[i] = deepClone(obj[i], format, refs);
    }
    return _clone;
  }
  if (obj instanceof Date) return new Date(obj.valueOf());
  if (!(obj instanceof Object)) return obj;
  var clone = {};
  refs.set(obj, clone);
  var keys = Object.keys(obj);
  for (var _i = 0; _i < keys.length; _i++) {
    var key = format ? format(keys[_i]) : keys[_i];
    clone[key] = deepClone(obj[keys[_i]], format, refs);
  }
  return clone;
}

function formatKeys(format) {
  return function (obj) {
    return deepClone(obj, format);
  };
}

deepClone.formatKeys = formatKeys;
},{}],"node_modules/deep-clone/index.js":[function(require,module,exports) {
module.exports = require('./lib').default

},{"./lib":"node_modules/deep-clone/lib/index.js"}],"src/systems/LoadJSONSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = LoadJSONSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _deepClone = _interopRequireDefault(require("deep-clone"));

var _threeUtil = require("../util/three-util");

var _EditorWayfinderSprite = require("../util/EditorWayfinderSprite");

var _materials = require("../util/materials");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import scene0 from "../assets/models/scenegrass.jsonw";
// import scene1 from "../assets/models/scene-empty.json";
// import { Assets } from "./AssetLoaderSystem";
async function LoadJSONSystem(world) {
  const group = new THREE.Group();
  world.entity().add(Tags.Object3D, group); // const noiseMap = await world
  //   .findTag(Tags.AssetCache)
  //   .request(Assets.SpriteNoiseMap);
  // let a = true;
  // setInterval(() => {
  //   a = !a;
  //   load(a ? scene0 : scene1);
  // }, 1000);
  // (async () => {
  //   const resp = await fetch(scene0);
  //   const json = await resp.json();
  //   load(json);
  // })();
  // load(testscene);

  return {
    process(dt) {},

    load
  };

  async function load(json) {
    json = (0, _deepClone.default)(json);
    group.traverse(child => {
      if (child.userData._entity) {
        child.userData._entity.kill();

        delete child.userData._entity;
        (0, _threeUtil.pruneUserData)(child);
      }
    });
    (0, _threeUtil.disposeTree)(group, {
      textures: true
    });
    const loader = new THREE.ObjectLoader();
    const scene = await new Promise(resolve => {
      loader.parse(json, resolve);
    });
    scene.traverse(child => {
      (0, _threeUtil.pruneUserData)(child);

      if (child.isMesh) {
        const isSprite = child.isSprite || child.userData.type === "WayfinderSprite";

        if (isSprite) {
          (0, _EditorWayfinderSprite.setMeshToSprite)(world, child);
          child.userData._entity = world.entity().add(Tags.Object3D, child).add(Tags.ShaderUniformTime, {
            uniform: child.material.uniforms.time
          }).add(Tags.ShadowCaster, {
            sprite: true
          });
        } else if (child.material) {
          const map = child.material.map;
          const tag = child.userData ? child.userData.tag : null;
          const ignoreGround = tag ? tag.includes("noshadow") || tag.includes("noground") : false;

          if (ignoreGround) {
            child.material.alphaTest = 0.5;
            child.material.transparent = true;
          }

          child.material = (0, _materials.createMeshMaterial)(world, child, {
            map,
            ignoreGround
          });
          child.userData._entity = world.entity().add(Tags.Object3D, child);
          if (!ignoreGround) child.userData._entity.add(Tags.ShadowCaster, {
            sprite: false
          });
        }
      } // if (
      //   child.isMesh &&
      //   child.material.isMeshBasicMaterial &&
      //   child.userData.type !== "WayfinderSprite"
      // ) {
      //   const map = child.material.map;
      //   child.material = createToonShader(world, child, map);
      //   child.userData._entity = world
      //     .entity()
      //     .add(Tags.Object3D, child)
      //     .add(Tags.ShadowCaster, { sprite: false });
      // }
      // if (child.userData.type === "WayfinderSprite") {
      //   child.userData._entity = world
      //     .entity()
      //     .add(Tags.Object3D, child)
      //     .add(Tags.ShadowCaster, { sprite: true });
      // }

    });
    group.add(scene);
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","deep-clone":"node_modules/deep-clone/index.js","../util/three-util":"src/util/three-util.js","../util/EditorWayfinderSprite":"src/util/EditorWayfinderSprite.js","../util/materials":"src/util/materials.js"}],"src/systems/TreeSpriteAnimationSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = TreeSpriteAnimationSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _SpriteManager = _interopRequireDefault(require("../util/SpriteManager"));

var _load = require("../util/load");

var _threeUtil = require("../util/three-util");

var _Assets = _interopRequireDefault(require("../util/Assets"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const sheetIds = {
  forest: "spritesheets/tree-anim-a",
  grasslands: "spritesheets/tree-anim-b",
  tundra: "spritesheets/tree-anim-c"
}; // Assets.prepare(sheets.forest);

function TreeSpriteAnimationSystem(world) {
  const renderer = world.findTag(Tags.Renderer);
  const activeEnv = world.view(Tags.ActiveEnvironmentState);
  const animationView = world.view([Tags.Object3D, Tags.SpriteAnimation, Tags.SpriteAnimationOriginTreeTag]);
  let currentBiome = null;
  let currentSheet;
  let tundraSheet;
  const endGameView = world.view(Tags.EndGameState);
  const outroFinishedView = world.view(Tags.OutroFinished);
  return function TreeSpriteAnimationSystem(dt) {
    let biome;

    if (activeEnv.length) {
      biome = activeEnv[0].get(Tags.EnvironmentState).name;

      if (biome !== currentBiome) {
        currentBiome = biome;

        if (endGameView.length === 0 && outroFinishedView.length === 0) {
          // console.log("[sheet] CLEARING!");
          currentSheet = null; // clear current sheet so we don't render the wrong image
          // load the new asset ID and set sheet

          const id = sheetIds[biome];
          (0, _SpriteManager.default)(id, renderer).then(sheet => {
            currentSheet = sheet;
            if (biome === "tundra") tundraSheet = sheet;
          });
        }
      }
    } // console.log("trees", animationView.length);


    animationView.forEach(e => {
      const d = e.get(Tags.SpriteAnimation); // update current sheet

      let oldSheet = d.sheet;
      d.sheet = outroFinishedView.length > 0 ? tundraSheet : currentSheet; // console.log("SPRITE TREE", d.sheet);

      if (oldSheet !== d.sheet) {}

      if (biome === "tundra") {
        e.get(Tags.Object3D).position.y = -0.25;
      }

      if (d.sheet && outroFinishedView.length > 0) {
        //
        const frameIndex = d.sheet.frames.length - 1;
        const oldFrame = d.frame;
        d.frame = frameIndex;
        d.playing = false;

        if (oldSheet !== d.sheet || oldFrame !== d.frame) {
          d.dirty = true;
        }
      }
    });
  };

  function setFrame(object, frame) {
    const material = object.material;
    const tex = material.uniforms.map.value;
    (0, _threeUtil.shareAtlasTexture)(renderer, frame.atlas, tex);
    material.uniforms.repeat.value.copy(frame.repeat);
    material.uniforms.offset.value.copy(frame.offset);
  }
}

function getFrameIndex(time, fps, totalFrames, loop) {
  const duration = fps * totalFrames;
  if (!loop && time >= duration) return totalFrames - 1;
  const timeOffset = 0;
  const playMode = 0;
  const intervalMS = 1 / fps * 1000;
  const timeMS = Math.round(time * 1000 / intervalMS) * intervalMS;
  const N = totalFrames;
  const elapsed = timeMS / 1000;
  const playDirection = 1;
  let curFrameReal = fps * elapsed * playDirection;
  curFrameReal = MathUtil.wrap(curFrameReal, 0, N);
  let curFrame = Math.floor(curFrameReal);
  const fract = curFrameReal - curFrame;
  curFrame = Math.max(0, Math.min(curFrame, totalFrames - 1));
  return curFrame;
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/math":"src/util/math.js","../util/SpriteManager":"src/util/SpriteManager.js","../util/load":"src/util/load.js","../util/three-util":"src/util/three-util.js","../util/Assets":"src/util/Assets.js"}],"src/systems/TextSpriteSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = TextSpriteSystem;

var _silkamonoRegularitalicWebfont = _interopRequireDefault(require("../assets/font/SilkaMono/silkamono-regularitalic-webfont.woff2"));

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _createPlaneSprite = _interopRequireDefault(require("../util/createPlaneSprite"));

var _threeUtil = require("../util/three-util");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function TextSpriteSystem(world) {
  world.system.info({
    hidden: true
  });
  const events = world.listen(Tags.TextSprite3D);
  const sprites = world.view(Tags.TextSprite3D);
  const createSprite = await createFastTextSprites();
  return dt => {
    events.added.forEach(e => {
      const opt = e.get(Tags.TextSprite3D);
      const sprite = createSprite(opt.text, opt.fontSize, opt.x, opt.y, opt.culling, opt.depth);
      opt.sprite = sprite;

      if (opt.parent) {
        opt.parent.add(opt.sprite);
      }
    });
    events.removing.forEach(e => {
      const opt = e.get(Tags.TextSprite3D);
      if (opt.sprite && opt.sprite.parent) (0, _threeUtil.detachObject)(opt.sprite);
    });
    sprites.forEach(e => {
      const data = e.get(Tags.TextSprite3D);

      if (data.sprite) {
        data.sprite.material.uniforms.opacity.value = data.opacity;
        data.sprite.material.uniforms.color.value.copy(data.color);
      }
    });
  };
}

async function createFastTextSprites() {
  const font = new window.FontFace("SilkaMono", `url(${_silkamonoRegularitalicWebfont.default})`, {
    family: "SilkaMono",
    style: "italic",
    weight: 400
  }); // We use async/await ES6 syntax to wait for the font to load

  await font.load(); // Add the loaded font to the document

  document.fonts.add(font);
  const plane = new THREE.PlaneGeometry(1, 1, 1, 1);
  return (text, fontSize = 32, x = 0, y = 0, culling = true, depth = true) => {
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    const padding = 2.5;
    const font = `italic ${fontSize}px "SilkaMono", sans-serif`;
    context.font = font;
    context.textAlign = "center";
    context.textBaseline = "middle";
    const textWidth = context.measureText(text).width;
    const pixelRatio = 512 / textWidth;
    const width = Math.round(textWidth + padding * 2);
    const height = Math.round(fontSize + padding * 2);
    canvas.width = Math.round(width * pixelRatio);
    canvas.height = Math.round(height * pixelRatio);
    context.fillStyle = "white";
    context.font = font;
    context.textAlign = "center";
    context.textBaseline = "middle";
    context.save();
    context.scale(pixelRatio, pixelRatio);
    context.clearRect(0, 0, width, height); // context.fillStyle = inverse ? "white" : "black";
    // context.fillRect(0, 0, width, height);

    context.fillStyle = "white";
    context.fillText(text, width / 2, height / 2);
    context.restore();
    const map = new THREE.CanvasTexture(canvas);
    map.premultiplyAlpha = false;
    map.needsUpdate = true;
    map.generateMipmaps = false;
    map.minFilter = THREE.LinearFilter; // const sprite = new THREE.Sprite(
    //   new THREE.SpriteMaterial({
    // map,
    // blending: THREE.AdditiveBlending,
    // transparent: true,
    // opacity: 1,
    // depthTest: false,
    // depthWrite: false,
    // side: THREE.DoubleSide,
    //   })
    // );

    const sprite = (0, _createPlaneSprite.default)({
      geometry: plane,
      map,
      rgba: true,
      // blending: inverse ? THREE.MultiplyBlending : THREE.AdditiveBlending,
      transparent: true,
      opacity: 1,
      depthTest: depth,
      depthWrite: depth,
      side: THREE.DoubleSide
    });
    sprite.renderOrder = 20;
    sprite.material.uniforms.translate.value.x = x;
    sprite.material.uniforms.translate.value.y = y;
    sprite.frustumCulled = culling;
    const aspect = width / height;
    const visibleScale = textWidth * 0.02;
    sprite.scale.set(1, 1 / aspect, 1).multiplyScalar(visibleScale);
    return sprite;
  };
}
},{"../assets/font/SilkaMono/silkamono-regularitalic-webfont.woff2":"src/assets/font/SilkaMono/silkamono-regularitalic-webfont.woff2","../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/createPlaneSprite":"src/util/createPlaneSprite.js","../util/three-util":"src/util/three-util.js"}],"src/shaders/ground-patch-instance.vert.js":[function(require,module,exports) {
module.exports = "#define GLSLIFY 1\nattribute vec2 offset;\nattribute float scale;\nattribute vec4 spriteCoords;\nattribute float spriteAspect;\n\nuniform bool useSpriteAtlas;\nuniform float spriteMapAspect;\n\nuniform sampler2D groundMap;\nuniform sampler2D worldDataMap;\nuniform sampler2D waterMap;\n// uniform sampler2D worldGrassMap;\n\nuniform bool worldDataMapEnabled;\nuniform float time;\nuniform float globalSpriteScale;\nuniform vec2 spriteTextureAtlasSize;\nuniform vec2 spriteTextureSize;\nuniform float spriteTextureAtlasColumns;\nuniform mat4 groundProjectionMatrix;\nuniform vec2 worldMapSize;\nuniform vec3 userTargetWorldPosition;\n\nuniform mat4 worldDataProjection;\nuniform mat4 worldDataView;\n\nvarying float vDataScale;\n\nvarying vec2 vDataUv;\nvarying vec3 vGroundColor;\n// varying float vSpriteIndex;\nvarying vec2 vUv;\nvarying vec2 vScreenUv;\nvarying vec2 vGroundUv;\nvarying vec2 vWorldUv;\nvarying vec2 vOriginalUv;\nvarying float vHighlight;\nvarying float gradientY;\nvarying vec3 vGrassColor;\n\n// #pragma glslify: noise = require('glsl-noise/simplex/3d')\n\n#define TRUE_FIXED_BLEND\n\n//returns -1.0 if x < 0, and 1.0 if x >= 0\nfloat sign01 (float x) {\n  return x < 0.0 ? -1.0 : 1.0;\n  // return step(0.0, x) * 2.0 - 1.0;\n}\n\nfloat hash(vec2 p)  // replace this by something better\n{\n  p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n  return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat fastnoise( in vec2 p )\n{\n  vec2 i = floor( p );\n  vec2 f = fract( p );\n  vec2 u = f*f*(3.0-2.0*f);\n  return mix( mix( hash( i + vec2(0.0,0.0) ), \n                   hash( i + vec2(1.0,0.0) ), u.x),\n              mix( hash( i + vec2(0.0,1.0) ), \n                   hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat smoothCurve(float x)\n{\n\treturn x * x * (3.0 - 2.0 * x);\n}\n\nfloat triangleWave(float x)\n{\n\treturn abs(fract(x + 0.5) * 2.0 - 1.0);\n}\n\nfloat smoothTriangleWave(float x)\n{\n  // return sin(x);\n\treturn smoothCurve(triangleWave(x)) * 2.0 - 1.0;\n}\n\nvec2 range(vec2 vmin, vec2 vmax, vec2 value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nfloat manhattanDistance(vec2 p1, vec2 p2) {\n  float d1 = abs(p1.x - p2.x);\n  float d2 = abs(p1.y - p2.y);\n  return d1 + d2;\n}\n\nfloat insideBox(vec2 v, vec2 bottomLeft, vec2 topRight) {\n  vec2 s = step(bottomLeft, v) - step(topRight, v);\n  return s.x * s.y;\n}\n\nvec3 opCheapBend( vec3 p, float angle )\n{\n    float c = cos(angle*p.y);\n    float s = sin(angle*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    c, 0.0, -s,\n    0.0, 1.0, 0.0,\n    s, 0.0, c\n  );\n}\n\nmat3 rotation3dX(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, c, s,\n\t\t0.0, -s, c\n\t);\n}\nmat3 rotation3dZ(float angle) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\n\treturn mat3(\n\t\tc, s, 0.0,\n\t\t-s, c, 0.0,\n\t\t0.0, 0.0, 1.0\n\t);\n}\n\nvoid main() {\n  float absScale = abs(scale);\n  vec3 offsetPos = vec3(offset.x, 0.0, offset.y);\n  vec2 spriteRepeat = useSpriteAtlas ? spriteCoords.xy : vec2(1.0);\n  vec2 spriteOffset = useSpriteAtlas ? spriteCoords.zw : vec2(0.0);\n  vec2 spriteCoord = uv;\n  if (scale < 0.0) spriteCoord.x = (1.0 - spriteCoord.x);\n  spriteCoord *= spriteRepeat;\n  spriteCoord += spriteOffset;\n  vOriginalUv = uv;\n  // if (scale < 0.0) spriteCoord.x = 1.0 - spriteCoord.x;\n  // spriteCoord.x += spriteIndex;\n  // spriteCoord.x *= 1.0 / spriteTextureAtlasColumns;\n  // if (spriteIndex < 1.5) gradientY += 0.15;\n\n  vec3 centerWorldPos = (modelMatrix * vec4(offsetPos, 1.0)).xyz;\n  vec3 camRightWorld = vec3(viewMatrix[0].x, viewMatrix[1].x, viewMatrix[2].x);\n  vec3 camUpWorld = vec3(viewMatrix[0].y, viewMatrix[1].y, viewMatrix[2].y);\n\n  vWorldUv = range(\n    -vec2(worldMapSize / 2.0),\n    vec2(worldMapSize / 2.0),\n    centerWorldPos.xz\n  );\n  vWorldUv.y = 1.0 - vWorldUv.y;\n\n  // float wdist = 0.1;\n  // float wd = distance(vWorldUv, vec2(0.5)) / wdist;\n  // float wt = 0.4;\n  // float wg = 0.1;\n  // wd = smoothstep(wt - wg, wt + wg, wd);\n  // float distFromCenter = clamp(wd, 0.0, 1.0);\n  // absScale *= distFromCenter;\n\n  float water = texture2D(waterMap, vWorldUv).r;\n  absScale *= 1.0 - water;\n\n  float wdist = 0.04;\n  float wd = distance(vWorldUv, vec2(0.5, 0.5)) / wdist;\n  float wt = 0.5;\n  float wg = 0.45;\n  wd = smoothstep(wt - wg, wt + wg, wd);\n  float distFromCenter = clamp(wd, 0.0, 1.0);\n  absScale *= distFromCenter;\n\n  // camRightWorld *= rotation3dZ(sin(time) * position.y);\n\n  \n  // vec2 centerWorldUv = range(\n  //   -vec2(worldMapSize / 2.0),\n  //   vec2(worldMapSize / 2.0),\n  //   centerWorldPos.xz\n  // );\n  // centerWorldUv.y = 1.0 - centerWorldUv.y;\n\n  // vec2 envPosInWorldPos = (centerWorldUv * 2.0 - 1.0) * worldMapSize / 2.0;\n  vec4 vDataUvPos4 = worldDataProjection * worldDataView * vec4(centerWorldPos.xz, 0.0, 1.0);\n  vec2 vDataScreen = vDataUvPos4.xy / vDataUvPos4.w;\n  vDataUv = vDataScreen.xy * 0.5 + 0.5;\n\n  // vec3 \n\n  // vec4 centerClipPos = projectionMatrix * viewMatrix * vec4(centerWorldPos, 1.0);\n  // vec2 center2D = centerClipPos.xy / centerClipPos.w;\n  // float distanceScale = manhattanDistance(center2D.xy, vec2(0.0));\n  // vec4 dataColor = texture2D(worldDataMap, centerWorldUv);\n  vec3 dCol = texture2D(worldDataMap, vDataUv).rgb;\n  // float dirAngle = (dCol.g * 2.0 - 1.0) * 3.14;\n  vec2 curDirection2D = vec2(dCol.gb) * 2.0 - 1.0;\n  vec3 curDirection = vec3(curDirection2D.x, 0.0, curDirection2D.y);\n  \n  float dScale = dCol.r;\n  // float dScale = 0.0;\n  float dataScale = 1.0 + dScale * 0.0;\n  vDataScale = dScale;\n  // float dataScale = 1.0; // green is leaf growth\n  float dataMove = 1.0;\n  \n  vec3 grassColor = vec3(1.0);\n  vGrassColor = grassColor;\n\n  // dataScale = smoothstep(1.75, 1.25, dataScale);\n  // float worldRadius = 30.0;\n  // float dataScale = 1.0 - clamp(distance(centerWorldPos, userTargetWorldPosition) / worldRadius, 0.0, 1.0);\n  // dataScale = smoothstep(0.0, 0.5, dataScale);\n  // vec3 modifiedCamUpWorld = normalize(camUpWorld + curDirection * 0.25);\n\n  // float aspect = 418.0/419.0;\n  // float aspect = spriteRepeat.x / spriteRepeat.y;\n  float aspect = useSpriteAtlas ? spriteAspect : spriteMapAspect;\n\n  float billboardSize01 = globalSpriteScale * absScale;\n  float billboardSize = dataScale * billboardSize01;\n  vec3 vertexStraightWorldPos = (centerWorldPos)\n    + camRightWorld * position.x * billboardSize * aspect\n    + camUpWorld * position.y * billboardSize;\n\n  float moveGradientY = clamp(vertexStraightWorldPos.y / 0.5, 0.0, 1.0);\n  gradientY = pow(clamp(vertexStraightWorldPos.y / 1.0, 0.0, 1.0), 1.25);\n\n  float scaleTime = time * 0.1;\n  // float noiseValue = (\n  //   smoothTriangleWave(scaleTime + centerWorldPos.x * 0.05 + centerWorldPos.z * -0.01) * 0.5 +\n  //   smoothTriangleWave(scaleTime + centerWorldPos.z * 0.05) * 0.25 + \n  //   sin(scaleTime + centerWorldPos.y * 0.1) * 0.25\n  // );\n\n  float noiseValue = 0.0;\n  noiseValue += cos(time * 2.0 + centerWorldPos.x * 0.5) * 0.33;\n  noiseValue += sin(time + centerWorldPos.z * 0.25) * 0.33;\n  noiseValue += sin(time + centerWorldPos.x * 0.25) * 0.33;\n  noiseValue = clamp(noiseValue, -1.0, 1.0);\n\n  float invDScale = 1.0;\n  camUpWorld *= rotation3dZ(noiseValue * 3.14 * 0.25 * moveGradientY * invDScale);\n\n  vec3 vertexWorldPos = (centerWorldPos)\n    + camRightWorld * position.x * billboardSize * aspect\n    + camUpWorld * position.y * billboardSize;\n  \n  // vec3 axisDirection = \n  \n  // noiseValue += sin(time * 0.75 + centerWorldPos.x * 0.2) * 0.25;\n  // noiseValue += sin(time * 0.75 + centerWorldPos.z * 0.2) * 0.25;\n  // noiseValue += sin(time * 0.85 + centerWorldPos.z * 0.2) * 0.25;\n  // noiseValue += cos(time * 0.25 + centerWorldPos.x * 0.1) * 0.25;\n  // noiseValue = smoothstep(0.2, 0.8, noiseValue * 0.5 + 0.5) * 2.0 - 1.0;\n\n  float skewValue = gradientY * noiseValue;\n  float skewScaled = skewValue * 0.25* invDScale;\n  \n  // vertexWorldPos *= rotationMatrix(vec3(0.0, 1.0, 0.0), sin(time) * 2.0);\n\n  vertexWorldPos += camRightWorld * skewScaled;\n  vertexWorldPos.xyz += curDirection * 0.1 * dScale;\n  vertexWorldPos.xyz += curDirection * gradientY * 0.66 * dScale;\n\n  // vertexWorldPos += dScale * moveGradientY * camRightWorld * curDirection.xyz * 1.0;\n  // vertexWorldPos += dScale * moveGradientY * camRightWorld * curDirection.xyz * 0.5;\n\n  vec3 vertexWorldBasePos = (centerWorldPos)\n    + camRightWorld * position.x * billboardSize * aspect\n    + camUpWorld * position.y * billboardSize;\n  \n  // vec3 vertexWorldBasePos = centerWorldPos;\n  \n\n  vec4 baseClipPos = groundProjectionMatrix * viewMatrix * vec4(vertexWorldBasePos, 1.0);\n  vec4 clipPos = projectionMatrix * viewMatrix * vec4(vertexWorldPos, 1.0);\n  vGroundUv = baseClipPos.xy / baseClipPos.w * 0.5 + 0.5;\n  // vGroundUv = clamp(vGroundUv, 0.0, 1.0);\n  vGroundColor = texture2D(groundMap, vGroundUv).rgb;\n  // vGroundUv = baseClipPos.xy / baseClipPos.w * 0.5 + 0.5;\n  // vGroundUv = floor(vGroundUv / 0.05) * 0.05;\n  \n  // if (absScale > 2.35) vGroundColor = vec3(1.0,0.0,0.0);\n  vUv = spriteCoord;\n  // if (scale < 0.0) vUv.x = 1.0 - vUv.x;\n\n  gl_Position = clipPos;\n  // vec4 mvPosition = modelViewMatrix * vec4(offsetPos, 1.0);\n  // vec2 mvScale;\n  // mvScale.x = length(modelMatrix[0].xyz);\n  // mvScale.y = length(modelMatrix[1].xyz);\n  // mvScale *= globalSpriteScale * absScale;\n  // vec2 mvOffset = mvScale * position.xy;\n\n  // vec3 worldPos = centerWorldPos;\n  // worldPos.xy += mvOffset;\n\n  // vec4 groundPoint = mvPosition;\n\n  // mvPosition.xy += mvOffset;\n  // mvPosition.x -= skewScaled * mvScale.x;\n\n  // #if defined(TRUE_BLEND)\n  // groundPoint.x += mvScale.x * position.x - skewScaled * mvScale.x;\n  // #elif defined(TRUE_FIXED_BLEND)\n  // groundPoint.x += mvScale.x * position.x;\n  // #endif\n\n  // vec4 screenPointSolid = groundProjectionMatrix * groundPoint;\n  // vGroundUv = screenPointSolid.xy / screenPointSolid.w * 0.5 + 0.5;\n  // gl_Position = projectionMatrix * mvPosition;\n\n  \n  // vec3 worldPos = \n  // const x = (u * environment.size) / 2;\n  // const z = (v * environment.size) / 2;\n  // vWorldUv = \n\n  // inverseLerp(-environment.size / 2, environment.size / 2, position.x) *\n  //         2 -\n  //       1;\n  \n  // vSpriteIndex = spriteIndex;\n  vHighlight = noiseValue * 0.5 + 0.5;\n  vScreenUv = gl_Position.xy / gl_Position.w * 0.5 + 0.5;\n}\n";
},{}],"src/shaders/ground-patch-instance.frag.js":[function(require,module,exports) {
module.exports = "#define GLSLIFY 1\nuniform sampler2D groundMap;\nuniform sampler2D worldMap;\nuniform sampler2D worldDataMap;\nuniform sampler2D spriteMap;\n\nuniform vec2 spriteTextureAtlasSize;\nuniform vec3 spriteColor;\nuniform vec3 highlightColor;\nuniform bool isSplitColor;\nuniform vec2 spriteTextureSize;\nuniform float highlightFactor;\nuniform vec2 resolution;\nuniform bool worldGrassMapEnabled;\n\nvarying vec2 vDataUv;\nvarying float vDataScale;\nvarying vec3 vGroundColor;\nvarying vec2 vUv;\nvarying vec2 vGroundUv;\nvarying vec2 vScreenUv;\nvarying vec2 vWorldUv;\nvarying vec3 vGrassColor;\nvarying float vHighlight;\nvarying vec2 vOriginalUv;\nvarying float gradientY;\n\nuniform float grassTipFactor;\n\nuniform sampler2D map;\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n\nfloat dither8x8(vec2 position, float brightness) {\n  int x = int(mod(position.x, 8.0));\n  int y = int(mod(position.y, 8.0));\n  int index = x + y * 8;\n  float limit = 0.0;\n\n  if (x < 8) {\n    if (index == 0) limit = 0.015625;\n    if (index == 1) limit = 0.515625;\n    if (index == 2) limit = 0.140625;\n    if (index == 3) limit = 0.640625;\n    if (index == 4) limit = 0.046875;\n    if (index == 5) limit = 0.546875;\n    if (index == 6) limit = 0.171875;\n    if (index == 7) limit = 0.671875;\n    if (index == 8) limit = 0.765625;\n    if (index == 9) limit = 0.265625;\n    if (index == 10) limit = 0.890625;\n    if (index == 11) limit = 0.390625;\n    if (index == 12) limit = 0.796875;\n    if (index == 13) limit = 0.296875;\n    if (index == 14) limit = 0.921875;\n    if (index == 15) limit = 0.421875;\n    if (index == 16) limit = 0.203125;\n    if (index == 17) limit = 0.703125;\n    if (index == 18) limit = 0.078125;\n    if (index == 19) limit = 0.578125;\n    if (index == 20) limit = 0.234375;\n    if (index == 21) limit = 0.734375;\n    if (index == 22) limit = 0.109375;\n    if (index == 23) limit = 0.609375;\n    if (index == 24) limit = 0.953125;\n    if (index == 25) limit = 0.453125;\n    if (index == 26) limit = 0.828125;\n    if (index == 27) limit = 0.328125;\n    if (index == 28) limit = 0.984375;\n    if (index == 29) limit = 0.484375;\n    if (index == 30) limit = 0.859375;\n    if (index == 31) limit = 0.359375;\n    if (index == 32) limit = 0.0625;\n    if (index == 33) limit = 0.5625;\n    if (index == 34) limit = 0.1875;\n    if (index == 35) limit = 0.6875;\n    if (index == 36) limit = 0.03125;\n    if (index == 37) limit = 0.53125;\n    if (index == 38) limit = 0.15625;\n    if (index == 39) limit = 0.65625;\n    if (index == 40) limit = 0.8125;\n    if (index == 41) limit = 0.3125;\n    if (index == 42) limit = 0.9375;\n    if (index == 43) limit = 0.4375;\n    if (index == 44) limit = 0.78125;\n    if (index == 45) limit = 0.28125;\n    if (index == 46) limit = 0.90625;\n    if (index == 47) limit = 0.40625;\n    if (index == 48) limit = 0.25;\n    if (index == 49) limit = 0.75;\n    if (index == 50) limit = 0.125;\n    if (index == 51) limit = 0.625;\n    if (index == 52) limit = 0.21875;\n    if (index == 53) limit = 0.71875;\n    if (index == 54) limit = 0.09375;\n    if (index == 55) limit = 0.59375;\n    if (index == 56) limit = 1.0;\n    if (index == 57) limit = 0.5;\n    if (index == 58) limit = 0.875;\n    if (index == 59) limit = 0.375;\n    if (index == 60) limit = 0.96875;\n    if (index == 61) limit = 0.46875;\n    if (index == 62) limit = 0.84375;\n    if (index == 63) limit = 0.34375;\n  }\n\n  return brightness < limit ? 0.0 : 1.0;\n}\n\nvec3 dither8x8(vec2 position, vec3 color) {\n  return color * dither8x8(position, luma(color));\n}\n\nvec4 dither8x8(vec2 position, vec4 color) {\n  return vec4(color.rgb * dither8x8(position, luma(color)), 1.0);\n}\n\nconst mat4 thresholdMatrix = mat4(\n  vec4(1.0 / 17.0,  9.0 / 17.0,  3.0 / 17.0, 11.0 / 17.0),\n  vec4(13.0 / 17.0,  5.0 / 17.0, 15.0 / 17.0,  7.0 / 17.0),\n  vec4(4.0 / 17.0, 12.0 / 17.0,  2.0 / 17.0, 10.0 / 17.0),\n  vec4(16.0 / 17.0,  8.0 / 17.0, 14.0 / 17.0,  6.0 / 17.0)\n);\nconst mat4 _RowAccess = mat4(\n  vec4(1.0,0.0,0.0,0.0),\n  vec4(0.0,1.0,0.0,0.0),\n  vec4(0.0,0.0,1.0,0.0),\n  vec4(0.0,0.0,0.0,1.0)\n);\n\nfloat aastep(float threshold, float value) {\n  float change = fwidth(value) * 0.5;\n  float lo = threshold - change;\n  float hi = threshold + change;\n  return clamp((value - lo) / (hi - lo), 0.0, 1.0);\n}\n\n// void main () {\n//   float a = texture2D(map, vUv).r;\n//   if (a <= 0.5) discard;\n//   gl_FragColor.rgba = vec4(vec3(1.0), 1.0);\n// }\n\nvoid main () {\n  // gl_FragColor.rgba = vec4(vec3)\n  float a = texture2D(map, vUv).r;\n  if (a <= 0.5) discard;\n  // gl_FragColor.rgba = vec4(vec3(1.0), a);\n\n  float dScale = vDataScale;\n  vec3 groundColor = vGroundColor.rgb;\n  float K = pow(gradientY, 0.5);\n\n  float highlight = mix(vHighlight, 1.0, dScale);\n  gl_FragColor.rgb = mix(groundColor, groundColor * grassTipFactor, gradientY) + smoothstep(0.5, 1.0, highlight) * 0.5 * gradientY;\n  gl_FragColor.a = 1.0;\n  // gl_FragColor.rgba = clamp(gl_FragColor.rgba, 0.0, 1.0);\n  // gl_FragColor.a *= pow(gradientY, 0.1); // alpha\n}\n";
},{}],"src/systems/environment/createGroundPatchPool.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createGroundPatchPool;
exports.GrassTileGeometry = void 0;

var THREE = _interopRequireWildcard(require("three"));

var Tags = _interopRequireWildcard(require("../../tags"));

var _fast2dPoissonDiskSampling = _interopRequireDefault(require("fast-2d-poisson-disk-sampling"));

var _Random = _interopRequireDefault(require("../../util/Random"));

var _groundPatchInstance = _interopRequireDefault(require("../../shaders/ground-patch-instance.vert"));

var _groundPatchInstance2 = _interopRequireDefault(require("../../shaders/ground-patch-instance.frag"));

var _boundPoints = _interopRequireDefault(require("bound-points"));

var _math = require("../../util/math");

var _ObjectPool = _interopRequireDefault(require("../../util/ObjectPool"));

var ShaderManager = _interopRequireWildcard(require("../../util/ShaderManager"));

var _Assets = _interopRequireDefault(require("../../util/Assets"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class GrassTileGeometry extends THREE.InstancedBufferGeometry {
  constructor(opts = {}) {
    super();
    const {
      position,
      index,
      uv
    } = opts;
    this._tmpVec3 = new THREE.Vector3();
    this._featureCount = Infinity;
    this.setAttribute("position", position);
    this.setAttribute("uv", uv);
    this.setIndex(index);
  }

  computeBoundingBox() {
    if (this.boundingBox === null) this.boundingBox = new THREE.Box3();

    this._computeBox3(this.boundingBox);
  }

  _computeBox3(b) {
    const offsets = this.attributes.offset;

    if (offsets != null) {
      b.makeEmpty();
      b.min.y = 0;
      b.max.y = 1;

      for (let i = 0; i < offsets.count; i++) {
        const x = offsets.getX(i);
        const z = offsets.getY(i);
        if (x < b.min.x) b.min.x = x;
        if (x > b.max.x) b.max.x = x;
        if (z < b.min.z) b.min.z = z;
        if (z > b.max.z) b.max.z = z;
      }
    }
  }

  computeBoundingSphere() {
    if (this.boundingSphere === null) this.boundingSphere = new THREE.Sphere();
    const offsets = this.attributes.offset;
    if (!offsets) return;
    this.computeBoundingBox();
    const center = this.boundingSphere.center;
    this.boundingBox.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the
    // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

    let maxRadiusSq = 0;
    const v = this._tmpVec3;

    for (let i = 0; i < offsets.count; i++) {
      const x = offsets.getX(i);
      const y = 0;
      const z = offsets.getY(i);
      v.set(x, y, z);
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(v));
    }

    this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
  }

  setCount(count) {
    this.instanceCount = Math.min(this._featureCount, count);
  }

  setFeatures(features, prefix) {
    this.instanceCount = features.length;
    this.prefix = prefix;
    this._featureCount = features.length; // pos.xy
    // scale.s
    // sprite.x = multiplies uv X by a uniform spriteSize.x
    // negative implies flip texture

    const floatsPerInstance = 2 + 1 + 4 + 1;
    const data = new Float32Array(features.length * floatsPerInstance);

    for (let i = 0, c = 0; i < features.length; i++) {
      const f = features[i]; // x, y

      data[c++] = f.position[0];
      data[c++] = f.position[1]; // scale s (scales by uniform spriteScale)
      // also include the flip value here since
      // we only care about absolute scale and > 0

      data[c++] = (f.flip ? -1 : 1) * f.scale; // xyzw UV into sprite atlas

      data[c++] = f.spriteCoords[0];
      data[c++] = f.spriteCoords[1];
      data[c++] = f.spriteCoords[2];
      data[c++] = f.spriteCoords[3];
      data[c++] = f.spriteAspect;
    }

    const buffer = new THREE.InstancedInterleavedBuffer(data, floatsPerInstance);
    this.setAttribute("offset", new THREE.InterleavedBufferAttribute(buffer, 2, 0));
    this.setAttribute("scale", new THREE.InterleavedBufferAttribute(buffer, 1, 2));
    this.setAttribute("spriteCoords", new THREE.InterleavedBufferAttribute(buffer, 4, 3));
    this.setAttribute("spriteAspect", new THREE.InterleavedBufferAttribute(buffer, 1, 7));
  }

}

exports.GrassTileGeometry = GrassTileGeometry;

function createGroundPatchPool(world, opt = {}) {
  const staticBuffers = createStaticBuffers();
  const random = (0, _Random.default)();
  const sampleOpts = opt.samples || {};
  const sprites = opt.sprites;
  const groundMap = opt.groundMap;
  const groundProjectionMatrix = opt.groundProjectionMatrix;
  const dataTarget = world.findTag(Tags.GroundDataRenderTarget); // const tex = new THREE.Texture();
  // const renderer = world.findTag(Tags.Renderer);
  // let spriteMapAspect;
  // Assets.loadGPUTexture(renderer, tex, "image/data/grass-temp").then((img) => {
  //   spriteMapAspect = img.image.width / img.image.height;
  // });

  const renderLayers = world.findTag(Tags.RenderLayers); // How many unique grass patches will be shared across all meshes

  const geometries = [];
  const nGeometries = 3;
  const activeEnv = world.findEntity(Tags.ActiveEnvironmentState);
  const initialPrefix = activeEnv ? activeEnv.get(Tags.EnvironmentState).name : "";

  for (let i = 0; i < nGeometries; i++) {
    const geometry = new GrassTileGeometry({ ...staticBuffers
    });
    const features = getFeatures(sampleOpts, initialPrefix);
    geometry.setFeatures(features, initialPrefix);
    geometries.push(geometry);
  }

  const deck = random.deck(geometries);
  const pool = new _ObjectPool.default({
    name: "GroundPatch",
    initialCapacity: opt.initialCapacity || 0,

    create() {
      const globalSpriteScale = 1;
      const geometry = deck.next();
      const shader = ShaderManager.create({
        name: "GrassGroundPatch",
        transparent: false,
        // depthTest: false,
        // depthWrite: false,
        vertexShader: _groundPatchInstance.default,
        fragmentShader: _groundPatchInstance2.default,
        extensions: {
          derivatives: true
        },
        uniforms: {
          useSpriteAtlas: {
            value: true
          },
          spriteMapAspect: {
            value: 1
          },
          waterMap: {
            value: new THREE.Texture()
          },
          map: {
            value: sprites.atlases[0]
          },
          worldMapSize: {
            value: new THREE.Vector2()
          },
          worldDataMap: {
            value: dataTarget ? dataTarget.target.texture : new THREE.Texture()
          },
          worldDataProjection: {
            value: dataTarget ? dataTarget.projection : new THREE.Matrix4()
          },
          worldDataView: {
            value: dataTarget ? dataTarget.view : new THREE.Matrix4()
          },
          globalSpriteScale: {
            value: globalSpriteScale
          },
          highlightColor: {
            value: new THREE.Color("#948059")
          },
          groundProjectionMatrix: {
            value: groundProjectionMatrix || new THREE.Matrix4()
          },
          grassTipFactor: {
            value: 1.5
          },
          groundMap: {
            value: groundMap || new THREE.Texture()
          },
          time: {
            value: 0
          }
        }
      });
      const mesh = new THREE.Mesh(geometry, shader);
      mesh.name = "ground-patch-pool";
      mesh.userData = {
        globalSpriteScale
      };
      mesh.layers.set(renderLayers.grass); // mesh.renderOrder = 1;

      mesh.userData.active = false;
      mesh.userData.entity = world.entity().add(Tags.ShaderUniformTime, {
        uniform: shader.uniforms.time
      }).add(Tags.GroundPatchInstance, mesh);
      return mesh;
    },

    renew(mesh) {
      mesh.userData.active = true;
    },

    release(mesh) {
      mesh.userData.active = false;
    },

    dispose(mesh) {
      if (mesh.userData.entity) {
        mesh.userData.entity.kill();
        mesh.userData.entity = null;
      }

      mesh.userData.active = false;
    }

  }); // const query = world.query(Tags.GroundPatchInstance);

  return {
    setPrefix(prefix) {
      geometries.forEach(geometry => {
        if (geometry.prefix !== prefix) {
          const features = getFeatures(sampleOpts, prefix);
          geometry.setFeatures(features, prefix);
        }
      });
    },

    next() {
      return pool.next();
    },

    release(m) {
      return pool.release(m);
    }

  };

  function getFeatures(opt, prefix = "", weights) {
    const {
      spriteTextureAtlasColumns = 1
    } = opt;
    const spriteList = prefix ? sprites.values.filter(s => s.type === prefix) : sprites.values;
    return getSamples(opt).map(p => {
      const sprite = random.pick(spriteList);
      const relHeight = 1;
      const aspect = sprite.width / sprite.height;
      const relWidth = 1 * aspect; // console.log(
      //   sprite.name,
      //   sprite.repeat.x / sprite.repeat.y,
      //   sprite.width / sprite.height
      // );

      const scl = 0.66;
      return {
        flip: random.boolean(),
        spriteCoords: sprite.repeat.toArray().concat(sprite.offset.toArray()),
        spriteAspect: sprite.width / sprite.height,
        // scale: relWidth * 0.35 * Math.abs(random.gaussian(1, 1 / 3)),
        scale: (0, _math.clamp)(random.gaussian(scl, scl / 2), 0.5, 1.25),
        // scale: Math.min(
        //   2.35,
        //   relWidth * 0.35 * Math.abs(random.gaussian(1, 1 / 3))
        // ),
        // scale: relWidth * 0.35 * Math.abs(random.gaussian(1, 1 / 3)),
        position: p
      };
    }).filter(p => p.scale >= 1e-5);
  }

  function getSamples({
    size = 40,
    spacing = 1,
    scale = 1,
    tries = 10,
    circular = false,
    maxSamples = 1000,
    filter = true
  }) {
    return random.shuffle(new _fast2dPoissonDiskSampling.default({
      shape: [size, size],
      radius: spacing,
      tries
    }, random.value).fill().map(p => {
      return [p[0] - size / 2, p[1] - size / 2];
    })).slice(0, maxSamples); // return random
    //   .shuffle(
    //     new FastPoissonDiskSampling(
    //       {
    //         shape: [size, size],
    //         radius: spacing,
    //         tries,
    //       },
    //       random.value
    //     )
    //       .fill()
    //       .filter((point) => {
    //         if (!circular) return true;
    //         const r = size / 2;
    //         const rsq = r * r;
    //         const dx = point[0] - size / 2;
    //         const dz = point[1] - size / 2;
    //         const insideOuter = dx * dx + dz * dz <= rsq;
    //         const rIn = random.gaussian(size / 4, size / 4);
    //         const rsqIn = rIn * rIn;
    //         const insideInner = dx * dx + dz * dz <= rsqIn;
    //         return insideOuter && insideInner;
    //       })
    //       // .filter((p) => {
    //       //   if (filter) return random.gaussian() > 0;
    //       //   else return true;
    //       // })
    //       .map((p) => {
    //         p = p.slice();
    //         const [x, y] = random.insideCircle(random.gaussian(0, spacing / 3));
    //         p[0] += x;
    //         p[1] += y;
    //         return [(p[0] - size / 2) * scale, (p[1] - size / 2) * scale];
    //       })
    //   )
    //   .slice(0, maxSamples);
  }
}

function createStaticBuffers() {
  const planeBufferGeometry = new THREE.PlaneBufferGeometry(1, 1, 1, 4);
  const attribs = planeBufferGeometry.attributes;
  const vertCount = attribs.position.count;
  const posArray = [];
  const uvArray = [];

  for (let i = 0; i < vertCount; i++) {
    const x = attribs.position.getX(i);
    const y = attribs.position.getY(i) + 0.5;
    posArray.push(x, y);
    const u = attribs.uv.getX(i);
    const v = attribs.uv.getY(i);
    uvArray.push(u, v);
  }

  const position = new THREE.BufferAttribute(new Float32Array(posArray), 2);
  const uv = new THREE.BufferAttribute(new Float32Array(uvArray), 2);
  const index = new THREE.BufferAttribute(planeBufferGeometry.getIndex().array, 1);
  planeBufferGeometry.dispose();
  return {
    position,
    uv,
    index
  };
}
},{"three":"src/vendor/three.module.js","../../tags":"src/tags/index.js","fast-2d-poisson-disk-sampling":"node_modules/fast-2d-poisson-disk-sampling/src/fast-poisson-disk-sampling.js","../../util/Random":"src/util/Random.js","../../shaders/ground-patch-instance.vert":"src/shaders/ground-patch-instance.vert.js","../../shaders/ground-patch-instance.frag":"src/shaders/ground-patch-instance.frag.js","bound-points":"node_modules/bound-points/bounds.js","../../util/math":"src/util/math.js","../../util/ObjectPool":"src/util/ObjectPool.js","../../util/ShaderManager":"src/util/ShaderManager.js","../../util/Assets":"src/util/Assets.js"}],"src/util/waitForSingleton.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = waitForSingleton;

function waitForSingleton(world, Tag, setup) {
  const state = world.listen(Tag);
  let hasInit = false;
  let hasWarned = false;
  return dt => {
    if (hasInit) return hasInit;
    state.added.forEach(e => {
      if (hasInit) {
        if (!hasWarned) {
          console.error(`Warning: More than one EnvironmentState found on ` + world.system.name);
        }

        hasWarned = true;
        return;
      }

      const data = e.get(Tag);
      setup(data);
      hasInit = true;
    });
    return hasInit;
  };
}
},{}],"src/util/createTilingGrid.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createTilingGrid;

var THREE = _interopRequireWildcard(require("three"));

var _math = require("./math");

var _threeUtil = require("./three-util");

var _ObjectPool = _interopRequireDefault(require("./ObjectPool"));

var _array = require("./array");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class CellData {
  visible = false;
  data = null;
  nearby = null;
  tile = [0, 0];
}

function createTilingGrid(opt = {}) {
  const {
    size = 30,
    maxCells = 9,
    initialCapacity = 9,
    tileHeight = 2.5,
    populateTile = () => {},
    releaseTile = (group, tile) => {
      (0, _threeUtil.detachObject)(group);
    }
  } = opt;
  const group = new THREE.Group();
  group.name = "tiling-grass-group";
  const GRID_DIMENSION = size;
  const GRID_DIMENSION_HALF = GRID_DIMENSION / 2;
  const GRID_TOTAL_TILES = 9;
  const GRID_ROWS = Math.sqrt(GRID_TOTAL_TILES);
  const GRID_ROW_MID = (GRID_ROWS - 1) / 2;
  let currentTilePosition = null; //new THREE.Vector2();

  const tmpBox = new THREE.Box3();
  const cellBox = new THREE.Box3(new THREE.Vector3(-GRID_DIMENSION_HALF, 0, -GRID_DIMENSION_HALF), new THREE.Vector3(GRID_DIMENSION_HALF, tileHeight, GRID_DIMENSION_HALF));
  const cells = [];
  const tmpMat = new THREE.Matrix4();
  const frustum = new THREE.Frustum();
  const projScreenMatrix = new THREE.Matrix4();
  const cellDataPool = new _ObjectPool.default({
    name: "TilingGridCellData",
    initialCapacity,

    create() {
      return new CellData();
    }

  });
  const pool = new _ObjectPool.default({
    name: "TilingGridGroup",
    initialCapacity,

    create() {
      return new THREE.Group();
    }

  });

  function setBox(tx, ty, out = new THREE.Box3()) {
    out.copy(cellBox);
    const px = tileToWorld(tx);
    const pz = tileToWorld(ty);
    out.min.x += px;
    out.max.x += px;
    out.min.z += pz;
    out.max.z += pz;
    return out;
  }

  return {
    update,
    group,
    cellBox
  };

  function update(camera, position) {
    projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    frustum.setFromProjectionMatrix(projScreenMatrix);
    let tileX = worldToTile(position.x);
    let tileY = worldToTile(position.z);

    if (currentTilePosition == null || currentTilePosition.x !== tileX || currentTilePosition.y !== tileY) {
      if (!currentTilePosition) currentTilePosition = new THREE.Vector2();
      currentTilePosition.set(tileX, tileY);
    }

    cells.forEach(c => {
      c.visible = false;
    });

    for (let y = 0; y < GRID_ROWS; y++) {
      for (let x = 0; x < GRID_ROWS; x++) {
        const tx = tileX + (x - GRID_ROW_MID);
        const ty = tileY + (y - GRID_ROW_MID);
        const hasCell = cells.some(c => c.tile[0] === tx && c.tile[1] === ty);
        setBox(tx, ty, tmpBox);
        const visible = frustum.intersectsBox(tmpBox);

        if (!hasCell && visible) {
          if (cells.length >= maxCells) {
            // try to remove the a 'far away' cell to make room for closer ones
            removeFirstFarCell();
          }

          if (cells.length >= maxCells) {
            // we reached capacity, break out early...
            break;
          }

          const cell = cellDataPool.next();
          cell.data = null;
          cell.nearby = true; // true as we are only adding NxN around target here

          cell.visible = true;
          cell.tile[0] = tx;
          cell.tile[1] = ty;
          cells.push(cell);
        }
      }
    }

    for (let i = cells.length - 1; i >= 0; i--) {
      const cell = cells[i];
      const [tx, ty] = cell.tile;
      setBox(tx, ty, tmpBox);
      const visible = cell.visible ? true : frustum.intersectsBox(tmpBox); // update cell

      cell.nearby = Math.abs(tx - currentTilePosition.x) <= GRID_ROW_MID && Math.abs(ty - currentTilePosition.y) <= GRID_ROW_MID;

      if (visible) {
        //create cell
        if (!cell.data) {
          const tileObject = pool.next();
          tileObject.position.set(tileToWorld(tx), 0, tileToWorld(ty));
          group.add(tileObject);
          cell.data = tileObject;
          populateTile(tileObject, cell.tile);
        }
      } else {
        // kill cell
        (0, _array.spliceOne)(cells, i);
        killCell(cell);
      }
    }
  }

  function killCell(cell) {
    if (cell.data) {
      pool.release(cell.data);
      releaseTile(cell.data, cell.tile);
      cell.data = null;
    }

    cellDataPool.release(cell);
  }

  function removeFirstFarCell() {
    for (let i = cells.length - 1; i >= 0; i--) {
      const c = cells[i];

      if (c.nearby === false) {
        cells.splice(i, 1);
        killCell(c);
        return;
      }
    }
  }

  function tileToWorld(n) {
    return n * GRID_DIMENSION;
  }

  function worldToTile(x) {
    return Math.floor((0, _math.inverseLerp)(-GRID_DIMENSION_HALF, GRID_DIMENSION_HALF, x)) || 0;
  }
}
},{"three":"src/vendor/three.module.js","./math":"src/util/math.js","./three-util":"src/util/three-util.js","./ObjectPool":"src/util/ObjectPool.js","./array":"src/util/array.js"}],"src/systems/EnvironmentGrassSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = EnvironmentGrassSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _createGroundPatchPool = _interopRequireDefault(require("./environment/createGroundPatchPool"));

var _waitForSingleton = _interopRequireDefault(require("../util/waitForSingleton"));

var _createTilingGrid = _interopRequireDefault(require("../util/createTilingGrid"));

var _threeUtil = require("../util/three-util");

var _load = require("../util/load");

var _AnimationSystem = require("./AnimationSystem");

var _SpriteManager = _interopRequireDefault(require("../util/SpriteManager"));

var _Assets = _interopRequireDefault(require("../util/Assets"));

var _materials = require("../util/materials");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

async function EnvironmentGrassSystem(world) {
  const renderer = world.findTag(Tags.Renderer);
  const sprites = await (0, _SpriteManager.default)("spritesheets/temp_grass_sprites", renderer); // sprites.atlases.forEach((atlas) => {
  //   atlas.anisotropy = 4;
  // });

  const grassEditableEntity = world.entity().add(Tags.GrassEditableData);
  const groundView = world.findTag(Tags.GroundPlaneView);
  const grassPatchView = world.view(Tags.GroundPatchInstance);
  const activeState = world.view([Tags.EnvironmentState, Tags.ActiveEnvironmentState]);
  let grid;
  let grass;
  let envVersion = null;
  let lastEnv = null;
  const emptyTex = (0, _materials.getEmptyTexture)();
  setup();
  return function envGrassSytem(dt) {
    const world0TweenTag = world.findTag(Tags.WorldTweens);
    let world0Tween = 0;

    if (world0TweenTag) {
      world0Tween = world0TweenTag[0];
    }

    let currentEnvironmentState;

    if (activeState.length) {
      currentEnvironmentState = activeState[0].get(Tags.EnvironmentState);
    }

    if (lastEnv !== currentEnvironmentState) {
      lastEnv = currentEnvironmentState;
      grass.setPrefix(currentEnvironmentState ? currentEnvironmentState.name : "");
    }

    const data = grassEditableEntity.get(Tags.GrassEditableData);
    const useSpriteAtlas = !data.useCustomGrass;
    const editScale = data.grassScale;
    const curMap = useSpriteAtlas ? sprites.atlases[0] : data.customGrassMap;
    grassPatchView.forEach(e => {
      const mesh = e.get(Tags.GroundPatchInstance);
      const t = 1 - world0Tween;
      let size = mesh.userData.globalSpriteScale;

      if (currentEnvironmentState) {
        size *= currentEnvironmentState.grassScale;
        mesh.material.uniforms.grassTipFactor.value = currentEnvironmentState.grassTipFactor;
        mesh.material.uniforms.worldMapSize.value.set(currentEnvironmentState.data.width, currentEnvironmentState.data.height);
        mesh.material.uniforms.waterMap.value = currentEnvironmentState.waterMap;
        mesh.geometry.setCount(currentEnvironmentState.grassInstanceCount);
      }

      mesh.material.uniforms.globalSpriteScale.value = editScale * t * size;
      mesh.material.uniforms.useSpriteAtlas.value = useSpriteAtlas;
      mesh.material.uniforms.map.value = curMap;

      if (!useSpriteAtlas) {
        const map = mesh.material.uniforms.map.value;

        if (map && map.image && map.image.height !== 0) {
          mesh.material.uniforms.spriteMapAspect.value = map.image.width / map.image.height;
        }
      }
    });
    const camera = world.findTag(Tags.MainCamera);
    const position = world.findTag(Tags.UserTarget).position;
    grid.update(camera, position);
  };

  function setup() {
    const size = 40;
    grass = (0, _createGroundPatchPool.default)(world, {
      sprites,
      groundMap: groundView.target.texture,
      groundProjectionMatrix: groundView.projectionMatrix,
      samples: {
        size
      },
      initialCapacity: 9
    });
    grid = (0, _createTilingGrid.default)({
      size,
      maxCells: 9,
      initialCapacity: 9,
      tileHeight: 2.5,
      populateTile: (group, tile) => {
        const mesh = grass.next();
        group.add(mesh);
        group.userData.grass = mesh; // group.userData.box = new THREE.BoxHelper(group);
        // group.add(group.userData.box);
        // const e = world.entity().add(Tags.Object3D, group.userData.box);
        // group.userData.boxEntity = e;
      },
      releaseTile: (group, tile) => {
        // if (group.userData.box) {
        //   group.userData.box.geometry.dispose();
        //   group.userData.box = null;
        // }
        // if (group.userData.boxEntity) {
        //   group.userData.boxEntity.kill();
        // }
        if (group.userData.grass) {
          grass.release(group.userData.grass);
          group.userData.grass = null;
        }

        (0, _threeUtil.detachObject)(group);
      }
    });
    world.entity().add(Tags.Object3D, grid.group);
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","./environment/createGroundPatchPool":"src/systems/environment/createGroundPatchPool.js","../util/waitForSingleton":"src/util/waitForSingleton.js","../util/createTilingGrid":"src/util/createTilingGrid.js","../util/three-util":"src/util/three-util.js","../util/load":"src/util/load.js","./AnimationSystem":"src/systems/AnimationSystem.js","../util/SpriteManager":"src/util/SpriteManager.js","../util/Assets":"src/util/Assets.js","../util/materials":"src/util/materials.js"}],"src/systems/EnvironmentGroundRenderTextureSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = EnvironmentGroundRenderTextureSystem;

var THREE = _interopRequireWildcard(require("three"));

var Tags = _interopRequireWildcard(require("../tags"));

var _addFrameTasks = require("../util/addFrameTasks");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function EnvironmentGroundRenderTextureSystem(world) {
  const renderTarget = new THREE.WebGLRenderTarget(16, 16);
  const RTSIZE = 128;
  const camera = new THREE.PerspectiveCamera();
  const mainCamera = world.findTag(Tags.MainCamera);
  const mainScene = world.findTag(Tags.MainScene);
  const groundPlaneTag = world.tag(Tags.GroundPlaneView, {
    camera: mainCamera,
    projectionMatrix: new THREE.Matrix4(),
    target: renderTarget
  });
  const groundView = world.findTag(Tags.GroundPlaneView);
  const renderLayers = world.findTag(Tags.RenderLayers);
  const GROUND_CAMERA_Y_OFFSET = 0;
  world.entity().add(Tags.DebugRenderTarget, {
    visible: false,
    target: renderTarget
  }); // world.entity().add(Tags.Object3D, camera);
  // camera.name = "groundrendercam";

  renderTarget.depthBuffer = false;
  renderTarget.texture.generateMipmaps = false;
  renderTarget.texture.minFilter = THREE.LinearFilter;
  renderTarget.texture.magFilter = THREE.LinearFilter;
  renderTarget.texture.wrapS = renderTarget.texture.wrapT = THREE.ClampToEdgeWrapping; // const group = new THREE.Group();
  // world.entity().add(Tags.Object3D, group);
  // group.name = "groundrendergroup";
  // single mesh
  // const planeGeometry = new THREE.PlaneGeometry(1, 1, 1, 1);
  // const planeMaterial = new THREE.MeshBasicMaterial({
  //   // map: grassTex,
  //   color: new THREE.Color("green"),
  // });
  // planeGeometry.rotateX(-Math.PI / 2);
  // const floor = new THREE.Mesh(planeGeometry, planeMaterial);
  // group.add(floor);
  // world.entity().add(Tags.GroundPlaneLayer, floor);
  // const tileSize = 20;
  // floor.scale.set(tileSize, 1, tileSize);

  const items = world.view(Tags.GroundPlaneLayer);
  const clearColor = new THREE.Color(0, 0, 0);
  const tmpColor = new THREE.Color();
  const renderer = world.findTag(Tags.Renderer);
  const state = world.findTag(Tags.AppState);
  (0, _addFrameTasks.addPreRenderCallback)(submitRender);
  return function envGroundRenderTexSystem(dt) {
    const canvas = renderer.domElement;
    const width = canvas.width;
    const height = canvas.height;
    if (canvas.width === 0 || canvas.height === 0) return;
    let newAspect = width / height;
    let aspect = renderTarget.width / renderTarget.height;
    const rWidth = RTSIZE;
    const rHeight = Math.round(rWidth / newAspect);

    if (renderTarget.width !== rWidth || renderTarget.height !== rHeight) {
      renderTarget.setSize(rWidth, rHeight);
    } // quickCopy(mainCamera, camera);
    // camera.layers.set(renderLayers.ground);
    // camera.zoom = 1;
    // const padding = 0;
    // camera.setViewOffset(
    //   width,
    //   height,
    //   -padding,
    //   -padding,
    //   width + padding,
    //   height + padding
    // );
    // camera.zoom = 1;
    // already in setViewOffset
    // camera.updateProjectionMatrix();
    // camera.updateMatrixWorld();
    // items.forEach((e) => {
    //   const obj = e.get(Tags.GroundPlaneLayer);
    //   if (obj) {
    //     obj.layers.set(renderLayers.ground);
    //     // obj.updateMatrixWorld();
    //   }
    // });
    // submitRender();

  };

  function submitRender() {
    // mainCamera.updateMatrixWorld();
    // mainCamera.updateProjectionMatrix();
    groundPlaneTag.projectionMatrix.copy(mainCamera.projectionMatrix);
    mainCamera.layers.disableAll();
    mainCamera.layers.enable(renderLayers.ground);
    mainCamera.layers.disable(renderLayers.groundDepth);
    tmpColor.copy(renderer.getClearColor());
    renderer.setRenderTarget(renderTarget);
    renderer.setClearColor(clearColor);
    renderer.clear();
    renderer.render(mainScene, mainCamera);
    renderer.setRenderTarget(null);
    renderer.setClearColor(tmpColor);
    mainCamera.layers.enableAll();
  }

  function quickCopy(cameraSrc, cameraDst) {
    THREE.Camera.prototype.copy.call(cameraDst, cameraSrc);
    cameraDst.fov = cameraSrc.fov;
    cameraDst.zoom = cameraSrc.zoom;
    cameraDst.near = cameraSrc.near;
    cameraDst.far = cameraSrc.far;
    cameraDst.focus = cameraSrc.focus;
    cameraDst.aspect = cameraSrc.aspect;
    cameraDst.filmGauge = cameraSrc.filmGauge;
    cameraDst.filmOffset = cameraSrc.filmOffset;
  }
}
},{"three":"src/vendor/three.module.js","../tags":"src/tags/index.js","../util/addFrameTasks":"src/util/addFrameTasks.js"}],"src/assets/textures/brush-stroke-sdf.png":[function(require,module,exports) {
module.exports = "/brush-stroke-sdf.8f6ba722.png";
},{}],"src/systems/ProceduralSpawningLeaves.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ProceduralSpawningLeaves;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _ObjectPool = _interopRequireDefault(require("../util/ObjectPool"));

var _Random = _interopRequireDefault(require("../util/Random"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var ShaderManager = _interopRequireWildcard(require("../util/ShaderManager"));

var _AnimationSystem = require("./AnimationSystem");

var _brushStrokeSdf = _interopRequireDefault(require("../assets/textures/brush-stroke-sdf.png"));

var _load = require("../util/load");

var _Assets = _interopRequireDefault(require("../util/Assets"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

async function ProceduralSpawningLeaves(world) {
  // const brushMap = await loadTexture(brushUrl, {
  //   minFilter: THREE.LinearFilter,
  //   generateMipmaps: false,
  // });
  const group = new THREE.Group();
  world.entity().add(Tags.Object3D, group);
  const brushIds = {
    forest: "image/data/ground-spawn-forest",
    grasslands: "image/data/ground-spawn-grasslands",
    tundra: "image/data/ground-spawn-tundra"
  };
  const renderer = world.findTag(Tags.Renderer);
  let currentBrushId;
  const brushMap = new THREE.Texture();
  const meshes = world.view([Tags.Object3D, Tags.GroundSpawningLeaf]);
  const triggerEvents = world.listen(Tags.PoemLineTriggerActivated);
  const geometry = new THREE.PlaneGeometry(1, 1, 5, 5);
  geometry.vertices.forEach(v => {
    const t = v.x * 2 * 0.5 + 0.5; // const side = Math.sign(v.x);
    // v.x *= Math.sin(t * Math.PI) * 1;

    v.z = Math.sin(t * Math.PI) * 0.2; // v.x = Math.sin(t * Math.PI) * side * 0.5;
  }); // geometry.scale(6, 6, 6);
  //new THREE.TetrahedronGeometry(1, 0);

  const pool = new _ObjectPool.default({
    maxCapacity: 50,
    initialCapacity: 50,

    create() {
      const mesh = new THREE.Mesh(geometry, ShaderManager.create({
        name: "SpawningLeaves",
        extensions: {
          derivatives: true
        },
        fragmentShader:
        /*glsl*/
        `
            varying vec2 vUv;
            uniform sampler2D map;
            uniform vec3 color;
            uniform float opacity;
            float aastep(float threshold, float value) {
              float change = fwidth(value) * 0.5;
              float lo = threshold - change;
              float hi = threshold + change;
              return clamp((value - lo) / (hi - lo), 0.0, 1.0);
            }

            void main () {
              float a = aastep(0.5, texture2D(map, vUv).a);
              gl_FragColor.rgb = color;
              if (!gl_FrontFacing) gl_FragColor.rgb *= 0.75;
              gl_FragColor.a = 1.0;
              // gl_FragColor.rgb *= opacity * a;
              gl_FragColor.a = opacity * a;
              // if (gl_FragColor.a < 0.1) discard;
            }
          `,
        vertexShader:
        /*glsl*/
        `
            varying vec2 vUv;
            void main () {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
            }
          `,
        uniforms: {
          map: {
            value: brushMap
          },
          opacity: {
            value: 1
          },
          color: {
            value: new THREE.Color()
          }
        },
        // depthTest: false,
        // depthWrite: false,
        side: THREE.DoubleSide,
        transparent: true // blending: THREE.CustomBlending,
        // blendEquation: THREE.AddEquation,
        // blendSrc: THREE.OneFactor,
        // blendDst: THREE.OneMinusSrcAlphaFactor,
        // blending: THREE.AdditiveBlending,

      }));
      const e = world.entity();
      e.add(Tags.GroundSpawningLeaf);
      e.add(Tags.TargetKeyTween, {
        active: false,
        duration: 1,
        ease: "expoOut",
        pauseOnModal: true,
        target: mesh.userData,
        killEntityOnFinish: false,
        assignFromOnStart: true,
        key: "tween"
      });
      mesh.userData.entity = e;
      mesh.userData.tween = 0;
      mesh.userData.size = 0.1;
      mesh.userData.speed = 0;
      mesh.userData.alpha = 1;
      mesh.userData.velocity = new THREE.Vector3();
      mesh.userData.rotationAxis = new THREE.Vector3();
      mesh.userData.rotationSpeed = 1;
      mesh.userData.rotationAngleOffset = 0;
      mesh.name = "spawning-leaves";
      mesh.frustumCulled = false;
      mesh.matrixAutoUpdate = false;
      return mesh;
    }

  });
  let lastPosition = new THREE.Vector3();
  let useFlowerColors = false; // const flowerHueBases = [16, 48, 210, 245, 282, 324];

  const flowerHueBases = [216];
  const distThreshold = 0.5;
  const distThresholdSq = distThreshold * distThreshold;
  const tmpDir = new THREE.Vector3();
  const tmpPos3D = new THREE.Vector3();
  const tmp2D = [0, 0];
  const tmp3D = [0, 0, 0];
  const tmpQuatArray = [0, 0, 0, 0];
  const random = (0, _Random.default)();
  const envData = world.findTag(Tags.EnvironmentState);
  const tmpColor = new THREE.Color(); // const nearestCell = world
  //   .findEntity(Tags.NearestEnvironmentCell)
  //   .getTag(Tags.NearestEnvironmentCell);

  const char = world.findTag(Tags.UserCharacter);
  const target = world.findTag(Tags.UserTarget);
  const environment = world.view([Tags.ActiveEnvironmentState, Tags.EnvironmentState]);
  let elapsed = 0;
  let minDelay = 0.1;
  let maxDelay = 0.3;
  let curDelay = minDelay;
  const tbloom = 0.5;
  const fixedColors = {
    tundra: new THREE.Color(206 / 255 + tbloom, 215 / 255 + tbloom, 219 / 255 + tbloom)
  };
  let lastEnv = null;
  let fixedColor = null;
  return function spawningLeavesSystem(dt) {
    const position = char.position;
    const dir = char.direction;
    const canMove = !Boolean(world.findTag(Tags.ModalStoppingUserMovement));
    if (!canMove) return; // const worldSize = 1;

    let newEnv = null;

    if (environment.length > 0) {
      const state = environment[0].get(Tags.EnvironmentState);
      newEnv = state.name;
    }

    let worldSize = newEnv === "tundra" ? 0.75 : 1;

    if (newEnv !== lastEnv) {
      let newId = brushIds[newEnv]; // useFlowerColors = state.name === "tundra";

      if (currentBrushId !== newId) {
        currentBrushId = newId; // dynamically swap LUT maps as needed

        _Assets.default.loadGPUTexture(renderer, brushMap, currentBrushId);
      }

      fixedColor = fixedColors[newEnv];
      lastEnv = newEnv;
    } // const world1TweenTag = world.findTag(Tags.WorldTweens);
    // if (world1TweenTag) {
    //   worldSize = world1TweenTag[1];
    // }
    // const worldSize = 1 - world.findTag(Tags.WorldTween0);
    // elapsed += dt;
    // if (elapsed >= curDelay) {
    //   elapsed %= curDelay;
    //   curDelay = random.range(minDelay, maxDelay);
    //   const cell = nearestCell.value;
    //   let valid = cell && cell.spawnLeaves;
    //   if (valid) spawn(cell, position, dir);
    // }


    const underPlayer = world.findTag(Tags.EnvironmentUnderPlayerState);
    const canSpawn = underPlayer ? !underPlayer.water : true;

    if (canSpawn && environment.length && (!lastPosition || position.distanceToSquared(lastPosition) >= distThresholdSq)) {
      if (!lastPosition) lastPosition = new THREE.Vector3(); // const cell = nearestCell.value;

      const envState = environment[0].get(Tags.EnvironmentState);
      const cell = envState.grid.getCellAt(position.x, position.z);
      if (cell) spawn(envState, cell, position, dir);
      lastPosition.copy(position);
    } // triggerEvents.added.forEach((e) => {
    //   const t = e.get(Tags.PoemLineTrigger);
    //   const yOffset = t.parent.get(Tags.PoemLine).yOffset;
    //   tmpPos3D.copy(t.position);
    //   tmpPos3D.y += yOffset;
    //   spawn(tmpPos3D, dir, true);
    // });


    for (let i = 0; i < meshes.length; i++) {
      const e = meshes[i];
      const tween = e.get(Tags.TargetKeyTween);
      const mesh = e.get(Tags.Object3D);
      const s = mesh.userData.tween * mesh.userData.size * worldSize;
      mesh.visible = mesh.userData.tween > 1e-5;

      if (mesh.visible) {
        mesh.scale.setScalar(s);
        const a = mesh.userData.tween * mesh.userData.alpha; // mesh.material.uniforms.color.value.setRGB(a, a, a);

        mesh.material.uniforms.opacity.value = a;
        mesh.position.addScaledVector(mesh.userData.velocity, dt * mesh.userData.speed);
        mesh.rotateOnWorldAxis(mesh.userData.rotationAxis, mesh.userData.rotationSpeed * dt);
        mesh.updateMatrix();
      } // mesh.userData.rotationSpeed


      if (tween.finished && mesh.userData.appearing) {
        mesh.userData.appearing = false;
        mesh.userData.killing = true;
        setAnimateTo(mesh, 0, mesh.userData.holdDelay);
      }

      if (tween.finished && mesh.userData.killing && !mesh.userData.appearing) {
        mesh.userData.killing = false;
        mesh.userData.appearing = false;
        group.remove(mesh);
        mesh.userData.entity.remove(Tags.Object3D);
        pool.release(mesh);
      }
    }
  };

  function spawn(envState, cell, position, direction, explode) {
    const n = explode ? random.rangeFloor(1, 5) : 2;

    for (let i = 0; i < n; i++) spawnOne(envState, cell, position, direction, explode);
  }

  function spawnOne(envState, cell, position, direction, explode) {
    let curColor;

    if (fixedColor) {
      curColor = fixedColor;
    } else if (useFlowerColors) {
      curColor = tmpColor.setHSL(random.pick(flowerHueBases) / 360, random.range(0.45, 0.75), random.range(0.45, 0.65));
    } else {
      const obj = envState.colors[cell.colorIndex % envState.colors.length];
      curColor = obj ? obj.color : null;
    }

    if (!curColor) return;
    const mesh = pool.next();

    if (mesh) {
      mesh.visible = false;
      group.add(mesh);
      mesh.userData.entity.add(Tags.Object3D, mesh);
      mesh.position.copy(position); // if (explode) {
      // } else {
      //   tmpDir.copy(direction).negate();
      //   tmpDir.y *= 0;
      //   mesh.position.addScaledVector(tmpDir, random.range(0, 10));
      // }
      // let r = random.gaussian(1, 3);
      // if (random.gaussian(0, 1) > 0) r += random.gaussian(0, 4);
      // if (random.gaussian(0, 1) > 1) r += random.gaussian(0, 8);

      let r = random.gaussian(1, 6);
      if (random.gaussian(0, 1) > 0) r += random.gaussian(0, 4);
      if (random.gaussian(0, 1) > 1) r += random.gaussian(0, 8);
      random.insideCircle(random.range(1, 1) + random.gaussian(0, 2) + 1 * r * random.gaussian(0, 2), tmp2D);
      mesh.position.x += tmp2D[0];
      mesh.position.z += tmp2D[1];

      if (cell) {
        mesh.material.uniforms.color.value.set(curColor).offsetHSL(random.range(-1, 1) * 20 / 360, random.range(0, 0.25), random.range(0, 0.25));
      } else {// mesh.material.uniforms.color.value.setRGB(1, 1, 1);
      }

      mesh.quaternion.fromArray(random.quaternion(tmpQuatArray));

      if (!explode) {// random.insideCircle(
        //   random.gaussian(0, 2) + 0.1 * r * random.gaussian(0, 2),
        //   tmp2D
        // );
        // mesh.position.x += tmp2D[0];
        // mesh.position.z += tmp2D[1];
        // random.insideCircle(10, tmp2D);
        // mesh.position.x += tmp2D[0];
        // mesh.position.z += tmp2D[1];
      }

      mesh.userData.holdDelay = random.range(0.0, 2);
      if (!explode) mesh.position.y = Math.abs(random.gaussian(0.25, 1));
      mesh.userData.appearing = true;
      mesh.userData.killing = false;
      mesh.userData.size = (0.15 + 2 * Math.abs(random.gaussian(0, 0.3 / 4))) * 1.1; // mesh.userData.size = 0.15 + 2 * Math.abs(random.gaussian(0, 0.3 / 4));
      // MathUtil.clamp(
      //   Math.abs(random.gaussian(0.1, 0.1)),
      //   0.025,
      //   0.09
      // );

      mesh.userData.speed = MathUtil.clamp(Math.abs(random.gaussian(0.5, 0.2)), 0.25, 1);
      mesh.userData.tween = 0;
      mesh.userData.velocity.set(0, 1, 0);
      mesh.quaternion.fromArray(random.quaternion(tmpQuatArray));
      mesh.userData.rotationAxis.fromArray(random.insideSphere(1, tmp3D));
      mesh.userData.rotationSpeed = 4;
      mesh.userData.rotationAngleOffset = random.range(-1, 1) * Math.PI * 2;
      mesh.userData.alpha = 1; //random.range(0.5, 1);

      if (explode) {
        random.insideCircle(1, tmp2D);
        tmpDir.x = tmp2D[0];
        tmpDir.y = random.range(0, 0.0);
        tmpDir.z = tmp2D[1];
        tmpDir.addScaledVector(direction, random.range(0, 1));
        tmpDir.normalize();
      } else {
        tmpDir.copy(direction);
        tmpDir.y += random.range(0, 0.5);
        tmpDir.normalize();
      }

      mesh.userData.velocity.copy(tmpDir);
      setAnimateTo(mesh, 1, explode ? 0 : random.range(0, 0.0));
    }
  }

  function setAnimateTo(mesh, to, delay) {
    const t = mesh.userData.entity.get(Tags.TargetKeyTween);
    t.to = to;
    t.delay = delay || 0;
    t.elapsed = 0;
    t.finished = false;
    t.started = false;
    t.active = true;
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/ObjectPool":"src/util/ObjectPool.js","../util/Random":"src/util/Random.js","../util/math":"src/util/math.js","../util/ShaderManager":"src/util/ShaderManager.js","./AnimationSystem":"src/systems/AnimationSystem.js","../assets/textures/brush-stroke-sdf.png":"src/assets/textures/brush-stroke-sdf.png","../util/load":"src/util/load.js","../util/Assets":"src/util/Assets.js"}],"src/systems/ProceduralSpawningDots.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ProceduralSpawningDots;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var ShaderManager = _interopRequireWildcard(require("../util/ShaderManager"));

var _ObjectPool = _interopRequireDefault(require("../util/ObjectPool"));

var _Random = _interopRequireDefault(require("../util/Random"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _AnimationSystem = require("./AnimationSystem");

var _load = require("../util/load");

var _threeUtil = require("../util/three-util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ProceduralSpawningDots(world) {
  const meshes = world.view([Tags.Object3D, Tags.GroundSpawningDot]);
  const triggerEvents = world.listen(Tags.PoemLineTriggerActivated);
  const random = (0, _Random.default)(175079320123);
  const group = new THREE.Group();
  world.entity().add(Tags.Object3D, group);
  const bases = [new THREE.TetrahedronBufferGeometry(1, 0), new THREE.TetrahedronBufferGeometry(1, 1)];
  const tmpVec = new THREE.Vector3();
  const geometries = new Array(3).fill(0).map((_, i) => {
    const geometry = new THREE.BufferGeometry();
    const baseGeometry = bases[i % bases.length];
    const positions = baseGeometry.attributes.position;
    const newPositions = new THREE.Float32BufferAttribute(new Float32Array(positions.array.length), 3);

    for (let i = 0; i < positions.count; i++) {
      const x = positions.getX(i);
      const y = positions.getY(i);
      const z = positions.getZ(i);
      tmpVec.set(x, y, z);
      const n = tmpVec.clone().normalize();
      const v = tmpVec.clone().addScaledVector(n, random.gaussian(0, 1 / 8));
      newPositions.setX(i, v.x);
      newPositions.setY(i, v.y);
      newPositions.setZ(i, v.z);
    }

    geometry.setAttribute("position", newPositions);
    geometry.setIndex(baseGeometry.getIndex());
    return geometry;
  }); // baseGeometry.dispose();

  const pool = new _ObjectPool.default({
    maxCapacity: 35,
    initialCapacity: 35,

    create() {
      const material = ShaderManager.create({
        name: "SpawningDots",
        extensions: {
          derivatives: true
        },
        fragmentShader:
        /*glsl*/
        `
          varying vec2 vUv;
          uniform sampler2D map;
          uniform vec3 color;
          uniform float opacity;
          float aastep(float threshold, float value) {
            float change = fwidth(value) * 0.5;
            float lo = threshold - change;
            float hi = threshold + change;
            return clamp((value - lo) / (hi - lo), 0.0, 1.0);
          }
    
          void main () {
            // float a = aastep(0.5, texture2D(map, vUv).a);
            
            gl_FragColor.rgb = color;
            // if (!gl_FrontFacing) gl_FragColor.rgb *= 0.75;
            gl_FragColor.a = 1.0;
            // gl_FragColor.rgb *= opacity * a;
            // gl_FragColor.a = opacity * a;
            // if (gl_FragColor.a < 0.1) discard;
          }
        `,
        vertexShader:
        /*glsl*/
        `
          varying vec2 vUv;
          void main () {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
          }
        `,
        uniforms: {
          opacity: {
            value: 1
          },
          color: {
            value: new THREE.Color()
          }
        },
        // depthTest: false,
        // depthWrite: false,
        // side: THREE.DoubleSide,
        // transparent: true,
        blending: THREE.AdditiveBlending
      });
      const mesh = new THREE.Mesh(random.pick(geometries), material);
      const e = world.entity();
      e.add(Tags.GroundSpawningDot);
      e.add(Tags.TargetKeyTween, {
        active: false,
        duration: 2,
        ease: "sineOut",
        pauseOnModal: true,
        target: mesh.userData,
        killEntityOnFinish: false,
        assignFromOnStart: true,
        key: "tween"
      });
      mesh.userData.entity = e;
      mesh.userData.tween = 0;
      mesh.userData.size = 0.1;
      mesh.userData.speed = 0;
      mesh.userData.alpha = 1;
      mesh.userData.velocity = new THREE.Vector3();
      mesh.userData.rotationAxis = new THREE.Vector3();
      mesh.userData.rotationSpeed = 1;
      mesh.userData.rotationAngleOffset = 0;
      mesh.frustumCulled = false;
      mesh.name = "spawning-dots";
      mesh.matrixAutoUpdate = false;
      return mesh;
    }

  });
  const distThreshold = 1;
  const distThresholdSq = distThreshold * distThreshold;
  const tmpDir = new THREE.Vector3();
  const tmpPos3D = new THREE.Vector3();
  const tmp2D = [0, 0];
  const tmp3D = [0, 0, 0];
  const tmpQuatArray = [0, 0, 0, 0];
  const tmpColor = new THREE.Color();
  const target = world.findTag(Tags.UserTarget);
  const char = world.findTag(Tags.UserCharacter); // const nearestCell = world
  //   .findEntity(Tags.NearestEnvironmentCell)
  //   .getTag(Tags.NearestEnvironmentCell);

  let elapsed = 0;
  let minDelay = 0.1;
  let maxDelay = 0.3;
  let curDelay = minDelay;
  const initialSpawns = 5;

  for (let i = 0; i < initialSpawns; i++) {
    spawn(null, target.position, char.direction);
  }

  const env = world.view([Tags.EnvironmentState, Tags.ActiveEnvironmentState]);
  return function spawningDotsSystem(dt) {
    const name = env.length ? env[0].get(Tags.EnvironmentState).name : null;
    if (name === "tundra") return;
    const position = char.position; // const canMove = !Boolean(world.findTag(Tags.ModalStoppingUserMovement));
    // if (!canMove) return;

    forward(dt); // triggerEvents.added.forEach((e) => {
    //   const t = e.get(Tags.PoemLineTrigger);
    //   const yOffset = t.parent.get(Tags.PoemLine).yOffset;
    //   tmpPos3D.copy(t.position);
    //   tmpPos3D.y += yOffset;
    //   spawn(tmpPos3D, dir, true);
    // });

    for (let i = 0; i < meshes.length; i++) {
      const e = meshes[i];
      const tween = e.get(Tags.TargetKeyTween);
      const mesh = e.get(Tags.Object3D);
      const s = mesh.userData.tween * mesh.userData.size;
      mesh.scale.setScalar(s);
      const a = mesh.userData.tween * mesh.userData.alpha;
      const bloom = 0.75;
      mesh.material.uniforms.color.value.setRGB(a + bloom, a + bloom, a + bloom);
      mesh.material.uniforms.opacity.value = a;
      mesh.position.addScaledVector(mesh.userData.velocity, dt * mesh.userData.speed);
      mesh.rotateOnWorldAxis(mesh.userData.rotationAxis, mesh.userData.rotationSpeed * dt);
      mesh.visible = mesh.userData.tween > 1e-5;

      if (mesh.visible) {
        mesh.updateMatrix();
      } // mesh.userData.rotationSpeed


      if (tween.finished && mesh.userData.appearing) {
        mesh.userData.appearing = false;
        mesh.userData.killing = true;
        setAnimateTo(mesh, 0, mesh.userData.holdDelay);
      }

      if (tween.finished && mesh.userData.killing && !mesh.userData.appearing) {
        mesh.userData.killing = false;
        mesh.userData.appearing = false;
        mesh.userData.entity.remove(Tags.Object3D);
        (0, _threeUtil.detachObject)(mesh);
        pool.release(mesh);
      }
    }
  };

  function forward(dt = 0) {
    elapsed += dt;

    if (elapsed >= curDelay) {
      elapsed %= curDelay;
      curDelay = random.range(minDelay, maxDelay);
      let cell; // const cell = nearestCell.value;
      // let valid = cell;

      spawn(cell, target.position, char.direction);
    }
  }

  function spawn(cell, position, direction, explode) {
    const n = explode ? random.rangeFloor(1, 5) : 1;

    for (let i = 0; i < n; i++) spawnOne(cell, position, direction, explode);
  }

  function spawnOne(cell, position, direction, explode) {
    const mesh = pool.next();

    if (mesh) {
      mesh.visible = false;
      group.add(mesh);
      mesh.userData.entity.add(Tags.Object3D, mesh);
      mesh.position.copy(position);

      if (explode) {} else {// tmpDir.copy(direction).negate();
        // tmpDir.y *= 0;
        // mesh.position.addScaledVector(tmpDir, random.range(5, 10));
      }

      let r = random.gaussian(1, 6);
      if (random.gaussian(0, 1) > 0) r += random.gaussian(0, 4);
      if (random.gaussian(0, 1) > 1) r += random.gaussian(0, 8);
      random.insideCircle(random.gaussian(4, 2) + random.range(5, 10) + random.gaussian(0, 2) + 1 * r * random.gaussian(0, 2), tmp2D);
      mesh.position.x += tmp2D[0];
      mesh.position.z += tmp2D[1];
      mesh.quaternion.fromArray(random.quaternion(tmpQuatArray));
      mesh.userData.holdDelay = random.range(0.0, 1);
      mesh.position.y = random.range(0.5, 6); // if (!explode) mesh.position.y += random.range(2, 2);

      mesh.userData.appearing = true;
      mesh.userData.killing = false;
      mesh.userData.size = random.range(0.05, 0.1); // mesh.userData.size = 0.15 + 1 * Math.abs(random.gaussian(0, 0.3 / 4));
      // MathUtil.clamp(
      //   Math.abs(random.gaussian(0.1, 0.1)),
      //   0.025,
      //   0.09
      // );

      mesh.userData.speed = MathUtil.clamp(Math.abs(random.gaussian(0.5, 0.2)), 0.25, 1);
      mesh.userData.tween = 0;
      mesh.userData.velocity.set(0, 1, 0);
      mesh.quaternion.fromArray(random.quaternion(tmpQuatArray));
      mesh.userData.rotationAxis.fromArray(random.insideSphere(1, tmp3D));
      mesh.userData.rotationSpeed = 4;
      mesh.userData.rotationAngleOffset = random.range(-1, 1) * Math.PI * 2;
      mesh.userData.alpha = random.range(0.5, 1);

      if (explode) {
        random.insideCircle(1, tmp2D);
        tmpDir.x = tmp2D[0];
        tmpDir.y = random.range(0, 0.0);
        tmpDir.z = tmp2D[1];
        tmpDir.addScaledVector(direction, random.range(0, 1));
        tmpDir.normalize();
      } else {
        tmpDir.copy(direction);
        tmpDir.y += random.range(0, 0.5);
        tmpDir.normalize();
      }

      mesh.userData.velocity.copy(tmpDir);
      setAnimateTo(mesh, 1, explode ? 0 : random.range(0, 1));
    }
  }

  function setAnimateTo(mesh, to, delay) {
    const t = mesh.userData.entity.get(Tags.TargetKeyTween);
    t.to = to;
    t.delay = delay || 0;
    t.elapsed = 0;
    t.finished = false;
    t.started = false;
    t.active = true;
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/ShaderManager":"src/util/ShaderManager.js","../util/ObjectPool":"src/util/ObjectPool.js","../util/Random":"src/util/Random.js","../util/math":"src/util/math.js","./AnimationSystem":"src/systems/AnimationSystem.js","../util/load":"src/util/load.js","../util/three-util":"src/util/three-util.js"}],"src/systems/EnvironmentGroundDataTextureSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = EnvironmentGroundDataTextureSystem;

var THREE = _interopRequireWildcard(require("three"));

var Tags = _interopRequireWildcard(require("../tags"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _load = require("../util/load");

var _threeUtil = require("../util/three-util");

var _array = require("../util/array");

var _sineOut = _interopRequireDefault(require("eases/sine-out"));

var _sineIn = _interopRequireDefault(require("eases/sine-in"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _ObjectPool = _interopRequireDefault(require("../util/ObjectPool"));

var ShaderManager = _interopRequireWildcard(require("../util/ShaderManager"));

var _Assets = _interopRequireDefault(require("../util/Assets"));

var _addFrameTasks = require("../util/addFrameTasks");

var _AnimationSystem = require("./AnimationSystem");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const SOFT_ID = "image/data/soft-circle";

function EnvironmentGroundDataTextureSystem(world) {
  const renderer = world.findTag(Tags.Renderer);

  const [softMap] = _Assets.default.createGPUTextureTask(renderer, SOFT_ID);

  const random = (0, _Random.default)();
  const RTSIZE = 256;
  const renderTarget = new THREE.WebGLRenderTarget(RTSIZE, RTSIZE);
  renderTarget.texture.generateMipmaps = false;
  renderTarget.depthBuffer = false;
  renderTarget.texture.minFilter = THREE.LinearFilter;
  renderTarget.texture.magFilter = THREE.LinearFilter;
  renderTarget.texture.wrapS = renderTarget.texture.wrapT = THREE.ClampToEdgeWrapping;
  world.entity().add(Tags.DebugRenderTarget, {
    visible: false,
    target: renderTarget
  });
  const projection = new THREE.Matrix4();
  const view = new THREE.Matrix4();
  world.entity().add(Tags.GroundDataRenderTarget, {
    target: renderTarget,
    projection,
    view
  });
  const orthoCam = new THREE.OrthographicCamera(-1, 1, -1, 1, -100, 100);
  const orthoScene = new THREE.Scene(); // const group = new THREE.Group();
  // world.entity().add(Tags.Object3D, group);

  const gh = 4;
  const gr = 0.1;
  const geo = new THREE.CylinderGeometry(gr, gr, gh, 8);
  geo.translate(0, gh / 2, 0);
  const clearColor = new THREE.Vector3(0, 0, 0);
  const tmpColor = new THREE.Vector3(0, 0, 0);
  const activeParticles = [];
  const tmpVec2Arr = [0, 0];
  let lastPosition = new THREE.Vector3();
  let hasLastPosition = false;
  const fastShaderMaterial = ShaderManager.create({
    name: "Shader-Data-Texture",
    uniforms: {
      color: {
        value: new THREE.Color()
      },
      map: {
        value: softMap
      },
      opacity: {
        value: 0.0
      }
    },
    transparent: true,
    depthWrite: false,
    depthTest: false,
    side: THREE.DoubleSide,
    vertexShader:
    /*glsl*/
    `
    #include <common>
    varying vec2 vUv;

    void main () {
      vUv = uv;

      vec3 centerWorldPos = (modelMatrix * vec4(vec3(0.0), 1.0)).xyz;
      vec3 camRightWorld = vec3(viewMatrix[0].x, viewMatrix[1].x, viewMatrix[2].x);
      vec3 camUpWorld = vec3(viewMatrix[0].y, viewMatrix[1].y, viewMatrix[2].y);

      vec2 scale;
      scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
      scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

      vec3 offsetPos = position.xyz;
      vec3 vertexWorldPos = centerWorldPos
        + camRightWorld * offsetPos.x * scale.x
        + camUpWorld * offsetPos.y * scale.y;

      gl_Position = projectionMatrix * viewMatrix * vec4(vertexWorldPos, 1.0);
    }`,
    fragmentShader:
    /*glsl*/
    `
    uniform sampler2D map;
    uniform float opacity;
    uniform vec3 color;
    varying vec2 vUv;
    void main () {
      gl_FragColor = texture2D(map, vUv) * vec4(color, opacity);
    }
    `
  });
  const particlePool = new _ObjectPool.default({
    name: "ParticlePool",
    initialCapacity: 100,

    create() {
      const material = fastShaderMaterial;
      const mesh = new THREE.Sprite(material // new THREE.SpriteMaterial({
      //   map: softMap,
      //   transparent: true,
      //   depthWrite: false,
      //   depthTest: false,
      //   opacity: 0.0,
      //   side: THREE.DoubleSide,
      // })
      );
      (0, _threeUtil.cloneMaterial)(mesh);
      ShaderManager.push(mesh.material);
      mesh.userData = {
        time: 0,
        directionX: 0,
        directionY: 0,
        velocity: new THREE.Vector3(),
        // angle: Math.atan2(userChar.direction.z, userChar.direction.x),
        userSpeed: 0,
        strength: 1,
        delay: random.range(0, 0.1),
        duration: random.range(0, 2),
        durationIn: random.range(1.25, 1.5),
        durationOut: 1,
        minSize: 2,
        size: random.range(5, 7.5),
        // position: position.clone(),
        alpha: 0,
        opacity: 1,
        active: false
      };
      return mesh;
    }

  });
  let time = 0;
  let globalAlpha = {
    value: 1,
    tweening: false
  };
  const biomeResolution = world.listen(Tags.FinalBiomeResolution); // const swapEvents = world.listen(Tags.SafeToSwapBiomes);
  // Note; we exit out of ECS linear system style here
  // This is a big error prone but hopefully improves per frame perf

  (0, _addFrameTasks.addPreRenderCallback)(submitRender);
  return function envGroundDataTexSystem(dt) {
    time += dt;
    const canvas = renderer.domElement;
    const width = canvas.width;
    const height = canvas.height;
    if (canvas.width === 0 || canvas.height === 0) return;

    if (biomeResolution.added.length > 0) {
      (0, _AnimationSystem.tweenTo)(world, globalAlpha, "value", 0, 1, "sineOut");
    } // if (swapEvents.added.length > 0) {
    //   tweenTo(world, globalAlpha, "value", 1, 1, "sineOut");
    // }
    // const camera = world.findTag(Tags.MainCamera);
    // camera.updateMatrixWorld();


    const userChar = world.findTag(Tags.UserCharacter);
    const userTarget = world.findTag(Tags.UserTarget);
    const position = userChar.position;
    const target = userTarget.position;
    const distThreshold = 0.5;
    const distThresholdSq = distThreshold * distThreshold;

    if (!hasLastPosition || lastPosition.distanceToSquared(position) >= distThresholdSq) {
      const mesh = particlePool.next();
      const d = mesh.userData;
      d.active = true;
      d.time = 0;
      d.alpha = 0;
      d.directionX = userChar.direction.x;
      d.directionY = userChar.direction.z;
      d.velocity.copy(userChar.velocity);
      d.userSpeed = userTarget.totalSpeedAlpha;
      const r = random.insideCircle(0.5, tmpVec2Arr);
      mesh.position.set(position.x, position.z, 0);
      mesh.position.x += r[0];
      mesh.position.y += r[1];
      mesh.position.x += userChar.direction.x * 1;
      mesh.position.z += userChar.direction.z * 1;
      orthoScene.add(mesh);
      activeParticles.push(mesh);
      lastPosition.copy(position);
      hasLastPosition = true;
    }

    activeParticles.forEach(mesh => {
      const p = mesh.userData;
      p.time += dt;
      const maxVel = 0.15;
      const vx = MathUtil.mapRange(p.velocity.x, -maxVel, maxVel, 0, 1, true);
      const vz = MathUtil.mapRange(p.velocity.z, -maxVel, maxVel, 0, 1, true);
      const velx = MathUtil.clamp(p.velocity.x, -maxVel, maxVel);
      const velz = MathUtil.clamp(p.velocity.z, -maxVel, maxVel);
      mesh.position.x += velx * 0.2;
      mesh.position.z += velz * 0.2;
      const curTime = Math.max(0, p.time - p.delay);
      const totalDur = p.duration + p.durationIn + p.durationOut;

      if (curTime < p.durationIn) {
        p.alpha = (0, _sineOut.default)(MathUtil.clamp01(curTime / p.durationIn));
      } else if (curTime >= p.durationIn + p.duration) {
        const start = Math.max(0, curTime - (p.durationIn + p.duration));
        p.alpha = 1 - (0, _sineIn.default)(MathUtil.clamp01(start / p.durationOut));
      } else {
        p.alpha = 1;
      }

      if (curTime >= totalDur) {
        p.active = false;
      } //


      const kt = 1; // const angleT = MathUtil.mapRange(p.angle, -Math.PI, Math.PI, 0, 1, true);
      // const angle = (angleT * 2 - 1) * Math.PI;

      mesh.material.uniforms.color.value.setRGB(1, p.directionX * 0.5 + 0.5, p.directionY * 0.5 + 0.5); // mesh.material.color.setRGB(1, vx, vz);

      mesh.material.uniforms.opacity.value = p.alpha * p.opacity * kt * globalAlpha.value;
      mesh.scale.setScalar(MathUtil.lerp(p.minSize, p.size, Math.pow(p.alpha, 1)));
    });

    for (let i = activeParticles.length - 1; i >= 0; i--) {
      if (!activeParticles[i].userData.active) {
        const mesh = activeParticles[i];
        particlePool.release(mesh);
        (0, _threeUtil.detachObject)(mesh);
        (0, _array.spliceOne)(activeParticles, i);
      }
    }

    const windowView = 40;
    orthoCam.left = -windowView / 2;
    orthoCam.right = windowView / 2;
    orthoCam.top = windowView / 2;
    orthoCam.bottom = -windowView / 2;
    orthoCam.position.set(target.x, target.z, 0);
    orthoCam.zoom = 1;
    orthoCam.updateProjectionMatrix();
    orthoCam.updateMatrixWorld();
    projection.copy(orthoCam.projectionMatrix).multiply(orthoCam.matrixWorldInverse);
    view.identity(); // view.copy(orthoCam.matrixWorldInverse);
    // orthoCam.zoom = Math.sin()
    // Note: we could render here but we save it for SubmitFrameSystem
    // we do this by adding a 'pre render' callback - not ideal with ECS
    // but will do for perf.
    // submitRender();
  };

  function submitRender() {
    tmpColor.copy(renderer.getClearColor());
    renderer.setRenderTarget(renderTarget);
    renderer.setClearColor(clearColor);
    renderer.clear();
    renderer.render(orthoScene, orthoCam);
    renderer.setRenderTarget(null);
    renderer.setClearColor(tmpColor);
  }

  function quickCopy(cameraSrc, cameraDst) {
    THREE.Camera.prototype.copy.call(cameraDst, cameraSrc);
    cameraDst.fov = cameraSrc.fov;
    cameraDst.zoom = cameraSrc.zoom;
    cameraDst.near = cameraSrc.near;
    cameraDst.far = cameraSrc.far;
    cameraDst.focus = cameraSrc.focus;
    cameraDst.aspect = cameraSrc.aspect;
    cameraDst.filmGauge = cameraSrc.filmGauge;
    cameraDst.filmOffset = cameraSrc.filmOffset;
  }
}
},{"three":"src/vendor/three.module.js","../tags":"src/tags/index.js","../util/math":"src/util/math.js","../util/load":"src/util/load.js","../util/three-util":"src/util/three-util.js","../util/array":"src/util/array.js","eases/sine-out":"node_modules/eases/sine-out.js","eases/sine-in":"node_modules/eases/sine-in.js","../util/Random":"src/util/Random.js","../util/ObjectPool":"src/util/ObjectPool.js","../util/ShaderManager":"src/util/ShaderManager.js","../util/Assets":"src/util/Assets.js","../util/addFrameTasks":"src/util/addFrameTasks.js","./AnimationSystem":"src/systems/AnimationSystem.js"}],"src/assets/audio/bird0.mp3":[function(require,module,exports) {
module.exports = "/bird0.c3e2e736.mp3";
},{}],"src/assets/audio/bird0.ogg":[function(require,module,exports) {
module.exports = "/bird0.42ef7885.ogg";
},{}],"src/assets/audio/bird1.mp3":[function(require,module,exports) {
module.exports = "/bird1.b5ce0d5e.mp3";
},{}],"src/assets/audio/bird1.ogg":[function(require,module,exports) {
module.exports = "/bird1.17c4a703.ogg";
},{}],"src/assets/audio/birdflap.mp3":[function(require,module,exports) {
module.exports = "/birdflap.e1903c61.mp3";
},{}],"src/assets/audio/birdflap.ogg":[function(require,module,exports) {
module.exports = "/birdflap.e7b7ac8b.ogg";
},{}],"src/assets/audio/bnote1.mp3":[function(require,module,exports) {
module.exports = "/bnote1.407fd5c7.mp3";
},{}],"src/assets/audio/bnote1.ogg":[function(require,module,exports) {
module.exports = "/bnote1.debdaf8c.ogg";
},{}],"src/assets/audio/bnote2.mp3":[function(require,module,exports) {
module.exports = "/bnote2.8c3849a5.mp3";
},{}],"src/assets/audio/bnote2.ogg":[function(require,module,exports) {
module.exports = "/bnote2.b3907fea.ogg";
},{}],"src/assets/audio/bnote3.mp3":[function(require,module,exports) {
module.exports = "/bnote3.eced6dc8.mp3";
},{}],"src/assets/audio/bnote3.ogg":[function(require,module,exports) {
module.exports = "/bnote3.1440a1fd.ogg";
},{}],"src/assets/audio/bnote4.mp3":[function(require,module,exports) {
module.exports = "/bnote4.de3384dc.mp3";
},{}],"src/assets/audio/bnote5.mp3":[function(require,module,exports) {
module.exports = "/bnote5.4fcfadde.mp3";
},{}],"src/assets/audio/bnote4.ogg":[function(require,module,exports) {
module.exports = "/bnote4.b1d68a78.ogg";
},{}],"src/assets/audio/bnote5.ogg":[function(require,module,exports) {
module.exports = "/bnote5.a380de6b.ogg";
},{}],"src/assets/audio/bnote6.mp3":[function(require,module,exports) {
module.exports = "/bnote6.b7d08403.mp3";
},{}],"src/assets/audio/bnote6.ogg":[function(require,module,exports) {
module.exports = "/bnote6.f68f1778.ogg";
},{}],"src/assets/audio/bnote7.mp3":[function(require,module,exports) {
module.exports = "/bnote7.edd549d3.mp3";
},{}],"src/assets/audio/bnote7.ogg":[function(require,module,exports) {
module.exports = "/bnote7.424b5477.ogg";
},{}],"src/assets/audio/butterfly.mp3":[function(require,module,exports) {
module.exports = "/butterfly.f3f85081.mp3";
},{}],"src/assets/audio/butterfly.ogg":[function(require,module,exports) {
module.exports = "/butterfly.231f283f.ogg";
},{}],"src/assets/audio/button-click.mp3":[function(require,module,exports) {
module.exports = "/button-click.5e3f218e.mp3";
},{}],"src/assets/audio/button-click.ogg":[function(require,module,exports) {
module.exports = "/button-click.a662dc85.ogg";
},{}],"src/assets/audio/button-hover.mp3":[function(require,module,exports) {
module.exports = "/button-hover.1e9bef33.mp3";
},{}],"src/assets/audio/button-hover.ogg":[function(require,module,exports) {
module.exports = "/button-hover.26940a8a.ogg";
},{}],"src/assets/audio/click.mp3":[function(require,module,exports) {
module.exports = "/click.4d6d2235.mp3";
},{}],"src/assets/audio/click.ogg":[function(require,module,exports) {
module.exports = "/click.1533b03b.ogg";
},{}],"src/assets/audio/collect-poem.mp3":[function(require,module,exports) {
module.exports = "/collect-poem.6e18be2c.mp3";
},{}],"src/assets/audio/collect-poem.ogg":[function(require,module,exports) {
module.exports = "/collect-poem.bd906b3c.ogg";
},{}],"src/assets/audio/collect1.mp3":[function(require,module,exports) {
module.exports = "/collect1.6b09ecd8.mp3";
},{}],"src/assets/audio/collect1.ogg":[function(require,module,exports) {
module.exports = "/collect1.4cc8cbd8.ogg";
},{}],"src/assets/audio/fish.mp3":[function(require,module,exports) {
module.exports = "/fish.90de149e.mp3";
},{}],"src/assets/audio/fish.ogg":[function(require,module,exports) {
module.exports = "/fish.e870c41d.ogg";
},{}],"src/assets/audio/flash-build-up.mp3":[function(require,module,exports) {
module.exports = "/flash-build-up.207a6e4c.mp3";
},{}],"src/assets/audio/foxhm.mp3":[function(require,module,exports) {
module.exports = "/foxhm.b4d21850.mp3";
},{}],"src/assets/audio/foxhm.ogg":[function(require,module,exports) {
module.exports = "/foxhm.5c5077c0.ogg";
},{}],"src/assets/audio/foxpurring.mp3":[function(require,module,exports) {
module.exports = "/foxpurring.e3f18341.mp3";
},{}],"src/assets/audio/foxpurring.ogg":[function(require,module,exports) {
module.exports = "/foxpurring.330e7942.ogg";
},{}],"src/assets/audio/grass-push1.mp3":[function(require,module,exports) {
module.exports = "/grass-push1.10c09a93.mp3";
},{}],"src/assets/audio/grass-push1.ogg":[function(require,module,exports) {
module.exports = "/grass-push1.e35ad619.ogg";
},{}],"src/assets/audio/grass-push2.mp3":[function(require,module,exports) {
module.exports = "/grass-push2.b4daacc8.mp3";
},{}],"src/assets/audio/grass-push2.ogg":[function(require,module,exports) {
module.exports = "/grass-push2.c7f0bc83.ogg";
},{}],"src/assets/audio/haiku-card.mp3":[function(require,module,exports) {
module.exports = "/haiku-card.b0dd74bb.mp3";
},{}],"src/assets/audio/haiku-card.ogg":[function(require,module,exports) {
module.exports = "/haiku-card.b2ccfdf7.ogg";
},{}],"src/assets/audio/ice-01.mp3":[function(require,module,exports) {
module.exports = "/ice-01.aaab26cc.mp3";
},{}],"src/assets/audio/ice-01.ogg":[function(require,module,exports) {
module.exports = "/ice-01.766934f2.ogg";
},{}],"src/assets/audio/ice-02.mp3":[function(require,module,exports) {
module.exports = "/ice-02.1a80266a.mp3";
},{}],"src/assets/audio/ice-02.ogg":[function(require,module,exports) {
module.exports = "/ice-02.12b9a2ef.ogg";
},{}],"src/assets/audio/ice-03.mp3":[function(require,module,exports) {
module.exports = "/ice-03.fcacf9df.mp3";
},{}],"src/assets/audio/ice-03.ogg":[function(require,module,exports) {
module.exports = "/ice-03.a24879b7.ogg";
},{}],"src/assets/audio/journal-open.mp3":[function(require,module,exports) {
module.exports = "/journal-open.42b43a1c.mp3";
},{}],"src/assets/audio/journal-open.ogg":[function(require,module,exports) {
module.exports = "/journal-open.29296714.ogg";
},{}],"src/assets/audio/leaves1.mp3":[function(require,module,exports) {
module.exports = "/leaves1.bac0c95d.mp3";
},{}],"src/assets/audio/leaves1.ogg":[function(require,module,exports) {
module.exports = "/leaves1.491389ac.ogg";
},{}],"src/assets/audio/leaves2.mp3":[function(require,module,exports) {
module.exports = "/leaves2.e875e307.mp3";
},{}],"src/assets/audio/leaves2.ogg":[function(require,module,exports) {
module.exports = "/leaves2.d67e9689.ogg";
},{}],"src/assets/audio/leaves3.mp3":[function(require,module,exports) {
module.exports = "/leaves3.d15c6b2f.mp3";
},{}],"src/assets/audio/leaves3.ogg":[function(require,module,exports) {
module.exports = "/leaves3.361f31b0.ogg";
},{}],"src/assets/audio/leaves4.mp3":[function(require,module,exports) {
module.exports = "/leaves4.9a7139c3.mp3";
},{}],"src/assets/audio/leaves4.ogg":[function(require,module,exports) {
module.exports = "/leaves4.dc299124.ogg";
},{}],"src/assets/audio/menu-open.mp3":[function(require,module,exports) {
module.exports = "/menu-open.8236b9e1.mp3";
},{}],"src/assets/audio/menu-open.ogg":[function(require,module,exports) {
module.exports = "/menu-open.b7c9a9dd.ogg";
},{}],"src/assets/audio/movement-forest.mp3":[function(require,module,exports) {
module.exports = "/movement-forest.30b3ac72.mp3";
},{}],"src/assets/audio/movement-forest.ogg":[function(require,module,exports) {
module.exports = "/movement-forest.940ae105.ogg";
},{}],"src/assets/audio/music1.mp3":[function(require,module,exports) {
module.exports = "/music1.1682337c.mp3";
},{}],"src/assets/audio/music1.ogg":[function(require,module,exports) {
module.exports = "/music1.050040b1.ogg";
},{}],"src/assets/audio/music2.ogg":[function(require,module,exports) {
module.exports = "/music2.769e305c.ogg";
},{}],"src/assets/audio/music2.mp3":[function(require,module,exports) {
module.exports = "/music2.5f4b34f5.mp3";
},{}],"src/assets/audio/music3a.mp3":[function(require,module,exports) {
module.exports = "/music3a.eadac3f0.mp3";
},{}],"src/assets/audio/music3a.ogg":[function(require,module,exports) {
module.exports = "/music3a.c9f8ce8a.ogg";
},{}],"src/assets/audio/music3b.mp3":[function(require,module,exports) {
module.exports = "/music3b.f3ce537f.mp3";
},{}],"src/assets/audio/music3b.ogg":[function(require,module,exports) {
module.exports = "/music3b.6c2aba77.ogg";
},{}],"src/assets/audio/nature1.mp3":[function(require,module,exports) {
module.exports = "/nature1.74a0a438.mp3";
},{}],"src/assets/audio/nature1.ogg":[function(require,module,exports) {
module.exports = "/nature1.ea65259b.ogg";
},{}],"src/assets/audio/nature2-old.mp3":[function(require,module,exports) {
module.exports = "/nature2-old.9a558dbf.mp3";
},{}],"src/assets/audio/nature2-old.ogg":[function(require,module,exports) {
module.exports = "/nature2-old.91729521.ogg";
},{}],"src/assets/audio/nature2.mp3":[function(require,module,exports) {
module.exports = "/nature2.97682acb.mp3";
},{}],"src/assets/audio/nature2.ogg":[function(require,module,exports) {
module.exports = "/nature2.2afd8d61.ogg";
},{}],"src/assets/audio/nature3.mp3":[function(require,module,exports) {
module.exports = "/nature3.04fbd52f.mp3";
},{}],"src/assets/audio/nature3.ogg":[function(require,module,exports) {
module.exports = "/nature3.9935a0aa.ogg";
},{}],"src/assets/audio/note-forest-a3.mp3":[function(require,module,exports) {
module.exports = "/note-forest-a3.486dee47.mp3";
},{}],"src/assets/audio/note-forest-a3.ogg":[function(require,module,exports) {
module.exports = "/note-forest-a3.cf9de8d7.ogg";
},{}],"src/assets/audio/note-forest-c3.mp3":[function(require,module,exports) {
module.exports = "/note-forest-c3.09227fcb.mp3";
},{}],"src/assets/audio/note-forest-c3.ogg":[function(require,module,exports) {
module.exports = "/note-forest-c3.de57945b.ogg";
},{}],"src/assets/audio/note-forest-c4.mp3":[function(require,module,exports) {
module.exports = "/note-forest-c4.7f6156d1.mp3";
},{}],"src/assets/audio/note-forest-d3.mp3":[function(require,module,exports) {
module.exports = "/note-forest-d3.2012c774.mp3";
},{}],"src/assets/audio/note-forest-c4.ogg":[function(require,module,exports) {
module.exports = "/note-forest-c4.d6eaea84.ogg";
},{}],"src/assets/audio/note-forest-d3.ogg":[function(require,module,exports) {
module.exports = "/note-forest-d3.60a86b3c.ogg";
},{}],"src/assets/audio/note-forest-d4.mp3":[function(require,module,exports) {
module.exports = "/note-forest-d4.6e680fe7.mp3";
},{}],"src/assets/audio/note-forest-e3.mp3":[function(require,module,exports) {
module.exports = "/note-forest-e3.5dae5b12.mp3";
},{}],"src/assets/audio/note-forest-d4.ogg":[function(require,module,exports) {
module.exports = "/note-forest-d4.08dfba55.ogg";
},{}],"src/assets/audio/note-forest-e3.ogg":[function(require,module,exports) {
module.exports = "/note-forest-e3.10abda78.ogg";
},{}],"src/assets/audio/note-forest-g3.mp3":[function(require,module,exports) {
module.exports = "/note-forest-g3.b98fed73.mp3";
},{}],"src/assets/audio/note-forest-g3.ogg":[function(require,module,exports) {
module.exports = "/note-forest-g3.e4bd9da0.ogg";
},{}],"src/assets/audio/note-grasslands-a3.ogg":[function(require,module,exports) {
module.exports = "/note-grasslands-a3.4269a5f4.ogg";
},{}],"src/assets/audio/note-grasslands-a3.mp3":[function(require,module,exports) {
module.exports = "/note-grasslands-a3.3f788275.mp3";
},{}],"src/assets/audio/note-grasslands-c3.mp3":[function(require,module,exports) {
module.exports = "/note-grasslands-c3.33d6d46d.mp3";
},{}],"src/assets/audio/note-grasslands-c4.mp3":[function(require,module,exports) {
module.exports = "/note-grasslands-c4.b638b8e2.mp3";
},{}],"src/assets/audio/note-grasslands-d3.mp3":[function(require,module,exports) {
module.exports = "/note-grasslands-d3.87e9b874.mp3";
},{}],"src/assets/audio/note-grasslands-d4.mp3":[function(require,module,exports) {
module.exports = "/note-grasslands-d4.a59ba08a.mp3";
},{}],"src/assets/audio/note-grasslands-e3.mp3":[function(require,module,exports) {
module.exports = "/note-grasslands-e3.4777987e.mp3";
},{}],"src/assets/audio/note-grasslands-g3.mp3":[function(require,module,exports) {
module.exports = "/note-grasslands-g3.5990559e.mp3";
},{}],"src/assets/audio/note-tundra-a3.mp3":[function(require,module,exports) {
module.exports = "/note-tundra-a3.5b7c0964.mp3";
},{}],"src/assets/audio/note-tundra-c3.mp3":[function(require,module,exports) {
module.exports = "/note-tundra-c3.50f100c7.mp3";
},{}],"src/assets/audio/note-tundra-c4.mp3":[function(require,module,exports) {
module.exports = "/note-tundra-c4.0e431424.mp3";
},{}],"src/assets/audio/note-tundra-d3.mp3":[function(require,module,exports) {
module.exports = "/note-tundra-d3.82043ffa.mp3";
},{}],"src/assets/audio/note-tundra-e3.mp3":[function(require,module,exports) {
module.exports = "/note-tundra-e3.97acc527.mp3";
},{}],"src/assets/audio/note-tundra-d4.mp3":[function(require,module,exports) {
module.exports = "/note-tundra-d4.9e8aea4b.mp3";
},{}],"src/assets/audio/note-tundra-g3.mp3":[function(require,module,exports) {
module.exports = "/note-tundra-g3.8dd87050.mp3";
},{}],"src/assets/audio/pickup.mp3":[function(require,module,exports) {
module.exports = "/pickup.2b40b3fe.mp3";
},{}],"src/assets/audio/rain.mp3":[function(require,module,exports) {
module.exports = "/rain.6dd5fdb0.mp3";
},{}],"src/assets/audio/reveal01.mp3":[function(require,module,exports) {
module.exports = "/reveal01.4b0f3830.mp3";
},{}],"src/assets/audio/reveal02.mp3":[function(require,module,exports) {
module.exports = "/reveal02.ec3f86df.mp3";
},{}],"src/assets/audio/score-haiku.mp3":[function(require,module,exports) {
module.exports = "/score-haiku.601adaf1.mp3";
},{}],"src/assets/audio/score-outro.mp3":[function(require,module,exports) {
module.exports = "/score-outro.b6732572.mp3";
},{}],"src/assets/audio/score-restore.mp3":[function(require,module,exports) {
module.exports = "/score-restore.7cc515fd.mp3";
},{}],"src/assets/audio/score-start.mp3":[function(require,module,exports) {
module.exports = "/score-start.a95dc886.mp3";
},{}],"src/assets/audio/score-transition.mp3":[function(require,module,exports) {
module.exports = "/score-transition.95962a57.mp3";
},{}],"src/assets/audio/tree-transition-0.mp3":[function(require,module,exports) {
module.exports = "/tree-transition-0.0b7d758b.mp3";
},{}],"src/assets/audio/tree-transition-1.mp3":[function(require,module,exports) {
module.exports = "/tree-transition-1.e500f7b6.mp3";
},{}],"src/assets/audio/water-01.mp3":[function(require,module,exports) {
module.exports = "/water-01.5537c0e6.mp3";
},{}],"src/assets/audio/water-02.mp3":[function(require,module,exports) {
module.exports = "/water-02.c7a0813f.mp3";
},{}],"src/assets/audio/writing-01.mp3":[function(require,module,exports) {
module.exports = "/writing-01.abfa9aea.mp3";
},{}],"src/assets/audio/writing-02.mp3":[function(require,module,exports) {
module.exports = "/writing-02.54ab428a.mp3";
},{}],"src/assets/audio/writing-03.mp3":[function(require,module,exports) {
module.exports = "/writing-03.e0fe9c61.mp3";
},{}],"src/assets/audio/*.{mp3,ogg}":[function(require,module,exports) {
module.exports = {
  "bird0": {
    "mp3": require("./bird0.mp3"),
    "ogg": require("./bird0.ogg")
  },
  "bird1": {
    "mp3": require("./bird1.mp3"),
    "ogg": require("./bird1.ogg")
  },
  "birdflap": {
    "mp3": require("./birdflap.mp3"),
    "ogg": require("./birdflap.ogg")
  },
  "bnote1": {
    "mp3": require("./bnote1.mp3"),
    "ogg": require("./bnote1.ogg")
  },
  "bnote2": {
    "mp3": require("./bnote2.mp3"),
    "ogg": require("./bnote2.ogg")
  },
  "bnote3": {
    "mp3": require("./bnote3.mp3"),
    "ogg": require("./bnote3.ogg")
  },
  "bnote4": {
    "mp3": require("./bnote4.mp3"),
    "ogg": require("./bnote4.ogg")
  },
  "bnote5": {
    "mp3": require("./bnote5.mp3"),
    "ogg": require("./bnote5.ogg")
  },
  "bnote6": {
    "mp3": require("./bnote6.mp3"),
    "ogg": require("./bnote6.ogg")
  },
  "bnote7": {
    "mp3": require("./bnote7.mp3"),
    "ogg": require("./bnote7.ogg")
  },
  "butterfly": {
    "mp3": require("./butterfly.mp3"),
    "ogg": require("./butterfly.ogg")
  },
  "button-click": {
    "mp3": require("./button-click.mp3"),
    "ogg": require("./button-click.ogg")
  },
  "button-hover": {
    "mp3": require("./button-hover.mp3"),
    "ogg": require("./button-hover.ogg")
  },
  "click": {
    "mp3": require("./click.mp3"),
    "ogg": require("./click.ogg")
  },
  "collect-poem": {
    "mp3": require("./collect-poem.mp3"),
    "ogg": require("./collect-poem.ogg")
  },
  "collect1": {
    "mp3": require("./collect1.mp3"),
    "ogg": require("./collect1.ogg")
  },
  "fish": {
    "mp3": require("./fish.mp3"),
    "ogg": require("./fish.ogg")
  },
  "flash-build-up": {
    "mp3": require("./flash-build-up.mp3")
  },
  "foxhm": {
    "mp3": require("./foxhm.mp3"),
    "ogg": require("./foxhm.ogg")
  },
  "foxpurring": {
    "mp3": require("./foxpurring.mp3"),
    "ogg": require("./foxpurring.ogg")
  },
  "grass-push1": {
    "mp3": require("./grass-push1.mp3"),
    "ogg": require("./grass-push1.ogg")
  },
  "grass-push2": {
    "mp3": require("./grass-push2.mp3"),
    "ogg": require("./grass-push2.ogg")
  },
  "haiku-card": {
    "mp3": require("./haiku-card.mp3"),
    "ogg": require("./haiku-card.ogg")
  },
  "ice-01": {
    "mp3": require("./ice-01.mp3"),
    "ogg": require("./ice-01.ogg")
  },
  "ice-02": {
    "mp3": require("./ice-02.mp3"),
    "ogg": require("./ice-02.ogg")
  },
  "ice-03": {
    "mp3": require("./ice-03.mp3"),
    "ogg": require("./ice-03.ogg")
  },
  "journal-open": {
    "mp3": require("./journal-open.mp3"),
    "ogg": require("./journal-open.ogg")
  },
  "leaves1": {
    "mp3": require("./leaves1.mp3"),
    "ogg": require("./leaves1.ogg")
  },
  "leaves2": {
    "mp3": require("./leaves2.mp3"),
    "ogg": require("./leaves2.ogg")
  },
  "leaves3": {
    "mp3": require("./leaves3.mp3"),
    "ogg": require("./leaves3.ogg")
  },
  "leaves4": {
    "mp3": require("./leaves4.mp3"),
    "ogg": require("./leaves4.ogg")
  },
  "menu-open": {
    "mp3": require("./menu-open.mp3"),
    "ogg": require("./menu-open.ogg")
  },
  "movement-forest": {
    "mp3": require("./movement-forest.mp3"),
    "ogg": require("./movement-forest.ogg")
  },
  "music1": {
    "mp3": require("./music1.mp3"),
    "ogg": require("./music1.ogg")
  },
  "music2": {
    "ogg": require("./music2.ogg"),
    "mp3": require("./music2.mp3")
  },
  "music3a": {
    "mp3": require("./music3a.mp3"),
    "ogg": require("./music3a.ogg")
  },
  "music3b": {
    "mp3": require("./music3b.mp3"),
    "ogg": require("./music3b.ogg")
  },
  "nature1": {
    "mp3": require("./nature1.mp3"),
    "ogg": require("./nature1.ogg")
  },
  "nature2-old": {
    "mp3": require("./nature2-old.mp3"),
    "ogg": require("./nature2-old.ogg")
  },
  "nature2": {
    "mp3": require("./nature2.mp3"),
    "ogg": require("./nature2.ogg")
  },
  "nature3": {
    "mp3": require("./nature3.mp3"),
    "ogg": require("./nature3.ogg")
  },
  "note-forest-a3": {
    "mp3": require("./note-forest-a3.mp3"),
    "ogg": require("./note-forest-a3.ogg")
  },
  "note-forest-c3": {
    "mp3": require("./note-forest-c3.mp3"),
    "ogg": require("./note-forest-c3.ogg")
  },
  "note-forest-c4": {
    "mp3": require("./note-forest-c4.mp3"),
    "ogg": require("./note-forest-c4.ogg")
  },
  "note-forest-d3": {
    "mp3": require("./note-forest-d3.mp3"),
    "ogg": require("./note-forest-d3.ogg")
  },
  "note-forest-d4": {
    "mp3": require("./note-forest-d4.mp3"),
    "ogg": require("./note-forest-d4.ogg")
  },
  "note-forest-e3": {
    "mp3": require("./note-forest-e3.mp3"),
    "ogg": require("./note-forest-e3.ogg")
  },
  "note-forest-g3": {
    "mp3": require("./note-forest-g3.mp3"),
    "ogg": require("./note-forest-g3.ogg")
  },
  "note-grasslands-a3": {
    "ogg": require("./note-grasslands-a3.ogg"),
    "mp3": require("./note-grasslands-a3.mp3")
  },
  "note-grasslands-c3": {
    "mp3": require("./note-grasslands-c3.mp3")
  },
  "note-grasslands-c4": {
    "mp3": require("./note-grasslands-c4.mp3")
  },
  "note-grasslands-d3": {
    "mp3": require("./note-grasslands-d3.mp3")
  },
  "note-grasslands-d4": {
    "mp3": require("./note-grasslands-d4.mp3")
  },
  "note-grasslands-e3": {
    "mp3": require("./note-grasslands-e3.mp3")
  },
  "note-grasslands-g3": {
    "mp3": require("./note-grasslands-g3.mp3")
  },
  "note-tundra-a3": {
    "mp3": require("./note-tundra-a3.mp3")
  },
  "note-tundra-c3": {
    "mp3": require("./note-tundra-c3.mp3")
  },
  "note-tundra-c4": {
    "mp3": require("./note-tundra-c4.mp3")
  },
  "note-tundra-d3": {
    "mp3": require("./note-tundra-d3.mp3")
  },
  "note-tundra-e3": {
    "mp3": require("./note-tundra-e3.mp3")
  },
  "note-tundra-d4": {
    "mp3": require("./note-tundra-d4.mp3")
  },
  "note-tundra-g3": {
    "mp3": require("./note-tundra-g3.mp3")
  },
  "pickup": {
    "mp3": require("./pickup.mp3")
  },
  "rain": {
    "mp3": require("./rain.mp3")
  },
  "reveal01": {
    "mp3": require("./reveal01.mp3")
  },
  "reveal02": {
    "mp3": require("./reveal02.mp3")
  },
  "score-haiku": {
    "mp3": require("./score-haiku.mp3")
  },
  "score-outro": {
    "mp3": require("./score-outro.mp3")
  },
  "score-restore": {
    "mp3": require("./score-restore.mp3")
  },
  "score-start": {
    "mp3": require("./score-start.mp3")
  },
  "score-transition": {
    "mp3": require("./score-transition.mp3")
  },
  "tree-transition-0": {
    "mp3": require("./tree-transition-0.mp3")
  },
  "tree-transition-1": {
    "mp3": require("./tree-transition-1.mp3")
  },
  "water-01": {
    "mp3": require("./water-01.mp3")
  },
  "water-02": {
    "mp3": require("./water-02.mp3")
  },
  "writing-01": {
    "mp3": require("./writing-01.mp3")
  },
  "writing-02": {
    "mp3": require("./writing-02.mp3")
  },
  "writing-03": {
    "mp3": require("./writing-03.mp3")
  }
};
},{"./bird0.mp3":"src/assets/audio/bird0.mp3","./bird0.ogg":"src/assets/audio/bird0.ogg","./bird1.mp3":"src/assets/audio/bird1.mp3","./bird1.ogg":"src/assets/audio/bird1.ogg","./birdflap.mp3":"src/assets/audio/birdflap.mp3","./birdflap.ogg":"src/assets/audio/birdflap.ogg","./bnote1.mp3":"src/assets/audio/bnote1.mp3","./bnote1.ogg":"src/assets/audio/bnote1.ogg","./bnote2.mp3":"src/assets/audio/bnote2.mp3","./bnote2.ogg":"src/assets/audio/bnote2.ogg","./bnote3.mp3":"src/assets/audio/bnote3.mp3","./bnote3.ogg":"src/assets/audio/bnote3.ogg","./bnote4.mp3":"src/assets/audio/bnote4.mp3","./bnote5.mp3":"src/assets/audio/bnote5.mp3","./bnote4.ogg":"src/assets/audio/bnote4.ogg","./bnote5.ogg":"src/assets/audio/bnote5.ogg","./bnote6.mp3":"src/assets/audio/bnote6.mp3","./bnote6.ogg":"src/assets/audio/bnote6.ogg","./bnote7.mp3":"src/assets/audio/bnote7.mp3","./bnote7.ogg":"src/assets/audio/bnote7.ogg","./butterfly.mp3":"src/assets/audio/butterfly.mp3","./butterfly.ogg":"src/assets/audio/butterfly.ogg","./button-click.mp3":"src/assets/audio/button-click.mp3","./button-click.ogg":"src/assets/audio/button-click.ogg","./button-hover.mp3":"src/assets/audio/button-hover.mp3","./button-hover.ogg":"src/assets/audio/button-hover.ogg","./click.mp3":"src/assets/audio/click.mp3","./click.ogg":"src/assets/audio/click.ogg","./collect-poem.mp3":"src/assets/audio/collect-poem.mp3","./collect-poem.ogg":"src/assets/audio/collect-poem.ogg","./collect1.mp3":"src/assets/audio/collect1.mp3","./collect1.ogg":"src/assets/audio/collect1.ogg","./fish.mp3":"src/assets/audio/fish.mp3","./fish.ogg":"src/assets/audio/fish.ogg","./flash-build-up.mp3":"src/assets/audio/flash-build-up.mp3","./foxhm.mp3":"src/assets/audio/foxhm.mp3","./foxhm.ogg":"src/assets/audio/foxhm.ogg","./foxpurring.mp3":"src/assets/audio/foxpurring.mp3","./foxpurring.ogg":"src/assets/audio/foxpurring.ogg","./grass-push1.mp3":"src/assets/audio/grass-push1.mp3","./grass-push1.ogg":"src/assets/audio/grass-push1.ogg","./grass-push2.mp3":"src/assets/audio/grass-push2.mp3","./grass-push2.ogg":"src/assets/audio/grass-push2.ogg","./haiku-card.mp3":"src/assets/audio/haiku-card.mp3","./haiku-card.ogg":"src/assets/audio/haiku-card.ogg","./ice-01.mp3":"src/assets/audio/ice-01.mp3","./ice-01.ogg":"src/assets/audio/ice-01.ogg","./ice-02.mp3":"src/assets/audio/ice-02.mp3","./ice-02.ogg":"src/assets/audio/ice-02.ogg","./ice-03.mp3":"src/assets/audio/ice-03.mp3","./ice-03.ogg":"src/assets/audio/ice-03.ogg","./journal-open.mp3":"src/assets/audio/journal-open.mp3","./journal-open.ogg":"src/assets/audio/journal-open.ogg","./leaves1.mp3":"src/assets/audio/leaves1.mp3","./leaves1.ogg":"src/assets/audio/leaves1.ogg","./leaves2.mp3":"src/assets/audio/leaves2.mp3","./leaves2.ogg":"src/assets/audio/leaves2.ogg","./leaves3.mp3":"src/assets/audio/leaves3.mp3","./leaves3.ogg":"src/assets/audio/leaves3.ogg","./leaves4.mp3":"src/assets/audio/leaves4.mp3","./leaves4.ogg":"src/assets/audio/leaves4.ogg","./menu-open.mp3":"src/assets/audio/menu-open.mp3","./menu-open.ogg":"src/assets/audio/menu-open.ogg","./movement-forest.mp3":"src/assets/audio/movement-forest.mp3","./movement-forest.ogg":"src/assets/audio/movement-forest.ogg","./music1.mp3":"src/assets/audio/music1.mp3","./music1.ogg":"src/assets/audio/music1.ogg","./music2.ogg":"src/assets/audio/music2.ogg","./music2.mp3":"src/assets/audio/music2.mp3","./music3a.mp3":"src/assets/audio/music3a.mp3","./music3a.ogg":"src/assets/audio/music3a.ogg","./music3b.mp3":"src/assets/audio/music3b.mp3","./music3b.ogg":"src/assets/audio/music3b.ogg","./nature1.mp3":"src/assets/audio/nature1.mp3","./nature1.ogg":"src/assets/audio/nature1.ogg","./nature2-old.mp3":"src/assets/audio/nature2-old.mp3","./nature2-old.ogg":"src/assets/audio/nature2-old.ogg","./nature2.mp3":"src/assets/audio/nature2.mp3","./nature2.ogg":"src/assets/audio/nature2.ogg","./nature3.mp3":"src/assets/audio/nature3.mp3","./nature3.ogg":"src/assets/audio/nature3.ogg","./note-forest-a3.mp3":"src/assets/audio/note-forest-a3.mp3","./note-forest-a3.ogg":"src/assets/audio/note-forest-a3.ogg","./note-forest-c3.mp3":"src/assets/audio/note-forest-c3.mp3","./note-forest-c3.ogg":"src/assets/audio/note-forest-c3.ogg","./note-forest-c4.mp3":"src/assets/audio/note-forest-c4.mp3","./note-forest-d3.mp3":"src/assets/audio/note-forest-d3.mp3","./note-forest-c4.ogg":"src/assets/audio/note-forest-c4.ogg","./note-forest-d3.ogg":"src/assets/audio/note-forest-d3.ogg","./note-forest-d4.mp3":"src/assets/audio/note-forest-d4.mp3","./note-forest-e3.mp3":"src/assets/audio/note-forest-e3.mp3","./note-forest-d4.ogg":"src/assets/audio/note-forest-d4.ogg","./note-forest-e3.ogg":"src/assets/audio/note-forest-e3.ogg","./note-forest-g3.mp3":"src/assets/audio/note-forest-g3.mp3","./note-forest-g3.ogg":"src/assets/audio/note-forest-g3.ogg","./note-grasslands-a3.ogg":"src/assets/audio/note-grasslands-a3.ogg","./note-grasslands-a3.mp3":"src/assets/audio/note-grasslands-a3.mp3","./note-grasslands-c3.mp3":"src/assets/audio/note-grasslands-c3.mp3","./note-grasslands-c4.mp3":"src/assets/audio/note-grasslands-c4.mp3","./note-grasslands-d3.mp3":"src/assets/audio/note-grasslands-d3.mp3","./note-grasslands-d4.mp3":"src/assets/audio/note-grasslands-d4.mp3","./note-grasslands-e3.mp3":"src/assets/audio/note-grasslands-e3.mp3","./note-grasslands-g3.mp3":"src/assets/audio/note-grasslands-g3.mp3","./note-tundra-a3.mp3":"src/assets/audio/note-tundra-a3.mp3","./note-tundra-c3.mp3":"src/assets/audio/note-tundra-c3.mp3","./note-tundra-c4.mp3":"src/assets/audio/note-tundra-c4.mp3","./note-tundra-d3.mp3":"src/assets/audio/note-tundra-d3.mp3","./note-tundra-e3.mp3":"src/assets/audio/note-tundra-e3.mp3","./note-tundra-d4.mp3":"src/assets/audio/note-tundra-d4.mp3","./note-tundra-g3.mp3":"src/assets/audio/note-tundra-g3.mp3","./pickup.mp3":"src/assets/audio/pickup.mp3","./rain.mp3":"src/assets/audio/rain.mp3","./reveal01.mp3":"src/assets/audio/reveal01.mp3","./reveal02.mp3":"src/assets/audio/reveal02.mp3","./score-haiku.mp3":"src/assets/audio/score-haiku.mp3","./score-outro.mp3":"src/assets/audio/score-outro.mp3","./score-restore.mp3":"src/assets/audio/score-restore.mp3","./score-start.mp3":"src/assets/audio/score-start.mp3","./score-transition.mp3":"src/assets/audio/score-transition.mp3","./tree-transition-0.mp3":"src/assets/audio/tree-transition-0.mp3","./tree-transition-1.mp3":"src/assets/audio/tree-transition-1.mp3","./water-01.mp3":"src/assets/audio/water-01.mp3","./water-02.mp3":"src/assets/audio/water-02.mp3","./writing-01.mp3":"src/assets/audio/writing-01.mp3","./writing-02.mp3":"src/assets/audio/writing-02.mp3","./writing-03.mp3":"src/assets/audio/writing-03.mp3"}],"node_modules/howler/dist/howler.js":[function(require,module,exports) {
var define;
var global = arguments[3];
/*!
 *  howler.js v2.2.1
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function() {

  'use strict';

  /** Global Methods **/
  /***************************************************************************/

  /**
   * Create the global controller. All contained methods and properties apply
   * to all sounds that are currently playing or will be in the future.
   */
  var HowlerGlobal = function() {
    this.init();
  };
  HowlerGlobal.prototype = {
    /**
     * Initialize the global Howler object.
     * @return {Howler}
     */
    init: function() {
      var self = this || Howler;

      // Create a global ID counter.
      self._counter = 1000;

      // Pool of unlocked HTML5 Audio objects.
      self._html5AudioPool = [];
      self.html5PoolSize = 10;

      // Internal properties.
      self._codecs = {};
      self._howls = [];
      self._muted = false;
      self._volume = 1;
      self._canPlayEvent = 'canplaythrough';
      self._navigator = (typeof window !== 'undefined' && window.navigator) ? window.navigator : null;

      // Public properties.
      self.masterGain = null;
      self.noAudio = false;
      self.usingWebAudio = true;
      self.autoSuspend = true;
      self.ctx = null;

      // Set to false to disable the auto audio unlocker.
      self.autoUnlock = true;

      // Setup the various state values for global tracking.
      self._setup();

      return self;
    },

    /**
     * Get/set the global volume for all sounds.
     * @param  {Float} vol Volume from 0.0 to 1.0.
     * @return {Howler/Float}     Returns self or current volume.
     */
    volume: function(vol) {
      var self = this || Howler;
      vol = parseFloat(vol);

      // If we don't have an AudioContext created yet, run the setup.
      if (!self.ctx) {
        setupAudioContext();
      }

      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        self._volume = vol;

        // Don't update any of the nodes if we are muted.
        if (self._muted) {
          return self;
        }

        // When using Web Audio, we just need to adjust the master gain.
        if (self.usingWebAudio) {
          self.masterGain.gain.setValueAtTime(vol, Howler.ctx.currentTime);
        }

        // Loop through and change volume for all HTML5 audio nodes.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and change the volumes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node) {
                sound._node.volume = sound._volume * vol;
              }
            }
          }
        }

        return self;
      }

      return self._volume;
    },

    /**
     * Handle muting and unmuting globally.
     * @param  {Boolean} muted Is muted or not.
     */
    mute: function(muted) {
      var self = this || Howler;

      // If we don't have an AudioContext created yet, run the setup.
      if (!self.ctx) {
        setupAudioContext();
      }

      self._muted = muted;

      // With Web Audio, we just need to mute the master gain.
      if (self.usingWebAudio) {
        self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler.ctx.currentTime);
      }

      // Loop through and mute all HTML5 Audio nodes.
      for (var i=0; i<self._howls.length; i++) {
        if (!self._howls[i]._webAudio) {
          // Get all of the sounds in this Howl group.
          var ids = self._howls[i]._getSoundIds();

          // Loop through all sounds and mark the audio node as muted.
          for (var j=0; j<ids.length; j++) {
            var sound = self._howls[i]._soundById(ids[j]);

            if (sound && sound._node) {
              sound._node.muted = (muted) ? true : sound._muted;
            }
          }
        }
      }

      return self;
    },

    /**
     * Handle stopping all sounds globally.
     */
    stop: function() {
      var self = this || Howler;

      // Loop through all Howls and stop them.
      for (var i=0; i<self._howls.length; i++) {
        self._howls[i].stop();
      }

      return self;
    },

    /**
     * Unload and destroy all currently loaded Howl objects.
     * @return {Howler}
     */
    unload: function() {
      var self = this || Howler;

      for (var i=self._howls.length-1; i>=0; i--) {
        self._howls[i].unload();
      }

      // Create a new AudioContext to make sure it is fully reset.
      if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== 'undefined') {
        self.ctx.close();
        self.ctx = null;
        setupAudioContext();
      }

      return self;
    },

    /**
     * Check for codec support of specific extension.
     * @param  {String} ext Audio file extention.
     * @return {Boolean}
     */
    codecs: function(ext) {
      return (this || Howler)._codecs[ext.replace(/^x-/, '')];
    },

    /**
     * Setup various state values for global tracking.
     * @return {Howler}
     */
    _setup: function() {
      var self = this || Howler;

      // Keeps track of the suspend/resume state of the AudioContext.
      self.state = self.ctx ? self.ctx.state || 'suspended' : 'suspended';

      // Automatically begin the 30-second suspend process
      self._autoSuspend();

      // Check if audio is available.
      if (!self.usingWebAudio) {
        // No audio is available on this system if noAudio is set to true.
        if (typeof Audio !== 'undefined') {
          try {
            var test = new Audio();

            // Check if the canplaythrough event is available.
            if (typeof test.oncanplaythrough === 'undefined') {
              self._canPlayEvent = 'canplay';
            }
          } catch(e) {
            self.noAudio = true;
          }
        } else {
          self.noAudio = true;
        }
      }

      // Test to make sure audio isn't disabled in Internet Explorer.
      try {
        var test = new Audio();
        if (test.muted) {
          self.noAudio = true;
        }
      } catch (e) {}

      // Check for supported codecs.
      if (!self.noAudio) {
        self._setupCodecs();
      }

      return self;
    },

    /**
     * Check for browser support for various codecs and cache the results.
     * @return {Howler}
     */
    _setupCodecs: function() {
      var self = this || Howler;
      var audioTest = null;

      // Must wrap in a try/catch because IE11 in server mode throws an error.
      try {
        audioTest = (typeof Audio !== 'undefined') ? new Audio() : null;
      } catch (err) {
        return self;
      }

      if (!audioTest || typeof audioTest.canPlayType !== 'function') {
        return self;
      }

      var mpegTest = audioTest.canPlayType('audio/mpeg;').replace(/^no$/, '');

      // Opera version <33 has mixed MP3 support, so we need to check for and block it.
      var checkOpera = self._navigator && self._navigator.userAgent.match(/OPR\/([0-6].)/g);
      var isOldOpera = (checkOpera && parseInt(checkOpera[0].split('/')[1], 10) < 33);

      self._codecs = {
        mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''))),
        mpeg: !!mpegTest,
        opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ''),
        ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''),
        wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType('audio/wav')).replace(/^no$/, ''),
        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),
        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),
        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        m4b: !!(audioTest.canPlayType('audio/x-m4b;') || audioTest.canPlayType('audio/m4b;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),
        weba: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
        webm: !!audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''),
        dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ''),
        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')
      };

      return self;
    },

    /**
     * Some browsers/devices will only allow audio to be played after a user interaction.
     * Attempt to automatically unlock audio on the first user interaction.
     * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     * @return {Howler}
     */
    _unlockAudio: function() {
      var self = this || Howler;

      // Only run this if Web Audio is supported and it hasn't already been unlocked.
      if (self._audioUnlocked || !self.ctx) {
        return;
      }

      self._audioUnlocked = false;
      self.autoUnlock = false;

      // Some mobile devices/platforms have distortion issues when opening/closing tabs and/or web views.
      // Bugs in the browser (especially Mobile Safari) can cause the sampleRate to change from 44100 to 48000.
      // By calling Howler.unload(), we create a new AudioContext with the correct sampleRate.
      if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
        self._mobileUnloaded = true;
        self.unload();
      }

      // Scratch buffer for enabling iOS to dispose of web audio buffers correctly, as per:
      // http://stackoverflow.com/questions/24119684
      self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);

      // Call this method on touch start to create and play a buffer,
      // then check if the audio actually played to determine if
      // audio has now been unlocked on iOS, Android, etc.
      var unlock = function(e) {
        // Create a pool of unlocked HTML5 Audio objects that can
        // be used for playing sounds without user interaction. HTML5
        // Audio objects must be individually unlocked, as opposed
        // to the WebAudio API which only needs a single activation.
        // This must occur before WebAudio setup or the source.onended
        // event will not fire.
        while (self._html5AudioPool.length < self.html5PoolSize) {
          try {
            var audioNode = new Audio();

            // Mark this Audio object as unlocked to ensure it can get returned
            // to the unlocked pool when released.
            audioNode._unlocked = true;

            // Add the audio node to the pool.
            self._releaseHtml5Audio(audioNode);
          } catch (e) {
            self.noAudio = true;
            break;
          }
        }

        // Loop through any assigned audio nodes and unlock them.
        for (var i=0; i<self._howls.length; i++) {
          if (!self._howls[i]._webAudio) {
            // Get all of the sounds in this Howl group.
            var ids = self._howls[i]._getSoundIds();

            // Loop through all sounds and unlock the audio nodes.
            for (var j=0; j<ids.length; j++) {
              var sound = self._howls[i]._soundById(ids[j]);

              if (sound && sound._node && !sound._node._unlocked) {
                sound._node._unlocked = true;
                sound._node.load();
              }
            }
          }
        }

        // Fix Android can not play in suspend state.
        self._autoResume();

        // Create an empty buffer.
        var source = self.ctx.createBufferSource();
        source.buffer = self._scratchBuffer;
        source.connect(self.ctx.destination);

        // Play the empty buffer.
        if (typeof source.start === 'undefined') {
          source.noteOn(0);
        } else {
          source.start(0);
        }

        // Calling resume() on a stack initiated by user gesture is what actually unlocks the audio on Android Chrome >= 55.
        if (typeof self.ctx.resume === 'function') {
          self.ctx.resume();
        }

        // Setup a timeout to check that we are unlocked on the next event loop.
        source.onended = function() {
          source.disconnect(0);

          // Update the unlocked state and prevent this check from happening again.
          self._audioUnlocked = true;

          // Remove the touch start listener.
          document.removeEventListener('touchstart', unlock, true);
          document.removeEventListener('touchend', unlock, true);
          document.removeEventListener('click', unlock, true);

          // Let all sounds know that audio has been unlocked.
          for (var i=0; i<self._howls.length; i++) {
            self._howls[i]._emit('unlock');
          }
        };
      };

      // Setup a touch start listener to attempt an unlock in.
      document.addEventListener('touchstart', unlock, true);
      document.addEventListener('touchend', unlock, true);
      document.addEventListener('click', unlock, true);

      return self;
    },

    /**
     * Get an unlocked HTML5 Audio object from the pool. If none are left,
     * return a new Audio object and throw a warning.
     * @return {Audio} HTML5 Audio object.
     */
    _obtainHtml5Audio: function() {
      var self = this || Howler;

      // Return the next object from the pool if one exists.
      if (self._html5AudioPool.length) {
        return self._html5AudioPool.pop();
      }

      //.Check if the audio is locked and throw a warning.
      var testPlay = new Audio().play();
      if (testPlay && typeof Promise !== 'undefined' && (testPlay instanceof Promise || typeof testPlay.then === 'function')) {
        testPlay.catch(function() {
          console.warn('HTML5 Audio pool exhausted, returning potentially locked audio object.');
        });
      }

      return new Audio();
    },

    /**
     * Return an activated HTML5 Audio object to the pool.
     * @return {Howler}
     */
    _releaseHtml5Audio: function(audio) {
      var self = this || Howler;

      // Don't add audio to the pool if we don't know if it has been unlocked.
      if (audio._unlocked) {
        self._html5AudioPool.push(audio);
      }

      return self;
    },

    /**
     * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
     * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
     * @return {Howler}
     */
    _autoSuspend: function() {
      var self = this;

      if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      // Check if any sounds are playing.
      for (var i=0; i<self._howls.length; i++) {
        if (self._howls[i]._webAudio) {
          for (var j=0; j<self._howls[i]._sounds.length; j++) {
            if (!self._howls[i]._sounds[j]._paused) {
              return self;
            }
          }
        }
      }

      if (self._suspendTimer) {
        clearTimeout(self._suspendTimer);
      }

      // If no sound has played after 30 seconds, suspend the context.
      self._suspendTimer = setTimeout(function() {
        if (!self.autoSuspend) {
          return;
        }

        self._suspendTimer = null;
        self.state = 'suspending';

        // Handle updating the state of the audio context after suspending.
        var handleSuspension = function() {
          self.state = 'suspended';

          if (self._resumeAfterSuspend) {
            delete self._resumeAfterSuspend;
            self._autoResume();
          }
        };

        // Either the state gets suspended or it is interrupted.
        // Either way, we need to update the state to suspended.
        self.ctx.suspend().then(handleSuspension, handleSuspension);
      }, 30000);

      return self;
    },

    /**
     * Automatically resume the Web Audio AudioContext when a new sound is played.
     * @return {Howler}
     */
    _autoResume: function() {
      var self = this;

      if (!self.ctx || typeof self.ctx.resume === 'undefined' || !Howler.usingWebAudio) {
        return;
      }

      if (self.state === 'running' && self.ctx.state !== 'interrupted' && self._suspendTimer) {
        clearTimeout(self._suspendTimer);
        self._suspendTimer = null;
      } else if (self.state === 'suspended' || self.state === 'running' && self.ctx.state === 'interrupted') {
        self.ctx.resume().then(function() {
          self.state = 'running';

          // Emit to all Howls that the audio has resumed.
          for (var i=0; i<self._howls.length; i++) {
            self._howls[i]._emit('resume');
          }
        });

        if (self._suspendTimer) {
          clearTimeout(self._suspendTimer);
          self._suspendTimer = null;
        }
      } else if (self.state === 'suspending') {
        self._resumeAfterSuspend = true;
      }

      return self;
    }
  };

  // Setup the global audio controller.
  var Howler = new HowlerGlobal();

  /** Group Methods **/
  /***************************************************************************/

  /**
   * Create an audio group controller.
   * @param {Object} o Passed in properties for this group.
   */
  var Howl = function(o) {
    var self = this;

    // Throw an error if no source is provided.
    if (!o.src || o.src.length === 0) {
      console.error('An array of source files must be passed with any new Howl.');
      return;
    }

    self.init(o);
  };
  Howl.prototype = {
    /**
     * Initialize a new Howl group object.
     * @param  {Object} o Passed in properties for this group.
     * @return {Howl}
     */
    init: function(o) {
      var self = this;

      // If we don't have an AudioContext created yet, run the setup.
      if (!Howler.ctx) {
        setupAudioContext();
      }

      // Setup user-defined default properties.
      self._autoplay = o.autoplay || false;
      self._format = (typeof o.format !== 'string') ? o.format : [o.format];
      self._html5 = o.html5 || false;
      self._muted = o.mute || false;
      self._loop = o.loop || false;
      self._pool = o.pool || 5;
      self._preload = (typeof o.preload === 'boolean' || o.preload === 'metadata') ? o.preload : true;
      self._rate = o.rate || 1;
      self._sprite = o.sprite || {};
      self._src = (typeof o.src !== 'string') ? o.src : [o.src];
      self._volume = o.volume !== undefined ? o.volume : 1;
      self._xhr = {
        method: o.xhr && o.xhr.method ? o.xhr.method : 'GET',
        headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
        withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false,
      };

      // Setup all other default properties.
      self._duration = 0;
      self._state = 'unloaded';
      self._sounds = [];
      self._endTimers = {};
      self._queue = [];
      self._playLock = false;

      // Setup event listeners.
      self._onend = o.onend ? [{fn: o.onend}] : [];
      self._onfade = o.onfade ? [{fn: o.onfade}] : [];
      self._onload = o.onload ? [{fn: o.onload}] : [];
      self._onloaderror = o.onloaderror ? [{fn: o.onloaderror}] : [];
      self._onplayerror = o.onplayerror ? [{fn: o.onplayerror}] : [];
      self._onpause = o.onpause ? [{fn: o.onpause}] : [];
      self._onplay = o.onplay ? [{fn: o.onplay}] : [];
      self._onstop = o.onstop ? [{fn: o.onstop}] : [];
      self._onmute = o.onmute ? [{fn: o.onmute}] : [];
      self._onvolume = o.onvolume ? [{fn: o.onvolume}] : [];
      self._onrate = o.onrate ? [{fn: o.onrate}] : [];
      self._onseek = o.onseek ? [{fn: o.onseek}] : [];
      self._onunlock = o.onunlock ? [{fn: o.onunlock}] : [];
      self._onresume = [];

      // Web Audio or HTML5 Audio?
      self._webAudio = Howler.usingWebAudio && !self._html5;

      // Automatically try to enable audio.
      if (typeof Howler.ctx !== 'undefined' && Howler.ctx && Howler.autoUnlock) {
        Howler._unlockAudio();
      }

      // Keep track of this Howl group in the global controller.
      Howler._howls.push(self);

      // If they selected autoplay, add a play event to the load queue.
      if (self._autoplay) {
        self._queue.push({
          event: 'play',
          action: function() {
            self.play();
          }
        });
      }

      // Load the source file unless otherwise specified.
      if (self._preload && self._preload !== 'none') {
        self.load();
      }

      return self;
    },

    /**
     * Load the audio file.
     * @return {Howler}
     */
    load: function() {
      var self = this;
      var url = null;

      // If no audio is available, quit immediately.
      if (Howler.noAudio) {
        self._emit('loaderror', null, 'No audio support.');
        return;
      }

      // Make sure our source is in an array.
      if (typeof self._src === 'string') {
        self._src = [self._src];
      }

      // Loop through the sources and pick the first one that is compatible.
      for (var i=0; i<self._src.length; i++) {
        var ext, str;

        if (self._format && self._format[i]) {
          // If an extension was specified, use that instead.
          ext = self._format[i];
        } else {
          // Make sure the source is a string.
          str = self._src[i];
          if (typeof str !== 'string') {
            self._emit('loaderror', null, 'Non-string found in selected audio sources - ignoring.');
            continue;
          }

          // Extract the file extension from the URL or base64 data URI.
          ext = /^data:audio\/([^;,]+);/i.exec(str);
          if (!ext) {
            ext = /\.([^.]+)$/.exec(str.split('?', 1)[0]);
          }

          if (ext) {
            ext = ext[1].toLowerCase();
          }
        }

        // Log a warning if no extension was found.
        if (!ext) {
          console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
        }

        // Check if this extension is available.
        if (ext && Howler.codecs(ext)) {
          url = self._src[i];
          break;
        }
      }

      if (!url) {
        self._emit('loaderror', null, 'No codec support for selected audio sources.');
        return;
      }

      self._src = url;
      self._state = 'loading';

      // If the hosting page is HTTPS and the source isn't,
      // drop down to HTML5 Audio to avoid Mixed Content errors.
      if (window.location.protocol === 'https:' && url.slice(0, 5) === 'http:') {
        self._html5 = true;
        self._webAudio = false;
      }

      // Create a new sound object and add it to the pool.
      new Sound(self);

      // Load and decode the audio data for playback.
      if (self._webAudio) {
        loadBuffer(self);
      }

      return self;
    },

    /**
     * Play a sound or resume previous playback.
     * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Number}          Sound ID.
     */
    play: function(sprite, internal) {
      var self = this;
      var id = null;

      // Determine if a sprite, sound id or nothing was passed
      if (typeof sprite === 'number') {
        id = sprite;
        sprite = null;
      } else if (typeof sprite === 'string' && self._state === 'loaded' && !self._sprite[sprite]) {
        // If the passed sprite doesn't exist, do nothing.
        return null;
      } else if (typeof sprite === 'undefined') {
        // Use the default sound sprite (plays the full audio length).
        sprite = '__default';

        // Check if there is a single paused sound that isn't ended.
        // If there is, play that sound. If not, continue as usual.
        if (!self._playLock) {
          var num = 0;
          for (var i=0; i<self._sounds.length; i++) {
            if (self._sounds[i]._paused && !self._sounds[i]._ended) {
              num++;
              id = self._sounds[i]._id;
            }
          }

          if (num === 1) {
            sprite = null;
          } else {
            id = null;
          }
        }
      }

      // Get the selected node, or get one from the pool.
      var sound = id ? self._soundById(id) : self._inactiveSound();

      // If the sound doesn't exist, do nothing.
      if (!sound) {
        return null;
      }

      // Select the sprite definition.
      if (id && !sprite) {
        sprite = sound._sprite || '__default';
      }

      // If the sound hasn't loaded, we must wait to get the audio's duration.
      // We also need to wait to make sure we don't run into race conditions with
      // the order of function calls.
      if (self._state !== 'loaded') {
        // Set the sprite value on this sound.
        sound._sprite = sprite;

        // Mark this sound as not ended in case another sound is played before this one loads.
        sound._ended = false;

        // Add the sound to the queue to be played on load.
        var soundId = sound._id;
        self._queue.push({
          event: 'play',
          action: function() {
            self.play(soundId);
          }
        });

        return soundId;
      }

      // Don't play the sound if an id was passed and it is already playing.
      if (id && !sound._paused) {
        // Trigger the play event, in order to keep iterating through queue.
        if (!internal) {
          self._loadQueue('play');
        }

        return sound._id;
      }

      // Make sure the AudioContext isn't suspended, and resume it if it is.
      if (self._webAudio) {
        Howler._autoResume();
      }

      // Determine how long to play for and where to start playing.
      var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1000);
      var duration = Math.max(0, ((self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000) - seek);
      var timeout = (duration * 1000) / Math.abs(sound._rate);
      var start = self._sprite[sprite][0] / 1000;
      var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1000;
      sound._sprite = sprite;

      // Mark the sound as ended instantly so that this async playback
      // doesn't get grabbed by another call to play while this one waits to start.
      sound._ended = false;

      // Update the parameters of the sound.
      var setParams = function() {
        sound._paused = false;
        sound._seek = seek;
        sound._start = start;
        sound._stop = stop;
        sound._loop = !!(sound._loop || self._sprite[sprite][2]);
      };

      // End the sound instantly if seek is at the end.
      if (seek >= stop) {
        self._ended(sound);
        return;
      }

      // Begin the actual playback.
      var node = sound._node;
      if (self._webAudio) {
        // Fire this when the sound is ready to play to begin Web Audio playback.
        var playWebAudio = function() {
          self._playLock = false;
          setParams();
          self._refreshBuffer(sound);

          // Setup the playback params.
          var vol = (sound._muted || self._muted) ? 0 : sound._volume;
          node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
          sound._playStart = Howler.ctx.currentTime;

          // Play the sound using the supported method.
          if (typeof node.bufferSource.start === 'undefined') {
            sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
          } else {
            sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
          }

          // Start a new timer if none is present.
          if (timeout !== Infinity) {
            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
          }

          if (!internal) {
            setTimeout(function() {
              self._emit('play', sound._id);
              self._loadQueue();
            }, 0);
          }
        };

        if (Howler.state === 'running' && Howler.ctx.state !== 'interrupted') {
          playWebAudio();
        } else {
          self._playLock = true;

          // Wait for the audio context to resume before playing.
          self.once('resume', playWebAudio);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      } else {
        // Fire this when the sound is ready to play to begin HTML5 Audio playback.
        var playHtml5 = function() {
          node.currentTime = seek;
          node.muted = sound._muted || self._muted || Howler._muted || node.muted;
          node.volume = sound._volume * Howler.volume();
          node.playbackRate = sound._rate;

          // Some browsers will throw an error if this is called without user interaction.
          try {
            var play = node.play();

            // Support older browsers that don't support promises, and thus don't have this issue.
            if (play && typeof Promise !== 'undefined' && (play instanceof Promise || typeof play.then === 'function')) {
              // Implements a lock to prevent DOMException: The play() request was interrupted by a call to pause().
              self._playLock = true;

              // Set param values immediately.
              setParams();

              // Releases the lock and executes queued actions.
              play
                .then(function() {
                  self._playLock = false;
                  node._unlocked = true;
                  if (!internal) {
                    self._emit('play', sound._id);
                    self._loadQueue();
                  }
                })
                .catch(function() {
                  self._playLock = false;
                  self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
                    'on mobile devices and Chrome where playback was not within a user interaction.');

                  // Reset the ended and paused values.
                  sound._ended = true;
                  sound._paused = true;
                });
            } else if (!internal) {
              self._playLock = false;
              setParams();
              self._emit('play', sound._id);
              self._loadQueue();
            }

            // Setting rate before playing won't work in IE, so we set it again here.
            node.playbackRate = sound._rate;

            // If the node is still paused, then we can assume there was a playback issue.
            if (node.paused) {
              self._emit('playerror', sound._id, 'Playback was unable to start. This is most commonly an issue ' +
                'on mobile devices and Chrome where playback was not within a user interaction.');
              return;
            }

            // Setup the end timer on sprites or listen for the ended event.
            if (sprite !== '__default' || sound._loop) {
              self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
            } else {
              self._endTimers[sound._id] = function() {
                // Fire ended on this audio node.
                self._ended(sound);

                // Clear this listener.
                node.removeEventListener('ended', self._endTimers[sound._id], false);
              };
              node.addEventListener('ended', self._endTimers[sound._id], false);
            }
          } catch (err) {
            self._emit('playerror', sound._id, err);
          }
        };

        // If this is streaming audio, make sure the src is set and load again.
        if (node.src === 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA') {
          node.src = self._src;
          node.load();
        }

        // Play immediately if ready, or wait for the 'canplaythrough'e vent.
        var loadedNoReadyState = (window && window.ejecta) || (!node.readyState && Howler._navigator.isCocoonJS);
        if (node.readyState >= 3 || loadedNoReadyState) {
          playHtml5();
        } else {
          self._playLock = true;

          var listener = function() {
            // Begin playback.
            playHtml5();

            // Clear this listener.
            node.removeEventListener(Howler._canPlayEvent, listener, false);
          };
          node.addEventListener(Howler._canPlayEvent, listener, false);

          // Cancel the end timer.
          self._clearTimer(sound._id);
        }
      }

      return sound._id;
    },

    /**
     * Pause playback and save current position.
     * @param  {Number} id The sound ID (empty to pause all in group).
     * @return {Howl}
     */
    pause: function(id) {
      var self = this;

      // If the sound hasn't loaded or a play() promise is pending, add it to the load queue to pause when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'pause',
          action: function() {
            self.pause(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be paused.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound && !sound._paused) {
          // Reset the seek position.
          sound._seek = self.seek(ids[i]);
          sound._rateSeek = 0;
          sound._paused = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound has been created.
              if (!sound._node.bufferSource) {
                continue;
              }

              if (typeof sound._node.bufferSource.stop === 'undefined') {
                sound._node.bufferSource.noteOff(0);
              } else {
                sound._node.bufferSource.stop(0);
              }

              // Clean up the buffer source.
              self._cleanBuffer(sound._node);
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.pause();
            }
          }
        }

        // Fire the pause event, unless `true` is passed as the 2nd argument.
        if (!arguments[1]) {
          self._emit('pause', sound ? sound._id : null);
        }
      }

      return self;
    },

    /**
     * Stop playback and reset to start.
     * @param  {Number} id The sound ID (empty to stop all in group).
     * @param  {Boolean} internal Internal Use: true prevents event firing.
     * @return {Howl}
     */
    stop: function(id, internal) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to stop when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'stop',
          action: function() {
            self.stop(id);
          }
        });

        return self;
      }

      // If no id is passed, get all ID's to be stopped.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Clear the end timer.
        self._clearTimer(ids[i]);

        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          // Reset the seek position.
          sound._seek = sound._start || 0;
          sound._rateSeek = 0;
          sound._paused = true;
          sound._ended = true;

          // Stop currently running fades.
          self._stopFade(ids[i]);

          if (sound._node) {
            if (self._webAudio) {
              // Make sure the sound's AudioBufferSourceNode has been created.
              if (sound._node.bufferSource) {
                if (typeof sound._node.bufferSource.stop === 'undefined') {
                  sound._node.bufferSource.noteOff(0);
                } else {
                  sound._node.bufferSource.stop(0);
                }

                // Clean up the buffer source.
                self._cleanBuffer(sound._node);
              }
            } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
              sound._node.currentTime = sound._start || 0;
              sound._node.pause();

              // If this is a live stream, stop download once the audio is stopped.
              if (sound._node.duration === Infinity) {
                self._clearSound(sound._node);
              }
            }
          }

          if (!internal) {
            self._emit('stop', sound._id);
          }
        }
      }

      return self;
    },

    /**
     * Mute/unmute a single sound or all sounds in this Howl group.
     * @param  {Boolean} muted Set to true to mute and false to unmute.
     * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
     * @return {Howl}
     */
    mute: function(muted, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to mute when capable.
      if (self._state !== 'loaded'|| self._playLock) {
        self._queue.push({
          event: 'mute',
          action: function() {
            self.mute(muted, id);
          }
        });

        return self;
      }

      // If applying mute/unmute to all sounds, update the group's value.
      if (typeof id === 'undefined') {
        if (typeof muted === 'boolean') {
          self._muted = muted;
        } else {
          return self._muted;
        }
      }

      // If no id is passed, get all ID's to be muted.
      var ids = self._getSoundIds(id);

      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        if (sound) {
          sound._muted = muted;

          // Cancel active fade and set the volume to the end value.
          if (sound._interval) {
            self._stopFade(sound._id);
          }

          if (self._webAudio && sound._node) {
            sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler.ctx.currentTime);
          } else if (sound._node) {
            sound._node.muted = Howler._muted ? true : muted;
          }

          self._emit('mute', sound._id);
        }
      }

      return self;
    },

    /**
     * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
     *   volume() -> Returns the group's volume value.
     *   volume(id) -> Returns the sound id's current volume.
     *   volume(vol) -> Sets the volume of all sounds in this Howl group.
     *   volume(vol, id) -> Sets the volume of passed sound id.
     * @return {Howl/Number} Returns self or current volume.
     */
    volume: function() {
      var self = this;
      var args = arguments;
      var vol, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // Return the value of the groups' volume.
        return self._volume;
      } else if (args.length === 1 || args.length === 2 && typeof args[1] === 'undefined') {
        // First check if this is an ID, and if not, assume it is a new volume.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          vol = parseFloat(args[0]);
        }
      } else if (args.length >= 2) {
        vol = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the volume or return the current volume.
      var sound;
      if (typeof vol !== 'undefined' && vol >= 0 && vol <= 1) {
        // If the sound hasn't loaded, add it to the load queue to change volume when capable.
        if (self._state !== 'loaded'|| self._playLock) {
          self._queue.push({
            event: 'volume',
            action: function() {
              self.volume.apply(self, args);
            }
          });

          return self;
        }

        // Set the group volume.
        if (typeof id === 'undefined') {
          self._volume = vol;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            sound._volume = vol;

            // Stop currently running fades.
            if (!args[2]) {
              self._stopFade(id[i]);
            }

            if (self._webAudio && sound._node && !sound._muted) {
              sound._node.gain.setValueAtTime(vol, Howler.ctx.currentTime);
            } else if (sound._node && !sound._muted) {
              sound._node.volume = vol * Howler.volume();
            }

            self._emit('volume', sound._id);
          }
        }
      } else {
        sound = id ? self._soundById(id) : self._sounds[0];
        return sound ? sound._volume : 0;
      }

      return self;
    },

    /**
     * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id (omit to fade all sounds).
     * @return {Howl}
     */
    fade: function(from, to, len, id) {
      var self = this;

      // If the sound hasn't loaded, add it to the load queue to fade when capable.
      if (self._state !== 'loaded' || self._playLock) {
        self._queue.push({
          event: 'fade',
          action: function() {
            self.fade(from, to, len, id);
          }
        });

        return self;
      }

      // Make sure the to/from/len values are numbers.
      from = Math.min(Math.max(0, parseFloat(from)), 1);
      to = Math.min(Math.max(0, parseFloat(to)), 1);
      len = parseFloat(len);

      // Set the volume to the start position.
      self.volume(from, id);

      // Fade the volume of one or all sounds.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        // Get the sound.
        var sound = self._soundById(ids[i]);

        // Create a linear fade or fall back to timeouts with HTML5 Audio.
        if (sound) {
          // Stop the previous fade if no sprite is being used (otherwise, volume handles this).
          if (!id) {
            self._stopFade(ids[i]);
          }

          // If we are using Web Audio, let the native methods do the actual fade.
          if (self._webAudio && !sound._muted) {
            var currentTime = Howler.ctx.currentTime;
            var end = currentTime + (len / 1000);
            sound._volume = from;
            sound._node.gain.setValueAtTime(from, currentTime);
            sound._node.gain.linearRampToValueAtTime(to, end);
          }

          self._startFadeInterval(sound, from, to, len, ids[i], typeof id === 'undefined');
        }
      }

      return self;
    },

    /**
     * Starts the internal interval to fade a sound.
     * @param  {Object} sound Reference to sound to fade.
     * @param  {Number} from The value to fade from (0.0 to 1.0).
     * @param  {Number} to   The volume to fade to (0.0 to 1.0).
     * @param  {Number} len  Time in milliseconds to fade.
     * @param  {Number} id   The sound id to fade.
     * @param  {Boolean} isGroup   If true, set the volume on the group.
     */
    _startFadeInterval: function(sound, from, to, len, id, isGroup) {
      var self = this;
      var vol = from;
      var diff = to - from;
      var steps = Math.abs(diff / 0.01);
      var stepLen = Math.max(4, (steps > 0) ? len / steps : len);
      var lastTick = Date.now();

      // Store the value being faded to.
      sound._fadeTo = to;

      // Update the volume value on each interval tick.
      sound._interval = setInterval(function() {
        // Update the volume based on the time since the last tick.
        var tick = (Date.now() - lastTick) / len;
        lastTick = Date.now();
        vol += diff * tick;

        // Round to within 2 decimal points.
        vol = Math.round(vol * 100) / 100;

        // Make sure the volume is in the right bounds.
        if (diff < 0) {
          vol = Math.max(to, vol);
        } else {
          vol = Math.min(to, vol);
        }

        // Change the volume.
        if (self._webAudio) {
          sound._volume = vol;
        } else {
          self.volume(vol, sound._id, true);
        }

        // Set the group's volume.
        if (isGroup) {
          self._volume = vol;
        }

        // When the fade is complete, stop it and fire event.
        if ((to < from && vol <= to) || (to > from && vol >= to)) {
          clearInterval(sound._interval);
          sound._interval = null;
          sound._fadeTo = null;
          self.volume(to, sound._id);
          self._emit('fade', sound._id);
        }
      }, stepLen);
    },

    /**
     * Internal method that stops the currently playing fade when
     * a new fade starts, volume is changed or the sound is stopped.
     * @param  {Number} id The sound id.
     * @return {Howl}
     */
    _stopFade: function(id) {
      var self = this;
      var sound = self._soundById(id);

      if (sound && sound._interval) {
        if (self._webAudio) {
          sound._node.gain.cancelScheduledValues(Howler.ctx.currentTime);
        }

        clearInterval(sound._interval);
        sound._interval = null;
        self.volume(sound._fadeTo, id);
        sound._fadeTo = null;
        self._emit('fade', id);
      }

      return self;
    },

    /**
     * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
     *   loop() -> Returns the group's loop value.
     *   loop(id) -> Returns the sound id's loop value.
     *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
     *   loop(loop, id) -> Sets the loop value of passed sound id.
     * @return {Howl/Boolean} Returns self or current loop value.
     */
    loop: function() {
      var self = this;
      var args = arguments;
      var loop, id, sound;

      // Determine the values for loop and id.
      if (args.length === 0) {
        // Return the grou's loop value.
        return self._loop;
      } else if (args.length === 1) {
        if (typeof args[0] === 'boolean') {
          loop = args[0];
          self._loop = loop;
        } else {
          // Return this sound's loop value.
          sound = self._soundById(parseInt(args[0], 10));
          return sound ? sound._loop : false;
        }
      } else if (args.length === 2) {
        loop = args[0];
        id = parseInt(args[1], 10);
      }

      // If no id is passed, get all ID's to be looped.
      var ids = self._getSoundIds(id);
      for (var i=0; i<ids.length; i++) {
        sound = self._soundById(ids[i]);

        if (sound) {
          sound._loop = loop;
          if (self._webAudio && sound._node && sound._node.bufferSource) {
            sound._node.bufferSource.loop = loop;
            if (loop) {
              sound._node.bufferSource.loopStart = sound._start || 0;
              sound._node.bufferSource.loopEnd = sound._stop;
            }
          }
        }
      }

      return self;
    },

    /**
     * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   rate() -> Returns the first sound node's current playback rate.
     *   rate(id) -> Returns the sound id's current playback rate.
     *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
     *   rate(rate, id) -> Sets the playback rate of passed sound id.
     * @return {Howl/Number} Returns self or the current playback rate.
     */
    rate: function() {
      var self = this;
      var args = arguments;
      var rate, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current rate of the first node.
        id = self._sounds[0]._id;
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new rate value.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else {
          rate = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        rate = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // Update the playback rate or return the current value.
      var sound;
      if (typeof rate === 'number') {
        // If the sound hasn't loaded, add it to the load queue to change playback rate when capable.
        if (self._state !== 'loaded' || self._playLock) {
          self._queue.push({
            event: 'rate',
            action: function() {
              self.rate.apply(self, args);
            }
          });

          return self;
        }

        // Set the group rate.
        if (typeof id === 'undefined') {
          self._rate = rate;
        }

        // Update one or all volumes.
        id = self._getSoundIds(id);
        for (var i=0; i<id.length; i++) {
          // Get the sound.
          sound = self._soundById(id[i]);

          if (sound) {
            // Keep track of our position when the rate changed and update the playback
            // start position so we can properly adjust the seek position for time elapsed.
            if (self.playing(id[i])) {
              sound._rateSeek = self.seek(id[i]);
              sound._playStart = self._webAudio ? Howler.ctx.currentTime : sound._playStart;
            }
            sound._rate = rate;

            // Change the playback rate.
            if (self._webAudio && sound._node && sound._node.bufferSource) {
              sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler.ctx.currentTime);
            } else if (sound._node) {
              sound._node.playbackRate = rate;
            }

            // Reset the timers.
            var seek = self.seek(id[i]);
            var duration = ((self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1000) - seek;
            var timeout = (duration * 1000) / Math.abs(sound._rate);

            // Start a new end timer if sound is already playing.
            if (self._endTimers[id[i]] || !sound._paused) {
              self._clearTimer(id[i]);
              self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
            }

            self._emit('rate', sound._id);
          }
        }
      } else {
        sound = self._soundById(id);
        return sound ? sound._rate : self._rate;
      }

      return self;
    },

    /**
     * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
     *   seek() -> Returns the first sound node's current seek position.
     *   seek(id) -> Returns the sound id's current seek position.
     *   seek(seek) -> Sets the seek position of the first sound node.
     *   seek(seek, id) -> Sets the seek position of passed sound id.
     * @return {Howl/Number} Returns self or the current seek position.
     */
    seek: function() {
      var self = this;
      var args = arguments;
      var seek, id;

      // Determine the values based on arguments.
      if (args.length === 0) {
        // We will simply return the current position of the first node.
        id = self._sounds[0]._id;
      } else if (args.length === 1) {
        // First check if this is an ID, and if not, assume it is a new seek position.
        var ids = self._getSoundIds();
        var index = ids.indexOf(args[0]);
        if (index >= 0) {
          id = parseInt(args[0], 10);
        } else if (self._sounds.length) {
          id = self._sounds[0]._id;
          seek = parseFloat(args[0]);
        }
      } else if (args.length === 2) {
        seek = parseFloat(args[0]);
        id = parseInt(args[1], 10);
      }

      // If there is no ID, bail out.
      if (typeof id === 'undefined') {
        return self;
      }

      // If the sound hasn't loaded, add it to the load queue to seek when capable.
      if (typeof seek === 'number' && (self._state !== 'loaded' || self._playLock)) {
        self._queue.push({
          event: 'seek',
          action: function() {
            self.seek.apply(self, args);
          }
        });

        return self;
      }

      // Get the sound.
      var sound = self._soundById(id);

      if (sound) {
        if (typeof seek === 'number' && seek >= 0) {
          // Pause the sound and update position for restarting playback.
          var playing = self.playing(id);
          if (playing) {
            self.pause(id, true);
          }

          // Move the position of the track and cancel timer.
          sound._seek = seek;
          sound._ended = false;
          self._clearTimer(id);

          // Update the seek position for HTML5 Audio.
          if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {
            sound._node.currentTime = seek;
          }

          // Seek and emit when ready.
          var seekAndEmit = function() {
            self._emit('seek', id);

            // Restart the playback if the sound was playing.
            if (playing) {
              self.play(id, true);
            }
          };

          // Wait for the play lock to be unset before emitting (HTML5 Audio).
          if (playing && !self._webAudio) {
            var emitSeek = function() {
              if (!self._playLock) {
                seekAndEmit();
              } else {
                setTimeout(emitSeek, 0);
              }
            };
            setTimeout(emitSeek, 0);
          } else {
            seekAndEmit();
          }
        } else {
          if (self._webAudio) {
            var realTime = self.playing(id) ? Howler.ctx.currentTime - sound._playStart : 0;
            var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
            return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
          } else {
            return sound._node.currentTime;
          }
        }
      }

      return self;
    },

    /**
     * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
     * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
     * @return {Boolean} True if playing and false if not.
     */
    playing: function(id) {
      var self = this;

      // Check the passed sound ID (if any).
      if (typeof id === 'number') {
        var sound = self._soundById(id);
        return sound ? !sound._paused : false;
      }

      // Otherwise, loop through all sounds and check if any are playing.
      for (var i=0; i<self._sounds.length; i++) {
        if (!self._sounds[i]._paused) {
          return true;
        }
      }

      return false;
    },

    /**
     * Get the duration of this sound. Passing a sound id will return the sprite duration.
     * @param  {Number} id The sound id to check. If none is passed, return full source duration.
     * @return {Number} Audio duration in seconds.
     */
    duration: function(id) {
      var self = this;
      var duration = self._duration;

      // If we pass an ID, get the sound and return the sprite length.
      var sound = self._soundById(id);
      if (sound) {
        duration = self._sprite[sound._sprite][1] / 1000;
      }

      return duration;
    },

    /**
     * Returns the current loaded state of this Howl.
     * @return {String} 'unloaded', 'loading', 'loaded'
     */
    state: function() {
      return this._state;
    },

    /**
     * Unload and destroy the current Howl object.
     * This will immediately stop all sound instances attached to this group.
     */
    unload: function() {
      var self = this;

      // Stop playing any active sounds.
      var sounds = self._sounds;
      for (var i=0; i<sounds.length; i++) {
        // Stop the sound if it is currently playing.
        if (!sounds[i]._paused) {
          self.stop(sounds[i]._id);
        }

        // Remove the source or disconnect.
        if (!self._webAudio) {
          // Set the source to 0-second silence to stop any downloading (except in IE).
          self._clearSound(sounds[i]._node);

          // Remove any event listeners.
          sounds[i]._node.removeEventListener('error', sounds[i]._errorFn, false);
          sounds[i]._node.removeEventListener(Howler._canPlayEvent, sounds[i]._loadFn, false);
          sounds[i]._node.removeEventListener('ended', sounds[i]._endFn, false);

          // Release the Audio object back to the pool.
          Howler._releaseHtml5Audio(sounds[i]._node);
        }

        // Empty out all of the nodes.
        delete sounds[i]._node;

        // Make sure all timers are cleared out.
        self._clearTimer(sounds[i]._id);
      }

      // Remove the references in the global Howler object.
      var index = Howler._howls.indexOf(self);
      if (index >= 0) {
        Howler._howls.splice(index, 1);
      }

      // Delete this sound from the cache (if no other Howl is using it).
      var remCache = true;
      for (i=0; i<Howler._howls.length; i++) {
        if (Howler._howls[i]._src === self._src || self._src.indexOf(Howler._howls[i]._src) >= 0) {
          remCache = false;
          break;
        }
      }

      if (cache && remCache) {
        delete cache[self._src];
      }

      // Clear global errors.
      Howler.noAudio = false;

      // Clear out `self`.
      self._state = 'unloaded';
      self._sounds = [];
      self = null;

      return null;
    },

    /**
     * Listen to a custom event.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
     * @return {Howl}
     */
    on: function(event, fn, id, once) {
      var self = this;
      var events = self['_on' + event];

      if (typeof fn === 'function') {
        events.push(once ? {id: id, fn: fn, once: once} : {id: id, fn: fn});
      }

      return self;
    },

    /**
     * Remove a custom event. Call without parameters to remove all events.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to remove. Leave empty to remove all.
     * @param  {Number}   id    (optional) Only remove events for this sound.
     * @return {Howl}
     */
    off: function(event, fn, id) {
      var self = this;
      var events = self['_on' + event];
      var i = 0;

      // Allow passing just an event and ID.
      if (typeof fn === 'number') {
        id = fn;
        fn = null;
      }

      if (fn || id) {
        // Loop through event store and remove the passed function.
        for (i=0; i<events.length; i++) {
          var isId = (id === events[i].id);
          if (fn === events[i].fn && isId || !fn && isId) {
            events.splice(i, 1);
            break;
          }
        }
      } else if (event) {
        // Clear out all events of this type.
        self['_on' + event] = [];
      } else {
        // Clear out all events of every type.
        var keys = Object.keys(self);
        for (i=0; i<keys.length; i++) {
          if ((keys[i].indexOf('_on') === 0) && Array.isArray(self[keys[i]])) {
            self[keys[i]] = [];
          }
        }
      }

      return self;
    },

    /**
     * Listen to a custom event and remove it once fired.
     * @param  {String}   event Event name.
     * @param  {Function} fn    Listener to call.
     * @param  {Number}   id    (optional) Only listen to events for this sound.
     * @return {Howl}
     */
    once: function(event, fn, id) {
      var self = this;

      // Setup the event listener.
      self.on(event, fn, id, 1);

      return self;
    },

    /**
     * Emit all events of a specific type and pass the sound id.
     * @param  {String} event Event name.
     * @param  {Number} id    Sound ID.
     * @param  {Number} msg   Message to go with event.
     * @return {Howl}
     */
    _emit: function(event, id, msg) {
      var self = this;
      var events = self['_on' + event];

      // Loop through event store and fire all functions.
      for (var i=events.length-1; i>=0; i--) {
        // Only fire the listener if the correct ID is used.
        if (!events[i].id || events[i].id === id || event === 'load') {
          setTimeout(function(fn) {
            fn.call(this, id, msg);
          }.bind(self, events[i].fn), 0);

          // If this event was setup with `once`, remove it.
          if (events[i].once) {
            self.off(event, events[i].fn, events[i].id);
          }
        }
      }

      // Pass the event type into load queue so that it can continue stepping.
      self._loadQueue(event);

      return self;
    },

    /**
     * Queue of actions initiated before the sound has loaded.
     * These will be called in sequence, with the next only firing
     * after the previous has finished executing (even if async like play).
     * @return {Howl}
     */
    _loadQueue: function(event) {
      var self = this;

      if (self._queue.length > 0) {
        var task = self._queue[0];

        // Remove this task if a matching event was passed.
        if (task.event === event) {
          self._queue.shift();
          self._loadQueue();
        }

        // Run the task if no event type is passed.
        if (!event) {
          task.action();
        }
      }

      return self;
    },

    /**
     * Fired when playback ends at the end of the duration.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _ended: function(sound) {
      var self = this;
      var sprite = sound._sprite;

      // If we are using IE and there was network latency we may be clipping
      // audio before it completes playing. Lets check the node to make sure it
      // believes it has completed, before ending the playback.
      if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
        setTimeout(self._ended.bind(self, sound), 100);
        return self;
      }

      // Should this sound loop?
      var loop = !!(sound._loop || self._sprite[sprite][2]);

      // Fire the ended event.
      self._emit('end', sound._id);

      // Restart the playback for HTML5 Audio loop.
      if (!self._webAudio && loop) {
        self.stop(sound._id, true).play(sound._id);
      }

      // Restart this timer if on a Web Audio loop.
      if (self._webAudio && loop) {
        self._emit('play', sound._id);
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        sound._playStart = Howler.ctx.currentTime;

        var timeout = ((sound._stop - sound._start) * 1000) / Math.abs(sound._rate);
        self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
      }

      // Mark the node as paused.
      if (self._webAudio && !loop) {
        sound._paused = true;
        sound._ended = true;
        sound._seek = sound._start || 0;
        sound._rateSeek = 0;
        self._clearTimer(sound._id);

        // Clean up the buffer source.
        self._cleanBuffer(sound._node);

        // Attempt to auto-suspend AudioContext if no sounds are still playing.
        Howler._autoSuspend();
      }

      // When using a sprite, end the track.
      if (!self._webAudio && !loop) {
        self.stop(sound._id, true);
      }

      return self;
    },

    /**
     * Clear the end timer for a sound playback.
     * @param  {Number} id The sound ID.
     * @return {Howl}
     */
    _clearTimer: function(id) {
      var self = this;

      if (self._endTimers[id]) {
        // Clear the timeout or remove the ended listener.
        if (typeof self._endTimers[id] !== 'function') {
          clearTimeout(self._endTimers[id]);
        } else {
          var sound = self._soundById(id);
          if (sound && sound._node) {
            sound._node.removeEventListener('ended', self._endTimers[id], false);
          }
        }

        delete self._endTimers[id];
      }

      return self;
    },

    /**
     * Return the sound identified by this ID, or return null.
     * @param  {Number} id Sound ID
     * @return {Object}    Sound object or null.
     */
    _soundById: function(id) {
      var self = this;

      // Loop through all sounds and find the one with this ID.
      for (var i=0; i<self._sounds.length; i++) {
        if (id === self._sounds[i]._id) {
          return self._sounds[i];
        }
      }

      return null;
    },

    /**
     * Return an inactive sound from the pool or create a new one.
     * @return {Sound} Sound playback object.
     */
    _inactiveSound: function() {
      var self = this;

      self._drain();

      // Find the first inactive node to recycle.
      for (var i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          return self._sounds[i].reset();
        }
      }

      // If no inactive node was found, create a new one.
      return new Sound(self);
    },

    /**
     * Drain excess inactive sounds from the pool.
     */
    _drain: function() {
      var self = this;
      var limit = self._pool;
      var cnt = 0;
      var i = 0;

      // If there are less sounds than the max pool size, we are done.
      if (self._sounds.length < limit) {
        return;
      }

      // Count the number of inactive sounds.
      for (i=0; i<self._sounds.length; i++) {
        if (self._sounds[i]._ended) {
          cnt++;
        }
      }

      // Remove excess inactive sounds, going in reverse order.
      for (i=self._sounds.length - 1; i>=0; i--) {
        if (cnt <= limit) {
          return;
        }

        if (self._sounds[i]._ended) {
          // Disconnect the audio source when using Web Audio.
          if (self._webAudio && self._sounds[i]._node) {
            self._sounds[i]._node.disconnect(0);
          }

          // Remove sounds until we have the pool size.
          self._sounds.splice(i, 1);
          cnt--;
        }
      }
    },

    /**
     * Get all ID's from the sounds pool.
     * @param  {Number} id Only return one ID if one is passed.
     * @return {Array}    Array of IDs.
     */
    _getSoundIds: function(id) {
      var self = this;

      if (typeof id === 'undefined') {
        var ids = [];
        for (var i=0; i<self._sounds.length; i++) {
          ids.push(self._sounds[i]._id);
        }

        return ids;
      } else {
        return [id];
      }
    },

    /**
     * Load the sound back into the buffer source.
     * @param  {Sound} sound The sound object to work with.
     * @return {Howl}
     */
    _refreshBuffer: function(sound) {
      var self = this;

      // Setup the buffer source for playback.
      sound._node.bufferSource = Howler.ctx.createBufferSource();
      sound._node.bufferSource.buffer = cache[self._src];

      // Connect to the correct node.
      if (sound._panner) {
        sound._node.bufferSource.connect(sound._panner);
      } else {
        sound._node.bufferSource.connect(sound._node);
      }

      // Setup looping and playback rate.
      sound._node.bufferSource.loop = sound._loop;
      if (sound._loop) {
        sound._node.bufferSource.loopStart = sound._start || 0;
        sound._node.bufferSource.loopEnd = sound._stop || 0;
      }
      sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler.ctx.currentTime);

      return self;
    },

    /**
     * Prevent memory leaks by cleaning up the buffer source after playback.
     * @param  {Object} node Sound's audio node containing the buffer source.
     * @return {Howl}
     */
    _cleanBuffer: function(node) {
      var self = this;
      var isIOS = Howler._navigator && Howler._navigator.vendor.indexOf('Apple') >= 0;

      if (Howler._scratchBuffer && node.bufferSource) {
        node.bufferSource.onended = null;
        node.bufferSource.disconnect(0);
        if (isIOS) {
          try { node.bufferSource.buffer = Howler._scratchBuffer; } catch(e) {}
        }
      }
      node.bufferSource = null;

      return self;
    },

    /**
     * Set the source to a 0-second silence to stop any downloading (except in IE).
     * @param  {Object} node Audio node to clear.
     */
    _clearSound: function(node) {
      var checkIE = /MSIE |Trident\//.test(Howler._navigator && Howler._navigator.userAgent);
      if (!checkIE) {
        node.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA';
      }
    }
  };

  /** Single Sound Methods **/
  /***************************************************************************/

  /**
   * Setup the sound object, which each node attached to a Howl group is contained in.
   * @param {Object} howl The Howl parent group.
   */
  var Sound = function(howl) {
    this._parent = howl;
    this.init();
  };
  Sound.prototype = {
    /**
     * Initialize a new Sound object.
     * @return {Sound}
     */
    init: function() {
      var self = this;
      var parent = self._parent;

      // Setup the default parameters.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a unique ID for this sound.
      self._id = ++Howler._counter;

      // Add itself to the parent's pool.
      parent._sounds.push(self);

      // Create the new node.
      self.create();

      return self;
    },

    /**
     * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
     * @return {Sound}
     */
    create: function() {
      var self = this;
      var parent = self._parent;
      var volume = (Howler._muted || self._muted || self._parent._muted) ? 0 : self._volume;

      if (parent._webAudio) {
        // Create the gain node for controlling volume (the source will connect to this).
        self._node = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
        self._node.gain.setValueAtTime(volume, Howler.ctx.currentTime);
        self._node.paused = true;
        self._node.connect(Howler.masterGain);
      } else if (!Howler.noAudio) {
        // Get an unlocked Audio object from the pool.
        self._node = Howler._obtainHtml5Audio();

        // Listen for errors (http://dev.w3.org/html5/spec-author-view/spec.html#mediaerror).
        self._errorFn = self._errorListener.bind(self);
        self._node.addEventListener('error', self._errorFn, false);

        // Listen for 'canplaythrough' event to let us know the sound is ready.
        self._loadFn = self._loadListener.bind(self);
        self._node.addEventListener(Howler._canPlayEvent, self._loadFn, false);

        // Listen for the 'ended' event on the sound to account for edge-case where
        // a finite sound has a duration of Infinity.
        self._endFn = self._endListener.bind(self);
        self._node.addEventListener('ended', self._endFn, false);

        // Setup the new audio node.
        self._node.src = parent._src;
        self._node.preload = parent._preload === true ? 'auto' : parent._preload;
        self._node.volume = volume * Howler.volume();

        // Begin loading the source.
        self._node.load();
      }

      return self;
    },

    /**
     * Reset the parameters of this sound to the original state (for recycle).
     * @return {Sound}
     */
    reset: function() {
      var self = this;
      var parent = self._parent;

      // Reset all of the parameters of this sound.
      self._muted = parent._muted;
      self._loop = parent._loop;
      self._volume = parent._volume;
      self._rate = parent._rate;
      self._seek = 0;
      self._rateSeek = 0;
      self._paused = true;
      self._ended = true;
      self._sprite = '__default';

      // Generate a new ID so that it isn't confused with the previous sound.
      self._id = ++Howler._counter;

      return self;
    },

    /**
     * HTML5 Audio error listener callback.
     */
    _errorListener: function() {
      var self = this;

      // Fire an error event and pass back the code.
      self._parent._emit('loaderror', self._id, self._node.error ? self._node.error.code : 0);

      // Clear the event listener.
      self._node.removeEventListener('error', self._errorFn, false);
    },

    /**
     * HTML5 Audio canplaythrough listener callback.
     */
    _loadListener: function() {
      var self = this;
      var parent = self._parent;

      // Round up the duration to account for the lower precision in HTML5 Audio.
      parent._duration = Math.ceil(self._node.duration * 10) / 10;

      // Setup a sprite if none is defined.
      if (Object.keys(parent._sprite).length === 0) {
        parent._sprite = {__default: [0, parent._duration * 1000]};
      }

      if (parent._state !== 'loaded') {
        parent._state = 'loaded';
        parent._emit('load');
        parent._loadQueue();
      }

      // Clear the event listener.
      self._node.removeEventListener(Howler._canPlayEvent, self._loadFn, false);
    },

    /**
     * HTML5 Audio ended listener callback.
     */
    _endListener: function() {
      var self = this;
      var parent = self._parent;

      // Only handle the `ended`` event if the duration is Infinity.
      if (parent._duration === Infinity) {
        // Update the parent duration to match the real audio duration.
        // Round up the duration to account for the lower precision in HTML5 Audio.
        parent._duration = Math.ceil(self._node.duration * 10) / 10;

        // Update the sprite that corresponds to the real duration.
        if (parent._sprite.__default[1] === Infinity) {
          parent._sprite.__default[1] = parent._duration * 1000;
        }

        // Run the regular ended method.
        parent._ended(self);
      }

      // Clear the event listener since the duration is now correct.
      self._node.removeEventListener('ended', self._endFn, false);
    }
  };

  /** Helper Methods **/
  /***************************************************************************/

  var cache = {};

  /**
   * Buffer a sound from URL, Data URI or cache and decode to audio source (Web Audio API).
   * @param  {Howl} self
   */
  var loadBuffer = function(self) {
    var url = self._src;

    // Check if the buffer has already been cached and use it instead.
    if (cache[url]) {
      // Set the duration from the cache.
      self._duration = cache[url].duration;

      // Load the sound into this Howl.
      loadSound(self);

      return;
    }

    if (/^data:[^;]+;base64,/.test(url)) {
      // Decode the base64 data URI without XHR, since some browsers don't support it.
      var data = atob(url.split(',')[1]);
      var dataView = new Uint8Array(data.length);
      for (var i=0; i<data.length; ++i) {
        dataView[i] = data.charCodeAt(i);
      }

      decodeAudioData(dataView.buffer, self);
    } else {
      // Load the buffer from the URL.
      var xhr = new XMLHttpRequest();
      xhr.open(self._xhr.method, url, true);
      xhr.withCredentials = self._xhr.withCredentials;
      xhr.responseType = 'arraybuffer';

      // Apply any custom headers to the request.
      if (self._xhr.headers) {
        Object.keys(self._xhr.headers).forEach(function(key) {
          xhr.setRequestHeader(key, self._xhr.headers[key]);
        });
      }

      xhr.onload = function() {
        // Make sure we get a successful response back.
        var code = (xhr.status + '')[0];
        if (code !== '0' && code !== '2' && code !== '3') {
          self._emit('loaderror', null, 'Failed loading audio file with status: ' + xhr.status + '.');
          return;
        }

        decodeAudioData(xhr.response, self);
      };
      xhr.onerror = function() {
        // If there is an error, switch to HTML5 Audio.
        if (self._webAudio) {
          self._html5 = true;
          self._webAudio = false;
          self._sounds = [];
          delete cache[url];
          self.load();
        }
      };
      safeXhrSend(xhr);
    }
  };

  /**
   * Send the XHR request wrapped in a try/catch.
   * @param  {Object} xhr XHR to send.
   */
  var safeXhrSend = function(xhr) {
    try {
      xhr.send();
    } catch (e) {
      xhr.onerror();
    }
  };

  /**
   * Decode audio data from an array buffer.
   * @param  {ArrayBuffer} arraybuffer The audio data.
   * @param  {Howl}        self
   */
  var decodeAudioData = function(arraybuffer, self) {
    // Fire a load error if something broke.
    var error = function() {
      self._emit('loaderror', null, 'Decoding audio data failed.');
    };

    // Load the sound on success.
    var success = function(buffer) {
      if (buffer && self._sounds.length > 0) {
        cache[self._src] = buffer;
        loadSound(self, buffer);
      } else {
        error();
      }
    };

    // Decode the buffer into an audio source.
    if (typeof Promise !== 'undefined' && Howler.ctx.decodeAudioData.length === 1) {
      Howler.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
    } else {
      Howler.ctx.decodeAudioData(arraybuffer, success, error);
    }
  }

  /**
   * Sound is now loaded, so finish setting everything up and fire the loaded event.
   * @param  {Howl} self
   * @param  {Object} buffer The decoded buffer sound source.
   */
  var loadSound = function(self, buffer) {
    // Set the duration.
    if (buffer && !self._duration) {
      self._duration = buffer.duration;
    }

    // Setup a sprite if none is defined.
    if (Object.keys(self._sprite).length === 0) {
      self._sprite = {__default: [0, self._duration * 1000]};
    }

    // Fire the loaded event.
    if (self._state !== 'loaded') {
      self._state = 'loaded';
      self._emit('load');
      self._loadQueue();
    }
  };

  /**
   * Setup the audio context when available, or switch to HTML5 Audio mode.
   */
  var setupAudioContext = function() {
    // If we have already detected that Web Audio isn't supported, don't run this step again.
    if (!Howler.usingWebAudio) {
      return;
    }

    // Check if we are using Web Audio and setup the AudioContext if we are.
    try {
      if (typeof AudioContext !== 'undefined') {
        Howler.ctx = new AudioContext();
      } else if (typeof webkitAudioContext !== 'undefined') {
        Howler.ctx = new webkitAudioContext();
      } else {
        Howler.usingWebAudio = false;
      }
    } catch(e) {
      Howler.usingWebAudio = false;
    }

    // If the audio context creation still failed, set using web audio to false.
    if (!Howler.ctx) {
      Howler.usingWebAudio = false;
    }

    // Check if a webview is being used on iOS8 or earlier (rather than the browser).
    // If it is, disable Web Audio as it causes crashing.
    var iOS = (/iP(hone|od|ad)/.test(Howler._navigator && Howler._navigator.platform));
    var appVersion = Howler._navigator && Howler._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
    var version = appVersion ? parseInt(appVersion[1], 10) : null;
    if (iOS && version && version < 9) {
      var safari = /safari/.test(Howler._navigator && Howler._navigator.userAgent.toLowerCase());
      if (Howler._navigator && !safari) {
        Howler.usingWebAudio = false;
      }
    }

    // Create and expose the master GainNode when using Web Audio (useful for plugins or advanced usage).
    if (Howler.usingWebAudio) {
      Howler.masterGain = (typeof Howler.ctx.createGain === 'undefined') ? Howler.ctx.createGainNode() : Howler.ctx.createGain();
      Howler.masterGain.gain.setValueAtTime(Howler._muted ? 0 : Howler._volume, Howler.ctx.currentTime);
      Howler.masterGain.connect(Howler.ctx.destination);
    }

    // Re-run the setup on Howler.
    Howler._setup();
  };

  // Add support for AMD (Asynchronous Module Definition) libraries such as require.js.
  if (typeof define === 'function' && define.amd) {
    define([], function() {
      return {
        Howler: Howler,
        Howl: Howl
      };
    });
  }

  // Add support for CommonJS libraries such as browserify.
  if (typeof exports !== 'undefined') {
    exports.Howler = Howler;
    exports.Howl = Howl;
  }

  // Add to global in Node.js (for testing, etc).
  if (typeof global !== 'undefined') {
    global.HowlerGlobal = HowlerGlobal;
    global.Howler = Howler;
    global.Howl = Howl;
    global.Sound = Sound;
  } else if (typeof window !== 'undefined') {  // Define globally in case AMD is not available or unused.
    window.HowlerGlobal = HowlerGlobal;
    window.Howler = Howler;
    window.Howl = Howl;
    window.Sound = Sound;
  }
})();


/*!
 *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
 *  
 *  howler.js v2.2.1
 *  howlerjs.com
 *
 *  (c) 2013-2020, James Simpson of GoldFire Studios
 *  goldfirestudios.com
 *
 *  MIT License
 */

(function() {

  'use strict';

  // Setup default properties.
  HowlerGlobal.prototype._pos = [0, 0, 0];
  HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];

  /** Global Methods **/
  /***************************************************************************/

  /**
   * Helper method to update the stereo panning position of all current Howls.
   * Future Howls will not use this value unless explicitly set.
   * @param  {Number} pan A value of -1.0 is all the way left and 1.0 is all the way right.
   * @return {Howler/Number}     Self or current stereo panning value.
   */
  HowlerGlobal.prototype.stereo = function(pan) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Loop through all Howls and update their stereo panning.
    for (var i=self._howls.length-1; i>=0; i--) {
      self._howls[i].stereo(pan);
    }

    return self;
  };

  /**
   * Get/set the position of the listener in 3D cartesian space. Sounds using
   * 3D position will be relative to the listener's position.
   * @param  {Number} x The x-position of the listener.
   * @param  {Number} y The y-position of the listener.
   * @param  {Number} z The z-position of the listener.
   * @return {Howler/Array}   Self or current listener position.
   */
  HowlerGlobal.prototype.pos = function(x, y, z) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? self._pos[1] : y;
    z = (typeof z !== 'number') ? self._pos[2] : z;

    if (typeof x === 'number') {
      self._pos = [x, y, z];

      if (typeof self.ctx.listener.positionX !== 'undefined') {
        self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);
        self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);
        self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);
      } else {
        self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
      }
    } else {
      return self._pos;
    }

    return self;
  };

  /**
   * Get/set the direction the listener is pointing in the 3D cartesian space.
   * A front and up vector must be provided. The front is the direction the
   * face of the listener is pointing, and up is the direction the top of the
   * listener is pointing. Thus, these values are expected to be at right angles
   * from each other.
   * @param  {Number} x   The x-orientation of the listener.
   * @param  {Number} y   The y-orientation of the listener.
   * @param  {Number} z   The z-orientation of the listener.
   * @param  {Number} xUp The x-orientation of the top of the listener.
   * @param  {Number} yUp The y-orientation of the top of the listener.
   * @param  {Number} zUp The z-orientation of the top of the listener.
   * @return {Howler/Array}     Returns self or the current orientation vectors.
   */
  HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self.ctx || !self.ctx.listener) {
      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    var or = self._orientation;
    y = (typeof y !== 'number') ? or[1] : y;
    z = (typeof z !== 'number') ? or[2] : z;
    xUp = (typeof xUp !== 'number') ? or[3] : xUp;
    yUp = (typeof yUp !== 'number') ? or[4] : yUp;
    zUp = (typeof zUp !== 'number') ? or[5] : zUp;

    if (typeof x === 'number') {
      self._orientation = [x, y, z, xUp, yUp, zUp];

      if (typeof self.ctx.listener.forwardX !== 'undefined') {
        self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
        self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
      } else {
        self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
      }
    } else {
      return or;
    }

    return self;
  };

  /** Group Methods **/
  /***************************************************************************/

  /**
   * Add new properties to the core init.
   * @param  {Function} _super Core init method.
   * @return {Howl}
   */
  Howl.prototype.init = (function(_super) {
    return function(o) {
      var self = this;

      // Setup user-defined default properties.
      self._orientation = o.orientation || [1, 0, 0];
      self._stereo = o.stereo || null;
      self._pos = o.pos || null;
      self._pannerAttr = {
        coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : 360,
        coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : 360,
        coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : 0,
        distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : 'inverse',
        maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : 10000,
        panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : 'HRTF',
        refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : 1,
        rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : 1
      };

      // Setup event listeners.
      self._onstereo = o.onstereo ? [{fn: o.onstereo}] : [];
      self._onpos = o.onpos ? [{fn: o.onpos}] : [];
      self._onorientation = o.onorientation ? [{fn: o.onorientation}] : [];

      // Complete initilization with howler.js core's init function.
      return _super.call(this, o);
    };
  })(Howl.prototype.init);

  /**
   * Get/set the stereo panning of the audio source for this sound or all in the group.
   * @param  {Number} pan  A value of -1.0 is all the way left and 1.0 is all the way right.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Number}    Returns self or the current stereo panning value.
   */
  Howl.prototype.stereo = function(pan, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change stereo pan when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'stereo',
        action: function() {
          self.stereo(pan, id);
        }
      });

      return self;
    }

    // Check for PannerStereoNode support and fallback to PannerNode if it doesn't exist.
    var pannerType = (typeof Howler.ctx.createStereoPanner === 'undefined') ? 'spatial' : 'stereo';

    // Setup the group's stereo panning if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's stereo panning if no parameters are passed.
      if (typeof pan === 'number') {
        self._stereo = pan;
        self._pos = [pan, 0, 0];
      } else {
        return self._stereo;
      }
    }

    // Change the streo panning of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof pan === 'number') {
          sound._stereo = pan;
          sound._pos = [pan, 0, 0];

          if (sound._node) {
            // If we are falling back, make sure the panningModel is equalpower.
            sound._pannerAttr.panningModel = 'equalpower';

            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner || !sound._panner.pan) {
              setupPanner(sound, pannerType);
            }

            if (pannerType === 'spatial') {
              if (typeof sound._panner.positionX !== 'undefined') {
                sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
              } else {
                sound._panner.setPosition(pan, 0, 0);
              }
            } else {
              sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
            }
          }

          self._emit('stereo', sound._id);
        } else {
          return sound._stereo;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the 3D spatial position of the audio source for this sound or group relative to the global listener.
   * @param  {Number} x  The x-position of the audio source.
   * @param  {Number} y  The y-position of the audio source.
   * @param  {Number} z  The z-position of the audio source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial position: [x, y, z].
   */
  Howl.prototype.pos = function(x, y, z, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change position when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'pos',
        action: function() {
          self.pos(x, y, z, id);
        }
      });

      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? 0 : y;
    z = (typeof z !== 'number') ? -0.5 : z;

    // Setup the group's spatial position if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's spatial position if no parameters are passed.
      if (typeof x === 'number') {
        self._pos = [x, y, z];
      } else {
        return self._pos;
      }
    }

    // Change the spatial position of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof x === 'number') {
          sound._pos = [x, y, z];

          if (sound._node) {
            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner || sound._panner.pan) {
              setupPanner(sound, 'spatial');
            }

            if (typeof sound._panner.positionX !== 'undefined') {
              sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
              sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
              sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
            } else {
              sound._panner.setPosition(x, y, z);
            }
          }

          self._emit('pos', sound._id);
        } else {
          return sound._pos;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the direction the audio source is pointing in the 3D cartesian coordinate
   * space. Depending on how direction the sound is, based on the `cone` attributes,
   * a sound pointing away from the listener can be quiet or silent.
   * @param  {Number} x  The x-orientation of the source.
   * @param  {Number} y  The y-orientation of the source.
   * @param  {Number} z  The z-orientation of the source.
   * @param  {Number} id (optional) The sound ID. If none is passed, all in group will be updated.
   * @return {Howl/Array}    Returns self or the current 3D spatial orientation: [x, y, z].
   */
  Howl.prototype.orientation = function(x, y, z, id) {
    var self = this;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // If the sound hasn't loaded, add it to the load queue to change orientation when capable.
    if (self._state !== 'loaded') {
      self._queue.push({
        event: 'orientation',
        action: function() {
          self.orientation(x, y, z, id);
        }
      });

      return self;
    }

    // Set the defaults for optional 'y' & 'z'.
    y = (typeof y !== 'number') ? self._orientation[1] : y;
    z = (typeof z !== 'number') ? self._orientation[2] : z;

    // Setup the group's spatial orientation if no ID is passed.
    if (typeof id === 'undefined') {
      // Return the group's spatial orientation if no parameters are passed.
      if (typeof x === 'number') {
        self._orientation = [x, y, z];
      } else {
        return self._orientation;
      }
    }

    // Change the spatial orientation of one or all sounds in group.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      // Get the sound.
      var sound = self._soundById(ids[i]);

      if (sound) {
        if (typeof x === 'number') {
          sound._orientation = [x, y, z];

          if (sound._node) {
            // Check if there is a panner setup and create a new one if not.
            if (!sound._panner) {
              // Make sure we have a position to setup the node with.
              if (!sound._pos) {
                sound._pos = self._pos || [0, 0, -0.5];
              }

              setupPanner(sound, 'spatial');
            }

            if (typeof sound._panner.orientationX !== 'undefined') {
              sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
              sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
              sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
            } else {
              sound._panner.setOrientation(x, y, z);
            }
          }

          self._emit('orientation', sound._id);
        } else {
          return sound._orientation;
        }
      }
    }

    return self;
  };

  /**
   * Get/set the panner node's attributes for a sound or group of sounds.
   * This method can optionall take 0, 1 or 2 arguments.
   *   pannerAttr() -> Returns the group's values.
   *   pannerAttr(id) -> Returns the sound id's values.
   *   pannerAttr(o) -> Set's the values of all sounds in this Howl group.
   *   pannerAttr(o, id) -> Set's the values of passed sound id.
   *
   *   Attributes:
   *     coneInnerAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      inside of which there will be no volume reduction.
   *     coneOuterAngle - (360 by default) A parameter for directional audio sources, this is an angle, in degrees,
   *                      outside of which the volume will be reduced to a constant value of `coneOuterGain`.
   *     coneOuterGain - (0 by default) A parameter for directional audio sources, this is the gain outside of the
   *                     `coneOuterAngle`. It is a linear value in the range `[0, 1]`.
   *     distanceModel - ('inverse' by default) Determines algorithm used to reduce volume as audio moves away from
   *                     listener. Can be `linear`, `inverse` or `exponential.
   *     maxDistance - (10000 by default) The maximum distance between source and listener, after which the volume
   *                   will not be reduced any further.
   *     refDistance - (1 by default) A reference distance for reducing volume as source moves further from the listener.
   *                   This is simply a variable of the distance model and has a different effect depending on which model
   *                   is used and the scale of your coordinates. Generally, volume will be equal to 1 at this distance.
   *     rolloffFactor - (1 by default) How quickly the volume reduces as source moves from listener. This is simply a
   *                     variable of the distance model and can be in the range of `[0, 1]` with `linear` and `[0, ∞]`
   *                     with `inverse` and `exponential`.
   *     panningModel - ('HRTF' by default) Determines which spatialization algorithm is used to position audio.
   *                     Can be `HRTF` or `equalpower`.
   *
   * @return {Howl/Object} Returns self or current panner attributes.
   */
  Howl.prototype.pannerAttr = function() {
    var self = this;
    var args = arguments;
    var o, id, sound;

    // Stop right here if not using Web Audio.
    if (!self._webAudio) {
      return self;
    }

    // Determine the values based on arguments.
    if (args.length === 0) {
      // Return the group's panner attribute values.
      return self._pannerAttr;
    } else if (args.length === 1) {
      if (typeof args[0] === 'object') {
        o = args[0];

        // Set the grou's panner attribute values.
        if (typeof id === 'undefined') {
          if (!o.pannerAttr) {
            o.pannerAttr = {
              coneInnerAngle: o.coneInnerAngle,
              coneOuterAngle: o.coneOuterAngle,
              coneOuterGain: o.coneOuterGain,
              distanceModel: o.distanceModel,
              maxDistance: o.maxDistance,
              refDistance: o.refDistance,
              rolloffFactor: o.rolloffFactor,
              panningModel: o.panningModel
            };
          }

          self._pannerAttr = {
            coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== 'undefined' ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,
            coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== 'undefined' ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,
            coneOuterGain: typeof o.pannerAttr.coneOuterGain !== 'undefined' ? o.pannerAttr.coneOuterGain : self._coneOuterGain,
            distanceModel: typeof o.pannerAttr.distanceModel !== 'undefined' ? o.pannerAttr.distanceModel : self._distanceModel,
            maxDistance: typeof o.pannerAttr.maxDistance !== 'undefined' ? o.pannerAttr.maxDistance : self._maxDistance,
            refDistance: typeof o.pannerAttr.refDistance !== 'undefined' ? o.pannerAttr.refDistance : self._refDistance,
            rolloffFactor: typeof o.pannerAttr.rolloffFactor !== 'undefined' ? o.pannerAttr.rolloffFactor : self._rolloffFactor,
            panningModel: typeof o.pannerAttr.panningModel !== 'undefined' ? o.pannerAttr.panningModel : self._panningModel
          };
        }
      } else {
        // Return this sound's panner attribute values.
        sound = self._soundById(parseInt(args[0], 10));
        return sound ? sound._pannerAttr : self._pannerAttr;
      }
    } else if (args.length === 2) {
      o = args[0];
      id = parseInt(args[1], 10);
    }

    // Update the values of the specified sounds.
    var ids = self._getSoundIds(id);
    for (var i=0; i<ids.length; i++) {
      sound = self._soundById(ids[i]);

      if (sound) {
        // Merge the new values into the sound.
        var pa = sound._pannerAttr;
        pa = {
          coneInnerAngle: typeof o.coneInnerAngle !== 'undefined' ? o.coneInnerAngle : pa.coneInnerAngle,
          coneOuterAngle: typeof o.coneOuterAngle !== 'undefined' ? o.coneOuterAngle : pa.coneOuterAngle,
          coneOuterGain: typeof o.coneOuterGain !== 'undefined' ? o.coneOuterGain : pa.coneOuterGain,
          distanceModel: typeof o.distanceModel !== 'undefined' ? o.distanceModel : pa.distanceModel,
          maxDistance: typeof o.maxDistance !== 'undefined' ? o.maxDistance : pa.maxDistance,
          refDistance: typeof o.refDistance !== 'undefined' ? o.refDistance : pa.refDistance,
          rolloffFactor: typeof o.rolloffFactor !== 'undefined' ? o.rolloffFactor : pa.rolloffFactor,
          panningModel: typeof o.panningModel !== 'undefined' ? o.panningModel : pa.panningModel
        };

        // Update the panner values or create a new panner if none exists.
        var panner = sound._panner;
        if (panner) {
          panner.coneInnerAngle = pa.coneInnerAngle;
          panner.coneOuterAngle = pa.coneOuterAngle;
          panner.coneOuterGain = pa.coneOuterGain;
          panner.distanceModel = pa.distanceModel;
          panner.maxDistance = pa.maxDistance;
          panner.refDistance = pa.refDistance;
          panner.rolloffFactor = pa.rolloffFactor;
          panner.panningModel = pa.panningModel;
        } else {
          // Make sure we have a position to setup the node with.
          if (!sound._pos) {
            sound._pos = self._pos || [0, 0, -0.5];
          }

          // Create a new panner node.
          setupPanner(sound, 'spatial');
        }
      }
    }

    return self;
  };

  /** Single Sound Methods **/
  /***************************************************************************/

  /**
   * Add new properties to the core Sound init.
   * @param  {Function} _super Core Sound init method.
   * @return {Sound}
   */
  Sound.prototype.init = (function(_super) {
    return function() {
      var self = this;
      var parent = self._parent;

      // Setup user-defined default properties.
      self._orientation = parent._orientation;
      self._stereo = parent._stereo;
      self._pos = parent._pos;
      self._pannerAttr = parent._pannerAttr;

      // Complete initilization with howler.js core Sound's init function.
      _super.call(this);

      // If a stereo or position was specified, set it up.
      if (self._stereo) {
        parent.stereo(self._stereo);
      } else if (self._pos) {
        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
      }
    };
  })(Sound.prototype.init);

  /**
   * Override the Sound.reset method to clean up properties from the spatial plugin.
   * @param  {Function} _super Sound reset method.
   * @return {Sound}
   */
  Sound.prototype.reset = (function(_super) {
    return function() {
      var self = this;
      var parent = self._parent;

      // Reset all spatial plugin properties on this sound.
      self._orientation = parent._orientation;
      self._stereo = parent._stereo;
      self._pos = parent._pos;
      self._pannerAttr = parent._pannerAttr;

      // If a stereo or position was specified, set it up.
      if (self._stereo) {
        parent.stereo(self._stereo);
      } else if (self._pos) {
        parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
      } else if (self._panner) {
        // Disconnect the panner.
        self._panner.disconnect(0);
        self._panner = undefined;
        parent._refreshBuffer(self);
      }

      // Complete resetting of the sound.
      return _super.call(this);
    };
  })(Sound.prototype.reset);

  /** Helper Methods **/
  /***************************************************************************/

  /**
   * Create a new panner node and save it on the sound.
   * @param  {Sound} sound Specific sound to setup panning on.
   * @param {String} type Type of panner to create: 'stereo' or 'spatial'.
   */
  var setupPanner = function(sound, type) {
    type = type || 'spatial';

    // Create the new panner node.
    if (type === 'spatial') {
      sound._panner = Howler.ctx.createPanner();
      sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
      sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
      sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
      sound._panner.distanceModel = sound._pannerAttr.distanceModel;
      sound._panner.maxDistance = sound._pannerAttr.maxDistance;
      sound._panner.refDistance = sound._pannerAttr.refDistance;
      sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
      sound._panner.panningModel = sound._pannerAttr.panningModel;

      if (typeof sound._panner.positionX !== 'undefined') {
        sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
        sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
        sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
      } else {
        sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
      }

      if (typeof sound._panner.orientationX !== 'undefined') {
        sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
        sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
        sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
      } else {
        sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
      }
    } else {
      sound._panner = Howler.ctx.createStereoPanner();
      sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
    }

    sound._panner.connect(sound._node);

    // Update the connections.
    if (!sound._paused) {
      sound._parent.pause(sound._id, true).play(sound._id, true);
    }
  };
})();

},{}],"node_modules/browser-media-mime-type/mime-types.json":[function(require,module,exports) {
module.exports = {
  "audio/midi": ["mid", "midi", "kar", "rmi"],
  "audio/mp4": ["mp4a", "m4a"],
  "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
  "audio/ogg": ["oga", "ogg", "spx"],
  "audio/webm": ["weba"],
  "audio/x-matroska": ["mka"],
  "audio/x-mpegurl": ["m3u"],
  "audio/wav": ["wav"],
  "video/3gpp": ["3gp"],
  "video/3gpp2": ["3g2"],
  "video/mp4": ["mp4", "mp4v", "mpg4"],
  "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
  "video/ogg": ["ogv"],
  "video/quicktime": ["qt", "mov"],
  "video/webm": ["webm"],
  "video/x-f4v": ["f4v"],
  "video/x-fli": ["fli"],
  "video/x-flv": ["flv"],
  "video/x-m4v": ["m4v"],
  "video/x-matroska": ["mkv", "mk3d", "mks"]
};
},{}],"node_modules/browser-media-mime-type/index.js":[function(require,module,exports) {
// sourced from:
// http://www.leanbackplayer.com/test/h5mt.html
// https://github.com/broofa/node-mime/blob/master/types.json
var mimeTypes = require('./mime-types.json')

var mimeLookup = {}
Object.keys(mimeTypes).forEach(function (key) {
  var extensions = mimeTypes[key]
  extensions.forEach(function (ext) {
    mimeLookup[ext] = key
  })
})

module.exports = function lookup (ext) {
  if (!ext) throw new TypeError('must specify extension string')
  if (ext.indexOf('.') === 0) {
    ext = ext.substring(1)
  }
  return mimeLookup[ext.toLowerCase()]
}

},{"./mime-types.json":"node_modules/browser-media-mime-type/mime-types.json"}],"node_modules/web-audio-player/lib/can-play-src.js":[function(require,module,exports) {
var lookup = require('browser-media-mime-type')
var audio

module.exports = isSrcPlayable
function isSrcPlayable (src) {
  if (!src) throw new TypeError('src cannot be empty')
  var type
  if (typeof src.getAttribute === 'function') {
    // <source> element
    type = src.getAttribute('type')
  } else if (typeof src === 'string') {
    // 'foo.mp3' string
    var ext = extension(src)
    if (ext) type = lookup(ext)
  } else {
    // { src: 'foo.mp3', type: 'audio/mpeg; codecs..'}
    type = src.type
  }

  // We have an unknown file extension or
  // a <source> tag without an explicit type,
  // just let the browser handle it!
  if (!type) return true

  // handle "no" edge case with super legacy browsers...
  // https://groups.google.com/forum/#!topic/google-web-toolkit-contributors/a8Uy0bXq1Ho
  if (!audio) audio = new window.Audio()
  var canplay = audio.canPlayType(type).replace(/no/, '')
  return Boolean(canplay)
}

module.exports.createError = createError
function createError (sources) {
  // All sources are unplayable
  var err = new Error('This browser does not support any of the following sources:\n    ' +
      sources.join(', ') + '\n' +
      'Try using an array of OGG, MP3 and WAV.')
  err.type = 'AUDIO_FORMAT'
  return err
}

function extension (data) {
  var extIdx = data.lastIndexOf('.')
  if (extIdx <= 0 || extIdx === data.length - 1) {
    return undefined
  }
  return data.substring(extIdx + 1)
}

},{"browser-media-mime-type":"node_modules/browser-media-mime-type/index.js"}],"node_modules/web-audio-player/lib/audio-context.js":[function(require,module,exports) {
module.exports = createAudioContext
function createAudioContext () {
  var AudioCtor = window.AudioContext || window.webkitAudioContext
  return new AudioCtor()
}

},{}],"node_modules/global/window.js":[function(require,module,exports) {
var global = arguments[3];
var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

},{}],"node_modules/is-function/index.js":[function(require,module,exports) {
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  if (!fn) {
    return false
  }
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],"node_modules/parse-headers/parse-headers.js":[function(require,module,exports) {
var trim = function(string) {
  return string.replace(/^\s+|\s+$/g, '');
}
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  var headersArr = trim(headers).split('\n')

  for (var i = 0; i < headersArr.length; i++) {
    var row = headersArr[i]
    var index = row.indexOf(':')
    , key = trim(row.slice(0, index)).toLowerCase()
    , value = trim(row.slice(index + 1))

    if (typeof(result[key]) === 'undefined') {
      result[key] = value
    } else if (isArray(result[key])) {
      result[key].push(value)
    } else {
      result[key] = [ result[key], value ]
    }
  }

  return result
}

},{}],"node_modules/xtend/immutable.js":[function(require,module,exports) {
module.exports = extend;
var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
  var target = {};

  for (var i = 0; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
}
},{}],"node_modules/xhr/index.js":[function(require,module,exports) {
"use strict";
var window = require("global/window")
var isFunction = require("is-function")
var parseHeaders = require("parse-headers")
var xtend = require("xtend")

module.exports = createXHR
// Allow use of default import syntax in TypeScript
module.exports.default = createXHR;
createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback)
        options.method = method.toUpperCase()
        return _createXHR(options)
    }
})

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
        iterator(array[i])
    }
}

function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function initParams(uri, options, callback) {
    var params = uri

    if (isFunction(options)) {
        callback = options
        if (typeof uri === "string") {
            params = {uri:uri}
        }
    } else {
        params = xtend(options, {uri: uri})
    }

    params.callback = callback
    return params
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback)
    return _createXHR(options)
}

function _createXHR(options) {
    if(typeof options.callback === "undefined"){
        throw new Error("callback argument missing")
    }

    var called = false
    var callback = function cbOnce(err, response, body){
        if(!called){
            called = true
            options.callback(err, response, body)
        }
    }

    function readystatechange() {
        if (xhr.readyState === 4) {
            setTimeout(loadFunc, 0)
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else {
            body = xhr.responseText || getXml(xhr)
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
        }
        evt.statusCode = 0
        return callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status
        clearTimeout(timeoutTimer)
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status)
        }
        var response = failureResponse
        var err = null

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        return callback(err, response, response.body)
    }

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest()
        }else{
            xhr = new createXHR.XMLHttpRequest()
        }
    }

    var key
    var aborted
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer
    var failureResponse = {
        body: undefined,
        headers: {},
        statusCode: 0,
        method: method,
        url: uri,
        rawRequest: xhr
    }

    if ("json" in options && options.json !== false) {
        isJson = true
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
            body = JSON.stringify(options.json === true ? body : options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.onabort = function(){
        aborted = true;
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync, options.username, options.password)
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            if (aborted) return
            aborted = true//IE9 may still call readystatechange
            xhr.abort("timeout")
            var e = new Error("XMLHttpRequest timeout")
            e.code = "ETIMEDOUT"
            errorFunc(e)
        }, options.timeout )
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    // Microsoft Edge browser sends "undefined" when send is called with undefined value.
    // XMLHttpRequest spec says to pass null as body to indicate no body
    // See https://github.com/naugtur/xhr/issues/100.
    xhr.send(body || null)

    return xhr


}

function getXml(xhr) {
    // xhr.responseXML will throw Exception "InvalidStateError" or "DOMException"
    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.
    try {
        if (xhr.responseType === "document") {
            return xhr.responseXML
        }
        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror"
        if (xhr.responseType === "" && !firefoxBugTakenEffect) {
            return xhr.responseXML
        }
    } catch (e) {}

    return null
}

function noop() {}

},{"global/window":"node_modules/global/window.js","is-function":"node_modules/is-function/index.js","parse-headers":"node_modules/parse-headers/parse-headers.js","xtend":"node_modules/xtend/immutable.js"}],"node_modules/xhr-progress/index.js":[function(require,module,exports) {
var EventEmitter = require('events').EventEmitter

module.exports = progress

function progress(xhr) {
  var emitter = new EventEmitter
  var finished = false

  if (xhr.attachEvent) {
    xhr.attachEvent('onreadystatechange', done)
    return emitter
  }

  xhr.addEventListener('load', done, false)
  xhr.addEventListener('progress', progress, false)
  function progress(event) {
    var value = event.lengthComputable
      ? event.loaded / event.total
      : 0

    if (!finished) emitter.emit('data'
      , value
      , event.total || null
    )

    finished = value === 1
  }

  function done(event) {
    if (event.type !== 'load' && !/^(ready|complete)$/g.test(
      (event.currentTarget || event.srcElement).readyState
    )) return

    if (finished) return
    if (xhr.removeEventListener) {
      xhr.removeEventListener('load', done, false)
      xhr.removeEventListener('progress', progress, false)
    } else
    if (xhr.detatchEvent) {
      xhr.detatchEvent('onreadystatechange', done)
    }

    emitter.emit('data', 1, event.total || null)
    emitter.emit('done')
    finished = true
  }

  return emitter
}

},{"events":"node_modules/events/events.js"}],"node_modules/web-audio-player/lib/xhr-audio.js":[function(require,module,exports) {
var xhr = require('xhr')
var xhrProgress = require('xhr-progress')

module.exports = xhrAudio
function xhrAudio (audioContext, src, cb, progress, decoding) {
  var xhrObject = xhr({
    uri: src,
    responseType: 'arraybuffer'
  }, function (err, resp, arrayBuf) {
    if (!/^2/.test(resp.statusCode)) {
      err = new Error('status code ' + resp.statusCode + ' requesting ' + src)
    }
    if (err) return cb(err)
    decode(arrayBuf)
  })

  xhrProgress(xhrObject)
    .on('data', function (amount, total) {
      progress(amount, total)
    })

  function decode (arrayBuf) {
    decoding()
    audioContext.decodeAudioData(arrayBuf, function (decoded) {
      cb(null, decoded)
    }, function () {
      var err = new Error('Error decoding audio data')
      err.type = 'DECODE_AUDIO_DATA'
      cb(err)
    })
  }
}

},{"xhr":"node_modules/xhr/index.js","xhr-progress":"node_modules/xhr-progress/index.js"}],"node_modules/web-audio-player/lib/resume-context.js":[function(require,module,exports) {
module.exports = function (audioContext) {
  if (audioContext.state === 'suspended' &&
      typeof audioContext.resume === 'function') {
    audioContext.resume()
  }
}

},{}],"node_modules/web-audio-player/lib/buffer-source.js":[function(require,module,exports) {
var process = require("process");
var canPlaySrc = require('./can-play-src')
var createAudioContext = require('./audio-context')
var xhrAudio = require('./xhr-audio')
var EventEmitter = require('events').EventEmitter
var rightNow = require('right-now')
var resume = require('./resume-context')

module.exports = createBufferSource
function createBufferSource (src, opt) {
  opt = opt || {}
  var emitter = new EventEmitter()
  var audioContext = opt.context || createAudioContext()

  // a pass-through node so user just needs to
  // connect() once
  var bufferNode, buffer, duration
  var node = audioContext.createGain()
  var audioStartTime = null
  var audioPauseTime = null
  var audioCurrentTime = 0
  var playing = false
  var loop = opt.loop

  emitter.play = function () {
    if (playing) return
    playing = true

    if (opt.autoResume !== false) resume(emitter.context)
    disposeBuffer()
    bufferNode = audioContext.createBufferSource()
    bufferNode.connect(emitter.node)
    bufferNode.onended = ended
    if (buffer) {
      // Might be null undefined if we are still loading
      bufferNode.buffer = buffer
    }
    if (loop) {
      bufferNode.loop = true
      if (typeof opt.loopStart === 'number') bufferNode.loopStart = opt.loopStart
      if (typeof opt.loopEnd === 'number') bufferNode.loopEnd = opt.loopEnd
    }

    if (duration && audioCurrentTime > duration) {
      // for when it loops...
      audioCurrentTime = audioCurrentTime % duration
    }
    var nextTime = audioCurrentTime

    bufferNode.start(0, nextTime)
    audioStartTime = rightNow()
  }

  emitter.pause = function () {
    if (!playing) return
    playing = false
    // Don't let the "end" event
    // get triggered on manual pause.
    bufferNode.onended = null
    bufferNode.stop(0)
    audioPauseTime = rightNow()
    audioCurrentTime += (audioPauseTime - audioStartTime) / 1000
  }

  emitter.stop = function () {
    emitter.pause()
    ended()
  }

  emitter.dispose = function () {
    disposeBuffer()
    buffer = null
  }

  emitter.node = node
  emitter.context = audioContext

  Object.defineProperties(emitter, {
    duration: {
      enumerable: true, configurable: true,
      get: function () {
        return duration
      }
    },
    playing: {
      enumerable: true, configurable: true,
      get: function () {
        return playing
      }
    },
    buffer: {
      enumerable: true, configurable: true,
      get: function () {
        return buffer
      }
    },
    volume: {
      enumerable: true, configurable: true,
      get: function () {
        return node.gain.value
      },
      set: function (n) {
        node.gain.value = n
      }
    }
  })

  // set initial volume
  if (typeof opt.volume === 'number') {
    emitter.volume = opt.volume
  }

  // filter down to a list of playable sources
  var sources = Array.isArray(src) ? src : [ src ]
  sources = sources.filter(Boolean)
  var playable = sources.some(canPlaySrc)
  if (playable) {
    var source = sources.filter(canPlaySrc)[0]
    // Support the same source types as in
    // MediaElement mode...
    if (typeof source.getAttribute === 'function') {
      source = source.getAttribute('src')
    } else if (typeof source.src === 'string') {
      source = source.src
    }
    // We have at least one playable source.
    // For now just play the first,
    // ideally this module could attempt each one.
    startLoad(source)
  } else {
    // no sources can be played...
    process.nextTick(function () {
      emitter.emit('error', canPlaySrc.createError(sources))
    })
  }
  return emitter

  function startLoad (src) {
    xhrAudio(audioContext, src, function audioDecoded (err, decoded) {
      if (err) return emitter.emit('error', err)
      buffer = decoded // store for later use
      if (bufferNode) {
        // if play() was called early
        bufferNode.buffer = buffer
      }
      duration = buffer.duration
      node.buffer = buffer
      emitter.emit('load')
    }, function audioProgress (amount, total) {
      emitter.emit('progress', amount, total)
    }, function audioDecoding () {
      emitter.emit('decoding')
    })
  }

  function ended () {
    emitter.emit('end')
    playing = false
    audioCurrentTime = 0
  }

  function disposeBuffer () {
    if (bufferNode) bufferNode.disconnect()
  }
}

},{"./can-play-src":"node_modules/web-audio-player/lib/can-play-src.js","./audio-context":"node_modules/web-audio-player/lib/audio-context.js","./xhr-audio":"node_modules/web-audio-player/lib/xhr-audio.js","events":"node_modules/events/events.js","right-now":"node_modules/right-now/browser.js","./resume-context":"node_modules/web-audio-player/lib/resume-context.js","process":"node_modules/process/browser.js"}],"node_modules/is-object/index.js":[function(require,module,exports) {
'use strict';

module.exports = function isObject(x) {
	return typeof x === 'object' && x !== null;
};

},{}],"node_modules/is-window/index.js":[function(require,module,exports) {
'use strict';

module.exports = function (obj) {

  if (obj == null) {
    return false;
  }

  var o = Object(obj);

  return o === o.window;
};

},{}],"node_modules/is-dom/index.js":[function(require,module,exports) {
var isObject = require('is-object')
var isWindow = require('is-window')

function isNode (val) {
  if (!isObject(val) || !isWindow(window) || typeof window.Node !== 'function') {
    return false
  }

  return typeof val.nodeType === 'number' &&
    typeof val.nodeName === 'string'
}

module.exports = isNode

},{"is-object":"node_modules/is-object/index.js","is-window":"node_modules/is-window/index.js"}],"node_modules/simple-media-element/index.js":[function(require,module,exports) {
var isDom = require('is-dom')
var lookup = require('browser-media-mime-type')

module.exports.video = simpleMediaElement.bind(null, 'video')
module.exports.audio = simpleMediaElement.bind(null, 'audio')

function simpleMediaElement (elementName, sources, opt) {
  opt = opt || {}

  if (!Array.isArray(sources)) {
    sources = [ sources ]
  }

  var media = opt.element || document.createElement(elementName)

  if (opt.loop) media.setAttribute('loop', 'loop')
  if (opt.muted) media.setAttribute('muted', 'muted')
  if (opt.autoplay) media.setAttribute('autoplay', 'autoplay')
  if (opt.controls) media.setAttribute('controls', 'controls')
  if (opt.crossOrigin) media.setAttribute('crossorigin', opt.crossOrigin)
  if (opt.preload) media.setAttribute('preload', opt.preload)
  if (opt.poster) media.setAttribute('poster', opt.poster)
  if (typeof opt.volume !== 'undefined') media.setAttribute('volume', opt.volume)

  sources = sources.filter(Boolean)
  sources.forEach(function (source) {
    media.appendChild(createSourceElement(source))
  })

  return media
}

function createSourceElement (data) {
  if (isDom(data)) return data
  if (typeof data === 'string') {
    data = { src: data }
    if (data.src) {
      var ext = extension(data.src)
      if (ext) data.type = lookup(ext)
    }
  }

  var source = document.createElement('source')
  if (data.src) source.setAttribute('src', data.src)
  if (data.type) source.setAttribute('type', data.type)
  return source
}

function extension (data) {
  var extIdx = data.lastIndexOf('.')
  if (extIdx <= 0 || extIdx === data.length - 1) {
    return null
  }
  return data.substring(extIdx + 1)
}

},{"is-dom":"node_modules/is-dom/index.js","browser-media-mime-type":"node_modules/browser-media-mime-type/index.js"}],"node_modules/object-assign/index.js":[function(require,module,exports) {
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
'use strict';
/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};
},{}],"node_modules/web-audio-player/lib/event-add-once.js":[function(require,module,exports) {
module.exports = addOnce
function addOnce (element, event, fn) {
  function tmp (ev) {
    element.removeEventListener(event, tmp, false)
    fn(ev, element)
  }
  element.addEventListener(event, tmp, false)
}
},{}],"node_modules/web-audio-player/lib/media-source.js":[function(require,module,exports) {
var process = require("process");
var EventEmitter = require('events').EventEmitter
var createAudio = require('simple-media-element').audio
var assign = require('object-assign')

var resume = require('./resume-context')
var createAudioContext = require('./audio-context')
var canPlaySrc = require('./can-play-src')
var addOnce = require('./event-add-once')

module.exports = createMediaSource
function createMediaSource (src, opt) {
  opt = assign({}, opt)
  var emitter = new EventEmitter()

  // Default to Audio instead of HTMLAudioElement
  // There is not much difference except in the following:
  //    x instanceof Audio
  //    x instanceof HTMLAudioElement
  // And in my experience Audio has better support on various
  // platforms like CocoonJS.
  // Please open an issue if there is a concern with this.
  if (!opt.element) opt.element = new window.Audio()

  var desiredVolume = opt.volume
  delete opt.volume // make sure <audio> tag receives full volume
  var audio = createAudio(src, opt)
  var audioContext = opt.context || createAudioContext()
  var node = audioContext.createGain()
  var mediaNode = audioContext.createMediaElementSource(audio)
  mediaNode.connect(node)

  audio.addEventListener('ended', function () {
    emitter.emit('end')
  })

  var loopStart = opt.loopStart
  var loopEnd = opt.loopEnd
  var hasLoopStart = typeof loopStart === 'number' && isFinite(loopStart)
  var hasLoopEnd = typeof loopEnd === 'number' && isFinite(loopEnd)
  var isLoopReady = false
  if (hasLoopStart || hasLoopEnd) {
    window.requestAnimationFrame(function update () {
      // audio hasn't been loaded yet...
      if (typeof audio.duration !== 'number') return
      var currentTime = audio.currentTime

      // where to end the buffer
      var endTime = hasLoopEnd ? Math.min(audio.duration, loopEnd) : audio.duration

      if (currentTime > (loopStart || 0)) {
        isLoopReady = true
      }

      // jump ahead to loop start point
      if (hasLoopStart && isLoopReady && currentTime < loopStart) {
        audio.currentTime = loopStart
      }

      // if we've hit the end of the buffer
      if (currentTime >= endTime) {
        // if there is no loop end point, let native looping take over
        // if we have a loop end point, jump back to start point or zero
        if (hasLoopEnd) {
          audio.currentTime = hasLoopStart ? loopStart : 0
        }
      }
      window.requestAnimationFrame(update)
    });
  }

  emitter.element = audio
  emitter.context = audioContext
  emitter.node = node
  emitter.pause = audio.pause.bind(audio)
  emitter.play = function () {
    if (opt.autoResume !== false) resume(emitter.context)
    return audio.play()
  }

  // This exists currently for parity with Buffer source
  // Open to suggestions for what this should dispose...
  emitter.dispose = function () {}

  emitter.stop = function () {
    var wasPlaying = emitter.playing
    audio.pause()
    audio.currentTime = 0
    isLoopReady = false
    if (wasPlaying) {
      emitter.emit('end')
    }
  }

  Object.defineProperties(emitter, {
    duration: {
      enumerable: true, configurable: true,
      get: function () {
        return audio.duration
      }
    },
    currentTime: {
      enumerable: true, configurable: true,
      get: function () {
        return audio.currentTime
      }
    },
    playing: {
      enumerable: true, configurable: true,
      get: function () {
        return !audio.paused
      }
    },
    volume: {
      enumerable: true, configurable: true,
      get: function () {
        return node.gain.value
      },
      set: function (n) {
        node.gain.value = n
      }
    }
  })

  // Set initial volume
  if (typeof desiredVolume === 'number') {
    emitter.volume = desiredVolume
  }

  // Check if all sources are unplayable,
  // if so we emit an error since the browser
  // might not.
  var sources = Array.isArray(src) ? src : [ src ]
  sources = sources.filter(Boolean)
  var playable = sources.some(canPlaySrc)
  if (playable) {
    // At least one source is probably/maybe playable
    startLoad()
  } else {
    // emit error on next tick so user can catch it
    process.nextTick(function () {
      emitter.emit('error', canPlaySrc.createError(sources))
    })
  }

  return emitter

  function startLoad () {
    // The file errors (like decoding / 404s) appear on <source>
    var srcElements = Array.prototype.slice.call(audio.children)
    var remainingSrcErrors = srcElements.length
    var hasErrored = false
    var sourceError = function (err, el) {
      if (hasErrored) return
      remainingSrcErrors--
      console.warn('Error loading source: ' + el.getAttribute('src'))
      if (remainingSrcErrors <= 0) {
        hasErrored = true
        srcElements.forEach(function (el) {
          el.removeEventListener('error', sourceError, false)
        })
        emitter.emit('error', new Error('Could not play any of the supplied sources'))
      }
    }

    var done = function () {
      emitter.emit('load')
    }

    if (audio.readyState >= audio.HAVE_ENOUGH_DATA) {
      process.nextTick(done)
    } else {
      addOnce(audio, 'canplay', done)
      addOnce(audio, 'error', function (ev) {
        emitter.emit(new Error('Unknown error while loading <audio>'))
      })
      srcElements.forEach(function (el) {
        addOnce(el, 'error', sourceError)
      })
    }

    // On most browsers the loading begins
    // immediately. However, on iOS 9.2 Safari,
    // you need to call load() for events
    // to be triggered.
    audio.load()
  }
}

},{"events":"node_modules/events/events.js","simple-media-element":"node_modules/simple-media-element/index.js","object-assign":"node_modules/object-assign/index.js","./resume-context":"node_modules/web-audio-player/lib/resume-context.js","./audio-context":"node_modules/web-audio-player/lib/audio-context.js","./can-play-src":"node_modules/web-audio-player/lib/can-play-src.js","./event-add-once":"node_modules/web-audio-player/lib/event-add-once.js","process":"node_modules/process/browser.js"}],"node_modules/web-audio-player/index.js":[function(require,module,exports) {
var buffer = require('./lib/buffer-source')
var media = require('./lib/media-source')

module.exports = webAudioPlayer
function webAudioPlayer (src, opt) {
  if (!src) throw new TypeError('must specify a src parameter')
  opt = opt || {}
  if (opt.buffer) return buffer(src, opt)
  else return media(src, opt)
}

},{"./lib/buffer-source":"node_modules/web-audio-player/lib/buffer-source.js","./lib/media-source":"node_modules/web-audio-player/lib/media-source.js"}],"src/systems/AudioSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AudioSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _ = _interopRequireDefault(require("../assets/audio/*.{mp3,ogg}"));

var _documentVisibility = _interopRequireDefault(require("../util/documentVisibility"));

var _howler = require("howler");

var _webAudioPlayer = _interopRequireDefault(require("web-audio-player"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _rightNow = _interopRequireDefault(require("right-now"));

var _addFrameTasks = require("../util/addFrameTasks");

var _queryString = _interopRequireDefault(require("../util/query-string"));

var _config = _interopRequireDefault(require("../config"));

var _stores = require("../util/stores");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Howler.autoUnlock = false;
// Audio options to be binded to start screen later
// import audioRamp from "../util/audio-ramp";
const IS_NATIVE = Boolean((0, _config.default)().native);
const USE_OGG = false; // On native we will be able to circumvent user gesture issues

const isAutoPlaySupported = IS_NATIVE;
const ALLOW_BUFFER = true;
const isLowQualityAudio = false;
const defaultOptions = {
  volume: 0.6
};
Object.keys(_.default).forEach(key => {
  const {
    mp3,
    ogg
  } = _.default[key];
  const arr = (USE_OGG ? [ogg, mp3] : [mp3]).filter(Boolean);
  _.default[key] = arr;
});
const CurAudioContext = window.AudioContext || window.webkitAudioContext;

const resume = context => {
  if (context.state === "suspended" && typeof context.resume === "function") {
    return context.resume();
  }
};

function AudioSystem(world) {
  if (!CurAudioContext) {
    console.log("No audio context, audio system skipped");
    return;
  }

  const willTriggerAudios = world.view([Tags.WillTriggerAudio, Tags.Object3D]);
  const tapEmitter = world.findTag(Tags.InputGestureEmitter);
  const isIOS = /(iOS|iPad|iPod|iPhone)/i.test(navigator.userAgent);

  _stores.audioState.subscribe(({
    muted,
    visible
  }) => {
    const shouldMute = muted || !visible;

    _howler.Howler.mute(shouldMute);
  });

  const gameIntroOverlayEvents = world.listen(Tags.OriginTreeIntroSequenceStarted);
  const random = (0, _Random.default)();
  let started = false; // const orbQuery = world.query(Tags.CollectTokenOrb);

  const orbTriggerEvent = world.listen(Tags.CollectTokenOrb);
  const orbNotes = ["a3", "c3", "c4", "d3", "d4", "e3", "g3"];
  const orbDeck = random.deck(orbNotes);
  const orbCache = {};
  const backgrounds = {
    forest: {
      biome: "forest",
      musicId: "music1",
      natureId: "nature1"
    },
    grasslands: {
      biome: "grasslands",
      musicId: "music2",
      natureId: "nature2"
    },
    tundra: {
      biome: "tundra",
      musicId: _queryString.default.musicA ? "music3a" : "music3b",
      natureId: "nature3"
    }
  };
  const triggers = triggerAudioEvents([// {
  //   query: Tags.GameStarted,
  //   assets: ["score-start"],
  //   options: { volume: 1, preload: true },
  // },
  {
    query: Tags.CollectedToken,
    assets: ["writing-01", "writing-02", "writing-03"],
    options: {
      volume: 0.5
    }
  }, // {
  //   query: Tags.CollectedToken,
  //   assets: ["collect1"],
  // },
  {
    query: Tags.HaikuCardSaved,
    assets: ["haiku-card"]
  }, {
    query: Tags.HaikuCardShown,
    assets: ["score-haiku"],
    options: {
      volume: 1
    }
  }, {
    query: Tags.UserHitAudioTrigger,
    condition: entity => {
      const d = entity.get(Tags.UserHitAudioTrigger);
      return d.type === "tree";
    },
    options: {
      volume: 0.5,
      allowMultiple: true
    },
    assets: ["leaves1", "leaves2", "leaves3", "leaves4"]
  }, {
    needsCharacter: false,
    query: Tags.TriggerTreeTransitionAudio,
    // condition: (entity) => {
    //   const d = entity.get(Tags.UserHitAudioTrigger);
    //   return d.type === "origin_tree";
    // },
    options: {
      volume: 0.5,
      preload: false
    },
    assets: ["tree-transition-0"]
  }, isLowQualityAudio ? false : {
    // leaf audio
    query: Tags.UserHitAudioTrigger,
    condition: entity => {
      const d = entity.get(Tags.UserHitAudioTrigger);
      return d.type === "ice";
    },
    // https://freesound.org/people/skinnytecboy/sounds/174388/
    options: {
      volume: 0.5,
      allowMultiple: false,
      preload: false,
      playthrough: true
    },
    assets: ["ice-01", "ice-02", "ice-03"]
  }, isLowQualityAudio ? false : {
    // leaf audio
    query: Tags.UserHitAudioTrigger,
    condition: entity => {
      const d = entity.get(Tags.UserHitAudioTrigger);
      return d.type === "water";
    },
    envelope: {
      attack: 0.2,
      sustain: 1,
      volume: [0.4, 0.75],
      release: 0.5,
      delay: 0
    },
    options: {
      volume: 0.5,
      preload: false,
      allowMultiple: true
    },
    assets: ["water-01", "water-02"]
  }, isLowQualityAudio ? false : {
    // leaf audio
    query: Tags.UserHitAudioTrigger,
    condition: entity => {
      const d = entity.get(Tags.UserHitAudioTrigger);
      return d.type === "leaf";
    },
    envelope: {
      attack: 0.2,
      sustain: 0.1,
      volume: [0.4, 0.75],
      release: 0.5,
      delay: 0
    },
    options: {
      volume: 0.11,
      preload: false,
      allowMultiple: true
    },
    assets: ["grass-push1", "grass-push2"]
  }, {
    query: Tags.WaitingForBiomeResolution,
    assets: ["collect-poem"],
    options: {
      preload: false
    }
  }, isLowQualityAudio ? false : {
    query: Tags.HatTipWindLineSound,
    condition: e => {
      return random.chance(0.5);
    },
    assets: ["movement-forest"],
    options: {
      volume: 0.2,
      allowMultiple: true
    }
  }, {
    query: Tags.TutorialBarrenGround,
    removing: true,
    assets: ["score-start"],
    options: {
      volume: 1
    }
  }, {
    query: Tags.TokenIsCollecting,
    assets: ["reveal01"],
    options: {
      volume: 1
    }
  }, {
    query: Tags.CompassVisible,
    assets: ["reveal02"],
    options: {
      volume: 0.75
    }
  }, // {
  //   query: orbQuery,
  //   deck: true,
  //   assets: [
  //     "bnote1",
  //     "bnote2",
  //     "bnote3",
  //     "bnote4",
  //     "bnote5",
  //     "bnote6",
  //     "bnote7",
  //   ],
  //   options: { volume: 0.65 },
  // },
  // {
  //   query: Tags.PauseOpen,
  //   assets: ["menu-open"],
  //   options: { volume: 0.6 },
  // },
  // {
  //   query: Tags.ButtonHover,
  //   assets: ["button-hover"],
  //   options: { volume: 0.6, preload: true },
  // },
  {
    query: Tags.ButtonClick,
    assets: ["click"],
    options: {
      volume: 0.75,
      preload: true
    }
  }, // {
  //   query: Tags.HaikuInInventory,
  //   assets: ["haiku-card"],
  // },
  {
    query: Tags.JournalOpen,
    assets: ["journal-open"],
    options: {
      volume: 0.5,
      preload: false
    }
  }, {
    query: Tags.AnimalSound,
    condition: e => e.get(Tags.AnimalSound) === "fish",
    assets: ["fish"],
    options: {
      volume: 0.45,
      preload: false
    }
  }, {
    query: Tags.AnimalSound,
    condition: e => random.chance(0.5) && e.get(Tags.AnimalSound) === "birdChirp",
    assets: ["bird0"],
    options: {
      volume: 0.4,
      preload: false
    }
  }, {
    query: Tags.AnimalSound,
    condition: e => e.get(Tags.AnimalSound) === "birdFlap",
    assets: ["birdflap"],
    options: {
      volume: 0.25,
      preload: false
    }
  }, {
    query: Tags.AnimalSound,
    condition: e => e.get(Tags.AnimalSound) === "butterfly",
    assets: ["butterfly"],
    options: {
      volume: 1,
      preload: false
    }
  }, {
    needsCharacter: false,
    query: Tags.ShowBiomeResolution,
    assets: ["score-restore"],
    options: {
      volume: 1,
      preload: false
    }
  }, {
    query: Tags.TransitionToNextBiome,
    condition: entity => {
      // const d = entity.get(Tags.UserHitAudioTrigger);
      // console.log("TRANSITIONING TO NEXT BIOME");
      return true;
    },
    assets: ["score-transition"],
    options: {
      volume: 1,
      preload: false
    }
  }, {
    query: Tags.EndGameState,
    assets: ["score-outro"],
    options: {
      volume: 1,
      preload: false
    }
  },, {
    query: Tags.FlashSound,
    assets: ["flash-build-up"],
    options: {
      volume: 0.25,
      preload: false
    }
  }].filter(Boolean));
  const tmp2DA = new THREE.Vector2();
  const tmp3DA = new THREE.Vector3();
  const tmp2DB = new THREE.Vector2();
  let audioTriggerCoolDown = false;
  let audioTriggerTime = 0;
  let audioTriggerThrottle = 0.1;
  let lastEnv;
  let curPlayingBackground;
  const envStates = world.view(Tags.ActiveEnvironmentState);
  const startCollectingEvent = world.listen(Tags.TokenIsCollecting);

  if (isAutoPlaySupported) {
    (0, _addFrameTasks.addFrameTask)(() => start());
  } else {
    tapEmitter.once("tap", () => {
      // console.log("Tapped once!");
      start();
    });
  } // rain


  const rainEvent = world.listen(Tags.Raining);
  const rainVolume = 0.25;
  let rainSound, rainTimer;

  const startRain = () => {
    if (!rainSound) {
      rainSound = new _howler.Howl({
        src: _.default.rain,
        loop: true,
        volume: 0.25
      });
    }

    clearTimeout(rainTimer);
    rainSound.stop();
    rainSound.play();
    rainSound.fade(0, rainVolume, 1000);
  }; // purring


  const purringEvent = world.listen(Tags.FoxPurring);
  const purringVolume = 0.18;
  let purringSound, purringTimer;

  const startPurring = () => {
    if (!purringSound) {
      purringSound = new _howler.Howl({
        src: _.default.foxpurring,
        loop: true,
        volume: purringVolume
      });
    }

    clearTimeout(purringTimer);
    purringSound.stop();
    purringSound.play();
    purringSound.fade(0, purringVolume, 1000);
  };

  const stopPurring = () => {
    if (!purringSound) return;
    purringSound.fade(purringVolume, 0, 1000);
    purringTimer = setTimeout(() => purringSound.stop(), 1000);
  }; // hm?


  const foxHmEvent = world.listen(Tags.FoxHm);
  const foxHmVolume = 0.4;
  let foxHmSound;

  const startFoxHm = () => {
    if (!foxHmSound) {
      foxHmSound = new _howler.Howl({
        src: _.default.foxhm,
        loop: false,
        volume: foxHmVolume
      });
    }

    foxHmSound.stop();
    foxHmSound.play();
    foxHmSound.fade(0, foxHmVolume, 1);
  };

  const stopFoxHm = () => {
    if (!foxHmSound) return;
    foxHmSound.stop();
  };

  const createOrb = id => {
    return new _howler.Howl({
      volume: 0.55,
      src: _.default[id]
    });
  };

  return function audioSystem(dt) {
    if (!started) return;

    if (rainEvent.changed) {
      if (rainEvent.added.length) {
        startRain();
      } else if (rainEvent.removing.length) {
        if (rainSound) {
          rainSound.fade(rainVolume, 0, 1000);
          rainTimer = setTimeout(() => rainSound.stop(), 1000);
        }
      }
    }

    if (purringEvent.changed) {
      if (purringEvent.added.length) {
        startPurring();
      } else if (purringEvent.removing.length) {
        stopPurring();
      }
    }

    if (foxHmEvent.changed) {
      if (foxHmEvent.added.length == 1) {
        startFoxHm();
      } else if (purringEvent.removing.length) {
        stopFoxHm();
      }
    }

    if (gameIntroOverlayEvents.changed) {
      const hasIntro = Boolean(world.findTag(Tags.OriginTreeIntroSequenceStarted));

      if (curPlayingBackground && curPlayingBackground.players && curPlayingBackground.ids) {
        curPlayingBackground.players.forEach(p => {
          p.fade(hasIntro ? 1 : 0, hasIntro ? 0 : 1, 500);
        });
      }
    }

    const envState = envStates.length ? envStates[0].get(Tags.EnvironmentState) : null;
    const envName = envState && envState.name;

    if (envStates.length) {
      if (envName !== lastEnv) {
        const bg = backgrounds[envName];

        if (curPlayingBackground) {
          stopBackground(curPlayingBackground); // console.log("[Audio]", "Stop background");
        }

        playBackground(bg); // console.log("[Audio]", "Play new background");
        // cache orb music notes

        orbNotes.forEach(note => {
          const id = `note-${envName}-${note}`;

          if (!(id in orbCache)) {
            orbCache[id] = createOrb(id);
          }
        });
      }

      lastEnv = envName;
    }

    if (audioTriggerCoolDown) {
      audioTriggerTime += dt;

      if (audioTriggerTime >= audioTriggerThrottle) {
        audioTriggerCoolDown = false;
        audioTriggerTime = 0;
      }
    }

    if (startCollectingEvent.added.length > 0) {
      orbDeck.reset(); // const orb = triggers.listeners.find(
      //   (listener) => listener.query === orbQuery
      // );
      // if (orb && orb.deck) {
      //   // reset notes so we don't get duplicates
      //   orb.deck.reset();
      // }
    }

    if (orbTriggerEvent.added.length > 0) {
      const note = orbDeck.next();
      const id = `note-${envName}-${note}`;

      if (!(id in orbCache)) {
        orbCache[id] = createOrb(id);
      }

      orbCache[id].play();
    }

    triggers.update(); // if (curPlayingBackground) {
    // curPlayingBackground.ramp.update(dt);
    // }

    const userPos = world.findTag(Tags.UserCharacter).position;
    tmp2DA.set(userPos.x, userPos.z);

    for (let i = 0; i < willTriggerAudios.length; i++) {
      const e = willTriggerAudios[i];
      const obj = e.get(Tags.Object3D);

      if (obj.visible) {
        obj.getWorldPosition(tmp3DA);
        tmp2DB.set(tmp3DA.x, tmp3DA.z);
        const distSq = tmp2DA.distanceToSquared(tmp2DB);
        const dTh = 2;
        const dThSq = dTh * dTh;
        const isInside = distSq <= dThSq;

        if (isInside) {
          if (!audioTriggerCoolDown && !e.has(Tags.UserHitAudioTrigger)) {
            audioTriggerCoolDown = true;
            audioTriggerTime = 0;
            e.add(Tags.UserHitAudioTrigger);
            const audioData = e.get(Tags.UserHitAudioTrigger); // TODO: other sound types

            audioData.type = "tree";
          }
        } else {
          if (e.has(Tags.UserHitAudioTrigger)) {
            e.remove(Tags.UserHitAudioTrigger);
          }
        }
      }
    }
  };

  function start() {
    started = true;
    let biome = "forest";

    if (envStates.length > 0) {
      const envState = envStates[0].get(Tags.EnvironmentState);
      biome = envState.name;
    } // console.log("starting audio");


    lastEnv = biome;
    const bg = biome in backgrounds ? backgrounds[biome] : null;

    if (bg) {
      playBackground(bg);
    }
  }

  function stopBackground(bg) {
    if (bg && bg.players) {
      // console.log("stopping background", bg);
      bg.players.forEach(p => {
        p.stop();
      });
      bg.ids = null;
    }

    curPlayingBackground = null;
  }

  function playBackground(bg) {
    if (bg) {
      if (!bg.players) {
        // console.log("starting background", bg);
        bg.players = [bg.natureId, bg.musicId].map(id => {
          return new _howler.Howl({
            src: _.default[id],
            loop: true,
            html5: true
          });
        });
      }

      bg.players.forEach(p => p.stop());
      bg.ids = bg.players.map(p => {
        return p.play();
      });
    }

    curPlayingBackground = bg;
  }

  function triggerAudioEvents(events) {
    const listeners = events.map(({
      query,
      envelope,
      assets,
      options,
      condition,
      deck = false,
      removing = false
    }) => {
      const listener = world.listen(query);
      const playerOptions = { ...defaultOptions,
        ...options
      };
      const preload = playerOptions.preload !== false;
      const players = assets.map(id => {
        const urls = _.default[id];
        const sound = new _howler.Howl({ ...playerOptions,
          src: urls,
          autoplay: false,
          preload // html5: false,

        });
        return sound;
      });
      let hasLoaded = preload;

      if (hasLoaded) {// console.log(
        //   "[audio] Pre-loading",
        //   AudioAssets[[].concat(assets)[0]][0]
        // );
      }

      return {
        deck: deck ? random.deck(players) : null,
        query,
        removing,
        condition,
        players,

        load() {
          if (!hasLoaded) {
            // console.log(
            //   "[audio] Loading",
            //   AudioAssets[[].concat(assets)[0]][0]
            // );
            hasLoaded = true;
            players.forEach(p => p.load());
          }
        },

        listener
      };
    });
    return {
      listeners,

      update(dt = 0) {
        const playerShowing = !world.findTag(Tags.HideCharacter) && !world.findTag(Tags.AnimateOutCharacter);
        listeners.forEach(audio => {
          const {
            listener,
            needsCharacter = true,
            condition,
            players,
            removing = false
          } = audio;
          const list = removing ? listener.removing : listener.added;

          if (listener.changed && list.length > 0) {
            if (needsCharacter && !playerShowing) {
              return;
            }

            if (condition) {
              list.forEach(e => {
                if (condition(e, audio)) {
                  playAudio(audio);
                }
              });
            } else {
              playAudio(audio);
            }
          }
        });
      }

    };

    function playAudio(audio) {
      audio.load();
      const player = audio.deck ? audio.deck.next() : random.pick(audio.players); // console.log("[audio] Playing", player._src);

      player.play();
    }
  }
}

function attachIOSAudioFix(audioCtx) {
  var fixAudioContext = function (e) {
    // Remove events
    document.removeEventListener("touchstart", fixAudioContext);
    document.removeEventListener("touchend", fixAudioContext);
    window.removeEventListener("mousedown", fixAudioContext);

    (async () => {
      const p = resume(audioCtx);
      if (p) await p; // Create empty buffer

      var buffer = audioCtx.createBuffer(1, 1, 22050);
      var source = audioCtx.createBufferSource();
      source.buffer = buffer; // Connect to output (speakers)

      source.connect(audioCtx.destination); // Play sound

      if (source.start) {
        source.start(0);
      } else if (source.play) {
        source.play(0);
      } else if (source.noteOn) {
        source.noteOn(0);
      }
    })();
  }; // iOS 6-8


  document.addEventListener("touchstart", fixAudioContext); // iOS 9

  document.addEventListener("touchend", fixAudioContext);
  window.addEventListener("mousedown", fixAudioContext);
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/math":"src/util/math.js","../assets/audio/*.{mp3,ogg}":"src/assets/audio/*.{mp3,ogg}","../util/documentVisibility":"src/util/documentVisibility.js","howler":"node_modules/howler/dist/howler.js","web-audio-player":"node_modules/web-audio-player/index.js","../util/Random":"src/util/Random.js","right-now":"node_modules/right-now/browser.js","../util/addFrameTasks":"src/util/addFrameTasks.js","../util/query-string":"src/util/query-string.js","../config":"src/config.js","../util/stores":"src/util/stores.js"}],"node_modules/array-almost-equal/node_modules/almost-equal/almost_equal.js":[function(require,module,exports) {
"use strict"

var abs = Math.abs
  , min = Math.min

function almostEqual(a, b, absoluteError, relativeError) {
  var d = abs(a - b)
  if(d <= absoluteError) {
    return true
  }
  if(d <= relativeError * min(abs(a), abs(b))) {
    return true
  }
  return a === b
}

almostEqual.FLT_EPSILON = 1.19209290e-7
almostEqual.DBL_EPSILON = 2.2204460492503131e-16

module.exports = almostEqual

},{}],"node_modules/array-almost-equal/index.js":[function(require,module,exports) {
var isArray = require('an-array')
var almost = require('almost-equal')

//determines whether two arrays are almost equal
module.exports = function(a, b, absoluteTolerance, relativeTolerance) {
    //will accept typed arrays
    if (!a || !b || !isArray(a) || !isArray(b))
        return false
    if (a.length !== b.length)
        return false
    if (typeof absoluteTolerance !== 'number')
        absoluteTolerance = almost.FLT_EPSILON
    if (typeof relativeTolerance !== 'number')
        relativeTolerance = absoluteTolerance

    return Array.prototype.slice.call(a).every(function(a0, i) {
        var b0 = b[i]
        return a0 === b0 || almost(a0, b0, absoluteTolerance, relativeTolerance)
    })
}
},{"an-array":"node_modules/an-array/index.js","almost-equal":"node_modules/array-almost-equal/node_modules/almost-equal/almost_equal.js"}],"node_modules/earcut/src/earcut.js":[function(require,module,exports) {
'use strict';

module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return filterPoints(p);
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);

        // filter collinear points around the cuts
        filterPoints(outerNode, outerNode.next);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m;

    do {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if (locallyInside(p, hole) &&
                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    } while (p !== stop);

    return m;
}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));

    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}

function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};

},{}],"src/util/helpers.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.multiLineSegments2D = multiLineSegments2D;
exports.multiPoly2D = multiPoly2D;
exports.filledPoly2D = filledPoly2D;
exports.filledMultiPoly2D = filledMultiPoly2D;
exports.multiPoints2D = multiPoints2D;
exports.circleHelper2D = circleHelper2D;
exports.boundsHelper2D = boundsHelper2D;
exports.curveHelper = curveHelper;
exports.spheresAlongCurve = spheresAlongCurve;
exports.pointsToSpheres = pointsToSpheres;
exports.animatedWindLineCurve = animatedWindLineCurve;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _arrayAlmostEqual = _interopRequireDefault(require("array-almost-equal"));

var _threeUtil = require("./three-util");

var _boundPoints = _interopRequireDefault(require("bound-points"));

var _math = require("canvas-sketch-util/math");

var _earcut = _interopRequireDefault(require("earcut"));

var GeomUtil = _interopRequireWildcard(require("./geometry"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let circleLineGeo;
let sphereGeo;

function multiLineSegments2D(segments, opt = {}) {
  const geometry = new THREE.Geometry();
  const mesh = new THREE.LineSegments(geometry, new THREE.LineBasicMaterial({
    color: "white",
    ...opt
  }));
  mesh.updateData = update;
  if (segments) update(segments);
  return mesh;

  function update(segments) {
    geometry.vertices.length = 0;
    segments.forEach(s => {
      s.forEach(a => {
        geometry.vertices.push(new THREE.Vector3(a[0], 0, a[1]));
      });
    });
    geometry.verticesNeedUpdate = true;
  }
}

function multiPoly2D(polygons = [], opt = {}) {
  const {
    closed = true
  } = opt;
  const geometry = new THREE.Geometry();
  const mesh = new THREE.LineSegments(geometry, new THREE.LineBasicMaterial({
    color: "white",
    ...opt
  }));
  mesh.updateData = update;
  if (polygons) update(polygons);
  return mesh;

  function update(polygons) {
    geometry.vertices.length = 0;
    polygons.forEach(polygon => {
      const isClosed = (0, _arrayAlmostEqual.default)(polygon[0], polygon[polygon.length - 1]);

      if (!isClosed && closed) {
        polygon = polygon.slice();
        polygon.push(polygon[0]);
      }

      for (let i = 0; i < polygon.length - 1; i++) {
        const a = polygon[i];
        const b = polygon[i + 1];
        geometry.vertices.push(new THREE.Vector3(a[0], 0, a[1]));
        geometry.vertices.push(new THREE.Vector3(b[0], 0, b[1]));
      }
    });
    geometry.verticesNeedUpdate = true;
  }
}

function filledPoly2D(polygon = [], opt = {}) {
  const {
    vertices,
    holes,
    dimensions
  } = _earcut.default.flatten([polygon]);

  const tris = (0, _earcut.default)(vertices, holes, dimensions);
  const [min, max] = opt.bounds || (0, _boundPoints.default)(polygon);
  const geo = new THREE.BufferGeometry();
  geo.setIndex(new THREE.Uint16BufferAttribute(tris, 1));
  geo.setAttribute("position", new THREE.Float32BufferAttribute(polygon.map(p => [p[0], 0, p[1]]).flat(Infinity), 3));
  geo.setAttribute("uv", new THREE.Float32BufferAttribute(polygon.map(p => {
    return [(0, _math.inverseLerp)(min[0], max[0], p[0]), (0, _math.inverseLerp)(min[1], max[1], p[1])];
  }).flat(Infinity), 2));
  const matOpt = { ...opt
  };
  delete matOpt.bounds;
  return new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ ...matOpt,
    side: THREE.DoubleSide
  }));
}

function filledMultiPoly2D(polygon = [], opt = {}) {
  const {
    closed = true,
    color = "white"
  } = opt;
  const geometry = new THREE.Geometry();
  const mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
    color: color,
    side: THREE.DoubleSide,
    ...opt
  }));
  mesh.updateData = update;
  if (polygon) update(polygon);
  return mesh;

  function update(polygon) {
    geometry.vertices.length = 0;
    polygons.forEach(polygon => {
      const isClosed = (0, _arrayAlmostEqual.default)(polygon[0], polygon[polygon.length - 1]);

      if (!isClosed && closed) {
        polygon = polygon.slice();
        polygon.push(polygon[0]);
      }

      for (let i = 0; i < polygon.length - 1; i++) {
        const a = polygon[i];
        const b = polygon[i + 1];
        geometry.vertices.push(new THREE.Vector3(a[0], 0, a[1]));
        geometry.vertices.push(new THREE.Vector3(b[0], 0, b[1]));
      }
    });
    geometry.verticesNeedUpdate = true;
  }
}

function multiPoints2D(points = [], opt = {}) {
  const geometry = new THREE.BufferGeometry();
  const mesh = new THREE.Points(geometry, new THREE.PointsMaterial({
    color: "white",
    size: 1,
    sizeAttenuation: true,
    ...opt
  }));
  mesh.updateData = update;
  if (points) update(points);
  return mesh;

  function update(points) {
    (0, _threeUtil.setPointsToBufferPosition)(geometry, points.map(p => new THREE.Vector3(p[0], 0, p[1])));
  }
}

function circleHelper2D(position, radius, color = "white", steps = 32) {
  if (!circleLineGeo) {
    circleLineGeo = new THREE.Geometry();
    circleLineGeo.vertices = (0, _math.linspace)(steps, true).map(t => {
      const angle = t * Math.PI * 2;
      const r = 1;
      return new THREE.Vector3(Math.cos(angle) * r, 0, Math.sin(angle) * r);
    });
  }

  const mesh = new THREE.Line(circleLineGeo, new THREE.LineBasicMaterial({
    // depthTest: false,
    // depthWrite: false,
    color
  }));
  mesh.position.x = position[0];
  mesh.position.z = position[1];
  mesh.scale.setScalar(radius);
  return mesh;
}

function boundsHelper2D(bounds, opt = {}) {
  const verts = GeomUtil.boundsToVerts(bounds);
  const geo = new THREE.Geometry();
  geo.vertices = verts.map(v => new THREE.Vector3(v[0], 0, v[1]));
  return new THREE.LineLoop(geo, new THREE.LineBasicMaterial({ ...opt
  }));
}

function curveHelper(curve, opt = {}) {
  const {
    divisions = 50
  } = opt;
  const verts = curve.getPoints(divisions);
  const geo = new THREE.Geometry();
  geo.vertices = verts;
  return new THREE.Line(geo, new THREE.LineBasicMaterial({ ...opt
  }));
}

function spheresAlongCurve(curve, opt = {}) {
  let {
    count,
    spaced = true,
    spacing
  } = opt;

  if (count == null && spacing) {
    count = Math.max(2, Math.round(curve.getLength() / spacing));
  }

  count = Math.max(2, count);
  const matOpt = { ...opt
  };
  delete matOpt.count;
  delete matOpt.spaced;
  delete matOpt.spacing;
  delete matOpt.scale;
  const verts = spaced ? curve.getSpacedPoints(count - 1) : curve.getPoints(count - 1);
  if (!sphereGeo) sphereGeo = new THREE.SphereGeometry(1, 32, 32);
  const group = new THREE.Group();
  verts.map(v => {
    const mesh = new THREE.Mesh(sphereGeo, new THREE.MeshBasicMaterial(matOpt));
    const scl = opt.scale != null ? opt.scale : 0.5;
    mesh.scale.setScalar(scl);
    mesh.position.copy(v);
    group.add(mesh);
  });
  return group;
}

function pointsToSpheres(points, opt = {}) {
  if (!sphereGeo) sphereGeo = new THREE.SphereGeometry(1, 32, 32);
  const group = new THREE.Group();
  const matOpt = { ...opt
  };
  delete matOpt.scale;
  points.map(v => {
    const mesh = new THREE.Mesh(sphereGeo, new THREE.MeshBasicMaterial(matOpt));
    const scl = opt.scale != null ? opt.scale : 0.5;
    mesh.scale.setScalar(scl);
    mesh.position.copy(v);
    group.add(mesh);
  });
  return group;
}

function animatedWindLineCurve(world, curve, opt = {}) {
  const {
    divisions = 25
  } = opt;
  const verts = curve.getPoints(divisions - 1);
  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.Float32BufferAttribute(verts.map(p => p.toArray()).flat(Infinity), 3));
  geo.setAttribute("coord", new THREE.Float32BufferAttribute(verts.map((_, i, list) => {
    const u = list.length <= 1 ? 0.5 : i / (list.length - 1);
    return u;
  }).flat(Infinity), 1));
  const line = new THREE.Line(geo, new THREE.ShaderMaterial({
    name: "helperWindLine",
    transparent: true,
    fragmentShader:
    /*glsl*/
    `
        const float PI = 3.14159265359;
        const float TWO_PI = 6.28318530718;

        float repeat(float t, float length) {
          return t - floor(t / length) * length;
        }

        float deltaAngle(float current, float target) {
          float num = repeat(target - current, TWO_PI);
          if (num > PI) num -= TWO_PI;
          return num;
        }

        float wrapAngle(float angle) {
          float n = repeat(angle, TWO_PI);
          if (n > PI) n -= TWO_PI;
          return n;
        }

        float ToroidalDistance (float x1, float x2)
        {
            float dx = abs(x2 - x1);
            if (dx > 0.5) dx = 1.0 - dx;
            return sqrt(dx*dx);
        }
        
        uniform vec3 color;
        uniform float opacity;
        uniform float time;
        varying float vCoord;
        void main () {
          float alpha = opacity;
          float progress = mod(time, 1.0);
          
          // float smoothness = 0.1;
          // float target = mix(-0.5, 1.5, progress);
          // alpha *= smoothstep(target - smoothness, target + smoothness, vCoord);
          alpha *= pow(sin(vCoord * 10.0 + time * -3.0) * 0.5 + 0.5, 2.0);
          gl_FragColor = vec4(color, alpha);
        }
      `,
    vertexShader:
    /*glsl*/
    `
        attribute float coord;
        varying float vCoord;
        void main () {
          vCoord = coord;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);
        }
      `,
    uniforms: {
      color: {
        value: new THREE.Color(opt.color || "white")
      },
      opacity: {
        value: 1
      },
      time: {
        value: 0
      }
    }
  }));
  world.tag(Tags.ShaderUniformTime, {
    uniform: line.material.uniforms.time
  });
  return line;
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","array-almost-equal":"node_modules/array-almost-equal/index.js","./three-util":"src/util/three-util.js","bound-points":"node_modules/bound-points/bounds.js","canvas-sketch-util/math":"node_modules/canvas-sketch-util/math.js","earcut":"node_modules/earcut/src/earcut.js","./geometry":"src/util/geometry.js"}],"node_modules/d3-polygon/src/area.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(polygon) {
  var i = -1,
      n = polygon.length,
      a,
      b = polygon[n - 1],
      area = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    area += a[1] * b[0] - a[0] * b[1];
  }

  return area / 2;
}
},{}],"node_modules/d3-polygon/src/centroid.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(polygon) {
  var i = -1,
      n = polygon.length,
      x = 0,
      y = 0,
      a,
      b = polygon[n - 1],
      c,
      k = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    k += c = a[0] * b[1] - b[0] * a[1];
    x += (a[0] + b[0]) * c;
    y += (a[1] + b[1]) * c;
  }

  return k *= 3, [x / k, y / k];
}
},{}],"node_modules/d3-polygon/src/cross.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
// right, +y is up). Returns a positive value if ABC is counter-clockwise,
// negative if clockwise, and zero if the points are collinear.
function _default(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
}
},{}],"node_modules/d3-polygon/src/hull.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _cross = _interopRequireDefault(require("./cross.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function lexicographicOrder(a, b) {
  return a[0] - b[0] || a[1] - b[1];
} // Computes the upper convex hull per the monotone chain algorithm.
// Assumes points.length >= 3, is sorted by x, unique in y.
// Returns an array of indices into points in left-to-right order.


function computeUpperHullIndexes(points) {
  const n = points.length,
        indexes = [0, 1];
  let size = 2,
      i;

  for (i = 2; i < n; ++i) {
    while (size > 1 && (0, _cross.default)(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;

    indexes[size++] = i;
  }

  return indexes.slice(0, size); // remove popped points
}

function _default(points) {
  if ((n = points.length) < 3) return null;
  var i,
      n,
      sortedPoints = new Array(n),
      flippedPoints = new Array(n);

  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];

  sortedPoints.sort(lexicographicOrder);

  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

  var upperIndexes = computeUpperHullIndexes(sortedPoints),
      lowerIndexes = computeUpperHullIndexes(flippedPoints); // Construct the hull polygon, removing possible duplicate endpoints.

  var skipLeft = lowerIndexes[0] === upperIndexes[0],
      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
      hull = []; // Add upper hull in right-to-l order.
  // Then add lower hull in left-to-right order.

  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);

  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

  return hull;
}
},{"./cross.js":"node_modules/d3-polygon/src/cross.js"}],"node_modules/d3-polygon/src/contains.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(polygon, point) {
  var n = polygon.length,
      p = polygon[n - 1],
      x = point[0],
      y = point[1],
      x0 = p[0],
      y0 = p[1],
      x1,
      y1,
      inside = false;

  for (var i = 0; i < n; ++i) {
    p = polygon[i], x1 = p[0], y1 = p[1];
    if (y1 > y !== y0 > y && x < (x0 - x1) * (y - y1) / (y0 - y1) + x1) inside = !inside;
    x0 = x1, y0 = y1;
  }

  return inside;
}
},{}],"node_modules/d3-polygon/src/length.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(polygon) {
  var i = -1,
      n = polygon.length,
      b = polygon[n - 1],
      xa,
      ya,
      xb = b[0],
      yb = b[1],
      perimeter = 0;

  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.hypot(xa, ya);
  }

  return perimeter;
}
},{}],"node_modules/d3-polygon/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "polygonArea", {
  enumerable: true,
  get: function () {
    return _area.default;
  }
});
Object.defineProperty(exports, "polygonCentroid", {
  enumerable: true,
  get: function () {
    return _centroid.default;
  }
});
Object.defineProperty(exports, "polygonHull", {
  enumerable: true,
  get: function () {
    return _hull.default;
  }
});
Object.defineProperty(exports, "polygonContains", {
  enumerable: true,
  get: function () {
    return _contains.default;
  }
});
Object.defineProperty(exports, "polygonLength", {
  enumerable: true,
  get: function () {
    return _length.default;
  }
});

var _area = _interopRequireDefault(require("./area.js"));

var _centroid = _interopRequireDefault(require("./centroid.js"));

var _hull = _interopRequireDefault(require("./hull.js"));

var _contains = _interopRequireDefault(require("./contains.js"));

var _length = _interopRequireDefault(require("./length.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./area.js":"node_modules/d3-polygon/src/area.js","./centroid.js":"node_modules/d3-polygon/src/centroid.js","./hull.js":"node_modules/d3-polygon/src/hull.js","./contains.js":"node_modules/d3-polygon/src/contains.js","./length.js":"node_modules/d3-polygon/src/length.js"}],"node_modules/euclidean-distance/index.js":[function(require,module,exports) {
// http://en.wikipedia.org/wiki/Euclidean_distance#Three_dimensions

var distanceSquared = require('./squared')

module.exports = function (a, b) {
  return Math.sqrt(distanceSquared(a,b))
}

},{"./squared":"node_modules/euclidean-distance/squared.js"}],"src/util/mst.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMinimumSpanningTree = getMinimumSpanningTree;

const euclideanDist = require("euclidean-distance");

function getMinimumSpanningTree(items, distFunc, opt = {}) {
  const {
    maxSteps = Infinity
  } = opt;
  if (items.length <= 1) return [];
  distFunc = distFunc || euclideanDist;
  let indices = new Map();
  items.forEach((c, i) => {
    indices.set(c, i);
  });
  let connected = new Set(items.slice(0, 1));
  let remaining = new Set(items.slice(1));
  let connections = new Map();
  let steps = 0;
  let results = [];

  while (remaining.size != 0 && steps++ < maxSteps) {
    if (steps > maxSteps - 1) console.warn("Infinite loop");
    const result = findWithDistance(connected, remaining, distFunc);
    if (!result || !isFinite(result.distance)) continue;
    const {
      from,
      to,
      distance
    } = result;
    let keys = [indices.get(from), indices.get(to)];
    const indexList = keys.slice();
    keys.sort();
    const key = keys.join(":");

    if (!connections.has(key)) {
      connections.set(key, true);
      results.push({ ...result,
        indices: indexList,
        key
      });
      connected.add(to);
      remaining.delete(to);
    }
  }

  return results;
}

function findWithDistance(connected, remaining, distanceFn) {
  let minDist = Infinity;
  let from, candidate;

  for (let a of connected) {
    for (let b of remaining) {
      let dist = distanceFn(a, b);

      if (dist < minDist) {
        minDist = dist;
        from = a;
        candidate = b;
      }
    }
  }

  return {
    from,
    to: candidate,
    distance: minDist
  };
}
},{"euclidean-distance":"node_modules/euclidean-distance/index.js"}],"node_modules/robust-predicates/esm/util.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sum = sum;
exports.sum_three = sum_three;
exports.scale = scale;
exports.negate = negate;
exports.estimate = estimate;
exports.vec = vec;
exports.resulterrbound = exports.splitter = exports.epsilon = void 0;
const epsilon = 1.1102230246251565e-16;
exports.epsilon = epsilon;
const splitter = 134217729;
exports.splitter = splitter;
const resulterrbound = (3 + 8 * epsilon) * epsilon; // fast_expansion_sum_zeroelim routine from oritinal code

exports.resulterrbound = resulterrbound;

function sum(elen, e, flen, f, h) {
  let Q, Qnew, hh, bvirt;
  let enow = e[0];
  let fnow = f[0];
  let eindex = 0;
  let findex = 0;

  if (fnow > enow === fnow > -enow) {
    Q = enow;
    enow = e[++eindex];
  } else {
    Q = fnow;
    fnow = f[++findex];
  }

  let hindex = 0;

  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q;
      hh = Q - (Qnew - enow);
      enow = e[++eindex];
    } else {
      Qnew = fnow + Q;
      hh = Q - (Qnew - fnow);
      fnow = f[++findex];
    }

    Q = Qnew;

    if (hh !== 0) {
      h[hindex++] = hh;
    }

    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e[++eindex];
      } else {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
      }

      Q = Qnew;

      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
  }

  while (eindex < elen) {
    Qnew = Q + enow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (enow - bvirt);
    enow = e[++eindex];
    Q = Qnew;

    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }

  while (findex < flen) {
    Qnew = Q + fnow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f[++findex];
    Q = Qnew;

    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }

  if (Q !== 0 || hindex === 0) {
    h[hindex++] = Q;
  }

  return hindex;
}

function sum_three(alen, a, blen, b, clen, c, tmp, out) {
  return sum(sum(alen, a, blen, b, tmp), tmp, clen, c, out);
} // scale_expansion_zeroelim routine from oritinal code


function scale(elen, e, b, h) {
  let Q, sum, hh, product1, product0;
  let bvirt, c, ahi, alo, bhi, blo;
  c = splitter * b;
  bhi = c - (c - b);
  blo = b - bhi;
  let enow = e[0];
  Q = enow * b;
  c = splitter * enow;
  ahi = c - (c - enow);
  alo = enow - ahi;
  hh = alo * blo - (Q - ahi * bhi - alo * bhi - ahi * blo);
  let hindex = 0;

  if (hh !== 0) {
    h[hindex++] = hh;
  }

  for (let i = 1; i < elen; i++) {
    enow = e[i];
    product1 = enow * b;
    c = splitter * enow;
    ahi = c - (c - enow);
    alo = enow - ahi;
    product0 = alo * blo - (product1 - ahi * bhi - alo * bhi - ahi * blo);
    sum = Q + product0;
    bvirt = sum - Q;
    hh = Q - (sum - bvirt) + (product0 - bvirt);

    if (hh !== 0) {
      h[hindex++] = hh;
    }

    Q = product1 + sum;
    hh = sum - (Q - product1);

    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }

  if (Q !== 0 || hindex === 0) {
    h[hindex++] = Q;
  }

  return hindex;
}

function negate(elen, e) {
  for (let i = 0; i < elen; i++) e[i] = -e[i];

  return elen;
}

function estimate(elen, e) {
  let Q = e[0];

  for (let i = 1; i < elen; i++) Q += e[i];

  return Q;
}

function vec(n) {
  return new Float64Array(n);
}
},{}],"node_modules/robust-predicates/esm/orient2d.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.orient2d = orient2d;
exports.orient2dfast = orient2dfast;

var _util = require("./util.js");

const ccwerrboundA = (3 + 16 * _util.epsilon) * _util.epsilon;
const ccwerrboundB = (2 + 12 * _util.epsilon) * _util.epsilon;
const ccwerrboundC = (9 + 64 * _util.epsilon) * _util.epsilon * _util.epsilon;
const B = (0, _util.vec)(4);
const C1 = (0, _util.vec)(8);
const C2 = (0, _util.vec)(12);
const D = (0, _util.vec)(16);
const u = (0, _util.vec)(4);

function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;

  let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;

  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c = _util.splitter * acx;
  ahi = c - (c - acx);
  alo = acx - ahi;
  c = _util.splitter * bcy;
  bhi = c - (c - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcx;
  c = _util.splitter * acy;
  ahi = c - (c - acy);
  alo = acy - ahi;
  c = _util.splitter * bcx;
  bhi = c - (c - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  B[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  B[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  B[2] = _j - (u3 - bvirt) + (_i - bvirt);
  B[3] = u3;
  let det = (0, _util.estimate)(4, B);
  let errbound = ccwerrboundB * detsum;

  if (det >= errbound || -det >= errbound) {
    return det;
  }

  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);

  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }

  errbound = ccwerrboundC * detsum + _util.resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound) return det;
  s1 = acxtail * bcy;
  c = _util.splitter * acxtail;
  ahi = c - (c - acxtail);
  alo = acxtail - ahi;
  c = _util.splitter * bcy;
  bhi = c - (c - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcx;
  c = _util.splitter * acytail;
  ahi = c - (c - acytail);
  alo = acytail - ahi;
  c = _util.splitter * bcx;
  bhi = c - (c - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  u[2] = _j - (u3 - bvirt) + (_i - bvirt);
  u[3] = u3;
  const C1len = (0, _util.sum)(4, B, 4, u, C1);
  s1 = acx * bcytail;
  c = _util.splitter * acx;
  ahi = c - (c - acx);
  alo = acx - ahi;
  c = _util.splitter * bcytail;
  bhi = c - (c - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcxtail;
  c = _util.splitter * acy;
  ahi = c - (c - acy);
  alo = acy - ahi;
  c = _util.splitter * bcxtail;
  bhi = c - (c - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  u[2] = _j - (u3 - bvirt) + (_i - bvirt);
  u[3] = u3;
  const C2len = (0, _util.sum)(C1len, C1, 4, u, C2);
  s1 = acxtail * bcytail;
  c = _util.splitter * acxtail;
  ahi = c - (c - acxtail);
  alo = acxtail - ahi;
  c = _util.splitter * bcytail;
  bhi = c - (c - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcxtail;
  c = _util.splitter * acytail;
  ahi = c - (c - acytail);
  alo = acytail - ahi;
  c = _util.splitter * bcxtail;
  bhi = c - (c - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  u[2] = _j - (u3 - bvirt) + (_i - bvirt);
  u[3] = u3;
  const Dlen = (0, _util.sum)(C2len, C2, 4, u, D);
  return D[Dlen - 1];
}

function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  if (detleft === 0 || detright === 0 || detleft > 0 !== detright > 0) return det;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum) return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}

function orient2dfast(ax, ay, bx, by, cx, cy) {
  return (ay - cy) * (bx - cx) - (ax - cx) * (by - cy);
}
},{"./util.js":"node_modules/robust-predicates/esm/util.js"}],"node_modules/robust-predicates/esm/orient3d.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.orient3d = orient3d;
exports.orient3dfast = orient3dfast;

var _util = require("./util.js");

const o3derrboundA = (7 + 56 * _util.epsilon) * _util.epsilon;
const o3derrboundB = (3 + 28 * _util.epsilon) * _util.epsilon;
const o3derrboundC = (26 + 288 * _util.epsilon) * _util.epsilon * _util.epsilon;
const bc = (0, _util.vec)(4);
const ca = (0, _util.vec)(4);
const ab = (0, _util.vec)(4);
const at_b = (0, _util.vec)(4);
const at_c = (0, _util.vec)(4);
const bt_c = (0, _util.vec)(4);
const bt_a = (0, _util.vec)(4);
const ct_a = (0, _util.vec)(4);
const ct_b = (0, _util.vec)(4);
const bct = (0, _util.vec)(8);
const cat = (0, _util.vec)(8);
const abt = (0, _util.vec)(8);
const u = (0, _util.vec)(4);

const _8 = (0, _util.vec)(8);

const _8b = (0, _util.vec)(8);

const _16 = (0, _util.vec)(8);

const _12 = (0, _util.vec)(12);

let fin = (0, _util.vec)(192);
let fin2 = (0, _util.vec)(192);

function finadd(finlen, alen, a) {
  finlen = (0, _util.sum)(finlen, fin, alen, a, fin2);
  const tmp = fin;
  fin = fin2;
  fin2 = tmp;
  return finlen;
}

function tailinit(xtail, ytail, ax, ay, bx, by, a, b) {
  let bvirt, c, ahi, alo, bhi, blo, _i, _j, _k, _0, s1, s0, t1, t0, u3, negate;

  if (xtail === 0) {
    if (ytail === 0) {
      a[0] = 0;
      b[0] = 0;
      return 1;
    } else {
      negate = -ytail;
      s1 = negate * ax;
      c = _util.splitter * negate;
      ahi = c - (c - negate);
      alo = negate - ahi;
      c = _util.splitter * ax;
      bhi = c - (c - ax);
      blo = ax - bhi;
      a[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      a[1] = s1;
      s1 = ytail * bx;
      c = _util.splitter * ytail;
      ahi = c - (c - ytail);
      alo = ytail - ahi;
      c = _util.splitter * bx;
      bhi = c - (c - bx);
      blo = bx - bhi;
      b[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      b[1] = s1;
      return 2;
    }
  } else {
    if (ytail === 0) {
      s1 = xtail * ay;
      c = _util.splitter * xtail;
      ahi = c - (c - xtail);
      alo = xtail - ahi;
      c = _util.splitter * ay;
      bhi = c - (c - ay);
      blo = ay - bhi;
      a[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      a[1] = s1;
      negate = -xtail;
      s1 = negate * by;
      c = _util.splitter * negate;
      ahi = c - (c - negate);
      alo = negate - ahi;
      c = _util.splitter * by;
      bhi = c - (c - by);
      blo = by - bhi;
      b[0] = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      b[1] = s1;
      return 2;
    } else {
      s1 = xtail * ay;
      c = _util.splitter * xtail;
      ahi = c - (c - xtail);
      alo = xtail - ahi;
      c = _util.splitter * ay;
      bhi = c - (c - ay);
      blo = ay - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = ytail * ax;
      c = _util.splitter * ytail;
      ahi = c - (c - ytail);
      alo = ytail - ahi;
      c = _util.splitter * ax;
      bhi = c - (c - ax);
      blo = ax - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      a[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      a[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u3 = _j + _i;
      bvirt = u3 - _j;
      a[2] = _j - (u3 - bvirt) + (_i - bvirt);
      a[3] = u3;
      s1 = ytail * bx;
      c = _util.splitter * ytail;
      ahi = c - (c - ytail);
      alo = ytail - ahi;
      c = _util.splitter * bx;
      bhi = c - (c - bx);
      blo = bx - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = xtail * by;
      c = _util.splitter * xtail;
      ahi = c - (c - xtail);
      alo = xtail - ahi;
      c = _util.splitter * by;
      bhi = c - (c - by);
      blo = by - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      b[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      b[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u3 = _j + _i;
      bvirt = u3 - _j;
      b[2] = _j - (u3 - bvirt) + (_i - bvirt);
      b[3] = u3;
      return 4;
    }
  }
}

function tailadd(finlen, a, b, k, z) {
  let bvirt, c, ahi, alo, bhi, blo, _i, _j, _k, _0, s1, s0, u3;

  s1 = a * b;
  c = _util.splitter * a;
  ahi = c - (c - a);
  alo = a - ahi;
  c = _util.splitter * b;
  bhi = c - (c - b);
  blo = b - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  c = _util.splitter * k;
  bhi = c - (c - k);
  blo = k - bhi;
  _i = s0 * k;
  c = _util.splitter * s0;
  ahi = c - (c - s0);
  alo = s0 - ahi;
  u[0] = alo * blo - (_i - ahi * bhi - alo * bhi - ahi * blo);
  _j = s1 * k;
  c = _util.splitter * s1;
  ahi = c - (c - s1);
  alo = s1 - ahi;
  _0 = alo * blo - (_j - ahi * bhi - alo * bhi - ahi * blo);
  _k = _i + _0;
  bvirt = _k - _i;
  u[1] = _i - (_k - bvirt) + (_0 - bvirt);
  u3 = _j + _k;
  u[2] = _k - (u3 - _j);
  u[3] = u3;
  finlen = finadd(finlen, 4, u);

  if (z !== 0) {
    c = _util.splitter * z;
    bhi = c - (c - z);
    blo = z - bhi;
    _i = s0 * z;
    c = _util.splitter * s0;
    ahi = c - (c - s0);
    alo = s0 - ahi;
    u[0] = alo * blo - (_i - ahi * bhi - alo * bhi - ahi * blo);
    _j = s1 * z;
    c = _util.splitter * s1;
    ahi = c - (c - s1);
    alo = s1 - ahi;
    _0 = alo * blo - (_j - ahi * bhi - alo * bhi - ahi * blo);
    _k = _i + _0;
    bvirt = _k - _i;
    u[1] = _i - (_k - bvirt) + (_0 - bvirt);
    u3 = _j + _k;
    u[2] = _k - (u3 - _j);
    u[3] = u3;
    finlen = finadd(finlen, 4, u);
  }

  return finlen;
}

function orient3dadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, permanent) {
  let finlen;
  let adxtail, bdxtail, cdxtail;
  let adytail, bdytail, cdytail;
  let adztail, bdztail, cdztail;

  let bvirt, c, ahi, alo, bhi, blo, _i, _j, _k, _0, s1, s0, t1, t0, u3;

  const adx = ax - dx;
  const bdx = bx - dx;
  const cdx = cx - dx;
  const ady = ay - dy;
  const bdy = by - dy;
  const cdy = cy - dy;
  const adz = az - dz;
  const bdz = bz - dz;
  const cdz = cz - dz;
  s1 = bdx * cdy;
  c = _util.splitter * bdx;
  ahi = c - (c - bdx);
  alo = bdx - ahi;
  c = _util.splitter * cdy;
  bhi = c - (c - cdy);
  blo = cdy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = cdx * bdy;
  c = _util.splitter * cdx;
  ahi = c - (c - cdx);
  alo = cdx - ahi;
  c = _util.splitter * bdy;
  bhi = c - (c - bdy);
  blo = bdy - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  bc[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  bc[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  bc[2] = _j - (u3 - bvirt) + (_i - bvirt);
  bc[3] = u3;
  s1 = cdx * ady;
  c = _util.splitter * cdx;
  ahi = c - (c - cdx);
  alo = cdx - ahi;
  c = _util.splitter * ady;
  bhi = c - (c - ady);
  blo = ady - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = adx * cdy;
  c = _util.splitter * adx;
  ahi = c - (c - adx);
  alo = adx - ahi;
  c = _util.splitter * cdy;
  bhi = c - (c - cdy);
  blo = cdy - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  ca[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  ca[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  ca[2] = _j - (u3 - bvirt) + (_i - bvirt);
  ca[3] = u3;
  s1 = adx * bdy;
  c = _util.splitter * adx;
  ahi = c - (c - adx);
  alo = adx - ahi;
  c = _util.splitter * bdy;
  bhi = c - (c - bdy);
  blo = bdy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = bdx * ady;
  c = _util.splitter * bdx;
  ahi = c - (c - bdx);
  alo = bdx - ahi;
  c = _util.splitter * ady;
  bhi = c - (c - ady);
  blo = ady - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  ab[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  ab[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  ab[2] = _j - (u3 - bvirt) + (_i - bvirt);
  ab[3] = u3;
  finlen = (0, _util.sum)((0, _util.sum)((0, _util.scale)(4, bc, adz, _8), _8, (0, _util.scale)(4, ca, bdz, _8b), _8b, _16), _16, (0, _util.scale)(4, ab, cdz, _8), _8, fin);
  let det = (0, _util.estimate)(finlen, fin);
  let errbound = o3derrboundB * permanent;

  if (det >= errbound || -det >= errbound) {
    return det;
  }

  bvirt = ax - adx;
  adxtail = ax - (adx + bvirt) + (bvirt - dx);
  bvirt = bx - bdx;
  bdxtail = bx - (bdx + bvirt) + (bvirt - dx);
  bvirt = cx - cdx;
  cdxtail = cx - (cdx + bvirt) + (bvirt - dx);
  bvirt = ay - ady;
  adytail = ay - (ady + bvirt) + (bvirt - dy);
  bvirt = by - bdy;
  bdytail = by - (bdy + bvirt) + (bvirt - dy);
  bvirt = cy - cdy;
  cdytail = cy - (cdy + bvirt) + (bvirt - dy);
  bvirt = az - adz;
  adztail = az - (adz + bvirt) + (bvirt - dz);
  bvirt = bz - bdz;
  bdztail = bz - (bdz + bvirt) + (bvirt - dz);
  bvirt = cz - cdz;
  cdztail = cz - (cdz + bvirt) + (bvirt - dz);

  if (adxtail === 0 && bdxtail === 0 && cdxtail === 0 && adytail === 0 && bdytail === 0 && cdytail === 0 && adztail === 0 && bdztail === 0 && cdztail === 0) {
    return det;
  }

  errbound = o3derrboundC * permanent + _util.resulterrbound * Math.abs(det);
  det += adz * (bdx * cdytail + cdy * bdxtail - (bdy * cdxtail + cdx * bdytail)) + adztail * (bdx * cdy - bdy * cdx) + bdz * (cdx * adytail + ady * cdxtail - (cdy * adxtail + adx * cdytail)) + bdztail * (cdx * ady - cdy * adx) + cdz * (adx * bdytail + bdy * adxtail - (ady * bdxtail + bdx * adytail)) + cdztail * (adx * bdy - ady * bdx);

  if (det >= errbound || -det >= errbound) {
    return det;
  }

  const at_len = tailinit(adxtail, adytail, bdx, bdy, cdx, cdy, at_b, at_c);
  const bt_len = tailinit(bdxtail, bdytail, cdx, cdy, adx, ady, bt_c, bt_a);
  const ct_len = tailinit(cdxtail, cdytail, adx, ady, bdx, bdy, ct_a, ct_b);
  const bctlen = (0, _util.sum)(bt_len, bt_c, ct_len, ct_b, bct);
  finlen = finadd(finlen, (0, _util.scale)(bctlen, bct, adz, _16), _16);
  const catlen = (0, _util.sum)(ct_len, ct_a, at_len, at_c, cat);
  finlen = finadd(finlen, (0, _util.scale)(catlen, cat, bdz, _16), _16);
  const abtlen = (0, _util.sum)(at_len, at_b, bt_len, bt_a, abt);
  finlen = finadd(finlen, (0, _util.scale)(abtlen, abt, cdz, _16), _16);

  if (adztail !== 0) {
    finlen = finadd(finlen, (0, _util.scale)(4, bc, adztail, _12), _12);
    finlen = finadd(finlen, (0, _util.scale)(bctlen, bct, adztail, _16), _16);
  }

  if (bdztail !== 0) {
    finlen = finadd(finlen, (0, _util.scale)(4, ca, bdztail, _12), _12);
    finlen = finadd(finlen, (0, _util.scale)(catlen, cat, bdztail, _16), _16);
  }

  if (cdztail !== 0) {
    finlen = finadd(finlen, (0, _util.scale)(4, ab, cdztail, _12), _12);
    finlen = finadd(finlen, (0, _util.scale)(abtlen, abt, cdztail, _16), _16);
  }

  if (adxtail !== 0) {
    if (bdytail !== 0) {
      finlen = tailadd(finlen, adxtail, bdytail, cdz, cdztail);
    }

    if (cdytail !== 0) {
      finlen = tailadd(finlen, -adxtail, cdytail, bdz, bdztail);
    }
  }

  if (bdxtail !== 0) {
    if (cdytail !== 0) {
      finlen = tailadd(finlen, bdxtail, cdytail, adz, adztail);
    }

    if (adytail !== 0) {
      finlen = tailadd(finlen, -bdxtail, adytail, cdz, cdztail);
    }
  }

  if (cdxtail !== 0) {
    if (adytail !== 0) {
      finlen = tailadd(finlen, cdxtail, adytail, bdz, bdztail);
    }

    if (bdytail !== 0) {
      finlen = tailadd(finlen, -cdxtail, bdytail, adz, adztail);
    }
  }

  return fin[finlen - 1];
}

function orient3d(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz) {
  const adx = ax - dx;
  const bdx = bx - dx;
  const cdx = cx - dx;
  const ady = ay - dy;
  const bdy = by - dy;
  const cdy = cy - dy;
  const adz = az - dz;
  const bdz = bz - dz;
  const cdz = cz - dz;
  const bdxcdy = bdx * cdy;
  const cdxbdy = cdx * bdy;
  const cdxady = cdx * ady;
  const adxcdy = adx * cdy;
  const adxbdy = adx * bdy;
  const bdxady = bdx * ady;
  const det = adz * (bdxcdy - cdxbdy) + bdz * (cdxady - adxcdy) + cdz * (adxbdy - bdxady);
  const permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz) + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz) + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz);
  const errbound = o3derrboundA * permanent;

  if (det > errbound || -det > errbound) {
    return det;
  }

  return orient3dadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, permanent);
}

function orient3dfast(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz) {
  const adx = ax - dx;
  const bdx = bx - dx;
  const cdx = cx - dx;
  const ady = ay - dy;
  const bdy = by - dy;
  const cdy = cy - dy;
  const adz = az - dz;
  const bdz = bz - dz;
  const cdz = cz - dz;
  return adx * (bdy * cdz - bdz * cdy) + bdx * (cdy * adz - cdz * ady) + cdx * (ady * bdz - adz * bdy);
}
},{"./util.js":"node_modules/robust-predicates/esm/util.js"}],"node_modules/robust-predicates/esm/incircle.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.incircle = incircle;
exports.incirclefast = incirclefast;

var _util = require("./util.js");

const iccerrboundA = (10 + 96 * _util.epsilon) * _util.epsilon;
const iccerrboundB = (4 + 48 * _util.epsilon) * _util.epsilon;
const iccerrboundC = (44 + 576 * _util.epsilon) * _util.epsilon * _util.epsilon;
const bc = (0, _util.vec)(4);
const ca = (0, _util.vec)(4);
const ab = (0, _util.vec)(4);
const aa = (0, _util.vec)(4);
const bb = (0, _util.vec)(4);
const cc = (0, _util.vec)(4);
const u = (0, _util.vec)(4);
const v = (0, _util.vec)(4);
const axtbc = (0, _util.vec)(8);
const aytbc = (0, _util.vec)(8);
const bxtca = (0, _util.vec)(8);
const bytca = (0, _util.vec)(8);
const cxtab = (0, _util.vec)(8);
const cytab = (0, _util.vec)(8);
const abt = (0, _util.vec)(8);
const bct = (0, _util.vec)(8);
const cat = (0, _util.vec)(8);
const abtt = (0, _util.vec)(4);
const bctt = (0, _util.vec)(4);
const catt = (0, _util.vec)(4);

const _8 = (0, _util.vec)(8);

const _16 = (0, _util.vec)(16);

const _16b = (0, _util.vec)(16);

const _16c = (0, _util.vec)(16);

const _32 = (0, _util.vec)(32);

const _32b = (0, _util.vec)(32);

const _48 = (0, _util.vec)(48);

const _64 = (0, _util.vec)(64);

let fin = (0, _util.vec)(1152);
let fin2 = (0, _util.vec)(1152);

function finadd(finlen, a, alen) {
  finlen = (0, _util.sum)(finlen, fin, a, alen, fin2);
  const tmp = fin;
  fin = fin2;
  fin2 = tmp;
  return finlen;
}

function incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent) {
  let finlen;
  let adxtail, bdxtail, cdxtail, adytail, bdytail, cdytail;
  let axtbclen, aytbclen, bxtcalen, bytcalen, cxtablen, cytablen;
  let abtlen, bctlen, catlen;
  let abttlen, bcttlen, cattlen;
  let n1, n0;

  let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;

  const adx = ax - dx;
  const bdx = bx - dx;
  const cdx = cx - dx;
  const ady = ay - dy;
  const bdy = by - dy;
  const cdy = cy - dy;
  s1 = bdx * cdy;
  c = _util.splitter * bdx;
  ahi = c - (c - bdx);
  alo = bdx - ahi;
  c = _util.splitter * cdy;
  bhi = c - (c - cdy);
  blo = cdy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = cdx * bdy;
  c = _util.splitter * cdx;
  ahi = c - (c - cdx);
  alo = cdx - ahi;
  c = _util.splitter * bdy;
  bhi = c - (c - bdy);
  blo = bdy - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  bc[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  bc[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  bc[2] = _j - (u3 - bvirt) + (_i - bvirt);
  bc[3] = u3;
  s1 = cdx * ady;
  c = _util.splitter * cdx;
  ahi = c - (c - cdx);
  alo = cdx - ahi;
  c = _util.splitter * ady;
  bhi = c - (c - ady);
  blo = ady - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = adx * cdy;
  c = _util.splitter * adx;
  ahi = c - (c - adx);
  alo = adx - ahi;
  c = _util.splitter * cdy;
  bhi = c - (c - cdy);
  blo = cdy - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  ca[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  ca[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  ca[2] = _j - (u3 - bvirt) + (_i - bvirt);
  ca[3] = u3;
  s1 = adx * bdy;
  c = _util.splitter * adx;
  ahi = c - (c - adx);
  alo = adx - ahi;
  c = _util.splitter * bdy;
  bhi = c - (c - bdy);
  blo = bdy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = bdx * ady;
  c = _util.splitter * bdx;
  ahi = c - (c - bdx);
  alo = bdx - ahi;
  c = _util.splitter * ady;
  bhi = c - (c - ady);
  blo = ady - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  ab[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  ab[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  ab[2] = _j - (u3 - bvirt) + (_i - bvirt);
  ab[3] = u3;
  finlen = (0, _util.sum)((0, _util.sum)((0, _util.sum)((0, _util.scale)((0, _util.scale)(4, bc, adx, _8), _8, adx, _16), _16, (0, _util.scale)((0, _util.scale)(4, bc, ady, _8), _8, ady, _16b), _16b, _32), _32, (0, _util.sum)((0, _util.scale)((0, _util.scale)(4, ca, bdx, _8), _8, bdx, _16), _16, (0, _util.scale)((0, _util.scale)(4, ca, bdy, _8), _8, bdy, _16b), _16b, _32b), _32b, _64), _64, (0, _util.sum)((0, _util.scale)((0, _util.scale)(4, ab, cdx, _8), _8, cdx, _16), _16, (0, _util.scale)((0, _util.scale)(4, ab, cdy, _8), _8, cdy, _16b), _16b, _32), _32, fin);
  let det = (0, _util.estimate)(finlen, fin);
  let errbound = iccerrboundB * permanent;

  if (det >= errbound || -det >= errbound) {
    return det;
  }

  bvirt = ax - adx;
  adxtail = ax - (adx + bvirt) + (bvirt - dx);
  bvirt = ay - ady;
  adytail = ay - (ady + bvirt) + (bvirt - dy);
  bvirt = bx - bdx;
  bdxtail = bx - (bdx + bvirt) + (bvirt - dx);
  bvirt = by - bdy;
  bdytail = by - (bdy + bvirt) + (bvirt - dy);
  bvirt = cx - cdx;
  cdxtail = cx - (cdx + bvirt) + (bvirt - dx);
  bvirt = cy - cdy;
  cdytail = cy - (cdy + bvirt) + (bvirt - dy);

  if (adxtail === 0 && bdxtail === 0 && cdxtail === 0 && adytail === 0 && bdytail === 0 && cdytail === 0) {
    return det;
  }

  errbound = iccerrboundC * permanent + _util.resulterrbound * Math.abs(det);
  det += (adx * adx + ady * ady) * (bdx * cdytail + cdy * bdxtail - (bdy * cdxtail + cdx * bdytail)) + 2 * (adx * adxtail + ady * adytail) * (bdx * cdy - bdy * cdx) + ((bdx * bdx + bdy * bdy) * (cdx * adytail + ady * cdxtail - (cdy * adxtail + adx * cdytail)) + 2 * (bdx * bdxtail + bdy * bdytail) * (cdx * ady - cdy * adx)) + ((cdx * cdx + cdy * cdy) * (adx * bdytail + bdy * adxtail - (ady * bdxtail + bdx * adytail)) + 2 * (cdx * cdxtail + cdy * cdytail) * (adx * bdy - ady * bdx));

  if (det >= errbound || -det >= errbound) {
    return det;
  }

  if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {
    s1 = adx * adx;
    c = _util.splitter * adx;
    ahi = c - (c - adx);
    alo = adx - ahi;
    s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
    t1 = ady * ady;
    c = _util.splitter * ady;
    ahi = c - (c - ady);
    alo = ady - ahi;
    t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
    _i = s0 + t0;
    bvirt = _i - s0;
    aa[0] = s0 - (_i - bvirt) + (t0 - bvirt);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 + t1;
    bvirt = _i - _0;
    aa[1] = _0 - (_i - bvirt) + (t1 - bvirt);
    u3 = _j + _i;
    bvirt = u3 - _j;
    aa[2] = _j - (u3 - bvirt) + (_i - bvirt);
    aa[3] = u3;
  }

  if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {
    s1 = bdx * bdx;
    c = _util.splitter * bdx;
    ahi = c - (c - bdx);
    alo = bdx - ahi;
    s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
    t1 = bdy * bdy;
    c = _util.splitter * bdy;
    ahi = c - (c - bdy);
    alo = bdy - ahi;
    t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
    _i = s0 + t0;
    bvirt = _i - s0;
    bb[0] = s0 - (_i - bvirt) + (t0 - bvirt);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 + t1;
    bvirt = _i - _0;
    bb[1] = _0 - (_i - bvirt) + (t1 - bvirt);
    u3 = _j + _i;
    bvirt = u3 - _j;
    bb[2] = _j - (u3 - bvirt) + (_i - bvirt);
    bb[3] = u3;
  }

  if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {
    s1 = cdx * cdx;
    c = _util.splitter * cdx;
    ahi = c - (c - cdx);
    alo = cdx - ahi;
    s0 = alo * alo - (s1 - ahi * ahi - (ahi + ahi) * alo);
    t1 = cdy * cdy;
    c = _util.splitter * cdy;
    ahi = c - (c - cdy);
    alo = cdy - ahi;
    t0 = alo * alo - (t1 - ahi * ahi - (ahi + ahi) * alo);
    _i = s0 + t0;
    bvirt = _i - s0;
    cc[0] = s0 - (_i - bvirt) + (t0 - bvirt);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 + t1;
    bvirt = _i - _0;
    cc[1] = _0 - (_i - bvirt) + (t1 - bvirt);
    u3 = _j + _i;
    bvirt = u3 - _j;
    cc[2] = _j - (u3 - bvirt) + (_i - bvirt);
    cc[3] = u3;
  }

  if (adxtail !== 0) {
    axtbclen = (0, _util.scale)(4, bc, adxtail, axtbc);
    finlen = finadd(finlen, (0, _util.sum_three)((0, _util.scale)(axtbclen, axtbc, 2 * adx, _16), _16, (0, _util.scale)((0, _util.scale)(4, cc, adxtail, _8), _8, bdy, _16b), _16b, (0, _util.scale)((0, _util.scale)(4, bb, adxtail, _8), _8, -cdy, _16c), _16c, _32, _48), _48);
  }

  if (adytail !== 0) {
    aytbclen = (0, _util.scale)(4, bc, adytail, aytbc);
    finlen = finadd(finlen, (0, _util.sum_three)((0, _util.scale)(aytbclen, aytbc, 2 * ady, _16), _16, (0, _util.scale)((0, _util.scale)(4, bb, adytail, _8), _8, cdx, _16b), _16b, (0, _util.scale)((0, _util.scale)(4, cc, adytail, _8), _8, -bdx, _16c), _16c, _32, _48), _48);
  }

  if (bdxtail !== 0) {
    bxtcalen = (0, _util.scale)(4, ca, bdxtail, bxtca);
    finlen = finadd(finlen, (0, _util.sum_three)((0, _util.scale)(bxtcalen, bxtca, 2 * bdx, _16), _16, (0, _util.scale)((0, _util.scale)(4, aa, bdxtail, _8), _8, cdy, _16b), _16b, (0, _util.scale)((0, _util.scale)(4, cc, bdxtail, _8), _8, -ady, _16c), _16c, _32, _48), _48);
  }

  if (bdytail !== 0) {
    bytcalen = (0, _util.scale)(4, ca, bdytail, bytca);
    finlen = finadd(finlen, (0, _util.sum_three)((0, _util.scale)(bytcalen, bytca, 2 * bdy, _16), _16, (0, _util.scale)((0, _util.scale)(4, cc, bdytail, _8), _8, adx, _16b), _16b, (0, _util.scale)((0, _util.scale)(4, aa, bdytail, _8), _8, -cdx, _16c), _16c, _32, _48), _48);
  }

  if (cdxtail !== 0) {
    cxtablen = (0, _util.scale)(4, ab, cdxtail, cxtab);
    finlen = finadd(finlen, (0, _util.sum_three)((0, _util.scale)(cxtablen, cxtab, 2 * cdx, _16), _16, (0, _util.scale)((0, _util.scale)(4, bb, cdxtail, _8), _8, ady, _16b), _16b, (0, _util.scale)((0, _util.scale)(4, aa, cdxtail, _8), _8, -bdy, _16c), _16c, _32, _48), _48);
  }

  if (cdytail !== 0) {
    cytablen = (0, _util.scale)(4, ab, cdytail, cytab);
    finlen = finadd(finlen, (0, _util.sum_three)((0, _util.scale)(cytablen, cytab, 2 * cdy, _16), _16, (0, _util.scale)((0, _util.scale)(4, aa, cdytail, _8), _8, bdx, _16b), _16b, (0, _util.scale)((0, _util.scale)(4, bb, cdytail, _8), _8, -adx, _16c), _16c, _32, _48), _48);
  }

  if (adxtail !== 0 || adytail !== 0) {
    if (bdxtail !== 0 || bdytail !== 0 || cdxtail !== 0 || cdytail !== 0) {
      s1 = bdxtail * cdy;
      c = _util.splitter * bdxtail;
      ahi = c - (c - bdxtail);
      alo = bdxtail - ahi;
      c = _util.splitter * cdy;
      bhi = c - (c - cdy);
      blo = cdy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = bdx * cdytail;
      c = _util.splitter * bdx;
      ahi = c - (c - bdx);
      alo = bdx - ahi;
      c = _util.splitter * cdytail;
      bhi = c - (c - cdytail);
      blo = cdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      u[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      u[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u3 = _j + _i;
      bvirt = u3 - _j;
      u[2] = _j - (u3 - bvirt) + (_i - bvirt);
      u[3] = u3;
      s1 = cdxtail * -bdy;
      c = _util.splitter * cdxtail;
      ahi = c - (c - cdxtail);
      alo = cdxtail - ahi;
      c = _util.splitter * -bdy;
      bhi = c - (c - -bdy);
      blo = -bdy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = cdx * -bdytail;
      c = _util.splitter * cdx;
      ahi = c - (c - cdx);
      alo = cdx - ahi;
      c = _util.splitter * -bdytail;
      bhi = c - (c - -bdytail);
      blo = -bdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      v[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      v[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u3 = _j + _i;
      bvirt = u3 - _j;
      v[2] = _j - (u3 - bvirt) + (_i - bvirt);
      v[3] = u3;
      bctlen = (0, _util.sum)(4, u, 4, v, bct);
      s1 = bdxtail * cdytail;
      c = _util.splitter * bdxtail;
      ahi = c - (c - bdxtail);
      alo = bdxtail - ahi;
      c = _util.splitter * cdytail;
      bhi = c - (c - cdytail);
      blo = cdytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = cdxtail * bdytail;
      c = _util.splitter * cdxtail;
      ahi = c - (c - cdxtail);
      alo = cdxtail - ahi;
      c = _util.splitter * bdytail;
      bhi = c - (c - bdytail);
      blo = bdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      bctt[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      bctt[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u3 = _j + _i;
      bvirt = u3 - _j;
      bctt[2] = _j - (u3 - bvirt) + (_i - bvirt);
      bctt[3] = u3;
      bcttlen = 4;
    } else {
      bct[0] = 0;
      bctlen = 1;
      bctt[0] = 0;
      bcttlen = 1;
    }

    if (adxtail !== 0) {
      const len = (0, _util.scale)(bctlen, bct, adxtail, _16c);
      finlen = finadd(finlen, (0, _util.sum)((0, _util.scale)(axtbclen, axtbc, adxtail, _16), _16, (0, _util.scale)(len, _16c, 2 * adx, _32), _32, _48), _48);
      const len2 = (0, _util.scale)(bcttlen, bctt, adxtail, _8);
      finlen = finadd(finlen, (0, _util.sum_three)((0, _util.scale)(len2, _8, 2 * adx, _16), _16, (0, _util.scale)(len2, _8, adxtail, _16b), _16b, (0, _util.scale)(len, _16c, adxtail, _32), _32, _32b, _64), _64);

      if (bdytail !== 0) {
        finlen = finadd(finlen, (0, _util.scale)((0, _util.scale)(4, cc, adxtail, _8), _8, bdytail, _16), _16);
      }

      if (cdytail !== 0) {
        finlen = finadd(finlen, (0, _util.scale)((0, _util.scale)(4, bb, -adxtail, _8), _8, cdytail, _16), _16);
      }
    }

    if (adytail !== 0) {
      const len = (0, _util.scale)(bctlen, bct, adytail, _16c);
      finlen = finadd(finlen, (0, _util.sum)((0, _util.scale)(aytbclen, aytbc, adytail, _16), _16, (0, _util.scale)(len, _16c, 2 * ady, _32), _32, _48), _48);
      const len2 = (0, _util.scale)(bcttlen, bctt, adytail, _8);
      finlen = finadd(finlen, (0, _util.sum_three)((0, _util.scale)(len2, _8, 2 * ady, _16), _16, (0, _util.scale)(len2, _8, adytail, _16b), _16b, (0, _util.scale)(len, _16c, adytail, _32), _32, _32b, _64), _64);
    }
  }

  if (bdxtail !== 0 || bdytail !== 0) {
    if (cdxtail !== 0 || cdytail !== 0 || adxtail !== 0 || adytail !== 0) {
      s1 = cdxtail * ady;
      c = _util.splitter * cdxtail;
      ahi = c - (c - cdxtail);
      alo = cdxtail - ahi;
      c = _util.splitter * ady;
      bhi = c - (c - ady);
      blo = ady - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = cdx * adytail;
      c = _util.splitter * cdx;
      ahi = c - (c - cdx);
      alo = cdx - ahi;
      c = _util.splitter * adytail;
      bhi = c - (c - adytail);
      blo = adytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      u[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      u[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u3 = _j + _i;
      bvirt = u3 - _j;
      u[2] = _j - (u3 - bvirt) + (_i - bvirt);
      u[3] = u3;
      n1 = -cdy;
      n0 = -cdytail;
      s1 = adxtail * n1;
      c = _util.splitter * adxtail;
      ahi = c - (c - adxtail);
      alo = adxtail - ahi;
      c = _util.splitter * n1;
      bhi = c - (c - n1);
      blo = n1 - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = adx * n0;
      c = _util.splitter * adx;
      ahi = c - (c - adx);
      alo = adx - ahi;
      c = _util.splitter * n0;
      bhi = c - (c - n0);
      blo = n0 - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      v[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      v[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u3 = _j + _i;
      bvirt = u3 - _j;
      v[2] = _j - (u3 - bvirt) + (_i - bvirt);
      v[3] = u3;
      catlen = (0, _util.sum)(4, u, 4, v, cat);
      s1 = cdxtail * adytail;
      c = _util.splitter * cdxtail;
      ahi = c - (c - cdxtail);
      alo = cdxtail - ahi;
      c = _util.splitter * adytail;
      bhi = c - (c - adytail);
      blo = adytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = adxtail * cdytail;
      c = _util.splitter * adxtail;
      ahi = c - (c - adxtail);
      alo = adxtail - ahi;
      c = _util.splitter * cdytail;
      bhi = c - (c - cdytail);
      blo = cdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      catt[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      catt[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u3 = _j + _i;
      bvirt = u3 - _j;
      catt[2] = _j - (u3 - bvirt) + (_i - bvirt);
      catt[3] = u3;
      cattlen = 4;
    } else {
      cat[0] = 0;
      catlen = 1;
      catt[0] = 0;
      cattlen = 1;
    }

    if (bdxtail !== 0) {
      const len = (0, _util.scale)(catlen, cat, bdxtail, _16c);
      finlen = finadd(finlen, (0, _util.sum)((0, _util.scale)(bxtcalen, bxtca, bdxtail, _16), _16, (0, _util.scale)(len, _16c, 2 * bdx, _32), _32, _48), _48);
      const len2 = (0, _util.scale)(cattlen, catt, bdxtail, _8);
      finlen = finadd(finlen, (0, _util.sum_three)((0, _util.scale)(len2, _8, 2 * bdx, _16), _16, (0, _util.scale)(len2, _8, bdxtail, _16b), _16b, (0, _util.scale)(len, _16c, bdxtail, _32), _32, _32b, _64), _64);

      if (cdytail !== 0) {
        finlen = finadd(finlen, (0, _util.scale)((0, _util.scale)(4, aa, bdxtail, _8), _8, cdytail, _16), _16);
      }

      if (adytail !== 0) {
        finlen = finadd(finlen, (0, _util.scale)((0, _util.scale)(4, cc, -bdxtail, _8), _8, adytail, _16), _16);
      }
    }

    if (bdytail !== 0) {
      const len = (0, _util.scale)(catlen, cat, bdytail, _16c);
      finlen = finadd(finlen, (0, _util.sum)((0, _util.scale)(bytcalen, bytca, bdytail, _16), _16, (0, _util.scale)(len, _16c, 2 * bdy, _32), _32, _48), _48);
      const len2 = (0, _util.scale)(cattlen, catt, bdytail, _8);
      finlen = finadd(finlen, (0, _util.sum_three)((0, _util.scale)(len2, _8, 2 * bdy, _16), _16, (0, _util.scale)(len2, _8, bdytail, _16b), _16b, (0, _util.scale)(len, _16c, bdytail, _32), _32, _32b, _64), _64);
    }
  }

  if (cdxtail !== 0 || cdytail !== 0) {
    if (adxtail !== 0 || adytail !== 0 || bdxtail !== 0 || bdytail !== 0) {
      s1 = adxtail * bdy;
      c = _util.splitter * adxtail;
      ahi = c - (c - adxtail);
      alo = adxtail - ahi;
      c = _util.splitter * bdy;
      bhi = c - (c - bdy);
      blo = bdy - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = adx * bdytail;
      c = _util.splitter * adx;
      ahi = c - (c - adx);
      alo = adx - ahi;
      c = _util.splitter * bdytail;
      bhi = c - (c - bdytail);
      blo = bdytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      u[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      u[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u3 = _j + _i;
      bvirt = u3 - _j;
      u[2] = _j - (u3 - bvirt) + (_i - bvirt);
      u[3] = u3;
      n1 = -ady;
      n0 = -adytail;
      s1 = bdxtail * n1;
      c = _util.splitter * bdxtail;
      ahi = c - (c - bdxtail);
      alo = bdxtail - ahi;
      c = _util.splitter * n1;
      bhi = c - (c - n1);
      blo = n1 - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = bdx * n0;
      c = _util.splitter * bdx;
      ahi = c - (c - bdx);
      alo = bdx - ahi;
      c = _util.splitter * n0;
      bhi = c - (c - n0);
      blo = n0 - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 + t0;
      bvirt = _i - s0;
      v[0] = s0 - (_i - bvirt) + (t0 - bvirt);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 + t1;
      bvirt = _i - _0;
      v[1] = _0 - (_i - bvirt) + (t1 - bvirt);
      u3 = _j + _i;
      bvirt = u3 - _j;
      v[2] = _j - (u3 - bvirt) + (_i - bvirt);
      v[3] = u3;
      abtlen = (0, _util.sum)(4, u, 4, v, abt);
      s1 = adxtail * bdytail;
      c = _util.splitter * adxtail;
      ahi = c - (c - adxtail);
      alo = adxtail - ahi;
      c = _util.splitter * bdytail;
      bhi = c - (c - bdytail);
      blo = bdytail - bhi;
      s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
      t1 = bdxtail * adytail;
      c = _util.splitter * bdxtail;
      ahi = c - (c - bdxtail);
      alo = bdxtail - ahi;
      c = _util.splitter * adytail;
      bhi = c - (c - adytail);
      blo = adytail - bhi;
      t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
      _i = s0 - t0;
      bvirt = s0 - _i;
      abtt[0] = s0 - (_i + bvirt) + (bvirt - t0);
      _j = s1 + _i;
      bvirt = _j - s1;
      _0 = s1 - (_j - bvirt) + (_i - bvirt);
      _i = _0 - t1;
      bvirt = _0 - _i;
      abtt[1] = _0 - (_i + bvirt) + (bvirt - t1);
      u3 = _j + _i;
      bvirt = u3 - _j;
      abtt[2] = _j - (u3 - bvirt) + (_i - bvirt);
      abtt[3] = u3;
      abttlen = 4;
    } else {
      abt[0] = 0;
      abtlen = 1;
      abtt[0] = 0;
      abttlen = 1;
    }

    if (cdxtail !== 0) {
      const len = (0, _util.scale)(abtlen, abt, cdxtail, _16c);
      finlen = finadd(finlen, (0, _util.sum)((0, _util.scale)(cxtablen, cxtab, cdxtail, _16), _16, (0, _util.scale)(len, _16c, 2 * cdx, _32), _32, _48), _48);
      const len2 = (0, _util.scale)(abttlen, abtt, cdxtail, _8);
      finlen = finadd(finlen, (0, _util.sum_three)((0, _util.scale)(len2, _8, 2 * cdx, _16), _16, (0, _util.scale)(len2, _8, cdxtail, _16b), _16b, (0, _util.scale)(len, _16c, cdxtail, _32), _32, _32b, _64), _64);

      if (adytail !== 0) {
        finlen = finadd(finlen, (0, _util.scale)((0, _util.scale)(4, bb, cdxtail, _8), _8, adytail, _16), _16);
      }

      if (bdytail !== 0) {
        finlen = finadd(finlen, (0, _util.scale)((0, _util.scale)(4, aa, -cdxtail, _8), _8, bdytail, _16), _16);
      }
    }

    if (cdytail !== 0) {
      const len = (0, _util.scale)(abtlen, abt, cdytail, _16c);
      finlen = finadd(finlen, (0, _util.sum)((0, _util.scale)(cytablen, cytab, cdytail, _16), _16, (0, _util.scale)(len, _16c, 2 * cdy, _32), _32, _48), _48);
      const len2 = (0, _util.scale)(abttlen, abtt, cdytail, _8);
      finlen = finadd(finlen, (0, _util.sum_three)((0, _util.scale)(len2, _8, 2 * cdy, _16), _16, (0, _util.scale)(len2, _8, cdytail, _16b), _16b, (0, _util.scale)(len, _16c, cdytail, _32), _32, _32b, _64), _64);
    }
  }

  return fin[finlen - 1];
}

function incircle(ax, ay, bx, by, cx, cy, dx, dy) {
  const adx = ax - dx;
  const bdx = bx - dx;
  const cdx = cx - dx;
  const ady = ay - dy;
  const bdy = by - dy;
  const cdy = cy - dy;
  const bdxcdy = bdx * cdy;
  const cdxbdy = cdx * bdy;
  const alift = adx * adx + ady * ady;
  const cdxady = cdx * ady;
  const adxcdy = adx * cdy;
  const blift = bdx * bdx + bdy * bdy;
  const adxbdy = adx * bdy;
  const bdxady = bdx * ady;
  const clift = cdx * cdx + cdy * cdy;
  const det = alift * (bdxcdy - cdxbdy) + blift * (cdxady - adxcdy) + clift * (adxbdy - bdxady);
  const permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * alift + (Math.abs(cdxady) + Math.abs(adxcdy)) * blift + (Math.abs(adxbdy) + Math.abs(bdxady)) * clift;
  const errbound = iccerrboundA * permanent;

  if (det > errbound || -det > errbound) {
    return det;
  }

  return incircleadapt(ax, ay, bx, by, cx, cy, dx, dy, permanent);
}

function incirclefast(ax, ay, bx, by, cx, cy, dx, dy) {
  const adx = ax - dx;
  const ady = ay - dy;
  const bdx = bx - dx;
  const bdy = by - dy;
  const cdx = cx - dx;
  const cdy = cy - dy;
  const abdet = adx * bdy - bdx * ady;
  const bcdet = bdx * cdy - cdx * bdy;
  const cadet = cdx * ady - adx * cdy;
  const alift = adx * adx + ady * ady;
  const blift = bdx * bdx + bdy * bdy;
  const clift = cdx * cdx + cdy * cdy;
  return alift * bcdet + blift * cadet + clift * abdet;
}
},{"./util.js":"node_modules/robust-predicates/esm/util.js"}],"node_modules/robust-predicates/esm/insphere.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.insphere = insphere;
exports.inspherefast = inspherefast;

var _util = require("./util.js");

const isperrboundA = (16 + 224 * _util.epsilon) * _util.epsilon;
const isperrboundB = (5 + 72 * _util.epsilon) * _util.epsilon;
const isperrboundC = (71 + 1408 * _util.epsilon) * _util.epsilon * _util.epsilon;
const ab = (0, _util.vec)(4);
const bc = (0, _util.vec)(4);
const cd = (0, _util.vec)(4);
const de = (0, _util.vec)(4);
const ea = (0, _util.vec)(4);
const ac = (0, _util.vec)(4);
const bd = (0, _util.vec)(4);
const ce = (0, _util.vec)(4);
const da = (0, _util.vec)(4);
const eb = (0, _util.vec)(4);
const abc = (0, _util.vec)(24);
const bcd = (0, _util.vec)(24);
const cde = (0, _util.vec)(24);
const dea = (0, _util.vec)(24);
const eab = (0, _util.vec)(24);
const abd = (0, _util.vec)(24);
const bce = (0, _util.vec)(24);
const cda = (0, _util.vec)(24);
const deb = (0, _util.vec)(24);
const eac = (0, _util.vec)(24);
const adet = (0, _util.vec)(1152);
const bdet = (0, _util.vec)(1152);
const cdet = (0, _util.vec)(1152);
const ddet = (0, _util.vec)(1152);
const edet = (0, _util.vec)(1152);
const abdet = (0, _util.vec)(2304);
const cddet = (0, _util.vec)(2304);
const cdedet = (0, _util.vec)(3456);
const deter = (0, _util.vec)(5760);

const _8 = (0, _util.vec)(8);

const _8b = (0, _util.vec)(8);

const _8c = (0, _util.vec)(8);

const _16 = (0, _util.vec)(16);

const _24 = (0, _util.vec)(24);

const _48 = (0, _util.vec)(48);

const _48b = (0, _util.vec)(48);

const _96 = (0, _util.vec)(96);

const _192 = (0, _util.vec)(192);

const _384x = (0, _util.vec)(384);

const _384y = (0, _util.vec)(384);

const _384z = (0, _util.vec)(384);

const _768 = (0, _util.vec)(768);

function sum_three_scale(a, b, c, az, bz, cz, out) {
  return (0, _util.sum_three)((0, _util.scale)(4, a, az, _8), _8, (0, _util.scale)(4, b, bz, _8b), _8b, (0, _util.scale)(4, c, cz, _8c), _8c, _16, out);
}

function liftexact(alen, a, blen, b, clen, c, dlen, d, x, y, z, out) {
  const len = (0, _util.sum)((0, _util.sum)(alen, a, blen, b, _48), _48, (0, _util.negate)((0, _util.sum)(clen, c, dlen, d, _48b), _48b), _48b, _96);
  return (0, _util.sum_three)((0, _util.scale)((0, _util.scale)(len, _96, x, _192), _192, x, _384x), _384x, (0, _util.scale)((0, _util.scale)(len, _96, y, _192), _192, y, _384y), _384y, (0, _util.scale)((0, _util.scale)(len, _96, z, _192), _192, z, _384z), _384z, _768, out);
}

function insphereexact(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez) {
  let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;

  s1 = ax * by;
  c = _util.splitter * ax;
  ahi = c - (c - ax);
  alo = ax - ahi;
  c = _util.splitter * by;
  bhi = c - (c - by);
  blo = by - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = bx * ay;
  c = _util.splitter * bx;
  ahi = c - (c - bx);
  alo = bx - ahi;
  c = _util.splitter * ay;
  bhi = c - (c - ay);
  blo = ay - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  ab[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  ab[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  ab[2] = _j - (u3 - bvirt) + (_i - bvirt);
  ab[3] = u3;
  s1 = bx * cy;
  c = _util.splitter * bx;
  ahi = c - (c - bx);
  alo = bx - ahi;
  c = _util.splitter * cy;
  bhi = c - (c - cy);
  blo = cy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = cx * by;
  c = _util.splitter * cx;
  ahi = c - (c - cx);
  alo = cx - ahi;
  c = _util.splitter * by;
  bhi = c - (c - by);
  blo = by - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  bc[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  bc[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  bc[2] = _j - (u3 - bvirt) + (_i - bvirt);
  bc[3] = u3;
  s1 = cx * dy;
  c = _util.splitter * cx;
  ahi = c - (c - cx);
  alo = cx - ahi;
  c = _util.splitter * dy;
  bhi = c - (c - dy);
  blo = dy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = dx * cy;
  c = _util.splitter * dx;
  ahi = c - (c - dx);
  alo = dx - ahi;
  c = _util.splitter * cy;
  bhi = c - (c - cy);
  blo = cy - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  cd[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  cd[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  cd[2] = _j - (u3 - bvirt) + (_i - bvirt);
  cd[3] = u3;
  s1 = dx * ey;
  c = _util.splitter * dx;
  ahi = c - (c - dx);
  alo = dx - ahi;
  c = _util.splitter * ey;
  bhi = c - (c - ey);
  blo = ey - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = ex * dy;
  c = _util.splitter * ex;
  ahi = c - (c - ex);
  alo = ex - ahi;
  c = _util.splitter * dy;
  bhi = c - (c - dy);
  blo = dy - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  de[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  de[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  de[2] = _j - (u3 - bvirt) + (_i - bvirt);
  de[3] = u3;
  s1 = ex * ay;
  c = _util.splitter * ex;
  ahi = c - (c - ex);
  alo = ex - ahi;
  c = _util.splitter * ay;
  bhi = c - (c - ay);
  blo = ay - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = ax * ey;
  c = _util.splitter * ax;
  ahi = c - (c - ax);
  alo = ax - ahi;
  c = _util.splitter * ey;
  bhi = c - (c - ey);
  blo = ey - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  ea[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  ea[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  ea[2] = _j - (u3 - bvirt) + (_i - bvirt);
  ea[3] = u3;
  s1 = ax * cy;
  c = _util.splitter * ax;
  ahi = c - (c - ax);
  alo = ax - ahi;
  c = _util.splitter * cy;
  bhi = c - (c - cy);
  blo = cy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = cx * ay;
  c = _util.splitter * cx;
  ahi = c - (c - cx);
  alo = cx - ahi;
  c = _util.splitter * ay;
  bhi = c - (c - ay);
  blo = ay - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  ac[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  ac[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  ac[2] = _j - (u3 - bvirt) + (_i - bvirt);
  ac[3] = u3;
  s1 = bx * dy;
  c = _util.splitter * bx;
  ahi = c - (c - bx);
  alo = bx - ahi;
  c = _util.splitter * dy;
  bhi = c - (c - dy);
  blo = dy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = dx * by;
  c = _util.splitter * dx;
  ahi = c - (c - dx);
  alo = dx - ahi;
  c = _util.splitter * by;
  bhi = c - (c - by);
  blo = by - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  bd[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  bd[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  bd[2] = _j - (u3 - bvirt) + (_i - bvirt);
  bd[3] = u3;
  s1 = cx * ey;
  c = _util.splitter * cx;
  ahi = c - (c - cx);
  alo = cx - ahi;
  c = _util.splitter * ey;
  bhi = c - (c - ey);
  blo = ey - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = ex * cy;
  c = _util.splitter * ex;
  ahi = c - (c - ex);
  alo = ex - ahi;
  c = _util.splitter * cy;
  bhi = c - (c - cy);
  blo = cy - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  ce[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  ce[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  ce[2] = _j - (u3 - bvirt) + (_i - bvirt);
  ce[3] = u3;
  s1 = dx * ay;
  c = _util.splitter * dx;
  ahi = c - (c - dx);
  alo = dx - ahi;
  c = _util.splitter * ay;
  bhi = c - (c - ay);
  blo = ay - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = ax * dy;
  c = _util.splitter * ax;
  ahi = c - (c - ax);
  alo = ax - ahi;
  c = _util.splitter * dy;
  bhi = c - (c - dy);
  blo = dy - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  da[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  da[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  da[2] = _j - (u3 - bvirt) + (_i - bvirt);
  da[3] = u3;
  s1 = ex * by;
  c = _util.splitter * ex;
  ahi = c - (c - ex);
  alo = ex - ahi;
  c = _util.splitter * by;
  bhi = c - (c - by);
  blo = by - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = bx * ey;
  c = _util.splitter * bx;
  ahi = c - (c - bx);
  alo = bx - ahi;
  c = _util.splitter * ey;
  bhi = c - (c - ey);
  blo = ey - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  eb[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  eb[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  eb[2] = _j - (u3 - bvirt) + (_i - bvirt);
  eb[3] = u3;
  const abclen = sum_three_scale(ab, bc, ac, cz, az, -bz, abc);
  const bcdlen = sum_three_scale(bc, cd, bd, dz, bz, -cz, bcd);
  const cdelen = sum_three_scale(cd, de, ce, ez, cz, -dz, cde);
  const dealen = sum_three_scale(de, ea, da, az, dz, -ez, dea);
  const eablen = sum_three_scale(ea, ab, eb, bz, ez, -az, eab);
  const abdlen = sum_three_scale(ab, bd, da, dz, az, bz, abd);
  const bcelen = sum_three_scale(bc, ce, eb, ez, bz, cz, bce);
  const cdalen = sum_three_scale(cd, da, ac, az, cz, dz, cda);
  const deblen = sum_three_scale(de, eb, bd, bz, dz, ez, deb);
  const eaclen = sum_three_scale(ea, ac, ce, cz, ez, az, eac);
  const deterlen = (0, _util.sum_three)(liftexact(cdelen, cde, bcelen, bce, deblen, deb, bcdlen, bcd, ax, ay, az, adet), adet, liftexact(dealen, dea, cdalen, cda, eaclen, eac, cdelen, cde, bx, by, bz, bdet), bdet, (0, _util.sum_three)(liftexact(eablen, eab, deblen, deb, abdlen, abd, dealen, dea, cx, cy, cz, cdet), cdet, liftexact(abclen, abc, eaclen, eac, bcelen, bce, eablen, eab, dx, dy, dz, ddet), ddet, liftexact(bcdlen, bcd, abdlen, abd, cdalen, cda, abclen, abc, ex, ey, ez, edet), edet, cddet, cdedet), cdedet, abdet, deter);
  return deter[deterlen - 1];
}

const xdet = (0, _util.vec)(96);
const ydet = (0, _util.vec)(96);
const zdet = (0, _util.vec)(96);
const fin = (0, _util.vec)(1152);

function liftadapt(a, b, c, az, bz, cz, x, y, z, out) {
  const len = sum_three_scale(a, b, c, az, bz, cz, _24);
  return (0, _util.sum_three)((0, _util.scale)((0, _util.scale)(len, _24, x, _48), _48, x, xdet), xdet, (0, _util.scale)((0, _util.scale)(len, _24, y, _48), _48, y, ydet), ydet, (0, _util.scale)((0, _util.scale)(len, _24, z, _48), _48, z, zdet), zdet, _192, out);
}

function insphereadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez, permanent) {
  let ab3, bc3, cd3, da3, ac3, bd3;
  let aextail, bextail, cextail, dextail;
  let aeytail, beytail, ceytail, deytail;
  let aeztail, beztail, ceztail, deztail;

  let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0;

  const aex = ax - ex;
  const bex = bx - ex;
  const cex = cx - ex;
  const dex = dx - ex;
  const aey = ay - ey;
  const bey = by - ey;
  const cey = cy - ey;
  const dey = dy - ey;
  const aez = az - ez;
  const bez = bz - ez;
  const cez = cz - ez;
  const dez = dz - ez;
  s1 = aex * bey;
  c = _util.splitter * aex;
  ahi = c - (c - aex);
  alo = aex - ahi;
  c = _util.splitter * bey;
  bhi = c - (c - bey);
  blo = bey - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = bex * aey;
  c = _util.splitter * bex;
  ahi = c - (c - bex);
  alo = bex - ahi;
  c = _util.splitter * aey;
  bhi = c - (c - aey);
  blo = aey - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  ab[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  ab[1] = _0 - (_i + bvirt) + (bvirt - t1);
  ab3 = _j + _i;
  bvirt = ab3 - _j;
  ab[2] = _j - (ab3 - bvirt) + (_i - bvirt);
  ab[3] = ab3;
  s1 = bex * cey;
  c = _util.splitter * bex;
  ahi = c - (c - bex);
  alo = bex - ahi;
  c = _util.splitter * cey;
  bhi = c - (c - cey);
  blo = cey - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = cex * bey;
  c = _util.splitter * cex;
  ahi = c - (c - cex);
  alo = cex - ahi;
  c = _util.splitter * bey;
  bhi = c - (c - bey);
  blo = bey - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  bc[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  bc[1] = _0 - (_i + bvirt) + (bvirt - t1);
  bc3 = _j + _i;
  bvirt = bc3 - _j;
  bc[2] = _j - (bc3 - bvirt) + (_i - bvirt);
  bc[3] = bc3;
  s1 = cex * dey;
  c = _util.splitter * cex;
  ahi = c - (c - cex);
  alo = cex - ahi;
  c = _util.splitter * dey;
  bhi = c - (c - dey);
  blo = dey - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = dex * cey;
  c = _util.splitter * dex;
  ahi = c - (c - dex);
  alo = dex - ahi;
  c = _util.splitter * cey;
  bhi = c - (c - cey);
  blo = cey - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  cd[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  cd[1] = _0 - (_i + bvirt) + (bvirt - t1);
  cd3 = _j + _i;
  bvirt = cd3 - _j;
  cd[2] = _j - (cd3 - bvirt) + (_i - bvirt);
  cd[3] = cd3;
  s1 = dex * aey;
  c = _util.splitter * dex;
  ahi = c - (c - dex);
  alo = dex - ahi;
  c = _util.splitter * aey;
  bhi = c - (c - aey);
  blo = aey - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = aex * dey;
  c = _util.splitter * aex;
  ahi = c - (c - aex);
  alo = aex - ahi;
  c = _util.splitter * dey;
  bhi = c - (c - dey);
  blo = dey - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  da[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  da[1] = _0 - (_i + bvirt) + (bvirt - t1);
  da3 = _j + _i;
  bvirt = da3 - _j;
  da[2] = _j - (da3 - bvirt) + (_i - bvirt);
  da[3] = da3;
  s1 = aex * cey;
  c = _util.splitter * aex;
  ahi = c - (c - aex);
  alo = aex - ahi;
  c = _util.splitter * cey;
  bhi = c - (c - cey);
  blo = cey - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = cex * aey;
  c = _util.splitter * cex;
  ahi = c - (c - cex);
  alo = cex - ahi;
  c = _util.splitter * aey;
  bhi = c - (c - aey);
  blo = aey - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  ac[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  ac[1] = _0 - (_i + bvirt) + (bvirt - t1);
  ac3 = _j + _i;
  bvirt = ac3 - _j;
  ac[2] = _j - (ac3 - bvirt) + (_i - bvirt);
  ac[3] = ac3;
  s1 = bex * dey;
  c = _util.splitter * bex;
  ahi = c - (c - bex);
  alo = bex - ahi;
  c = _util.splitter * dey;
  bhi = c - (c - dey);
  blo = dey - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = dex * bey;
  c = _util.splitter * dex;
  ahi = c - (c - dex);
  alo = dex - ahi;
  c = _util.splitter * bey;
  bhi = c - (c - bey);
  blo = bey - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  bd[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  bd[1] = _0 - (_i + bvirt) + (bvirt - t1);
  bd3 = _j + _i;
  bvirt = bd3 - _j;
  bd[2] = _j - (bd3 - bvirt) + (_i - bvirt);
  bd[3] = bd3;
  const finlen = (0, _util.sum)((0, _util.sum)((0, _util.negate)(liftadapt(bc, cd, bd, dez, bez, -cez, aex, aey, aez, adet), adet), adet, liftadapt(cd, da, ac, aez, cez, dez, bex, bey, bez, bdet), bdet, abdet), abdet, (0, _util.sum)((0, _util.negate)(liftadapt(da, ab, bd, bez, dez, aez, cex, cey, cez, cdet), cdet), cdet, liftadapt(ab, bc, ac, cez, aez, -bez, dex, dey, dez, ddet), ddet, cddet), cddet, fin);
  let det = (0, _util.estimate)(finlen, fin);
  let errbound = isperrboundB * permanent;

  if (det >= errbound || -det >= errbound) {
    return det;
  }

  bvirt = ax - aex;
  aextail = ax - (aex + bvirt) + (bvirt - ex);
  bvirt = ay - aey;
  aeytail = ay - (aey + bvirt) + (bvirt - ey);
  bvirt = az - aez;
  aeztail = az - (aez + bvirt) + (bvirt - ez);
  bvirt = bx - bex;
  bextail = bx - (bex + bvirt) + (bvirt - ex);
  bvirt = by - bey;
  beytail = by - (bey + bvirt) + (bvirt - ey);
  bvirt = bz - bez;
  beztail = bz - (bez + bvirt) + (bvirt - ez);
  bvirt = cx - cex;
  cextail = cx - (cex + bvirt) + (bvirt - ex);
  bvirt = cy - cey;
  ceytail = cy - (cey + bvirt) + (bvirt - ey);
  bvirt = cz - cez;
  ceztail = cz - (cez + bvirt) + (bvirt - ez);
  bvirt = dx - dex;
  dextail = dx - (dex + bvirt) + (bvirt - ex);
  bvirt = dy - dey;
  deytail = dy - (dey + bvirt) + (bvirt - ey);
  bvirt = dz - dez;
  deztail = dz - (dez + bvirt) + (bvirt - ez);

  if (aextail === 0 && aeytail === 0 && aeztail === 0 && bextail === 0 && beytail === 0 && beztail === 0 && cextail === 0 && ceytail === 0 && ceztail === 0 && dextail === 0 && deytail === 0 && deztail === 0) {
    return det;
  }

  errbound = isperrboundC * permanent + _util.resulterrbound * Math.abs(det);
  const abeps = aex * beytail + bey * aextail - (aey * bextail + bex * aeytail);
  const bceps = bex * ceytail + cey * bextail - (bey * cextail + cex * beytail);
  const cdeps = cex * deytail + dey * cextail - (cey * dextail + dex * ceytail);
  const daeps = dex * aeytail + aey * dextail - (dey * aextail + aex * deytail);
  const aceps = aex * ceytail + cey * aextail - (aey * cextail + cex * aeytail);
  const bdeps = bex * deytail + dey * bextail - (bey * dextail + dex * beytail);
  det += (bex * bex + bey * bey + bez * bez) * (cez * daeps + dez * aceps + aez * cdeps + (ceztail * da3 + deztail * ac3 + aeztail * cd3)) + (dex * dex + dey * dey + dez * dez) * (aez * bceps - bez * aceps + cez * abeps + (aeztail * bc3 - beztail * ac3 + ceztail * ab3)) - ((aex * aex + aey * aey + aez * aez) * (bez * cdeps - cez * bdeps + dez * bceps + (beztail * cd3 - ceztail * bd3 + deztail * bc3)) + (cex * cex + cey * cey + cez * cez) * (dez * abeps + aez * bdeps + bez * daeps + (deztail * ab3 + aeztail * bd3 + beztail * da3))) + 2 * ((bex * bextail + bey * beytail + bez * beztail) * (cez * da3 + dez * ac3 + aez * cd3) + (dex * dextail + dey * deytail + dez * deztail) * (aez * bc3 - bez * ac3 + cez * ab3) - ((aex * aextail + aey * aeytail + aez * aeztail) * (bez * cd3 - cez * bd3 + dez * bc3) + (cex * cextail + cey * ceytail + cez * ceztail) * (dez * ab3 + aez * bd3 + bez * da3)));

  if (det >= errbound || -det >= errbound) {
    return det;
  }

  return insphereexact(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez);
}

function insphere(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez) {
  const aex = ax - ex;
  const bex = bx - ex;
  const cex = cx - ex;
  const dex = dx - ex;
  const aey = ay - ey;
  const bey = by - ey;
  const cey = cy - ey;
  const dey = dy - ey;
  const aez = az - ez;
  const bez = bz - ez;
  const cez = cz - ez;
  const dez = dz - ez;
  const aexbey = aex * bey;
  const bexaey = bex * aey;
  const ab = aexbey - bexaey;
  const bexcey = bex * cey;
  const cexbey = cex * bey;
  const bc = bexcey - cexbey;
  const cexdey = cex * dey;
  const dexcey = dex * cey;
  const cd = cexdey - dexcey;
  const dexaey = dex * aey;
  const aexdey = aex * dey;
  const da = dexaey - aexdey;
  const aexcey = aex * cey;
  const cexaey = cex * aey;
  const ac = aexcey - cexaey;
  const bexdey = bex * dey;
  const dexbey = dex * bey;
  const bd = bexdey - dexbey;
  const abc = aez * bc - bez * ac + cez * ab;
  const bcd = bez * cd - cez * bd + dez * bc;
  const cda = cez * da + dez * ac + aez * cd;
  const dab = dez * ab + aez * bd + bez * da;
  const alift = aex * aex + aey * aey + aez * aez;
  const blift = bex * bex + bey * bey + bez * bez;
  const clift = cex * cex + cey * cey + cez * cez;
  const dlift = dex * dex + dey * dey + dez * dez;
  const det = clift * dab - dlift * abc + (alift * bcd - blift * cda);
  const aezplus = Math.abs(aez);
  const bezplus = Math.abs(bez);
  const cezplus = Math.abs(cez);
  const dezplus = Math.abs(dez);
  const aexbeyplus = Math.abs(aexbey);
  const bexaeyplus = Math.abs(bexaey);
  const bexceyplus = Math.abs(bexcey);
  const cexbeyplus = Math.abs(cexbey);
  const cexdeyplus = Math.abs(cexdey);
  const dexceyplus = Math.abs(dexcey);
  const dexaeyplus = Math.abs(dexaey);
  const aexdeyplus = Math.abs(aexdey);
  const aexceyplus = Math.abs(aexcey);
  const cexaeyplus = Math.abs(cexaey);
  const bexdeyplus = Math.abs(bexdey);
  const dexbeyplus = Math.abs(dexbey);
  const permanent = ((cexdeyplus + dexceyplus) * bezplus + (dexbeyplus + bexdeyplus) * cezplus + (bexceyplus + cexbeyplus) * dezplus) * alift + ((dexaeyplus + aexdeyplus) * cezplus + (aexceyplus + cexaeyplus) * dezplus + (cexdeyplus + dexceyplus) * aezplus) * blift + ((aexbeyplus + bexaeyplus) * dezplus + (bexdeyplus + dexbeyplus) * aezplus + (dexaeyplus + aexdeyplus) * bezplus) * clift + ((bexceyplus + cexbeyplus) * aezplus + (cexaeyplus + aexceyplus) * bezplus + (aexbeyplus + bexaeyplus) * cezplus) * dlift;
  const errbound = isperrboundA * permanent;

  if (det > errbound || -det > errbound) {
    return det;
  }

  return -insphereadapt(ax, ay, az, bx, by, bz, cx, cy, cz, dx, dy, dz, ex, ey, ez, permanent);
}

function inspherefast(pax, pay, paz, pbx, pby, pbz, pcx, pcy, pcz, pdx, pdy, pdz, pex, pey, pez) {
  const aex = pax - pex;
  const bex = pbx - pex;
  const cex = pcx - pex;
  const dex = pdx - pex;
  const aey = pay - pey;
  const bey = pby - pey;
  const cey = pcy - pey;
  const dey = pdy - pey;
  const aez = paz - pez;
  const bez = pbz - pez;
  const cez = pcz - pez;
  const dez = pdz - pez;
  const ab = aex * bey - bex * aey;
  const bc = bex * cey - cex * bey;
  const cd = cex * dey - dex * cey;
  const da = dex * aey - aex * dey;
  const ac = aex * cey - cex * aey;
  const bd = bex * dey - dex * bey;
  const abc = aez * bc - bez * ac + cez * ab;
  const bcd = bez * cd - cez * bd + dez * bc;
  const cda = cez * da + dez * ac + aez * cd;
  const dab = dez * ab + aez * bd + bez * da;
  const alift = aex * aex + aey * aey + aez * aez;
  const blift = bex * bex + bey * bey + bez * bez;
  const clift = cex * cex + cey * cey + cez * cez;
  const dlift = dex * dex + dey * dey + dez * dez;
  return clift * dab - dlift * abc + (alift * bcd - blift * cda);
}
},{"./util.js":"node_modules/robust-predicates/esm/util.js"}],"node_modules/robust-predicates/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "orient2d", {
  enumerable: true,
  get: function () {
    return _orient2d.orient2d;
  }
});
Object.defineProperty(exports, "orient2dfast", {
  enumerable: true,
  get: function () {
    return _orient2d.orient2dfast;
  }
});
Object.defineProperty(exports, "orient3d", {
  enumerable: true,
  get: function () {
    return _orient3d.orient3d;
  }
});
Object.defineProperty(exports, "orient3dfast", {
  enumerable: true,
  get: function () {
    return _orient3d.orient3dfast;
  }
});
Object.defineProperty(exports, "incircle", {
  enumerable: true,
  get: function () {
    return _incircle.incircle;
  }
});
Object.defineProperty(exports, "incirclefast", {
  enumerable: true,
  get: function () {
    return _incircle.incirclefast;
  }
});
Object.defineProperty(exports, "insphere", {
  enumerable: true,
  get: function () {
    return _insphere.insphere;
  }
});
Object.defineProperty(exports, "inspherefast", {
  enumerable: true,
  get: function () {
    return _insphere.inspherefast;
  }
});

var _orient2d = require("./esm/orient2d.js");

var _orient3d = require("./esm/orient3d.js");

var _incircle = require("./esm/incircle.js");

var _insphere = require("./esm/insphere.js");
},{"./esm/orient2d.js":"node_modules/robust-predicates/esm/orient2d.js","./esm/orient3d.js":"node_modules/robust-predicates/esm/orient3d.js","./esm/incircle.js":"node_modules/robust-predicates/esm/incircle.js","./esm/insphere.js":"node_modules/robust-predicates/esm/insphere.js"}],"node_modules/delaunator/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _robustPredicates = require("robust-predicates");

const EPSILON = Math.pow(2, -52);
const EDGE_STACK = new Uint32Array(512);

class Delaunator {
  static from(points, getX = defaultGetX, getY = defaultGetY) {
    const n = points.length;
    const coords = new Float64Array(n * 2);

    for (let i = 0; i < n; i++) {
      const p = points[i];
      coords[2 * i] = getX(p);
      coords[2 * i + 1] = getY(p);
    }

    return new Delaunator(coords);
  }

  constructor(coords) {
    const n = coords.length >> 1;
    if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');
    this.coords = coords; // arrays that will store the triangulation graph

    const maxTriangles = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(maxTriangles * 3);
    this._halfedges = new Int32Array(maxTriangles * 3); // temporary arrays for tracking the edges of the advancing convex hull

    this._hashSize = Math.ceil(Math.sqrt(n));
    this._hullPrev = new Uint32Array(n); // edge to prev edge

    this._hullNext = new Uint32Array(n); // edge to next edge

    this._hullTri = new Uint32Array(n); // edge to adjacent triangle

    this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash
    // temporary arrays for sorting points

    this._ids = new Uint32Array(n);
    this._dists = new Float64Array(n);
    this.update();
  }

  update() {
    const {
      coords,
      _hullPrev: hullPrev,
      _hullNext: hullNext,
      _hullTri: hullTri,
      _hullHash: hullHash
    } = this;
    const n = coords.length >> 1; // populate an array of point indices; calculate input data bbox

    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;

    for (let i = 0; i < n; i++) {
      const x = coords[2 * i];
      const y = coords[2 * i + 1];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      this._ids[i] = i;
    }

    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;
    let minDist = Infinity;
    let i0, i1, i2; // pick a seed point close to the center

    for (let i = 0; i < n; i++) {
      const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);

      if (d < minDist) {
        i0 = i;
        minDist = d;
      }
    }

    const i0x = coords[2 * i0];
    const i0y = coords[2 * i0 + 1];
    minDist = Infinity; // find the point closest to the seed

    for (let i = 0; i < n; i++) {
      if (i === i0) continue;
      const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);

      if (d < minDist && d > 0) {
        i1 = i;
        minDist = d;
      }
    }

    let i1x = coords[2 * i1];
    let i1y = coords[2 * i1 + 1];
    let minRadius = Infinity; // find the third point which forms the smallest circumcircle with the first two

    for (let i = 0; i < n; i++) {
      if (i === i0 || i === i1) continue;
      const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);

      if (r < minRadius) {
        i2 = i;
        minRadius = r;
      }
    }

    let i2x = coords[2 * i2];
    let i2y = coords[2 * i2 + 1];

    if (minRadius === Infinity) {
      // order collinear points by dx (or dy if all x are identical)
      // and return the list as a hull
      for (let i = 0; i < n; i++) {
        this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
      }

      quicksort(this._ids, this._dists, 0, n - 1);
      const hull = new Uint32Array(n);
      let j = 0;

      for (let i = 0, d0 = -Infinity; i < n; i++) {
        const id = this._ids[i];

        if (this._dists[id] > d0) {
          hull[j++] = id;
          d0 = this._dists[id];
        }
      }

      this.hull = hull.subarray(0, j);
      this.triangles = new Uint32Array(0);
      this.halfedges = new Uint32Array(0);
      return;
    } // swap the order of the seed points for counter-clockwise orientation


    if ((0, _robustPredicates.orient2d)(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
      const i = i1;
      const x = i1x;
      const y = i1y;
      i1 = i2;
      i1x = i2x;
      i1y = i2y;
      i2 = i;
      i2x = x;
      i2y = y;
    }

    const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
    this._cx = center.x;
    this._cy = center.y;

    for (let i = 0; i < n; i++) {
      this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
    } // sort the points by distance from the seed triangle circumcenter


    quicksort(this._ids, this._dists, 0, n - 1); // set up the seed triangle as the starting hull

    this._hullStart = i0;
    let hullSize = 3;
    hullNext[i0] = hullPrev[i2] = i1;
    hullNext[i1] = hullPrev[i0] = i2;
    hullNext[i2] = hullPrev[i1] = i0;
    hullTri[i0] = 0;
    hullTri[i1] = 1;
    hullTri[i2] = 2;
    hullHash.fill(-1);
    hullHash[this._hashKey(i0x, i0y)] = i0;
    hullHash[this._hashKey(i1x, i1y)] = i1;
    hullHash[this._hashKey(i2x, i2y)] = i2;
    this.trianglesLen = 0;

    this._addTriangle(i0, i1, i2, -1, -1, -1);

    for (let k = 0, xp, yp; k < this._ids.length; k++) {
      const i = this._ids[k];
      const x = coords[2 * i];
      const y = coords[2 * i + 1]; // skip near-duplicate points

      if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
      xp = x;
      yp = y; // skip seed triangle points

      if (i === i0 || i === i1 || i === i2) continue; // find a visible edge on the convex hull using edge hash

      let start = 0;

      for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
        start = hullHash[(key + j) % this._hashSize];
        if (start !== -1 && start !== hullNext[start]) break;
      }

      start = hullPrev[start];
      let e = start,
          q;

      while (q = hullNext[e], (0, _robustPredicates.orient2d)(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
        e = q;

        if (e === start) {
          e = -1;
          break;
        }
      }

      if (e === -1) continue; // likely a near-duplicate point; skip it
      // add the first triangle from the point

      let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]); // recursively flip triangles from the point until they satisfy the Delaunay condition


      hullTri[i] = this._legalize(t + 2);
      hullTri[e] = t; // keep track of boundary triangles on the hull

      hullSize++; // walk forward through the hull, adding more triangles and flipping recursively

      let n = hullNext[e];

      while (q = hullNext[n], (0, _robustPredicates.orient2d)(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
        t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
        hullTri[i] = this._legalize(t + 2);
        hullNext[n] = n; // mark as removed

        hullSize--;
        n = q;
      } // walk backward from the other side, adding more triangles and flipping


      if (e === start) {
        while (q = hullPrev[e], (0, _robustPredicates.orient2d)(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
          t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);

          this._legalize(t + 2);

          hullTri[q] = t;
          hullNext[e] = e; // mark as removed

          hullSize--;
          e = q;
        }
      } // update the hull indices


      this._hullStart = hullPrev[i] = e;
      hullNext[e] = hullPrev[n] = i;
      hullNext[i] = n; // save the two new edges in the hash table

      hullHash[this._hashKey(x, y)] = i;
      hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
    }

    this.hull = new Uint32Array(hullSize);

    for (let i = 0, e = this._hullStart; i < hullSize; i++) {
      this.hull[i] = e;
      e = hullNext[e];
    } // trim typed triangle mesh arrays


    this.triangles = this._triangles.subarray(0, this.trianglesLen);
    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }

  _hashKey(x, y) {
    return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
  }

  _legalize(a) {
    const {
      _triangles: triangles,
      _halfedges: halfedges,
      coords
    } = this;
    let i = 0;
    let ar = 0; // recursion eliminated with a fixed-size stack

    while (true) {
      const b = halfedges[a];
      /* if the pair of triangles doesn't satisfy the Delaunay condition
       * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
       * then do the same check/flip recursively for the new pair of triangles
       *
       *           pl                    pl
       *          /||\                  /  \
       *       al/ || \bl            al/    \a
       *        /  ||  \              /      \
       *       /  a||b  \    flip    /___ar___\
       *     p0\   ||   /p1   =>   p0\---bl---/p1
       *        \  ||  /              \      /
       *       ar\ || /br             b\    /br
       *          \||/                  \  /
       *           pr                    pr
       */

      const a0 = a - a % 3;
      ar = a0 + (a + 2) % 3;

      if (b === -1) {
        // convex hull edge
        if (i === 0) break;
        a = EDGE_STACK[--i];
        continue;
      }

      const b0 = b - b % 3;
      const al = a0 + (a + 1) % 3;
      const bl = b0 + (b + 2) % 3;
      const p0 = triangles[ar];
      const pr = triangles[a];
      const pl = triangles[al];
      const p1 = triangles[bl];
      const illegal = inCircle(coords[2 * p0], coords[2 * p0 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1]);

      if (illegal) {
        triangles[a] = p1;
        triangles[b] = p0;
        const hbl = halfedges[bl]; // edge swapped on the other side of the hull (rare); fix the halfedge reference

        if (hbl === -1) {
          let e = this._hullStart;

          do {
            if (this._hullTri[e] === bl) {
              this._hullTri[e] = a;
              break;
            }

            e = this._hullPrev[e];
          } while (e !== this._hullStart);
        }

        this._link(a, hbl);

        this._link(b, halfedges[ar]);

        this._link(ar, bl);

        const br = b0 + (b + 1) % 3; // don't worry about hitting the cap: it can only happen on extremely degenerate input

        if (i < EDGE_STACK.length) {
          EDGE_STACK[i++] = br;
        }
      } else {
        if (i === 0) break;
        a = EDGE_STACK[--i];
      }
    }

    return ar;
  }

  _link(a, b) {
    this._halfedges[a] = b;
    if (b !== -1) this._halfedges[b] = a;
  } // add a new triangle given vertex indices and adjacent half-edge ids


  _addTriangle(i0, i1, i2, a, b, c) {
    const t = this.trianglesLen;
    this._triangles[t] = i0;
    this._triangles[t + 1] = i1;
    this._triangles[t + 2] = i2;

    this._link(t, a);

    this._link(t + 1, b);

    this._link(t + 2, c);

    this.trianglesLen += 3;
    return t;
  }

} // monotonically increases with real angle, but doesn't need expensive trigonometry


exports.default = Delaunator;

function pseudoAngle(dx, dy) {
  const p = dx / (Math.abs(dx) + Math.abs(dy));
  return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
}

function dist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}

function inCircle(ax, ay, bx, by, cx, cy, px, py) {
  const dx = ax - px;
  const dy = ay - py;
  const ex = bx - px;
  const ey = by - py;
  const fx = cx - px;
  const fy = cy - py;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}

function circumradius(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x = (ey * bl - dy * cl) * d;
  const y = (dx * cl - ex * bl) * d;
  return x * x + y * y;
}

function circumcenter(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x = ax + (ey * bl - dy * cl) * d;
  const y = ay + (dx * cl - ex * bl) * d;
  return {
    x,
    y
  };
}

function quicksort(ids, dists, left, right) {
  if (right - left <= 20) {
    for (let i = left + 1; i <= right; i++) {
      const temp = ids[i];
      const tempDist = dists[temp];
      let j = i - 1;

      while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];

      ids[j + 1] = temp;
    }
  } else {
    const median = left + right >> 1;
    let i = left + 1;
    let j = right;
    swap(ids, median, i);
    if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
    if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
    if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);
    const temp = ids[i];
    const tempDist = dists[temp];

    while (true) {
      do i++; while (dists[ids[i]] < tempDist);

      do j--; while (dists[ids[j]] > tempDist);

      if (j < i) break;
      swap(ids, i, j);
    }

    ids[left + 1] = ids[j];
    ids[j] = temp;

    if (right - i + 1 >= j - left) {
      quicksort(ids, dists, i, right);
      quicksort(ids, dists, left, j - 1);
    } else {
      quicksort(ids, dists, left, j - 1);
      quicksort(ids, dists, i, right);
    }
  }
}

function swap(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}

function defaultGetX(p) {
  return p[0];
}

function defaultGetY(p) {
  return p[1];
}
},{"robust-predicates":"node_modules/robust-predicates/index.js"}],"node_modules/d3-delaunay/src/path.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const epsilon = 1e-6;

class Path {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath

    this._ = "";
  }

  moveTo(x, y) {
    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
  }

  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  }

  lineTo(x, y) {
    this._ += `L${this._x1 = +x},${this._y1 = +y}`;
  }

  arc(x, y, r) {
    x = +x, y = +y, r = +r;
    const x0 = x + r;
    const y0 = y;
    if (r < 0) throw new Error("negative radius");
    if (this._x1 === null) this._ += `M${x0},${y0}`;else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._ += "L" + x0 + "," + y0;
    if (!r) return;
    this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
  }

  rect(x, y, w, h) {
    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;
  }

  value() {
    return this._ || null;
  }

}

exports.default = Path;
},{}],"node_modules/d3-delaunay/src/polygon.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

class Polygon {
  constructor() {
    this._ = [];
  }

  moveTo(x, y) {
    this._.push([x, y]);
  }

  closePath() {
    this._.push(this._[0].slice());
  }

  lineTo(x, y) {
    this._.push([x, y]);
  }

  value() {
    return this._.length ? this._ : null;
  }

}

exports.default = Polygon;
},{}],"node_modules/d3-delaunay/src/voronoi.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("./path.js"));

var _polygon = _interopRequireDefault(require("./polygon.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Voronoi {
  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;

    this._init();
  }

  update() {
    this.delaunay.update();

    this._init();

    return this;
  }

  _init() {
    const {
      delaunay: {
        points,
        hull,
        triangles
      },
      vectors
    } = this; // Compute circumcenters.

    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);

    for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {
      const t1 = triangles[i] * 2;
      const t2 = triangles[i + 1] * 2;
      const t3 = triangles[i + 2] * 2;
      const x1 = points[t1];
      const y1 = points[t1 + 1];
      const x2 = points[t2];
      const y2 = points[t2 + 1];
      const x3 = points[t3];
      const y3 = points[t3 + 1];
      const dx = x2 - x1;
      const dy = y2 - y1;
      const ex = x3 - x1;
      const ey = y3 - y1;
      const ab = (dx * ey - dy * ex) * 2;

      if (Math.abs(ab) < 1e-9) {
        // degenerate case (collinear diagram)
        // almost equal points (degenerate triangle)
        // the circumcenter is at the infinity, in a
        // direction that is:
        // 1. orthogonal to the halfedge.
        let a = 1e9; // 2. points away from the center; since the list of triangles starts
        // in the center, the first point of the first triangle
        // will be our reference

        const r = triangles[0] * 2;
        a *= Math.sign((points[r] - x1) * ey - (points[r + 1] - y1) * ex);
        x = (x1 + x3) / 2 - a * ey;
        y = (y1 + y3) / 2 + a * ex;
      } else {
        const d = 1 / ab;
        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        x = x1 + (ey * bl - dy * cl) * d;
        y = y1 + (dx * cl - ex * bl) * d;
      }

      circumcenters[j] = x;
      circumcenters[j + 1] = y;
    } // Compute exterior cell rays.


    let h = hull[hull.length - 1];
    let p0,
        p1 = h * 4;
    let x0,
        x1 = points[2 * h];
    let y0,
        y1 = points[2 * h + 1];
    vectors.fill(0);

    for (let i = 0; i < hull.length; ++i) {
      h = hull[i];
      p0 = p1, x0 = x1, y0 = y1;
      p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
      vectors[p0 + 2] = vectors[p1] = y0 - y1;
      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
    }
  }

  render(context) {
    const buffer = context == null ? context = new _path.default() : undefined;
    const {
      delaunay: {
        halfedges,
        inedges,
        hull
      },
      circumcenters,
      vectors
    } = this;
    if (hull.length <= 1) return null;

    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = Math.floor(i / 3) * 2;
      const tj = Math.floor(j / 3) * 2;
      const xi = circumcenters[ti];
      const yi = circumcenters[ti + 1];
      const xj = circumcenters[tj];
      const yj = circumcenters[tj + 1];

      this._renderSegment(xi, yi, xj, yj, context);
    }

    let h0,
        h1 = hull[hull.length - 1];

    for (let i = 0; i < hull.length; ++i) {
      h0 = h1, h1 = hull[i];
      const t = Math.floor(inedges[h1] / 3) * 2;
      const x = circumcenters[t];
      const y = circumcenters[t + 1];
      const v = h0 * 4;

      const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);

      if (p) this._renderSegment(x, y, p[0], p[1], context);
    }

    return buffer && buffer.value();
  }

  renderBounds(context) {
    const buffer = context == null ? context = new _path.default() : undefined;
    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer && buffer.value();
  }

  renderCell(i, context) {
    const buffer = context == null ? context = new _path.default() : undefined;

    const points = this._clip(i);

    if (points === null || !points.length) return;
    context.moveTo(points[0], points[1]);
    let n = points.length;

    while (points[0] === points[n - 2] && points[1] === points[n - 1] && n > 1) n -= 2;

    for (let i = 2; i < n; i += 2) {
      if (points[i] !== points[i - 2] || points[i + 1] !== points[i - 1]) context.lineTo(points[i], points[i + 1]);
    }

    context.closePath();
    return buffer && buffer.value();
  }

  *cellPolygons() {
    const {
      delaunay: {
        points
      }
    } = this;

    for (let i = 0, n = points.length / 2; i < n; ++i) {
      const cell = this.cellPolygon(i);
      if (cell) cell.index = i, yield cell;
    }
  }

  cellPolygon(i) {
    const polygon = new _polygon.default();
    this.renderCell(i, polygon);
    return polygon.value();
  }

  _renderSegment(x0, y0, x1, y1, context) {
    let S;

    const c0 = this._regioncode(x0, y0);

    const c1 = this._regioncode(x1, y1);

    if (c0 === 0 && c1 === 0) {
      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
    } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
      context.moveTo(S[0], S[1]);
      context.lineTo(S[2], S[3]);
    }
  }

  contains(i, x, y) {
    if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
    return this.delaunay._step(i, x, y) === i;
  }

  *neighbors(i) {
    const ci = this._clip(i);

    if (ci) for (const j of this.delaunay.neighbors(i)) {
      const cj = this._clip(j); // find the common edge


      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
          if (ci[ai] == cj[aj] && ci[ai + 1] == cj[aj + 1] && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]) {
            yield j;
            break loop;
          }
        }
      }
    }
  }

  _cell(i) {
    const {
      circumcenters,
      delaunay: {
        inedges,
        halfedges,
        triangles
      }
    } = this;
    const e0 = inedges[i];
    if (e0 === -1) return null; // coincident point

    const points = [];
    let e = e0;

    do {
      const t = Math.floor(e / 3);
      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break; // bad triangulation

      e = halfedges[e];
    } while (e !== e0 && e !== -1);

    return points;
  }

  _clip(i) {
    // degenerate case (1 valid point: return the box)
    if (i === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }

    const points = this._cell(i);

    if (points === null) return null;
    const {
      vectors: V
    } = this;
    const v = i * 4;
    return V[v] || V[v + 1] ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3]) : this._clipFinite(i, points);
  }

  _clipFinite(i, points) {
    const n = points.length;
    let P = null;
    let x0,
        y0,
        x1 = points[n - 2],
        y1 = points[n - 1];

    let c0,
        c1 = this._regioncode(x1, y1);

    let e0,
        e1 = 0;

    for (let j = 0; j < n; j += 2) {
      x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
      c0 = c1, c1 = this._regioncode(x1, y1);

      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P) P.push(x1, y1);else P = [x1, y1];
      } else {
        let S, sx0, sy0, sx1, sy1;

        if (c0 === 0) {
          if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
          [sx0, sy0, sx1, sy1] = S;
        } else {
          if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
          [sx1, sy1, sx0, sy0] = S;
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
          if (P) P.push(sx0, sy0);else P = [sx0, sy0];
        }

        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        if (P) P.push(sx1, sy1);else P = [sx1, sy1];
      }
    }

    if (P) {
      e0 = e1, e1 = this._edgecode(P[0], P[1]);
      if (e0 && e1) this._edge(i, e0, e1, P, P.length);
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }

    return P;
  }

  _clipSegment(x0, y0, x1, y1, c0, c1) {
    while (true) {
      if (c0 === 0 && c1 === 0) return [x0, y0, x1, y1];
      if (c0 & c1) return null;
      let x,
          y,
          c = c0 || c1;
      if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;
      if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);
    }
  }

  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
    let P = Array.from(points),
        p;
    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);

    if (P = this._clipFinite(i, P)) {
      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
      }
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }

    return P;
  }

  _edge(i, e0, e1, P, j) {
    while (e0 !== e1) {
      let x, y;

      switch (e0) {
        case 0b0101:
          e0 = 0b0100;
          continue;
        // top-left

        case 0b0100:
          e0 = 0b0110, x = this.xmax, y = this.ymin;
          break;
        // top

        case 0b0110:
          e0 = 0b0010;
          continue;
        // top-right

        case 0b0010:
          e0 = 0b1010, x = this.xmax, y = this.ymax;
          break;
        // right

        case 0b1010:
          e0 = 0b1000;
          continue;
        // bottom-right

        case 0b1000:
          e0 = 0b1001, x = this.xmin, y = this.ymax;
          break;
        // bottom

        case 0b1001:
          e0 = 0b0001;
          continue;
        // bottom-left

        case 0b0001:
          e0 = 0b0101, x = this.xmin, y = this.ymin;
          break;
        // left
      } // Note: this implicitly checks for out of bounds: if P[j] or P[j+1] are
      // undefined, the conditional statement will be executed.


      if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
        P.splice(j, 0, x, y), j += 2;
      }
    }

    if (P.length > 4) {
      for (let i = 0; i < P.length; i += 2) {
        const j = (i + 2) % P.length,
              k = (i + 4) % P.length;
        if (P[i] === P[j] && P[j] === P[k] || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1]) P.splice(j, 2), i -= 2;
      }
    }

    return j;
  }

  _project(x0, y0, vx, vy) {
    let t = Infinity,
        c,
        x,
        y;

    if (vy < 0) {
      // top
      if (y0 <= this.ymin) return null;
      if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
    } else if (vy > 0) {
      // bottom
      if (y0 >= this.ymax) return null;
      if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
    }

    if (vx > 0) {
      // right
      if (x0 >= this.xmax) return null;
      if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
    } else if (vx < 0) {
      // left
      if (x0 <= this.xmin) return null;
      if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
    }

    return [x, y];
  }

  _edgecode(x, y) {
    return (x === this.xmin ? 0b0001 : x === this.xmax ? 0b0010 : 0b0000) | (y === this.ymin ? 0b0100 : y === this.ymax ? 0b1000 : 0b0000);
  }

  _regioncode(x, y) {
    return (x < this.xmin ? 0b0001 : x > this.xmax ? 0b0010 : 0b0000) | (y < this.ymin ? 0b0100 : y > this.ymax ? 0b1000 : 0b0000);
  }

}

exports.default = Voronoi;
},{"./path.js":"node_modules/d3-delaunay/src/path.js","./polygon.js":"node_modules/d3-delaunay/src/polygon.js"}],"node_modules/d3-delaunay/src/delaunay.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _delaunator = _interopRequireDefault(require("delaunator"));

var _path = _interopRequireDefault(require("./path.js"));

var _polygon = _interopRequireDefault(require("./polygon.js"));

var _voronoi = _interopRequireDefault(require("./voronoi.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const tau = 2 * Math.PI,
      pow = Math.pow;

function pointX(p) {
  return p[0];
}

function pointY(p) {
  return p[1];
} // A triangulation is collinear if all its triangles have a non-null area


function collinear(d) {
  const {
    triangles,
    coords
  } = d;

  for (let i = 0; i < triangles.length; i += 3) {
    const a = 2 * triangles[i],
          b = 2 * triangles[i + 1],
          c = 2 * triangles[i + 2],
          cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1]) - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);
    if (cross > 1e-10) return false;
  }

  return true;
}

function jitter(x, y, r) {
  return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
}

class Delaunay {
  static from(points, fx = pointX, fy = pointY, that) {
    return new Delaunay("length" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));
  }

  constructor(points) {
    this._delaunator = new _delaunator.default(points);
    this.inedges = new Int32Array(points.length / 2);
    this._hullIndex = new Int32Array(points.length / 2);
    this.points = this._delaunator.coords;

    this._init();
  }

  update() {
    this._delaunator.update();

    this._init();

    return this;
  }

  _init() {
    const d = this._delaunator,
          points = this.points; // check for collinear

    if (d.hull && d.hull.length > 2 && collinear(d)) {
      this.collinear = Int32Array.from({
        length: points.length / 2
      }, (_, i) => i).sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors

      const e = this.collinear[0],
            f = this.collinear[this.collinear.length - 1],
            bounds = [points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1]],
            r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);

      for (let i = 0, n = points.length / 2; i < n; ++i) {
        const p = jitter(points[2 * i], points[2 * i + 1], r);
        points[2 * i] = p[0];
        points[2 * i + 1] = p[1];
      }

      this._delaunator = new _delaunator.default(points);
    } else {
      delete this.collinear;
    }

    const halfedges = this.halfedges = this._delaunator.halfedges;
    const hull = this.hull = this._delaunator.hull;
    const triangles = this.triangles = this._delaunator.triangles;
    const inedges = this.inedges.fill(-1);

    const hullIndex = this._hullIndex.fill(-1); // Compute an index from each point to an (arbitrary) incoming halfedge
    // Used to give the first neighbor of each point; for this reason,
    // on the hull we give priority to exterior halfedges


    for (let e = 0, n = halfedges.length; e < n; ++e) {
      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
    }

    for (let i = 0, n = hull.length; i < n; ++i) {
      hullIndex[hull[i]] = i;
    } // degenerate case: 1 or 2 (distinct) points


    if (hull.length <= 2 && hull.length > 0) {
      this.triangles = new Int32Array(3).fill(-1);
      this.halfedges = new Int32Array(3).fill(-1);
      this.triangles[0] = hull[0];
      inedges[hull[0]] = 1;

      if (hull.length === 2) {
        inedges[hull[1]] = 0;
        this.triangles[1] = hull[1];
        this.triangles[2] = hull[1];
      }
    }
  }

  voronoi(bounds) {
    return new _voronoi.default(this, bounds);
  }

  *neighbors(i) {
    const {
      inedges,
      hull,
      _hullIndex,
      halfedges,
      triangles,
      collinear
    } = this; // degenerate case with several collinear points

    if (collinear) {
      const l = collinear.indexOf(i);
      if (l > 0) yield collinear[l - 1];
      if (l < collinear.length - 1) yield collinear[l + 1];
      return;
    }

    const e0 = inedges[i];
    if (e0 === -1) return; // coincident point

    let e = e0,
        p0 = -1;

    do {
      yield p0 = triangles[e];
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) return; // bad triangulation

      e = halfedges[e];

      if (e === -1) {
        const p = hull[(_hullIndex[i] + 1) % hull.length];
        if (p !== p0) yield p;
        return;
      }
    } while (e !== e0);
  }

  find(x, y, i = 0) {
    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
    const i0 = i;
    let c;

    while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;

    return c;
  }

  _step(i, x, y) {
    const {
      inedges,
      hull,
      _hullIndex,
      halfedges,
      triangles,
      points
    } = this;
    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
    let c = i;
    let dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);
    const e0 = inedges[i];
    let e = e0;

    do {
      let t = triangles[e];
      const dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);
      if (dt < dc) dc = dt, c = t;
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break; // bad triangulation

      e = halfedges[e];

      if (e === -1) {
        e = hull[(_hullIndex[i] + 1) % hull.length];

        if (e !== t) {
          if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;
        }

        break;
      }
    } while (e !== e0);

    return c;
  }

  render(context) {
    const buffer = context == null ? context = new _path.default() : undefined;
    const {
      points,
      halfedges,
      triangles
    } = this;

    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = triangles[i] * 2;
      const tj = triangles[j] * 2;
      context.moveTo(points[ti], points[ti + 1]);
      context.lineTo(points[tj], points[tj + 1]);
    }

    this.renderHull(context);
    return buffer && buffer.value();
  }

  renderPoints(context, r) {
    if (r === undefined && (!context || typeof context.moveTo !== "function")) r = context, context = null;
    r = r == undefined ? 2 : +r;
    const buffer = context == null ? context = new _path.default() : undefined;
    const {
      points
    } = this;

    for (let i = 0, n = points.length; i < n; i += 2) {
      const x = points[i],
            y = points[i + 1];
      context.moveTo(x + r, y);
      context.arc(x, y, r, 0, tau);
    }

    return buffer && buffer.value();
  }

  renderHull(context) {
    const buffer = context == null ? context = new _path.default() : undefined;
    const {
      hull,
      points
    } = this;
    const h = hull[0] * 2,
          n = hull.length;
    context.moveTo(points[h], points[h + 1]);

    for (let i = 1; i < n; ++i) {
      const h = 2 * hull[i];
      context.lineTo(points[h], points[h + 1]);
    }

    context.closePath();
    return buffer && buffer.value();
  }

  hullPolygon() {
    const polygon = new _polygon.default();
    this.renderHull(polygon);
    return polygon.value();
  }

  renderTriangle(i, context) {
    const buffer = context == null ? context = new _path.default() : undefined;
    const {
      points,
      triangles
    } = this;
    const t0 = triangles[i *= 3] * 2;
    const t1 = triangles[i + 1] * 2;
    const t2 = triangles[i + 2] * 2;
    context.moveTo(points[t0], points[t0 + 1]);
    context.lineTo(points[t1], points[t1 + 1]);
    context.lineTo(points[t2], points[t2 + 1]);
    context.closePath();
    return buffer && buffer.value();
  }

  *trianglePolygons() {
    const {
      triangles
    } = this;

    for (let i = 0, n = triangles.length / 3; i < n; ++i) {
      yield this.trianglePolygon(i);
    }
  }

  trianglePolygon(i) {
    const polygon = new _polygon.default();
    this.renderTriangle(i, polygon);
    return polygon.value();
  }

}

exports.default = Delaunay;

function flatArray(points, fx, fy, that) {
  const n = points.length;
  const array = new Float64Array(n * 2);

  for (let i = 0; i < n; ++i) {
    const p = points[i];
    array[i * 2] = fx.call(that, p, i, points);
    array[i * 2 + 1] = fy.call(that, p, i, points);
  }

  return array;
}

function* flatIterable(points, fx, fy, that) {
  let i = 0;

  for (const p of points) {
    yield fx.call(that, p, i, points);
    yield fy.call(that, p, i, points);
    ++i;
  }
}
},{"delaunator":"node_modules/delaunator/index.js","./path.js":"node_modules/d3-delaunay/src/path.js","./polygon.js":"node_modules/d3-delaunay/src/polygon.js","./voronoi.js":"node_modules/d3-delaunay/src/voronoi.js"}],"node_modules/d3-delaunay/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Delaunay", {
  enumerable: true,
  get: function () {
    return _delaunay.default;
  }
});
Object.defineProperty(exports, "Voronoi", {
  enumerable: true,
  get: function () {
    return _voronoi.default;
  }
});

var _delaunay = _interopRequireDefault(require("./delaunay.js"));

var _voronoi = _interopRequireDefault(require("./voronoi.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./delaunay.js":"node_modules/d3-delaunay/src/delaunay.js","./voronoi.js":"node_modules/d3-delaunay/src/voronoi.js"}],"src/assets/gltf/coin.gltf":[function(require,module,exports) {
module.exports = "/coin.753517b6.gltf";
},{}],"src/assets/gltf/forest.glb":[function(require,module,exports) {
module.exports = "/forest.0ac635c0.glb";
},{}],"src/assets/gltf/grasslands.glb":[function(require,module,exports) {
module.exports = "/grasslands.17f215ac.glb";
},{}],"src/assets/gltf/hat.gltf":[function(require,module,exports) {
module.exports = "/hat.1b609ad8.gltf";
},{}],"src/assets/gltf/map-0A3C840A-1259-4342-94A8-476258923E0C.jpg":[function(require,module,exports) {
module.exports = "/map-0A3C840A-1259-4342-94A8-476258923E0C.6f30f783.jpg";
},{}],"src/assets/gltf/map-0DB6312F-078E-464F-9597-198B12899E4D.jpg":[function(require,module,exports) {
module.exports = "/map-0DB6312F-078E-464F-9597-198B12899E4D.fa8dcf6c.jpg";
},{}],"src/assets/gltf/map-10C9B800-5663-492A-8F3A-BE6D7256387E.jpg":[function(require,module,exports) {
module.exports = "/map-10C9B800-5663-492A-8F3A-BE6D7256387E.9bbb9ead.jpg";
},{}],"src/assets/gltf/map-19306294-F575-479A-AA37-C2DB5020A469.jpg":[function(require,module,exports) {
module.exports = "/map-19306294-F575-479A-AA37-C2DB5020A469.5513673c.jpg";
},{}],"src/assets/gltf/map-3CA1D1C7-F1C1-46A4-9892-094F299AA6FE.jpg":[function(require,module,exports) {
module.exports = "/map-3CA1D1C7-F1C1-46A4-9892-094F299AA6FE.a4ef80d2.jpg";
},{}],"src/assets/gltf/map-554D4548-E3F4-4F92-8137-887B88B2E0AD.jpg":[function(require,module,exports) {
module.exports = "/map-554D4548-E3F4-4F92-8137-887B88B2E0AD.e1d9a43c.jpg";
},{}],"src/assets/gltf/map-5B229F00-724F-42B0-A8B3-3F24E3FDD766.jpg":[function(require,module,exports) {
module.exports = "/map-5B229F00-724F-42B0-A8B3-3F24E3FDD766.422b171d.jpg";
},{}],"src/assets/gltf/map-5E463828-72AC-4402-93B9-F1A30FBAF1A9.jpg":[function(require,module,exports) {
module.exports = "/map-5E463828-72AC-4402-93B9-F1A30FBAF1A9.f726a6ee.jpg";
},{}],"src/assets/gltf/map-61639B10-AEB3-4390-AAFD-BA15E257F174.jpg":[function(require,module,exports) {
module.exports = "/map-61639B10-AEB3-4390-AAFD-BA15E257F174.95bbfa0b.jpg";
},{}],"src/assets/gltf/map-84EECF42-EC52-4843-9D60-A84F2B2F189A.jpg":[function(require,module,exports) {
module.exports = "/map-84EECF42-EC52-4843-9D60-A84F2B2F189A.5d1869fc.jpg";
},{}],"src/assets/gltf/map-8A5767B2-5854-4C51-B601-B218F4B1CAB3.jpg":[function(require,module,exports) {
module.exports = "/map-8A5767B2-5854-4C51-B601-B218F4B1CAB3.6662f8dc.jpg";
},{}],"src/assets/gltf/map-8BE18773-E490-48B0-8799-F10071581689.jpg":[function(require,module,exports) {
module.exports = "/map-8BE18773-E490-48B0-8799-F10071581689.b3741040.jpg";
},{}],"src/assets/gltf/map-95E4709A-A35D-4B74-9CF9-3A00E8805100.jpg":[function(require,module,exports) {
module.exports = "/map-95E4709A-A35D-4B74-9CF9-3A00E8805100.d54104d0.jpg";
},{}],"src/assets/gltf/map-9A24D72F-C314-4B3D-83E0-1633769C4335.jpg":[function(require,module,exports) {
module.exports = "/map-9A24D72F-C314-4B3D-83E0-1633769C4335.e7811fac.jpg";
},{}],"src/assets/gltf/map-B1791F03-1745-4A58-B1B2-E66309AA223F.jpg":[function(require,module,exports) {
module.exports = "/map-B1791F03-1745-4A58-B1B2-E66309AA223F.1467c479.jpg";
},{}],"src/assets/gltf/map-C2C4D224-8C13-475F-9702-5A70F0E3EBD7.jpg":[function(require,module,exports) {
module.exports = "/map-C2C4D224-8C13-475F-9702-5A70F0E3EBD7.10c9df0a.jpg";
},{}],"src/assets/gltf/map-CC6E3490-F52C-48B8-8FC3-E8E0D99C8C34.jpg":[function(require,module,exports) {
module.exports = "/map-CC6E3490-F52C-48B8-8FC3-E8E0D99C8C34.72616f81.jpg";
},{}],"src/assets/gltf/map-CFA60390-A98D-4E16-8F6D-09215731619C.jpg":[function(require,module,exports) {
module.exports = "/map-CFA60390-A98D-4E16-8F6D-09215731619C.3b7677aa.jpg";
},{}],"src/assets/gltf/map-E9EACF7C-BD3B-4052-8366-C50F0FC1E6DA.jpg":[function(require,module,exports) {
module.exports = "/map-E9EACF7C-BD3B-4052-8366-C50F0FC1E6DA.eb5d1751.jpg";
},{}],"src/assets/gltf/origin.glb":[function(require,module,exports) {
module.exports = "/origin.c637e0bb.glb";
},{}],"src/assets/gltf/sprites-forest-0.png":[function(require,module,exports) {
module.exports = "/sprites-forest-0.f2cfea87.png";
},{}],"src/assets/gltf/sprites-forest-1.png":[function(require,module,exports) {
module.exports = "/sprites-forest-1.d56677c0.png";
},{}],"src/assets/gltf/sprites-grasslands-0.png":[function(require,module,exports) {
module.exports = "/sprites-grasslands-0.0848c3dd.png";
},{}],"src/assets/gltf/sprites-origin-0.png":[function(require,module,exports) {
module.exports = "/sprites-origin-0.4ffb2b98.png";
},{}],"src/assets/gltf/sprites-tundra-0.png":[function(require,module,exports) {
module.exports = "/sprites-tundra-0.fc2f5afe.png";
},{}],"src/assets/gltf/tundra.glb":[function(require,module,exports) {
module.exports = "/tundra.63c44ec6.glb";
},{}],"src/assets/gltf/*.{gltf,glb,png,jpg}":[function(require,module,exports) {
module.exports = {
  "coin": {
    "gltf": require("./coin.gltf")
  },
  "forest": {
    "glb": require("./forest.glb")
  },
  "grasslands": {
    "glb": require("./grasslands.glb")
  },
  "hat": {
    "gltf": require("./hat.gltf")
  },
  "map-0A3C840A-1259-4342-94A8-476258923E0C": {
    "jpg": require("./map-0A3C840A-1259-4342-94A8-476258923E0C.jpg")
  },
  "map-0DB6312F-078E-464F-9597-198B12899E4D": {
    "jpg": require("./map-0DB6312F-078E-464F-9597-198B12899E4D.jpg")
  },
  "map-10C9B800-5663-492A-8F3A-BE6D7256387E": {
    "jpg": require("./map-10C9B800-5663-492A-8F3A-BE6D7256387E.jpg")
  },
  "map-19306294-F575-479A-AA37-C2DB5020A469": {
    "jpg": require("./map-19306294-F575-479A-AA37-C2DB5020A469.jpg")
  },
  "map-3CA1D1C7-F1C1-46A4-9892-094F299AA6FE": {
    "jpg": require("./map-3CA1D1C7-F1C1-46A4-9892-094F299AA6FE.jpg")
  },
  "map-554D4548-E3F4-4F92-8137-887B88B2E0AD": {
    "jpg": require("./map-554D4548-E3F4-4F92-8137-887B88B2E0AD.jpg")
  },
  "map-5B229F00-724F-42B0-A8B3-3F24E3FDD766": {
    "jpg": require("./map-5B229F00-724F-42B0-A8B3-3F24E3FDD766.jpg")
  },
  "map-5E463828-72AC-4402-93B9-F1A30FBAF1A9": {
    "jpg": require("./map-5E463828-72AC-4402-93B9-F1A30FBAF1A9.jpg")
  },
  "map-61639B10-AEB3-4390-AAFD-BA15E257F174": {
    "jpg": require("./map-61639B10-AEB3-4390-AAFD-BA15E257F174.jpg")
  },
  "map-84EECF42-EC52-4843-9D60-A84F2B2F189A": {
    "jpg": require("./map-84EECF42-EC52-4843-9D60-A84F2B2F189A.jpg")
  },
  "map-8A5767B2-5854-4C51-B601-B218F4B1CAB3": {
    "jpg": require("./map-8A5767B2-5854-4C51-B601-B218F4B1CAB3.jpg")
  },
  "map-8BE18773-E490-48B0-8799-F10071581689": {
    "jpg": require("./map-8BE18773-E490-48B0-8799-F10071581689.jpg")
  },
  "map-95E4709A-A35D-4B74-9CF9-3A00E8805100": {
    "jpg": require("./map-95E4709A-A35D-4B74-9CF9-3A00E8805100.jpg")
  },
  "map-9A24D72F-C314-4B3D-83E0-1633769C4335": {
    "jpg": require("./map-9A24D72F-C314-4B3D-83E0-1633769C4335.jpg")
  },
  "map-B1791F03-1745-4A58-B1B2-E66309AA223F": {
    "jpg": require("./map-B1791F03-1745-4A58-B1B2-E66309AA223F.jpg")
  },
  "map-C2C4D224-8C13-475F-9702-5A70F0E3EBD7": {
    "jpg": require("./map-C2C4D224-8C13-475F-9702-5A70F0E3EBD7.jpg")
  },
  "map-CC6E3490-F52C-48B8-8FC3-E8E0D99C8C34": {
    "jpg": require("./map-CC6E3490-F52C-48B8-8FC3-E8E0D99C8C34.jpg")
  },
  "map-CFA60390-A98D-4E16-8F6D-09215731619C": {
    "jpg": require("./map-CFA60390-A98D-4E16-8F6D-09215731619C.jpg")
  },
  "map-E9EACF7C-BD3B-4052-8366-C50F0FC1E6DA": {
    "jpg": require("./map-E9EACF7C-BD3B-4052-8366-C50F0FC1E6DA.jpg")
  },
  "origin": {
    "glb": require("./origin.glb")
  },
  "sprites-forest-0": {
    "png": require("./sprites-forest-0.png")
  },
  "sprites-forest-1": {
    "png": require("./sprites-forest-1.png")
  },
  "sprites-grasslands-0": {
    "png": require("./sprites-grasslands-0.png")
  },
  "sprites-origin-0": {
    "png": require("./sprites-origin-0.png")
  },
  "sprites-tundra-0": {
    "png": require("./sprites-tundra-0.png")
  },
  "tundra": {
    "glb": require("./tundra.glb")
  }
};
},{"./coin.gltf":"src/assets/gltf/coin.gltf","./forest.glb":"src/assets/gltf/forest.glb","./grasslands.glb":"src/assets/gltf/grasslands.glb","./hat.gltf":"src/assets/gltf/hat.gltf","./map-0A3C840A-1259-4342-94A8-476258923E0C.jpg":"src/assets/gltf/map-0A3C840A-1259-4342-94A8-476258923E0C.jpg","./map-0DB6312F-078E-464F-9597-198B12899E4D.jpg":"src/assets/gltf/map-0DB6312F-078E-464F-9597-198B12899E4D.jpg","./map-10C9B800-5663-492A-8F3A-BE6D7256387E.jpg":"src/assets/gltf/map-10C9B800-5663-492A-8F3A-BE6D7256387E.jpg","./map-19306294-F575-479A-AA37-C2DB5020A469.jpg":"src/assets/gltf/map-19306294-F575-479A-AA37-C2DB5020A469.jpg","./map-3CA1D1C7-F1C1-46A4-9892-094F299AA6FE.jpg":"src/assets/gltf/map-3CA1D1C7-F1C1-46A4-9892-094F299AA6FE.jpg","./map-554D4548-E3F4-4F92-8137-887B88B2E0AD.jpg":"src/assets/gltf/map-554D4548-E3F4-4F92-8137-887B88B2E0AD.jpg","./map-5B229F00-724F-42B0-A8B3-3F24E3FDD766.jpg":"src/assets/gltf/map-5B229F00-724F-42B0-A8B3-3F24E3FDD766.jpg","./map-5E463828-72AC-4402-93B9-F1A30FBAF1A9.jpg":"src/assets/gltf/map-5E463828-72AC-4402-93B9-F1A30FBAF1A9.jpg","./map-61639B10-AEB3-4390-AAFD-BA15E257F174.jpg":"src/assets/gltf/map-61639B10-AEB3-4390-AAFD-BA15E257F174.jpg","./map-84EECF42-EC52-4843-9D60-A84F2B2F189A.jpg":"src/assets/gltf/map-84EECF42-EC52-4843-9D60-A84F2B2F189A.jpg","./map-8A5767B2-5854-4C51-B601-B218F4B1CAB3.jpg":"src/assets/gltf/map-8A5767B2-5854-4C51-B601-B218F4B1CAB3.jpg","./map-8BE18773-E490-48B0-8799-F10071581689.jpg":"src/assets/gltf/map-8BE18773-E490-48B0-8799-F10071581689.jpg","./map-95E4709A-A35D-4B74-9CF9-3A00E8805100.jpg":"src/assets/gltf/map-95E4709A-A35D-4B74-9CF9-3A00E8805100.jpg","./map-9A24D72F-C314-4B3D-83E0-1633769C4335.jpg":"src/assets/gltf/map-9A24D72F-C314-4B3D-83E0-1633769C4335.jpg","./map-B1791F03-1745-4A58-B1B2-E66309AA223F.jpg":"src/assets/gltf/map-B1791F03-1745-4A58-B1B2-E66309AA223F.jpg","./map-C2C4D224-8C13-475F-9702-5A70F0E3EBD7.jpg":"src/assets/gltf/map-C2C4D224-8C13-475F-9702-5A70F0E3EBD7.jpg","./map-CC6E3490-F52C-48B8-8FC3-E8E0D99C8C34.jpg":"src/assets/gltf/map-CC6E3490-F52C-48B8-8FC3-E8E0D99C8C34.jpg","./map-CFA60390-A98D-4E16-8F6D-09215731619C.jpg":"src/assets/gltf/map-CFA60390-A98D-4E16-8F6D-09215731619C.jpg","./map-E9EACF7C-BD3B-4052-8366-C50F0FC1E6DA.jpg":"src/assets/gltf/map-E9EACF7C-BD3B-4052-8366-C50F0FC1E6DA.jpg","./origin.glb":"src/assets/gltf/origin.glb","./sprites-forest-0.png":"src/assets/gltf/sprites-forest-0.png","./sprites-forest-1.png":"src/assets/gltf/sprites-forest-1.png","./sprites-grasslands-0.png":"src/assets/gltf/sprites-grasslands-0.png","./sprites-origin-0.png":"src/assets/gltf/sprites-origin-0.png","./sprites-tundra-0.png":"src/assets/gltf/sprites-tundra-0.png","./tundra.glb":"src/assets/gltf/tundra.glb"}],"src/assets/gltf/meta.json":[function(require,module,exports) {
module.exports = module.exports = {
  "forest-items-autumn": {
    type: "forest",
    boundingBox: [[-15.075365, -.201858, -9.123892], [15.075365, 10.988423, 9.123892]],
    boundingCircle: {
      center: [0, 0],
      radius: 17.62135168228842
    }
  },
  "forest-items-dry": {
    type: "forest",
    boundingBox: [[-20.1001245, -.166717, -11.677783], [20.1001245, 10.988423, 11.677783]],
    boundingCircle: {
      center: [0, 0],
      radius: 23.246195833094696
    }
  },
  "forest-items-triangle": {
    type: "forest",
    boundingBox: [[-16.3033225, -.166717, -9.929113000000001], [16.3033225, 10.988423, 9.929113000000001]],
    boundingCircle: {
      center: [0, 0],
      radius: 19.088887068285967
    }
  },
  "forest-patch-01": {
    type: "forest",
    boundingBox: [[-4.282827470550442, -.225994, -5.5629157463329975], [4.282827470550442, 16.013626, 5.5629157463329975]],
    boundingCircle: {
      center: [0, 0],
      radius: 7.020587065431289
    }
  },
  "forest-patch-02": {
    type: "forest",
    boundingBox: [[-5.679010180449813, -.8172855571679642, -4.018972643388868], [5.679010180449813, 13.773834, 4.018972643388867]],
    boundingCircle: {
      center: [0, -8.881784197001252e-16],
      radius: 6.9572478565852975
    }
  },
  "forest-patch-03": {
    type: "forest",
    boundingBox: [[-7.050933692768162, -2.0237250280074877, -6.357039456992861], [7.05093369277567, 16.096272, 6.357039456992576]],
    boundingCircle: {
      center: [3.754330180072429e-12, -1.4299672557172016e-13],
      radius: 9.493556583158309
    }
  },
  "forest-patch-04": {
    type: "forest",
    boundingBox: [[-11.78628, -1.5445471634768424, -7.587937542475294], [11.78628, 15.291956, 7.5879377151416705]],
    boundingCircle: {
      center: [0, 8.63331885980756e-8],
      radius: 14.01760299398894
    }
  },
  "forest-patch-05": {
    type: "forest",
    boundingBox: [[-12.62494825, -1.5445471634768424, -11.368848], [12.62494825, 14.61118, 11.368848]],
    boundingCircle: {
      center: [0, 0],
      radius: 16.989409146944517
    }
  },
  "forest-patch-06": {
    type: "forest",
    boundingBox: [[-10.70346825, -1.5445471634768424, -11.918848], [10.70346825, 14.61118, 11.918848]],
    boundingCircle: {
      center: [0, 0],
      radius: 16.019462232729975
    }
  },
  "forest-patch-07": {
    type: "forest",
    boundingBox: [[-14.5646979992935, -.3694360944802759, -17.295879783627747], [14.564697999293498, 20.0170325, 17.295879783627747]],
    boundingCircle: {
      center: [0, 0],
      radius: 22.6114547364898
    }
  },
  "forest-patch-08": {
    type: "forest",
    boundingBox: [[-18.971581498912506, -.327765, -18.083026509657323], [18.971581498912506, 1.856911, 18.083026509657323]],
    boundingCircle: {
      center: [0, 0],
      radius: 26.209096747481567
    }
  },
  "forest-patch-09": {
    type: "forest",
    boundingBox: [[-8.731351668853138, -.327765, -6.684054056717754], [8.73135166885314, 1.486463, 6.684054056717753]],
    boundingCircle: {
      center: [1.7763568394002505e-15, 0],
      radius: 10.996048408328765
    }
  },
  "forest-patch-10": {
    type: "forest",
    boundingBox: [[-11.197153498005997, -.268145, -7.866099509657324], [11.197153498006, 1.856911, 7.866099509657323]],
    boundingCircle: {
      center: [1.7763568394002505e-15, -8.881784197001252e-16],
      radius: 13.683996782875212
    }
  },
  "forest-patch-11": {
    type: "forest",
    boundingBox: [[-8.983995498912504, -.268145, -7.866099509657324], [8.983995498912506, 1.486463, 7.866099509657323]],
    boundingCircle: {
      center: [1.7763568394002505e-15, -8.881784197001252e-16],
      radius: 11.941009028566695
    }
  },
  "forest-patch-12": {
    type: "forest",
    boundingBox: [[-7.330616433621152, -.3694360944802759, -8.510333287792683], [7.330616433621153, 14.043758, 8.510333287792681]],
    boundingCircle: {
      center: [0, 0],
      radius: 11.232262014669562
    }
  },
  "forest-patch-13": {
    type: "forest",
    boundingBox: [[-14.2951739443525, -.6105425455860001, -8.432619685039], [14.2951739443525, 14.967650787505, 8.432619685039]],
    boundingCircle: {
      center: [0, 0],
      radius: 16.597019999138457
    }
  },
  "forest-patch-14": {
    type: "forest",
    boundingBox: [[-9.470601411567001, -.6105425455860001, -7.050573921378], [9.470601411567, 13.472909359065, 7.050573921378]],
    boundingCircle: {
      center: [-1.7763568394002505e-15, 0],
      radius: 11.806899835163776
    }
  },
  "forest-patch-15": {
    type: "forest",
    boundingBox: [[-6.347426777728752, -.34234517972188266, -8.205905287232017], [6.347426777728751, 14.967650787505, 8.205905287232017]],
    boundingCircle: {
      center: [-8.881784197001252e-16, 0],
      radius: 10.37432929309892
    }
  },
  "forest-patch-16": {
    type: "forest",
    boundingBox: [[-13.431709136212001, -.6105425455860001, -8.432619685039], [13.431709136212001, 14.967650787505, 8.432619685039]],
    boundingCircle: {
      center: [0, 0],
      radius: 15.859378457944317
    }
  },
  "forest-patch-17": {
    type: "forest",
    boundingBox: [[-7.59376126906725, -.6105425455860001, -7.050573921378], [7.593761269067249, 14.482444680213, 7.050573921378]],
    boundingCircle: {
      center: [-8.881784197001252e-16, 0],
      radius: 10.3622296265042
    }
  },
  "forest-patch-18": {
    type: "forest",
    boundingBox: [[-5.5603789513075, -.03805385048043891, -8.205905287232017], [5.560378951307501, 14.967650787505, 8.205905287232017]],
    boundingCircle: {
      center: [0, 0],
      radius: 9.912350662943975
    }
  },
  "origin-patch-0": {
    type: "origin",
    boundingBox: [[-5.280339000000001, -.2832338416705871, -5.668591315287967], [5.001145, 10.19964, 3.65937712011832]],
    boundingCircle: {
      center: [-.1395970000000002, -1.004607097584823],
      radius: 6.941179805591266
    }
  },
  "tundra-items-basic": {
    type: "tundra",
    boundingBox: [[-8.8325125, -.13764725184078516, -11.163409000000001], [8.8325125, 3.927917, 11.163409000000001]],
    boundingCircle: {
      center: [0, 0],
      radius: 14.23499130888169
    }
  },
  "tundra-items-ice": {
    type: "tundra",
    boundingBox: [[-10.259167378689172, -.4111513000239432, -8.718396812160492], [10.25916737868917, 1.1697286148071289, 8.718396812160492]],
    boundingCircle: {
      center: [-1.7763568394002505e-15, 0],
      radius: 13.463318991922097
    }
  },
  "tundra-patch-rock-01": {
    type: "tundra",
    boundingBox: [[-8.469741291864153, -.22670792279715837, -11.065931719579186], [8.469741291864157, 6.068279626955509, 11.065931719579186]],
    boundingCircle: {
      center: [1.7763568394002505e-15, 0],
      radius: 13.935256092856616
    }
  },
  "tundra-patch-rock-02": {
    type: "tundra",
    boundingBox: [[-16.520271783891413, -.6568209019796876, -11.133370217871766], [16.52027178389141, 10.381391628779411, 11.133370217871768]],
    boundingCircle: {
      center: [-3.552713678800501e-15, 1.7763568394002505e-15],
      radius: 19.92162925620876
    }
  },
  "tundra-patch-rock-03": {
    type: "tundra",
    boundingBox: [[-10.268560327452711, -3.6310188780527115, -9.497291529625407], [10.018307334331904, 4.905083811461026, 9.49729152966382]],
    boundingCircle: {
      center: [-.1251264965604033, 1.9205970147595508e-11],
      radius: 13.895603487461416
    }
  },
  "tundra-patch-rock-04": {
    type: "tundra",
    boundingBox: [[-7.87126668514793, -2.1669320795611555, -8.236571820530331], [7.871266685387804, 2.4768795429526858, 8.236571820530333]],
    boundingCircle: {
      center: [1.199369492610458e-10, 1.7763568394002505e-15],
      radius: 11.392890528104013
    }
  },
  "tundra-patch-rock-05": {
    type: "tundra",
    boundingBox: [[-9.35049296050986, -3.0744205886997986, -8.983492483035336], [9.350493216352906, 4.3417406702058505, 8.983492484233793]],
    boundingCircle: {
      center: [1.279215222638186e-7, 5.992273344190835e-10],
      radius: 12.966682621253662
    }
  },
  "tundra-patch-rock-06": {
    type: "tundra",
    boundingBox: [[-14.893484516967165, -5.467920771498083, -14.308852236946258], [14.063264769059757, 6.345591006819735, 13.383327007132198]],
    boundingCircle: {
      center: [-.41510987395370513, -.46276261490702986],
      radius: 20.033410346843034
    }
  },
  "tundra-patch-rock-07": {
    type: "tundra",
    boundingBox: [[-14.407030459073379, -5.467920771498083, -9.779526112076555], [13.576810711165969, 5.790646771498082, 9.779526112076555]],
    boundingCircle: {
      center: [-.41510987395370513, 0],
      radius: 17.070822260133895
    }
  },
  "tundra-patch-rock-08": {
    type: "tundra",
    boundingBox: [[-11.606490749999999, -4.038116878052712, -8.678903948533314], [11.60649075, 4.8079788993186945, 8.678903704277717]],
    boundingCircle: {
      center: [0, -1.2212779765263804e-7],
      radius: 14.49254978110587
    }
  },
  "grasslands-items-field": {
    type: "grasslands",
    boundingBox: [[-7.623313964143387, -.174038, -10.987582973752348], [7.623313964143387, 2.62681, 10.98758297375235]],
    boundingCircle: {
      center: [0, 1.7763568394002505e-15],
      radius: 13.373178208675606
    }
  },
  "grasslands-items-water": {
    type: "grasslands",
    boundingBox: [[-4.323165250000001, -.0691744677450005, -2.7235592888081], [4.32316525, 1.8051, 2.7235592888081]],
    boundingCircle: {
      center: [0, 0],
      radius: 5.109553109466663
    }
  },
  "grasslands-items-wet": {
    type: "grasslands",
    boundingBox: [[-7.412936621334076, 0, -9.3358775], [7.412936621334076, 1.887006, 9.3358775]],
    boundingCircle: {
      center: [0, 0],
      radius: 11.920999876139675
    }
  },
  "grasslands-items-yellow": {
    type: "grasslands",
    boundingBox: [[-9.128126714143386, -.05953242321757357, -10.987582973752348], [9.128126714143386, 1.847419, 10.98758297375235]],
    boundingCircle: {
      center: [0, 1.7763568394002505e-15],
      radius: 14.284595791080358
    }
  },
  "grasslands-patch-01": {
    type: "grasslands",
    boundingBox: [[-14.959938216016791, -3.6909649259600004, -15.666905179722484], [14.959938216016791, 4.328240447011341, 15.666905179722482]],
    boundingCircle: {
      center: [0, 0],
      radius: 21.66221755355289
    }
  },
  "grasslands-patch-02": {
    type: "grasslands",
    boundingBox: [[-15.080166880418545, -.7677941213827133, -15.51645185207366], [15.080166880418542, 4.411131786013842, 15.51645185207366]],
    boundingCircle: {
      center: [-1.7763568394002505e-15, 0],
      radius: 21.63727596577241
    }
  },
  "grasslands-patch-03": {
    type: "grasslands",
    boundingBox: [[-14.960831770021974, -.7677941213827133, -9.253754335327436], [14.960831770021972, 4.411131786013842, 9.253754335327436]],
    boundingCircle: {
      center: [-1.7763568394002505e-15, 0],
      radius: 17.59143133885046
    }
  },
  "grasslands-patch-04": {
    type: "grasslands",
    boundingBox: [[-11.609907879139005, -.7408588420858384, -10.60802881274413], [11.609907879139005, 5.171772259669173, 10.60802881274413]],
    boundingCircle: {
      center: [0, 0],
      radius: 15.726418417875813
    }
  },
  "grasslands-patch-05": {
    type: "grasslands",
    boundingBox: [[-10.771474194501113, -1.108371, -9.920363270294326], [10.771474194501112, 4.488878414156625, 9.920363270294327]],
    boundingCircle: {
      center: [0, 1.7763568394002505e-15],
      radius: 14.643710722948887
    }
  },
  "grasslands-patch-06": {
    type: "grasslands",
    boundingBox: [[-8.876350413088124, -.360653, -8.983931123813939], [8.876350413088124, 3.158583462026596, 8.983931123813939]],
    boundingCircle: {
      center: [0, 0],
      radius: 12.629355292071029
    }
  },
  "grasslands-patch-07": {
    type: "grasslands",
    boundingBox: [[-15.12404227126358, -.437882, -15.125275886896539], [15.12404227126358, 2.64724140059495, 15.125275886896539]],
    boundingCircle: {
      center: [0, 0],
      radius: 21.389498013691238
    }
  },
  "grasslands-patch-08": {
    type: "grasslands",
    boundingBox: [[-15.495199489332597, -.437882, -15.53378018801633], [15.495199489332599, 2.64724140059495, 15.533780188016332]],
    boundingCircle: {
      center: [1.7763568394002505e-15, 0],
      radius: 21.940818903218307
    }
  },
  "grasslands-patch-09": {
    type: "grasslands",
    boundingBox: [[-15.495199489332597, -.437882, -15.53378018801633], [15.495199489332599, 2.64724140059495, 15.533780188016332]],
    boundingCircle: {
      center: [1.7763568394002505e-15, 0],
      radius: 21.940818903218307
    }
  },
  "grasslands-patch-10": {
    type: "grasslands",
    boundingBox: [[-15.204815010466952, -.437882, -15.125275886896539], [15.204815010466952, 1.4065690000000002, 15.125275886896539]],
    boundingCircle: {
      center: [0, 0],
      radius: 21.446686694155233
    }
  },
  "grasslands-patch-11": {
    type: "grasslands",
    boundingBox: [[-6.212267913747341, -.053716637376036436, -7.429459542071392], [6.2122679137473416, 4.328240447011341, 7.429459542071392]],
    boundingCircle: {
      center: [8.881784197001252e-16, 0],
      radius: 9.684479424287627
    }
  },
  "grasslands-patch-wetlands-01": {
    type: "grasslands",
    boundingBox: [[-7.17840425, -.477838, -4.578204980444312], [7.17840425, 1.893844, 4.578204980444312]],
    boundingCircle: {
      center: [0, 0],
      radius: 8.514073550268588
    }
  },
  "grasslands-patch-wetlands-02": {
    type: "grasslands",
    boundingBox: [[-6.306689158825398, -.743551, -4.0401339732815025], [6.306689158825398, 1.893844, 4.0401339732815025]],
    boundingCircle: {
      center: [0, 0],
      radius: 7.489793766727438
    }
  },
  "grasslands-patch-wetlands-03": {
    type: "grasslands",
    boundingBox: [[-7.119687073700281, -.477838, -4.3895528552785725], [7.119687073700281, 3.1333588074259757, 4.389552855278571]],
    boundingCircle: {
      center: [0, -8.881784197001252e-16],
      radius: 8.364096980349949
    }
  },
  "grasslands-patch-wetlands-04": {
    type: "grasslands",
    boundingBox: [[-5.479535, -.1604245623280853, -3.483777072610855], [5.479535, 2.1422665485835077, 3.483777072610855]],
    boundingCircle: {
      center: [0, 0],
      radius: 6.493227741876459
    }
  },
  "grasslands-patch-wetlands-05": {
    type: "grasslands",
    boundingBox: [[-6.196706936844499, -.477838, -5.6178066792835], [6.1967069368445, 1.893844, 5.617806679283499]],
    boundingCircle: {
      center: [8.881784197001252e-16, -8.881784197001252e-16],
      radius: 8.364145428370973
    }
  },
  "grasslands-patch-wetlands-06": {
    type: "grasslands",
    boundingBox: [[-9.886904918619768, -.477838, -6.46925514625175], [9.886904918619766, 1.929008, 6.469255146251749]],
    boundingCircle: {
      center: [-1.7763568394002505e-15, -8.881784197001252e-16],
      radius: 11.815335417038844
    }
  },
  "grasslands-patch-wetlands-07": {
    type: "grasslands",
    boundingBox: [[-6.402575567778268, -.477838, -5.982054236971601], [6.402575567778268, 1.929008, 5.982054236971601]],
    boundingCircle: {
      center: [0, 0],
      radius: 8.762302596645535
    }
  }
};
;
},{}],"src/assets/gltf/sprites-forest.json":[function(require,module,exports) {
module.exports = module.exports = {
  name: "sprites-forest",
  frames: [[{
    id: "67294C14-EF1A-4AF8-BB5F-8931621A01F8",
    x: 2,
    y: 2,
    w: 706,
    h: 256
  }, {
    id: "D3023B91-0D14-4C90-8F6D-2CA9E616804A",
    x: 2,
    y: 260,
    w: 706,
    h: 256
  }, {
    id: "15FDCF1E-B75B-4AD5-9A1F-51462126B983",
    x: 2,
    y: 518,
    w: 660,
    h: 256
  }, {
    id: "D0C25487-3087-47CD-B9C8-FC37D7E87396",
    x: 664,
    y: 518,
    w: 660,
    h: 256
  }, {
    id: "9F9AFA55-44A5-4539-8066-786C33BFA3CF",
    x: 710,
    y: 2,
    w: 580,
    h: 154
  }, {
    id: "694CC69A-37B1-4108-BD6B-BD6D80C765A5",
    x: 710,
    y: 158,
    w: 580,
    h: 154
  }, {
    id: "3C4AE536-1BCE-48D7-90E0-6EA95120DB56",
    x: 2,
    y: 776,
    w: 319,
    h: 512
  }, {
    id: "200B1345-E245-4BD6-A133-D362B8C79468",
    x: 323,
    y: 776,
    w: 284,
    h: 512
  }, {
    id: "7FD2B13D-374A-4FBA-B0B8-6AFF6D0AD473",
    x: 609,
    y: 776,
    w: 255,
    h: 512
  }, {
    id: "5200A118-22E4-446B-B07F-E1AB2D8275D7",
    x: 866,
    y: 776,
    w: 243,
    h: 512
  }, {
    id: "474D93F1-70A8-4B81-BAB1-83CDEF88983B",
    x: 2,
    y: 1290,
    w: 280,
    h: 512
  }, {
    id: "FB1FE2FA-8594-492D-8A27-7C3268B0302B",
    x: 284,
    y: 1290,
    w: 354,
    h: 512
  }, {
    id: "76635BA8-2B70-45C0-8284-5009E6C13D3A",
    x: 640,
    y: 1290,
    w: 354,
    h: 512
  }, {
    id: "BB410FB3-19E2-42EC-B23A-1A065363C543",
    x: 996,
    y: 1290,
    w: 243,
    h: 512
  }, {
    id: "64135345-B589-4847-9449-CE88B327F315",
    x: 1111,
    y: 776,
    w: 150,
    h: 512
  }, {
    id: "E113EB20-B7F7-46BD-9065-A91588D2A1EC",
    x: 1241,
    y: 1290,
    w: 169,
    h: 512
  }, {
    id: "B7B3A496-E705-4973-B0FF-BA1D43B42F4F",
    x: 1263,
    y: 776,
    w: 256,
    h: 512
  }, {
    id: "6FDC8BD1-0459-49DA-A212-611A7E9F607F",
    x: 1412,
    y: 1290,
    w: 312,
    h: 501
  }, {
    id: "6A045629-CB5F-45ED-974F-7F4F5EEC138D",
    x: 1292,
    y: 2,
    w: 312,
    h: 501
  }, {
    id: "A4FD1645-A4D5-4A87-95BB-DE692A857F7B",
    x: 1521,
    y: 505,
    w: 312,
    h: 501
  }, {
    id: "7946261F-3A99-4652-802B-58EDAC13FB69",
    x: 710,
    y: 314,
    w: 472,
    h: 125
  }, {
    id: "C9587649-B939-45E8-9097-F909053FD963",
    x: 2,
    y: 1804,
    w: 472,
    h: 125
  }, {
    id: "E409C6F3-5350-473F-9957-CC005E66DA10",
    x: 1521,
    y: 1008,
    w: 333,
    h: 256
  }, {
    id: "D5E397E9-F9CC-4430-8403-CD74DDB4A09A",
    x: 1606,
    y: 2,
    w: 214,
    h: 256
  }, {
    id: "4DEBC28F-CC95-4631-B620-86E50A2282D1",
    x: 1326,
    y: 505,
    w: 184,
    h: 256
  }, {
    id: "9B20BD15-62FA-4669-8829-13981D18F6FE",
    x: 1726,
    y: 1266,
    w: 113,
    h: 256
  }, {
    id: "7E224099-CB10-480E-AA42-BDA2C5EE2DCE",
    x: 1606,
    y: 260,
    w: 151,
    h: 181
  }, {
    id: "72C6CB9C-EF46-46E5-B277-D4A082D0C704",
    x: 1856,
    y: 2,
    w: 151,
    h: 181
  }, {
    id: "7A047DBE-B785-4A6F-A7D1-18654BEC802F",
    x: 476,
    y: 1804,
    w: 52,
    h: 106
  }, {
    id: "C5F6AD70-D605-40AD-8055-143DAC798B46",
    x: 530,
    y: 1804,
    w: 60,
    h: 83
  }, {
    id: "C342A4B3-66C6-45E5-A39F-FBC4FE5A085E",
    x: 592,
    y: 1804,
    w: 60,
    h: 83
  }], [{
    id: "E44FE03F-EC29-4753-AF0E-895B951AFD42",
    x: 2,
    y: 2,
    w: 488,
    h: 256
  }, {
    id: "34E60BA5-7E9D-4BDA-B6E5-19E474F18C84",
    x: 2,
    y: 260,
    w: 488,
    h: 256
  }, {
    id: "1F644C9D-CE32-4667-A423-212879544372",
    x: 492,
    y: 2,
    w: 431,
    h: 143
  }, {
    id: "77BF338F-5948-4A23-900D-652440F7C5A7",
    x: 492,
    y: 147,
    w: 348,
    h: 185
  }, {
    id: "4F18AF0D-5A0E-43BD-B5DC-D7AB1AE2F51B",
    x: 492,
    y: 334,
    w: 300,
    h: 175
  }, {
    id: "2150843C-15A9-4274-980E-3244D20CAA59",
    x: 2,
    y: 518,
    w: 292,
    h: 256
  }, {
    id: "A65F86AF-621C-4D69-9383-232F4A045463",
    x: 296,
    y: 518,
    w: 286,
    h: 256
  }, {
    id: "531C91F2-2508-469A-8117-E2E981EA6A33",
    x: 584,
    y: 511,
    w: 257,
    h: 203
  }, {
    id: "35B446D4-87AC-452F-AC6C-F88D4F38CD8A",
    x: 2,
    y: 776,
    w: 214,
    h: 256
  }, {
    id: "3111DE17-2B61-4EBE-8BA4-D7EC477AD571",
    x: 218,
    y: 776,
    w: 213,
    h: 256
  }, {
    id: "55DFC82B-9970-44B3-A887-654CA5BB772D",
    x: 433,
    y: 776,
    w: 233,
    h: 256
  }, {
    id: "A32211DA-F0B6-4449-A465-66015AC5ABE5",
    x: 668,
    y: 716,
    w: 249,
    h: 256
  }]],
  images: [{
    width: 2010,
    height: 1931
  }, {
    width: 925,
    height: 1034
  }]
};
;
},{}],"src/assets/gltf/sprites-grasslands.json":[function(require,module,exports) {
module.exports = module.exports = {
  name: "sprites-grasslands",
  frames: [[{
    id: "272CEE5F-A472-4CA5-A600-88C97949B9D1",
    x: 2,
    y: 2,
    w: 613,
    h: 256
  }, {
    id: "92C81C7F-4C91-4A70-BA1B-B2B2B1E47A9B",
    x: 2,
    y: 260,
    w: 564,
    h: 256
  }, {
    id: "FE57E7C9-22FB-44A6-93B4-2045102DDF6B",
    x: 2,
    y: 518,
    w: 462,
    h: 256
  }, {
    id: "6FA38119-6C0C-44F3-889F-496E8D51D25A",
    x: 617,
    y: 2,
    w: 379,
    h: 248
  }, {
    id: "14D5CD8C-26D1-4B3E-B5CB-6268B7F2910D",
    x: 466,
    y: 518,
    w: 319,
    h: 256
  }, {
    id: "C1A7A698-9EBB-4B24-932E-72D6120A3FFB",
    x: 568,
    y: 260,
    w: 319,
    h: 256
  }, {
    id: "447CCD67-AA9F-4D4D-831E-2D4B4AC39FA3",
    x: 2,
    y: 776,
    w: 319,
    h: 256
  }, {
    id: "BB607FAF-EF57-4EC6-853B-4F8AA9D94099",
    x: 323,
    y: 776,
    w: 319,
    h: 256
  }, {
    id: "87C25A5F-357A-4ED4-AE02-C3BC9A00B125",
    x: 644,
    y: 776,
    w: 284,
    h: 197
  }, {
    id: "4282A509-F0EE-4B3A-8A0A-3716682CBA18",
    x: 787,
    y: 518,
    w: 59,
    h: 256
  }, {
    id: "26F6F112-A247-43B6-A304-A096C69397C3",
    x: 848,
    y: 518,
    w: 59,
    h: 256
  }, {
    id: "38583CBC-4C68-47B6-8AC2-762F789EC3A5",
    x: 889,
    y: 252,
    w: 77,
    h: 256
  }, {
    id: "656660D5-68B2-4509-854E-A6FA2D70D809",
    x: 998,
    y: 2,
    w: 129,
    h: 256
  }, {
    id: "8225022F-694B-4EE7-AE15-A87FB613D243",
    x: 909,
    y: 510,
    w: 151,
    h: 256
  }, {
    id: "10476B9E-A1C7-4BA0-BC31-B580E3A2D252",
    x: 930,
    y: 768,
    w: 151,
    h: 256
  }, {
    id: "997789AE-F835-4778-95A7-A35CD2E43E4D",
    x: 2,
    y: 1034,
    w: 128,
    h: 256
  }, {
    id: "2D285696-01B4-4459-AD74-4BB85BA63FCF",
    x: 132,
    y: 1034,
    w: 224,
    h: 256
  }, {
    id: "4A747DC3-EF7B-492A-96DD-F862FBDBFDB5",
    x: 358,
    y: 1034,
    w: 140,
    h: 256
  }, {
    id: "159F5249-279B-4252-82C4-C41A0F0B7BC0",
    x: 500,
    y: 1034,
    w: 179,
    h: 256
  }, {
    id: "177F1D36-0623-4ACF-91FF-3D7119452232",
    x: 681,
    y: 1026,
    w: 150,
    h: 256
  }, {
    id: "39B9478E-3AAE-4D2B-93B6-CB8C4EECFC80",
    x: 833,
    y: 1026,
    w: 224,
    h: 256
  }, {
    id: "AD1BF24C-4FD3-4FCF-93EA-09E93B2E313B",
    x: 1129,
    y: 2,
    w: 215,
    h: 256
  }, {
    id: "F342F4E7-C2C0-4E3C-9FB7-93349C420A46",
    x: 968,
    y: 252,
    w: 25,
    h: 256
  }, {
    id: "8D0A87D9-B1F6-48C1-8F04-CD1F59BE22F3",
    x: 1059,
    y: 1026,
    w: 215,
    h: 256
  }, {
    id: "4895E2C7-D5D5-4D02-88CE-77E1BBA9913D",
    x: 1083,
    y: 260,
    w: 88,
    h: 256
  }, {
    id: "E55BD68A-8FD1-45D1-A01F-43CB85807C59",
    x: 1276,
    y: 260,
    w: 47,
    h: 256
  }, {
    id: "4E515EB2-B904-442B-BCDB-7D671447F7C6",
    x: 1173,
    y: 260,
    w: 88,
    h: 256
  }, {
    id: "14B6073B-71AD-4486-B074-1FC52F371FDB",
    x: 1083,
    y: 518,
    w: 173,
    h: 256
  }, {
    id: "8CBE7088-0036-4A84-90B3-F8A42FE538B8",
    x: 2,
    y: 1292,
    w: 248,
    h: 256
  }, {
    id: "DA1E3CE8-278B-47B9-BF7B-438E5F5BF687",
    x: 252,
    y: 1292,
    w: 176,
    h: 256
  }, {
    id: "66A3A3B8-1F1A-4CFF-8D90-CA6045326BBD",
    x: 430,
    y: 1292,
    w: 113,
    h: 256
  }, {
    id: "28B0D1BD-9F16-4B35-8B58-B4AEAD15134D",
    x: 545,
    y: 1292,
    w: 214,
    h: 256
  }, {
    id: "C9DAEE46-E76B-4E1F-9FA5-D4B631BE3BB0",
    x: 761,
    y: 1284,
    w: 190,
    h: 256
  }, {
    id: "C17EE260-68CC-4154-8486-E556444748A0",
    x: 953,
    y: 1284,
    w: 224,
    h: 256
  }, {
    id: "78B40147-FE41-47F1-A198-08E7F1666C6F",
    x: 1179,
    y: 1284,
    w: 113,
    h: 256
  }, {
    id: "845BAF92-DAA7-4D5B-AC73-5F1FCB0D98A2",
    x: 1346,
    y: 2,
    w: 176,
    h: 256
  }, {
    id: "4A3A388F-7316-46A6-A459-79BB449DE3BF",
    x: 1294,
    y: 518,
    w: 224,
    h: 256
  }, {
    id: "FF97616C-0E3F-4DD7-B21D-9C62E034E1C5",
    x: 1325,
    y: 260,
    w: 100,
    h: 256
  }, {
    id: "829BF8AC-A4B1-4BF8-8376-04162F33CD76",
    x: 1294,
    y: 776,
    w: 153,
    h: 256
  }, {
    id: "596C0606-0D9C-436F-9760-75258E264B0D",
    x: 1294,
    y: 1034,
    w: 153,
    h: 256
  }, {
    id: "42343ABE-D860-4F4D-B74D-1E2809226F61",
    x: 1294,
    y: 1292,
    w: 100,
    h: 256
  }, {
    id: "DB5AFCB3-5F84-4E19-93B6-30A3C6C12959",
    x: 1427,
    y: 260,
    w: 173,
    h: 256
  }, {
    id: "B28BDFF1-A351-4EB0-B74D-25BD39CBF590",
    x: 1396,
    y: 1292,
    w: 125,
    h: 256
  }, {
    id: "328AD96F-C60B-4B4E-A543-0AD2A427204E",
    x: 1524,
    y: 2,
    w: 145,
    h: 256
  }, {
    id: "99136B7E-AD50-43D6-BB49-3F35B179353B",
    x: 1083,
    y: 776,
    w: 188,
    h: 238
  }, {
    id: "9FB4FF7E-DD1E-485D-9E08-270C3CC75DCF",
    x: 1449,
    y: 776,
    w: 188,
    h: 238
  }, {
    id: "6DD1ADCB-DC65-4F60-994B-2A2769506F72",
    x: 1449,
    y: 1016,
    w: 188,
    h: 238
  }, {
    id: "C407E6EC-8BC1-4588-B03A-045C6D2214E3",
    x: 1523,
    y: 1256,
    w: 158,
    h: 216
  }, {
    id: "37870464-078A-456E-BEDB-B1F56233DF2A",
    x: 995,
    y: 260,
    w: 72,
    h: 186
  }, {
    id: "E1E25202-78F2-48E4-9326-31ECF38B57F2",
    x: 1520,
    y: 518,
    w: 118,
    h: 179
  }, {
    id: "7F355756-B79B-420F-827A-88185C25E4B9",
    x: 2,
    y: 1550,
    w: 118,
    h: 179
  }, {
    id: "83586F94-349F-48B1-8E6F-31A2D035C3FB",
    x: 122,
    y: 1550,
    w: 118,
    h: 179
  }, {
    id: "23B4A43A-76A1-4364-B844-2E22D6C7C7AD",
    x: 242,
    y: 1550,
    w: 118,
    h: 179
  }, {
    id: "F7A31617-D992-4797-AD56-01D72E9C7A57",
    x: 1523,
    y: 1474,
    w: 173,
    h: 107
  }, {
    id: "FB695BDB-085E-4533-85EA-35CA6927534D",
    x: 1520,
    y: 699,
    w: 157,
    h: 69
  }, {
    id: "0D478784-C3EB-4028-AA86-1999670A0885",
    x: 1602,
    y: 260,
    w: 84,
    h: 149
  }, {
    id: "CE380EE5-CBF2-41E8-A056-B91DC3B7AE14",
    x: 362,
    y: 1583,
    w: 146,
    h: 69
  }, {
    id: "157E3CF4-FEB6-4558-A985-9F59E0CF9DF1",
    x: 510,
    y: 1583,
    w: 73,
    h: 124
  }]],
  images: [{
    width: 1699,
    height: 1731
  }]
};
;
},{}],"src/assets/gltf/sprites-origin.json":[function(require,module,exports) {
module.exports = module.exports = {
  name: "sprites-origin",
  frames: [[{
    id: "C814F21A-DCEF-47F0-A4B1-5D18493C9FCD",
    x: 2,
    y: 2,
    w: 512,
    h: 512
  }]],
  images: [{
    width: 516,
    height: 516
  }]
};
;
},{}],"src/assets/gltf/sprites-tundra.json":[function(require,module,exports) {
module.exports = module.exports = {
  name: "sprites-tundra",
  frames: [[{
    id: "2ADEE4BA-D634-4AE2-9E34-847720036905",
    x: 2,
    y: 2,
    w: 423,
    h: 256
  }, {
    id: "0C1AFF0C-B255-4053-8F3E-7978F605B5D0",
    x: 2,
    y: 260,
    w: 397,
    h: 256
  }, {
    id: "EBD22B3A-DD03-4BB8-ACB3-01749D82A483",
    x: 401,
    y: 260,
    w: 372,
    h: 256
  }, {
    id: "5E4192AF-6D8D-4989-AC17-D590045E491B",
    x: 427,
    y: 2,
    w: 288,
    h: 256
  }, {
    id: "8EEE2A15-69BE-4517-BF3B-3BC21A9CB6D8",
    x: 2,
    y: 518,
    w: 288,
    h: 256
  }, {
    id: "B1F97040-C8B3-43B4-AEDC-62832559C2A5",
    x: 292,
    y: 518,
    w: 285,
    h: 256
  }, {
    id: "22F536A6-14AD-49CC-8E3D-EE8D9FC21E0E",
    x: 579,
    y: 518,
    w: 164,
    h: 256
  }, {
    id: "F6608748-5508-4CB3-BF1E-92DB889FDDAC",
    x: 2,
    y: 776,
    w: 102,
    h: 256
  }, {
    id: "07A77C07-3CEA-42C3-8F5A-80A3CF6C0207",
    x: 106,
    y: 776,
    w: 112,
    h: 256
  }, {
    id: "051EF604-6EA1-467A-BEE6-65416C43E48D",
    x: 220,
    y: 776,
    w: 157,
    h: 256
  }, {
    id: "775CCE63-C68E-4A1E-BEEB-85C25EA90573",
    x: 379,
    y: 776,
    w: 95,
    h: 256
  }, {
    id: "AF28AE6A-0DC7-4939-8D49-80B5D2289AE5",
    x: 476,
    y: 776,
    w: 141,
    h: 256
  }, {
    id: "49E1172E-8FE2-42F3-9E51-71527EC1051E",
    x: 619,
    y: 776,
    w: 161,
    h: 256
  }, {
    id: "E1B090AE-7227-4E22-9F91-3523A71E9852",
    x: 717,
    y: 2,
    w: 147,
    h: 256
  }, {
    id: "247C70CB-47F4-41AB-99A6-870C24E6D8B5",
    x: 745,
    y: 518,
    w: 147,
    h: 256
  }, {
    id: "F6BC2B99-0869-4309-A283-F101EF7F1DF0",
    x: 775,
    y: 260,
    w: 105,
    h: 256
  }, {
    id: "82F07511-B165-43BB-82A0-3DCB8CED9CB6",
    x: 782,
    y: 776,
    w: 163,
    h: 256
  }, {
    id: "B7BF4F8D-67AE-474B-B7A9-621D961AF81D",
    x: 866,
    y: 2,
    w: 159,
    h: 256
  }, {
    id: "AC17F6A7-D39E-4EC7-AD53-3DB7F7382C0B",
    x: 882,
    y: 260,
    w: 158,
    h: 256
  }, {
    id: "BE472EC6-4177-4DE5-A8AE-B9179F5FD73D",
    x: 894,
    y: 518,
    w: 207,
    h: 256
  }, {
    id: "682EEA65-3EEB-4D5B-9A15-C29397F47783",
    x: 2,
    y: 1034,
    w: 204,
    h: 256
  }, {
    id: "24B4566B-D599-4096-B720-8E81B15BA4CF",
    x: 208,
    y: 1034,
    w: 205,
    h: 256
  }, {
    id: "2A08376C-C912-40B9-A013-A505DE480FD3",
    x: 415,
    y: 1034,
    w: 204,
    h: 256
  }, {
    id: "5096DBF2-2498-4053-BBC6-56DCE99A4CFA",
    x: 621,
    y: 1034,
    w: 105,
    h: 256
  }, {
    id: "FDE9698A-B5C6-4669-8849-FA2740AFA2F5",
    x: 728,
    y: 1034,
    w: 105,
    h: 256
  }, {
    id: "209C5714-30A8-4438-A5F5-2ADF19A061EA",
    x: 835,
    y: 1034,
    w: 105,
    h: 256
  }, {
    id: "B67B0A7A-A20F-41BB-8678-B7E2D8FF17B5",
    x: 942,
    y: 1034,
    w: 105,
    h: 256
  }, {
    id: "9D1E1373-0BD4-489E-928B-B14480890D02",
    x: 947,
    y: 776,
    w: 105,
    h: 256
  }, {
    id: "0460DCAA-ED7A-4F59-A337-B1622C92E62D",
    x: 1027,
    y: 2,
    w: 105,
    h: 256
  }, {
    id: "2B3AD1B2-0277-4C92-8105-48A1B395C9E9",
    x: 1049,
    y: 1034,
    w: 232,
    h: 256
  }, {
    id: "8ADAC56A-2108-4C19-8D4A-2815DC1B82E2",
    x: 1042,
    y: 260,
    w: 232,
    h: 256
  }, {
    id: "A5B847C2-6951-4E21-9055-520B0EC7F1AD",
    x: 1054,
    y: 776,
    w: 215,
    h: 256
  }, {
    id: "E438792C-F36B-4D86-91B1-980207835107",
    x: 1134,
    y: 2,
    w: 232,
    h: 256
  }, {
    id: "206B9D1C-15C0-4887-9E46-9DB46E052C84",
    x: 1103,
    y: 518,
    w: 161,
    h: 256
  }, {
    id: "B8F11F36-5A33-4DA4-8DC7-3C3461C64EA0",
    x: 2,
    y: 1292,
    w: 204,
    h: 256
  }, {
    id: "446682BA-30CD-472C-A05C-87863D6CA8B4",
    x: 1266,
    y: 518,
    w: 113,
    h: 239
  }, {
    id: "8E5EC789-52F4-4603-9835-1726FEF2835A",
    x: 208,
    y: 1292,
    w: 188,
    h: 238
  }, {
    id: "41441AC2-F2C2-4A8F-860F-63EE69FBF3D4",
    x: 398,
    y: 1292,
    w: 188,
    h: 238
  }, {
    id: "044B0250-2E97-4675-A25F-DEF4933070CB",
    x: 588,
    y: 1292,
    w: 226,
    h: 159
  }, {
    id: "EFE8E349-BB06-45B0-8C90-CEFF7C91DDF1",
    x: 816,
    y: 1292,
    w: 204,
    h: 141
  }, {
    id: "2547E4A8-05BC-4344-A43D-D57E894FD4FF",
    x: 1283,
    y: 759,
    w: 123,
    h: 185
  }, {
    id: "EA3AD5F2-3868-4FA3-B74D-6C8D15220124",
    x: 1283,
    y: 946,
    w: 118,
    h: 179
  }, {
    id: "0E194309-4864-4FDF-A71E-FDE2C49EF348",
    x: 1283,
    y: 1127,
    w: 118,
    h: 179
  }, {
    id: "4601ADDE-E3F7-4B72-9123-5B44D27B8DDF",
    x: 1276,
    y: 260,
    w: 118,
    h: 179
  }, {
    id: "382F966C-0A31-43CB-9357-0E0E7EF699FA",
    x: 1381,
    y: 441,
    w: 68,
    h: 160
  }, {
    id: "0DC724E1-ED07-43DA-AC37-E68D4C992BF1",
    x: 1381,
    y: 603,
    w: 59,
    h: 123
  }, {
    id: "3E434D3C-6022-4C03-9174-DF575F0394E4",
    x: 1396,
    y: 2,
    w: 52,
    h: 118
  }, {
    id: "B5718C69-661D-4F3B-83D1-54D0F5696911",
    x: 1022,
    y: 1308,
    w: 100,
    h: 114
  }, {
    id: "EAE51B1B-A07D-41CF-8ADE-C0912D41367C",
    x: 588,
    y: 1453,
    w: 109,
    h: 95
  }, {
    id: "B4FAE2BF-E183-463D-8FF1-E46A1264B55E",
    x: 1368,
    y: 122,
    w: 66,
    h: 58
  }]],
  images: [{
    width: 1452,
    height: 1550
  }]
};
;
},{}],"src/assets/gltf/sprites-*.json":[function(require,module,exports) {
module.exports = {
  "forest": require("./sprites-forest.json"),
  "grasslands": require("./sprites-grasslands.json"),
  "origin": require("./sprites-origin.json"),
  "tundra": require("./sprites-tundra.json")
};
},{"./sprites-forest.json":"src/assets/gltf/sprites-forest.json","./sprites-grasslands.json":"src/assets/gltf/sprites-grasslands.json","./sprites-origin.json":"src/assets/gltf/sprites-origin.json","./sprites-tundra.json":"src/assets/gltf/sprites-tundra.json"}],"src/assets/gltf/sprites-*.png":[function(require,module,exports) {
module.exports = {
  "forest-0": require("./sprites-forest-0.png"),
  "forest-1": require("./sprites-forest-1.png"),
  "grasslands-0": require("./sprites-grasslands-0.png"),
  "origin-0": require("./sprites-origin-0.png"),
  "tundra-0": require("./sprites-tundra-0.png")
};
},{"./sprites-forest-0.png":"src/assets/gltf/sprites-forest-0.png","./sprites-forest-1.png":"src/assets/gltf/sprites-forest-1.png","./sprites-grasslands-0.png":"src/assets/gltf/sprites-grasslands-0.png","./sprites-origin-0.png":"src/assets/gltf/sprites-origin-0.png","./sprites-tundra-0.png":"src/assets/gltf/sprites-tundra-0.png"}],"src/util/objects.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fastAssign = fastAssign;

function fastAssign(target, opts) {
  if (opts) {
    for (let key in opts) {
      if (Object.prototype.hasOwnProperty.call(opts, key)) {
        target[key] = opts[key];
      }
    }
  }
}
},{}],"src/systems/environment/asset-types.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWeightedSets = getWeightedSets;
exports.addSampleData = addSampleData;

var Tags = _interopRequireWildcard(require("../../tags"));

var _objects = require("../../util/objects");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// const itemsTypeClasses = {
//   forest: ["forest-dry", "forest-autumn", "forest-triangle"],
// };
const baseWeights = {
  flower: 50,
  tree: 75,
  twig: 25,
  // grass: 25,
  acorns: 10,
  stump: 25,
  shroom: 25,
  rock: 50,
  "flower-patch": 10,
  sapling: 20
};

function getWeightedSets(instances) {
  const setMap = new Map();
  const items = instances.filter(child => child.userData.tag).map(child => {
    const tag = child.userData.tag;
    let list;

    if (setMap.has(tag)) {
      list = setMap.get(tag);
    } else {
      list = [];
      setMap.set(tag, list);
    }

    list.push(child);
    return {
      tag,
      child
    };
  });
  return Array.from(setMap.entries()).map(([tag, children]) => {
    const weight = tag in baseWeights ? baseWeights[tag] : 50;
    return {
      value: children,
      weight,
      tag
    };
  });
}

function addSampleData(container, itemsMap, entity, cellClass, random) {
  if (!itemsMap) return; // if (cellClass === "grasslands-water") cellClass = "grasslands-yellow";

  if (!itemsMap.has(cellClass)) {
    console.warn(`No cell class by key ${cellClass}`);
    return;
  }

  const items = itemsMap.get(cellClass);

  if (!items || !items.sets || !items.sets.length) {
    console.warn(`Cell not yet ready ${cellClass}`);
    return;
  }

  const set = random.weightedSet(items.sets);
  const child = items.next(random.pick(set));

  if (!child || !child.userData.tag) {
    if (child) console.warn("no tag for", child.name, cellClass);
    return;
  } // container.add(child);
  // console.log("Spawning child", child.userData.tag);


  const key = child.uuid;
  entity.add(Tags.GroundAssetData);
  const data = entity.get(Tags.GroundAssetData);
  data.key = key;
  data.variance = random.gaussian(0, 1);
  data.rotation = random.range(-1, 1) * Math.PI * 2;
  data.flip = random.boolean();
  data.instance = child;
  data.audio = child.scale.y > 5;
  data.ignoreFlip = child.userData.tag === "tree"; // if (cellClass.includes("water")) {
  //   // console.log("CELL WATER", child, data);
  // }

  return child;
}
},{"../../tags":"src/tags/index.js","../../util/objects":"src/util/objects.js"}],"src/util/RefGLTFLoader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = RefLoader;
exports.MetaData = void 0;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _GLTFLoader = require("../util/GLTFLoader");

var _ = _interopRequireDefault(require("../assets/gltf/*.{gltf,glb,png,jpg}"));

var _materials = require("./materials");

var _load = require("./load");

var _EditorWayfinderSprite = require("./EditorWayfinderSprite");

var _meta = _interopRequireDefault(require("../assets/gltf/meta.json"));

var Helpers = _interopRequireWildcard(require("./helpers"));

var _Assets = _interopRequireDefault(require("../util/Assets"));

var _sprites = _interopRequireDefault(require("../assets/gltf/sprites-*.json"));

var _sprites2 = _interopRequireDefault(require("../assets/gltf/sprites-*.png"));

var _threeUtil = require("./three-util");

var _assetTypes = require("../systems/environment/asset-types");

var _ObjectPool = _interopRequireDefault(require("./ObjectPool"));

var _addFrameTasks = require("./addFrameTasks");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

let spriteAtlasURLs = {}; // Object.entries(spriteURLObject).forEach(([id, urls]) => {

Object.keys(_sprites2.default).forEach(id => {
  const urls = _sprites2.default[id];
  const typeMatch = id.match(/([^\-]+)\-/);
  let type = typeMatch ? typeMatch[1] : "";
  const index = parseInt(id.replace(/[^\d]+/g, ""), 10);

  if (!(type in spriteAtlasURLs)) {
    spriteAtlasURLs[type] = [];
  }

  spriteAtlasURLs[type][index] = urls;

  if (type === "forest") {
    const id = _Assets.default.urlToID(urls);

    _Assets.default.prepare(id);
  }
}); // let spriteURLs = Object.entries(spriteURLObject);
// spriteURLs.sort((a, b) => parseInt(a[0], 10) - parseInt(b[0], 10));
// spriteURLs = spriteURLs.map((e) => e[1]);
// pre-fetch the assets for the world
// let spriteURLIDs = spriteURLs.map((url) => {
// const id = Assets.urlToID(url);
// Assets.prepare(id);
//   return id;
// });

const images = getURLMap(_.default, ["jpg", "png"], "map-");
const scenes = getURLMap(_.default, ["gltf", "glb"]); // const scenes = getURLMap(files, ["gltf", "glb"], "scene-");
// need to fix this with proper box test on sprites

const boundingBoxYPadding = 19;
Object.keys(_meta.default).forEach(k => {
  // clamp to ground so that we don't pick up any out of frame
  _meta.default[k].boundingBox[0][1] = 0; // pad a bit more for tall tree sprites, this is because
  // trees are not actually vertical in world space but
  // aligned to the camera direction, which means sometimes
  // they poke out of the bbox... this is arbitrary
  // and could probably be computed more accurately

  _meta.default[k].boundingBox[1][1] += boundingBoxYPadding; // metas[k].boundingCircle.radius += 2;
});
const MetaData = _meta.default; // export const AssetURLs = {
//   scenes,
//   geometries,
//   images,
// };

exports.MetaData = MetaData;

async function RefLoader(world) {
  const mapCache = new Map(); // const geometryCache = new Map();

  const sceneCache = new Map();
  const patchInstanceCache = new Map();
  const emptyGeometry = new THREE.BufferGeometry();
  const emptyTexture = (0, _materials.getEmptyTexture)();
  const tmpWorldScale = new THREE.Vector3(); // const container = new THREE.Group();
  // container.name = "gltf-refs";
  // world.entity().add(Tags.Object3D, container);

  const renderer = world.findTag(Tags.Renderer);
  const spritesUUIDMap = new Map();
  const spriteAtlasTextures = {};

  for (let [type, sheets] of Object.entries(spriteAtlasURLs)) {
    spriteAtlasTextures[type] = sheets.map(urls => {
      // const tex = new THREE.Texture();
      const id = _Assets.default.urlToID(urls); // Assets.loadGPUTexture(renderer, tex, id);


      return _Assets.default.createGPUTextureTask(renderer, id);
    }); // console.log(type, spriteAtlasTextures[type]);
  } // console.log("Loading textures...");
  // const atlasTextures = await Promise.all(
  //   spriteURLIDs.map((id) => {
  //     return Assets.createGPUTexture(renderer, id);
  //   })
  // );


  Object.entries(_sprites.default).forEach(([type, data]) => {
    const atlasTasks = spriteAtlasTextures[type];
    data.frames.forEach((frames, sheetIndex) => {
      frames.forEach(frame => {
        if (!spritesUUIDMap.has(frame.id)) {
          const {
            width,
            height
          } = data.images[sheetIndex];
          const repeat = new THREE.Vector2();
          const offset = new THREE.Vector2();
          repeat.set(frame.w / width, frame.h / height);
          offset.x = frame.x / width;
          offset.y = 1 - frame.h / height - frame.y / height;
          const atlasTask = atlasTasks[sheetIndex];
          const obj = { ...frame,
            repeat,
            offset,
            atlas: atlasTask[0],
            atlasPromise: atlasTask[1],
            sheetIndex
          };
          delete obj.id;
          spritesUUIDMap.set(frame.id, obj);
        } else {
          console.error("WARN: Clashing UUIDs in GLTF sprite sheet data");
        }
      });
    });
  }); // TODO: this should be cleaned up so we aren't waiting
  // on all item set assets upfront...

  const pools = new Map();
  const itemsMap = new Map(); // await Promise.all(["forest", "origin", "grasslands", "tundra"].map(
  //   (type) => {
  //     return loadGLTFScenesByType(type);
  //   }
  // ));

  await Promise.all(["forest-items-dry", "forest-items-autumn", "forest-items-triangle", "grasslands-items-water", "grasslands-items-yellow", "grasslands-items-wet", "grasslands-items-field", "tundra-items-basic", "tundra-items-ice"].map(async name => {
    const scene = await loadSceneByName(name, false, false); // console.log("GOT ITEM SCENE", scene);

    const type = name.replace(/^items\-/i, "");
    const sets = (0, _assetTypes.getWeightedSets)(scene.children);
    const items = GLTFItems(sets);
    itemsMap.set(type, items); // TODO: Here we actually preload / fetch pools
    // for each item... this needs to be done
    // per-environment instead

    sets.forEach(set => {
      set.value.forEach(item => {
        // setTimeout(() => {
        items.getPool(item, 10); // }, 100);
      });
    });
  })); // console.log("LOADING GLTF");

  world.entity().add(Tags.GLTFSpawnItemsMap, itemsMap);
  return {
    killEntities,
    nextPooledByName,
    loadSceneByName // prepareSceneByName,

  };

  function GLTFItems(sets) {
    return {
      sets,
      getPool,

      next(instance) {
        return nextPooledInstance(instance);
      }

    };
  }

  function getPool(instance, initialCapacity = 1) {
    let pool;

    if (!pools.has(instance)) {
      pool = createInstancePool(instance, initialCapacity);
      pools.set(instance, pool);
    } else {
      pool = pools.get(instance);
    }

    return pool;
  }

  function nextPooledInstance(instance) {
    return getPool(instance).next();
  }

  function createInstancePool(instance, initialCapacity = 1) {
    const id = instance.name; // console.log("Creating pool", id, instance.uuid);

    return new _ObjectPool.default({
      initialCapacity,
      name: `GLTFMesh-${id}`,

      create() {
        const m = fastCloneScene(instance);
        m.userData._pool = this;
        return m;
      },

      renew(m) {
        if (m.userData) m.userData._pool = this;
        createEntities(m); // if (m.parent) {
        //   throw new Error("wtf has a parent");
        // }
        // container.add(m);

        return m;
      },

      release(m) {
        // detachObject(m);
        if (m.userData) m.userData._pool = null;
        killEntities(m);
      }

    });
  }

  function killEntities(scene) {
    // console.log("killing scene", scene.name);
    scene.traverse(child => {
      if (child.userData && child.userData._entity) {
        // console.log("killing child entity", child.name);
        child.userData._entity.kill();

        child.userData._entity = null;
      }
    });
  }

  function createEntities(scene) {
    // let count = 0;
    // scene.traverse((child) => {
    //   if (child.isMesh) {
    //     count++;
    //     createChildEntity(child);
    //   }
    // });
    scene.traverse(child => {
      if (child.isMesh) {
        createChildEntity(child);
      }
    }); // on profiling this is a big cause of jank
    // so we split the work up across several frames
    // const maxPerFrame = 1;
    // let i = 0;
    // while (i < children.length) {
    //   const remaining = children.length - i;
    //   const count = Math.min(remaining, maxPerFrame);
    //   let start = i;
    //   let end = i + count;
    //   addFrameTask(() => {
    //     for (let c = start; c < end; c++) {
    //       createChildEntity(children[c]);
    //     }
    //   });
    //   i += count;
    // }
    // setTimeout(() => {
    //   scene.traverse((child) => {
    //     if (child.isMesh) {
    //       count++;
    //       createChildEntity(child);
    //     }
    //   });
    // }, 1000);
    // console.log("got count", count, scene.children.length);
  }

  function nextPooledByName(name, debounceCreate) {
    return loadSceneByName(name, true, debounceCreate);
  } // function prepareSceneByName(name) {
  //   if (!sceneCache.has(name)) {
  //     // addFrameTask(() => {
  //     // });
  //     // name = name.replace(/^scene\-/, "").replace(/\.(gltf|glb)$/i, "");
  //     const sceneUrl = scenes.get(name);
  //     const meta = name in metas ? metas[name] : null;
  //     const promise = loadScene(name, sceneUrl, meta);
  //     sceneCache.set(name, promise);
  //   }
  // }


  async function loadGLTFScenesByType(type) {
    if (!type || !scenes.has(type)) {
      console.warn(`No scene by ID prefix ${type}`);
      return null;
    } // Now load it, assuming it's not yet cached


    const url = scenes.get(type);
    let p;

    if (sceneCache.has(url)) {
      p = sceneCache.get(url);
    } else {
      p = loadGLTF(url).then(gltf => {
        const map = {};
        gltf.scenes.forEach(scene => {
          map[scene.name] = scene;
        });
        return map;
      });
      sceneCache.set(url, p);
    }

    return p;
  }

  async function loadSceneByName(name, pooling, debounceCreate) {
    let instance;

    if (patchInstanceCache.has(name)) {
      instance = patchInstanceCache.get(name);
    } else {
      // First extract the type of scene we need to load
      const typeMatch = name.match(/([^\-]+)\-/);
      let type = typeMatch ? typeMatch[1] : ""; // Now get the map of scenes from that set

      const map = await loadGLTFScenesByType(type);

      if (!map) {
        console.warn(`No scene by ID prefix ${type}`);
        return new THREE.Scene();
      }

      if (!(name in map)) {
        console.warn(`Missing patch ${name} in ${type}`);
        return new THREE.Scene();
      } // And load/process the actual instance


      instance = map[name]; // here's where we lazily pick up images and such

      const meta = _meta.default[name];

      if (!meta) {
        console.warn(`No Meta for ${name}`);
      }

      await loadSceneInstance(instance, meta);
      patchInstanceCache.set(name, instance);
    }

    const needsClone = true;

    if (pooling) {
      const pool = getPool(instance);
      return pool.next();
    } else {
      if (needsClone) return fastCloneScene(instance);else return instance;
    }
  }

  async function loadSceneInstance(scene, meta) {
    const childrenToLoad = [];
    scene.traverse(child => {
      if (child.isMesh) {
        childrenToLoad.push(child);
      }
    }); // now fetch all assets

    await Promise.all(childrenToLoad.map(async child => {
      const isSprite = child.isSprite || child.userData.type === "WayfinderSprite"; // if (child.userData.$g) {
      //   // a geometry asset
      //   console.log("FETCH GEOMETRY!");
      //   // child.geometry = await fetchGeometry(child.userData.$g);
      //   delete child.userData.$g;
      // }

      if (child.userData.$m) {
        // a sprite asset?
        const map = await fetchMap(child.userData.$m);
        if (child.material.uniforms) child.material.uniforms.map.value = map;else child.material.map = map;
        if (!isSprite && map) map.flipY = false;
        delete child.userData.$m;
      }

      createSceneChild(child, meta);
    }));
    return scene;
  }

  function fastCloneScene(scene) {
    // let count = 0;
    const newScene = scene.clone(true);
    const name = scene.name;
    const meta = name in _meta.default ? _meta.default[name] : null;
    newScene.traverse(child => {
      if (child.isMesh) {
        createSceneChild(child, meta);
      } // count++;

    }); // console.log("Scene node Count", name, count);

    return newScene;
  }

  async function fetchMap(id) {
    if (mapCache.has(id)) {
      return mapCache.get(id);
    } // first see if it exists in the sprite sheet
    // rather than being a opaque texture map for 3D mesh


    if (spritesUUIDMap.has(id)) {
      const frame = spritesUUIDMap.get(id);
      await frame.atlasPromise;
      const texture = new THREE.Texture();
      texture.repeat.copy(frame.repeat);
      texture.offset.copy(frame.offset);
      (0, _threeUtil.shareAtlasTexture)(renderer, frame.atlas, texture); // texture.needsUpdate = true;
      // frame.atlas.needsUpdate = true;

      return texture;
    } // if we get here it must be map- prefixed that is lazy loaded


    if (!images.has(id)) {
      console.warn(`Could not find map by UUID ${id}`);
      return emptyTexture;
    }

    const url = images.get(id);
    const promise = (0, _load.loadTexture)(url);
    mapCache.set(id, promise);
    return promise;
  } // async function fetchGeometry(id) {
  //   if (geometryCache.has(id)) {
  //     return geometryCache.get(id);
  //   }
  //   if (!geometries.has(id)) {
  //     console.warn(`Could not find geometry by UUID ${id}`);
  //     return emptyGeometry;
  //   }
  //   const url = geometries.get(id);
  //   const promise = loadGLTF(url).then((gltf) => {
  //     let geometry;
  //     if (
  //       !gltf.scene ||
  //       !gltf.scene.children ||
  //       gltf.scene.children.length !== 1
  //     ) {
  //       console.warn(`Geometry contains more than one mesh at UUID ${id}`);
  //     } else {
  //       const mesh = gltf.scene.children[0];
  //       geometry = mesh.geometry;
  //     }
  //     geometry = geometry || emptyGeometry;
  //     geometry.computeBoundingBox();
  //     return geometry;
  //   });
  //   geometryCache.set(id, promise);
  //   return promise;
  // }


  async function loadSceneOld(name, url, meta) {
    const gltf = await loadGLTF(url);
    const childrenToLoad = [];
    gltf.scene.traverse(child => {
      if (child.isMesh) {
        childrenToLoad.push(child);
      }
    }); // now fetch all assets

    await Promise.all(childrenToLoad.map(async child => {
      const isSprite = child.isSprite || child.userData.type === "WayfinderSprite";

      if (child.userData.$g) {
        // a geometry asset
        // child.geometry = await fetchGeometry(child.userData.$g);
        delete child.userData.$g;
      }

      if (child.userData.$m) {
        // a sprite asset
        child.material.map = await fetchMap(child.userData.$m);
        if (!isSprite) child.material.map.flipY = false;
        delete child.userData.$m;
      }

      createSceneChild(child, meta);
    }));
    const scene = gltf.scene;
    scene.name = name;
    return scene;
  }

  function createChildEntity(child) {
    const isSprite = child.isSprite || child.userData.type === "WayfinderSprite";

    if (child.userData._entity) {
      child.userData._entity.kill();

      console.error("ERROR: Entity already existed on child, removing it.");
    }

    const tag = child.userData ? child.userData.tag : null;
    const ignoreShadow = tag ? tag.includes("noshadow") : false;

    if (isSprite) {
      const spriteScaleY = child.getWorldScale(tmpWorldScale).y;
      child.userData._entity = world.entity().add(Tags.Object3D, child).add(Tags.Object3DKeepAlive).add(Tags.ShaderUniformTime, {
        uniform: child.material.uniforms.time
      });
      if (!ignoreShadow) child.userData._entity.add(Tags.ShadowCaster, {
        sprite: true
      });

      if (tag && tag === "origin_tree") {
        child.userData._entity.add(Tags.SpriteAnimation, {
          key: child.userData.tag
        });

        child.userData._entity.add(Tags.SpriteAnimationOriginTreeTag);
      }

      if (tag !== "origin_tree") {
        if (spriteScaleY > 5) {
          // TODO: use a tag in the editor instead of checking height
          child.userData._entity.add(Tags.WillTriggerAudio);
        }
      }
    } else {
      child.userData._entity = world.entity().add(Tags.Object3D, child).add(Tags.Object3DKeepAlive);
      if (!ignoreShadow) child.userData._entity.add(Tags.ShadowCaster, {
        sprite: false
      });
    }

    if (tag) {
      if (tag === "fox") {
        child.userData._entity.add(Tags.FoxSpriteTag);
      }
    }
  }

  function createSceneChild(child, meta) {
    const isSprite = child.isSprite || child.userData.type === "WayfinderSprite";

    if (meta && meta.type === "origin" && child.name && child.name.endsWith("origin-0-ORIGIN_TREE")) {
      child.userData.animation = "origin-0";
    }

    if (isSprite) {
      (0, _EditorWayfinderSprite.setMeshToSprite)(world, child);
    } else {
      const map = child.material.uniforms && child.material.uniforms.map ? child.material.uniforms.map.value : child.material.map;
      const tag = child.userData ? child.userData.tag : null;
      const ignoreGround = tag ? tag.includes("noshadow") || tag.includes("noground") : false;

      if (ignoreGround) {
        child.material.alphaTest = 0.5;
        child.material.transparent = true;
      }

      child.material = (0, _materials.createMeshMaterial)(world, child, {
        map,
        ignoreGround
      });
      map.minFilter = THREE.LinearFilter;
      map.generateMipmaps = false;
    }
  }
}

async function loadGLTF(url) {
  return new Promise(resolve => {
    const manager = new THREE.LoadingManager();
    const loader = new _GLTFLoader.GLTFLoader(manager);
    loader.setCrossOrigin("anonymous"); // console.log(`Loading GLTF ${url}`);

    loader.load(url, gltf => {
      resolve(gltf);
    });
  });
}

function getURLMap(files, extensions, prefix) {
  extensions = [].concat(extensions);
  const matching = Object.keys(files).filter(key => {
    if (prefix && !key.startsWith(prefix)) return false;
    return Object.keys(files[key]).some(type => extensions.includes(type));
  });
  return matching.reduce((map, key) => {
    const id = key.replace(/^map\-/, "").replace(/^geometry\-/, "").replace(/^scene\-/, "");
    const obj = files[key];
    const firstKey = Object.keys(obj)[0];

    if (firstKey) {
      map.set(id, obj[firstKey]);
    } else {
      console.warn("Object does not have any URL keys");
    }

    if (Object.keys(obj).length > 1) {
      console.log("Object has more than one URL key");
    }

    return map;
  }, new Map());
} // .map((n) => n.replace(regex, ""));
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/GLTFLoader":"src/util/GLTFLoader.js","../assets/gltf/*.{gltf,glb,png,jpg}":"src/assets/gltf/*.{gltf,glb,png,jpg}","./materials":"src/util/materials.js","./load":"src/util/load.js","./EditorWayfinderSprite":"src/util/EditorWayfinderSprite.js","../assets/gltf/meta.json":"src/assets/gltf/meta.json","./helpers":"src/util/helpers.js","../util/Assets":"src/util/Assets.js","../assets/gltf/sprites-*.json":"src/assets/gltf/sprites-*.json","../assets/gltf/sprites-*.png":"src/assets/gltf/sprites-*.png","./three-util":"src/util/three-util.js","../systems/environment/asset-types":"src/systems/environment/asset-types.js","./ObjectPool":"src/util/ObjectPool.js","./addFrameTasks":"src/util/addFrameTasks.js"}],"node_modules/d3-quadtree/src/add.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.addAll = addAll;

function _default(d) {
  const x = +this._x.call(null, d),
        y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {
    data: d
  },
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j; // If the tree is empty, initialize the root as a leaf.

  if (!node) return tree._root = leaf, tree; // Find the existing leaf for the new point, or add it.

  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  } // Is the new point is exactly coincident with the existing point?


  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree; // Otherwise, split the leaf node until the old and new point are separated.

  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));

  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d,
      i,
      n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity; // Compute the points and their extent.

  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  } // If there were no (valid) points, abort.


  if (x0 > x1 || y0 > y1) return this; // Expand the tree to cover the new points.

  this.cover(x0, y0).cover(x1, y1); // Add the new points.

  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}
},{}],"node_modules/d3-quadtree/src/cover.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1; // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!

  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  } // Otherwise, double repeatedly to cover.
  else {
      var z = x1 - x0 || 1,
          node = this._root,
          parent,
          i;

      while (x0 > x || x >= x1 || y0 > y || y >= y1) {
        i = (y < y0) << 1 | x < x0;
        parent = new Array(4), parent[i] = node, node = parent, z *= 2;

        switch (i) {
          case 0:
            x1 = x0 + z, y1 = y0 + z;
            break;

          case 1:
            x0 = x1 - z, y1 = y0 + z;
            break;

          case 2:
            x1 = x0 + z, y0 = y1 - z;
            break;

          case 3:
            x0 = x1 - z, y0 = y1 - z;
            break;
        }
      }

      if (this._root && this._root.length) this._root = node;
    }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}
},{}],"node_modules/d3-quadtree/src/data.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var data = [];
  this.visit(function (node) {
    if (!node.length) do data.push(node.data); while (node = node.next);
  });
  return data;
}
},{}],"node_modules/d3-quadtree/src/extent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(_) {
  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}
},{}],"node_modules/d3-quadtree/src/quad.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}
},{}],"node_modules/d3-quadtree/src/find.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _quad = _interopRequireDefault(require("./quad.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;
  if (node) quads.push(new _quad.default(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {
    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node) || (x1 = q.x0) > x3 || (y1 = q.y0) > y3 || (x2 = q.x1) < x0 || (y2 = q.y1) < y0) continue; // Bisect the current quadrant.

    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;
      quads.push(new _quad.default(node[3], xm, ym, x2, y2), new _quad.default(node[2], x1, ym, xm, y2), new _quad.default(node[1], xm, y1, x2, ym), new _quad.default(node[0], x1, y1, xm, ym)); // Visit the closest quadrant first.

      if (i = (y >= ym) << 1 | x >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
        var dx = x - +this._x.call(null, node.data),
            dy = y - +this._y.call(null, node.data),
            d2 = dx * dx + dy * dy;

        if (d2 < radius) {
          var d = Math.sqrt(radius = d2);
          x0 = x - d, y0 = y - d;
          x3 = x + d, y3 = y + d;
          data = node.data;
        }
      }
  }

  return data;
}
},{"./quad.js":"node_modules/d3-quadtree/src/quad.js"}],"node_modules/d3-quadtree/src/remove.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.removeAll = removeAll;

function _default(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j; // If the tree is empty, initialize the root as a leaf.

  if (!node) return this; // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.

  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;
  } // Find the point to remove.

  while (node.data !== d) if (!(previous = node, node = node.next)) return this;

  if (next = node.next) delete node.next; // If there are multiple coincident points, remove just the point.

  if (previous) return next ? previous.next = next : delete previous.next, this; // If this is the root point, remove it.

  if (!parent) return this._root = next, this; // Remove this leaf.

  next ? parent[i] = next : delete parent[i]; // If the parent now contains exactly one leaf, collapse superfluous parents.

  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j] = node;else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);

  return this;
}
},{}],"node_modules/d3-quadtree/src/root.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  return this._root;
}
},{}],"node_modules/d3-quadtree/src/size.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var size = 0;
  this.visit(function (node) {
    if (!node.length) do ++size; while (node = node.next);
  });
  return size;
}
},{}],"node_modules/d3-quadtree/src/visit.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _quad = _interopRequireDefault(require("./quad.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(callback) {
  var quads = [],
      q,
      node = this._root,
      child,
      x0,
      y0,
      x1,
      y1;
  if (node) quads.push(new _quad.default(node, this._x0, this._y0, this._x1, this._y1));

  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2,
          ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new _quad.default(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new _quad.default(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new _quad.default(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new _quad.default(child, x0, y0, xm, ym));
    }
  }

  return this;
}
},{"./quad.js":"node_modules/d3-quadtree/src/quad.js"}],"node_modules/d3-quadtree/src/visitAfter.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _quad = _interopRequireDefault(require("./quad.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(callback) {
  var quads = [],
      next = [],
      q;
  if (this._root) quads.push(new _quad.default(this._root, this._x0, this._y0, this._x1, this._y1));

  while (q = quads.pop()) {
    var node = q.node;

    if (node.length) {
      var child,
          x0 = q.x0,
          y0 = q.y0,
          x1 = q.x1,
          y1 = q.y1,
          xm = (x0 + x1) / 2,
          ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new _quad.default(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new _quad.default(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new _quad.default(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new _quad.default(child, xm, ym, x1, y1));
    }

    next.push(q);
  }

  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }

  return this;
}
},{"./quad.js":"node_modules/d3-quadtree/src/quad.js"}],"node_modules/d3-quadtree/src/x.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultX = defaultX;
exports.default = _default;

function defaultX(d) {
  return d[0];
}

function _default(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}
},{}],"node_modules/d3-quadtree/src/y.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultY = defaultY;
exports.default = _default;

function defaultY(d) {
  return d[1];
}

function _default(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}
},{}],"node_modules/d3-quadtree/src/quadtree.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = quadtree;

var _add = _interopRequireWildcard(require("./add.js"));

var _cover = _interopRequireDefault(require("./cover.js"));

var _data = _interopRequireDefault(require("./data.js"));

var _extent = _interopRequireDefault(require("./extent.js"));

var _find = _interopRequireDefault(require("./find.js"));

var _remove = _interopRequireWildcard(require("./remove.js"));

var _root = _interopRequireDefault(require("./root.js"));

var _size = _interopRequireDefault(require("./size.js"));

var _visit = _interopRequireDefault(require("./visit.js"));

var _visitAfter = _interopRequireDefault(require("./visitAfter.js"));

var _x = _interopRequireWildcard(require("./x.js"));

var _y = _interopRequireWildcard(require("./y.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? _x.defaultX : x, y == null ? _y.defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {
    data: leaf.data
  },
      next = copy;

  while (leaf = leaf.next) next = next.next = {
    data: leaf.data
  };

  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function () {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;
  if (!node) return copy;
  if (!node.length) return copy._root = leaf_copy(node), copy;
  nodes = [{
    source: node,
    target: copy._root = new Array(4)
  }];

  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({
          source: child,
          target: node.target[i] = new Array(4)
        });else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = _add.default;
treeProto.addAll = _add.addAll;
treeProto.cover = _cover.default;
treeProto.data = _data.default;
treeProto.extent = _extent.default;
treeProto.find = _find.default;
treeProto.remove = _remove.default;
treeProto.removeAll = _remove.removeAll;
treeProto.root = _root.default;
treeProto.size = _size.default;
treeProto.visit = _visit.default;
treeProto.visitAfter = _visitAfter.default;
treeProto.x = _x.default;
treeProto.y = _y.default;
},{"./add.js":"node_modules/d3-quadtree/src/add.js","./cover.js":"node_modules/d3-quadtree/src/cover.js","./data.js":"node_modules/d3-quadtree/src/data.js","./extent.js":"node_modules/d3-quadtree/src/extent.js","./find.js":"node_modules/d3-quadtree/src/find.js","./remove.js":"node_modules/d3-quadtree/src/remove.js","./root.js":"node_modules/d3-quadtree/src/root.js","./size.js":"node_modules/d3-quadtree/src/size.js","./visit.js":"node_modules/d3-quadtree/src/visit.js","./visitAfter.js":"node_modules/d3-quadtree/src/visitAfter.js","./x.js":"node_modules/d3-quadtree/src/x.js","./y.js":"node_modules/d3-quadtree/src/y.js"}],"node_modules/d3-quadtree/src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "quadtree", {
  enumerable: true,
  get: function () {
    return _quadtree.default;
  }
});

var _quadtree = _interopRequireDefault(require("./quadtree.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./quadtree.js":"node_modules/d3-quadtree/src/quadtree.js"}],"node_modules/canvas-sketch-util/lib/css-color-names.json":[function(require,module,exports) {
module.exports = {
  "aliceblue": "#f0f8ff",
  "antiquewhite": "#faebd7",
  "aqua": "#00ffff",
  "aquamarine": "#7fffd4",
  "azure": "#f0ffff",
  "beige": "#f5f5dc",
  "bisque": "#ffe4c4",
  "black": "#000000",
  "blanchedalmond": "#ffebcd",
  "blue": "#0000ff",
  "blueviolet": "#8a2be2",
  "brown": "#a52a2a",
  "burlywood": "#deb887",
  "cadetblue": "#5f9ea0",
  "chartreuse": "#7fff00",
  "chocolate": "#d2691e",
  "coral": "#ff7f50",
  "cornflowerblue": "#6495ed",
  "cornsilk": "#fff8dc",
  "crimson": "#dc143c",
  "cyan": "#00ffff",
  "darkblue": "#00008b",
  "darkcyan": "#008b8b",
  "darkgoldenrod": "#b8860b",
  "darkgray": "#a9a9a9",
  "darkgreen": "#006400",
  "darkgrey": "#a9a9a9",
  "darkkhaki": "#bdb76b",
  "darkmagenta": "#8b008b",
  "darkolivegreen": "#556b2f",
  "darkorange": "#ff8c00",
  "darkorchid": "#9932cc",
  "darkred": "#8b0000",
  "darksalmon": "#e9967a",
  "darkseagreen": "#8fbc8f",
  "darkslateblue": "#483d8b",
  "darkslategray": "#2f4f4f",
  "darkslategrey": "#2f4f4f",
  "darkturquoise": "#00ced1",
  "darkviolet": "#9400d3",
  "deeppink": "#ff1493",
  "deepskyblue": "#00bfff",
  "dimgray": "#696969",
  "dimgrey": "#696969",
  "dodgerblue": "#1e90ff",
  "firebrick": "#b22222",
  "floralwhite": "#fffaf0",
  "forestgreen": "#228b22",
  "fuchsia": "#ff00ff",
  "gainsboro": "#dcdcdc",
  "ghostwhite": "#f8f8ff",
  "gold": "#ffd700",
  "goldenrod": "#daa520",
  "gray": "#808080",
  "green": "#008000",
  "greenyellow": "#adff2f",
  "grey": "#808080",
  "honeydew": "#f0fff0",
  "hotpink": "#ff69b4",
  "indianred": "#cd5c5c",
  "indigo": "#4b0082",
  "ivory": "#fffff0",
  "khaki": "#f0e68c",
  "lavender": "#e6e6fa",
  "lavenderblush": "#fff0f5",
  "lawngreen": "#7cfc00",
  "lemonchiffon": "#fffacd",
  "lightblue": "#add8e6",
  "lightcoral": "#f08080",
  "lightcyan": "#e0ffff",
  "lightgoldenrodyellow": "#fafad2",
  "lightgray": "#d3d3d3",
  "lightgreen": "#90ee90",
  "lightgrey": "#d3d3d3",
  "lightpink": "#ffb6c1",
  "lightsalmon": "#ffa07a",
  "lightseagreen": "#20b2aa",
  "lightskyblue": "#87cefa",
  "lightslategray": "#778899",
  "lightslategrey": "#778899",
  "lightsteelblue": "#b0c4de",
  "lightyellow": "#ffffe0",
  "lime": "#00ff00",
  "limegreen": "#32cd32",
  "linen": "#faf0e6",
  "magenta": "#ff00ff",
  "maroon": "#800000",
  "mediumaquamarine": "#66cdaa",
  "mediumblue": "#0000cd",
  "mediumorchid": "#ba55d3",
  "mediumpurple": "#9370db",
  "mediumseagreen": "#3cb371",
  "mediumslateblue": "#7b68ee",
  "mediumspringgreen": "#00fa9a",
  "mediumturquoise": "#48d1cc",
  "mediumvioletred": "#c71585",
  "midnightblue": "#191970",
  "mintcream": "#f5fffa",
  "mistyrose": "#ffe4e1",
  "moccasin": "#ffe4b5",
  "navajowhite": "#ffdead",
  "navy": "#000080",
  "oldlace": "#fdf5e6",
  "olive": "#808000",
  "olivedrab": "#6b8e23",
  "orange": "#ffa500",
  "orangered": "#ff4500",
  "orchid": "#da70d6",
  "palegoldenrod": "#eee8aa",
  "palegreen": "#98fb98",
  "paleturquoise": "#afeeee",
  "palevioletred": "#db7093",
  "papayawhip": "#ffefd5",
  "peachpuff": "#ffdab9",
  "peru": "#cd853f",
  "pink": "#ffc0cb",
  "plum": "#dda0dd",
  "powderblue": "#b0e0e6",
  "purple": "#800080",
  "rebeccapurple": "#663399",
  "red": "#ff0000",
  "rosybrown": "#bc8f8f",
  "royalblue": "#4169e1",
  "saddlebrown": "#8b4513",
  "salmon": "#fa8072",
  "sandybrown": "#f4a460",
  "seagreen": "#2e8b57",
  "seashell": "#fff5ee",
  "sienna": "#a0522d",
  "silver": "#c0c0c0",
  "skyblue": "#87ceeb",
  "slateblue": "#6a5acd",
  "slategray": "#708090",
  "slategrey": "#708090",
  "snow": "#fffafa",
  "springgreen": "#00ff7f",
  "steelblue": "#4682b4",
  "tan": "#d2b48c",
  "teal": "#008080",
  "thistle": "#d8bfd8",
  "tomato": "#ff6347",
  "turquoise": "#40e0d0",
  "violet": "#ee82ee",
  "wheat": "#f5deb3",
  "white": "#ffffff",
  "whitesmoke": "#f5f5f5",
  "yellow": "#ffff00",
  "yellowgreen": "#9acd32"
};
},{}],"node_modules/float-hsl2rgb/index.js":[function(require,module,exports) {
module.exports = hsl2rgb
function hsl2rgb (hsl) {
  var h = hsl[0],
    s = hsl[1],
    l = hsl[2],
    t1, t2, t3, rgb, val

  if (s === 0) {
    val = l
    return [val, val, val]
  }

  if (l < 0.5) {
    t2 = l * (1 + s)
  } else {
    t2 = l + s - l * s
  }
  t1 = 2 * l - t2

  rgb = [0, 0, 0]
  for (var i = 0; i < 3; i++) {
    t3 = h + 1 / 3 * -(i - 1)
    if (t3 < 0) {
      t3++
    }
    if (t3 > 1) {
      t3--
    }

    if (6 * t3 < 1) {
      val = t1 + (t2 - t1) * 6 * t3
    } else if (2 * t3 < 1) {
      val = t2
    } else if (3 * t3 < 2) {
      val = t1 + (t2 - t1) * (2 / 3 - t3) * 6
    } else {
      val = t1
    }

    rgb[i] = val
  }

  return rgb
}

},{}],"node_modules/float-rgb2hsl/index.js":[function(require,module,exports) {
module.exports = rgb2hsl
function rgb2hsl (rgb) {
  var r = rgb[0],
    g = rgb[1],
    b = rgb[2],
    min = Math.min(r, g, b),
    max = Math.max(r, g, b),
    delta = max - min,
    h, s, l

  if (max === min) {
    h = 0
  } else if (r === max) {
    h = (g - b) / delta
  } else if (g === max) {
    h = 2 + (b - r) / delta
  } else if (b === max) {
    h = 4 + (r - g) / delta
  }

  h = Math.min(h * 60, 360)

  if (h < 0) {
    h += 360
  }

  l = (min + max) / 2

  if (max === min) {
    s = 0
  } else if (l <= 0.5) {
    s = delta / (max + min)
  } else {
    s = delta / (2 - max - min)
  }

  return [h / 360, s, l]
}

},{}],"node_modules/canvas-sketch-util/lib/hsl.js":[function(require,module,exports) {
var floatHSL2RGB = require('float-hsl2rgb');
var floatRGB2HSL = require('float-rgb2hsl');
var wrap = require('./wrap');

module.exports.RGBAToHSLA = RGBAToHSLA;
function RGBAToHSLA (rgba) {
  var floatHSL = floatRGB2HSL([ rgba[0] / 255, rgba[1] / 255, rgba[2] / 255 ]);
  return [
    Math.max(0, Math.min(360, Math.round(floatHSL[0] * 360))),
    Math.max(0, Math.min(100, Math.round(floatHSL[1] * 100))),
    Math.max(0, Math.min(100, Math.round(floatHSL[2] * 100))),
    rgba[3]
  ];
}

module.exports.HSLAToRGBA = HSLAToRGBA;
function HSLAToRGBA (hsla) {
  var hue = wrap(hsla[0], 0, 360);
  var floatRGB = floatHSL2RGB([ hue / 360, hsla[1] / 100, hsla[2] / 100 ]);
  return [
    Math.max(0, Math.min(255, Math.round(floatRGB[0] * 255))),
    Math.max(0, Math.min(255, Math.round(floatRGB[1] * 255))),
    Math.max(0, Math.min(255, Math.round(floatRGB[2] * 255))),
    hsla[3]
  ];
}

},{"float-hsl2rgb":"node_modules/float-hsl2rgb/index.js","float-rgb2hsl":"node_modules/float-rgb2hsl/index.js","./wrap":"node_modules/canvas-sketch-util/lib/wrap.js"}],"node_modules/canvas-sketch-util/lib/hex-to-rgba.js":[function(require,module,exports) {
module.exports = hexToRGBA;
function hexToRGBA (str) {
  if (typeof str !== 'string') {
    throw new TypeError('Hex code parsing must be performed on a string parameter');
  }

  str = str.toLowerCase();

  if (!/^#[a-f0-9]+$/.test(str)) {
    return null;
  }

  var hex = str.replace(/^#/, '');
  var alpha = 1;

  if (hex.length === 8) {
    alpha = parseInt(hex.slice(6, 8), 16) / 255;
    hex = hex.slice(0, 6);
  }

  if (hex.length === 4) {
    alpha = parseInt(hex.slice(3, 4).repeat(2), 16) / 255;
    hex = hex.slice(0, 3);
  }

  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }

  var num = parseInt(hex, 16);
  var red = num >> 16;
  var green = (num >> 8) & 255;
  var blue = num & 255;

  return [ red, green, blue, alpha ];
}

},{}],"node_modules/canvas-sketch-util/lib/rgba-to-hex.js":[function(require,module,exports) {
module.exports = rgbaToHex;
function rgbaToHex (rgba) {
  if (!rgba || !Array.isArray(rgba)) {
    throw new TypeError('Must specify an array to convert into a hex code');
  }

  var r = Math.max(0, Math.min(255, Math.round(rgba[0] || 0)));
  var g = Math.max(0, Math.min(255, Math.round(rgba[1] || 0)));
  var b = Math.max(0, Math.min(255, Math.round(rgba[2] || 0)));

  var alpha = rgba[3];
  if (typeof alpha === 'undefined' || !isFinite(alpha)) {
    alpha = 1;
  }
  var a = Math.max(0, Math.min(255, Math.round(alpha * 255)));
  var alphaParam = a === 255 ? '' : (a | 1 << 8).toString(16).slice(1);
  var result = ((b | g << 8 | r << 16) | 1 << 24).toString(16).slice(1) + alphaParam;
  return '#' + result;
}

},{}],"node_modules/canvas-sketch-util/lib/css-color.js":[function(require,module,exports) {

var names = require('./css-color-names.json');
var HSLUtil = require('./hsl');
var hexToRGBA = require('./hex-to-rgba');
var RGBAToHex = require('./rgba-to-hex');
var wrap = require('./wrap');

function parseStyle (str) {
  if (typeof str !== 'string') {
    throw new TypeError('Color parsing must be performed on a string parameter');
  }

  str = str.toLowerCase();

  if (str in names) {
    str = names[str];
  } else if (str === 'transparent') {
    str = '#00000000';
  }

  var rgba, hsla, hex;
  if (/^#[a-f0-9]+$/.test(str)) {
    rgba = hexToRGBA(str);
    hex = RGBAToHex(rgba);
    hsla = HSLUtil.RGBAToHSLA(rgba);
  } else {
    var match = /^((?:rgb|hsl)a?)\s*\(([^)]*)\)/.exec(str);
    if (!match) return null;
    var type = match[1].replace(/a$/, '');
    var parts = match[2].replace(/^\s+|\s+$/g, '').split(/\s*,\s*/).map(function (n, i) {
      // opaque part
      if (i <= 2) return Math.round(parseFloat(n) || 0);
      // alpha part
      else {
        n = parseFloat(n);
        if (typeof n !== 'number' || !isFinite(n)) n = 1;
        return n;
      }
    });
    // fill in alpha with 1.0 by default
    if (typeof parts[3] === 'undefined' || !isFinite(parts[3])) {
      parts[3] = 1;
    }
    if (type === 'rgb') {
      hsla = HSLUtil.RGBAToHSLA(parts);
      rgba = parts;
    } else if (type === 'hsl') {
      rgba = HSLUtil.HSLAToRGBA(parts);
      parts[0] = wrap(parts[0], 0, 360);
      hsla = parts;
    }
    hex = RGBAToHex(rgba);
  }

  if (!rgba && !hex && !hsla) return null;

  var ret = {
    hex: hex,
    alpha: rgba[3],
    rgb: rgba.slice(0, 3),
    rgba: rgba,
    hsl: hsla.slice(0, 3),
    hsla: hsla
  };

  return ret;
}

module.exports.parse = parseColor;
function parseColor (color) {
  if (typeof color === 'string') {
    return parseStyle(color);
  } else if (Array.isArray(color) && color.length >= 3) {
    var rgbStr = rgbStyle(color[0], color[1], color[2], color[3]);
    return parseStyle(rgbStr);
  } else if (color && typeof color === 'object') {
    var str;
    if (color.hex) str = color.hex;
    else if (color.rgba) str = rgbStyle(color.rgba[0], color.rgba[1], color.rgba[2], color.rgba[3]);
    else if (color.hsla) str = hslStyle(color.hsla[0], color.hsla[1], color.hsla[2], color.hsla[3]);
    else if (color.rgb) str = rgbStyle(color.rgb[0], color.rgb[1], color.rgb[2]);
    else if (color.hsl) str = hslStyle(color.hsl[0], color.hsl[1], color.hsl[2]);
    if (str) return parseStyle(str);
  }
  return null;
}

module.exports.style = style;
function style (color) {
  var result = module.exports.parse(color);
  if (result) {
    var rgba = result.rgba;
    return rgbStyle(rgba[0], rgba[1], rgba[2], rgba[3]);
  }
  return null;
}

function rgbStyle (r, g, b, a) {
  r = Math.max(0, Math.min(255, Math.round(r)));
  g = Math.max(0, Math.min(255, Math.round(g)));
  b = Math.max(0, Math.min(255, Math.round(b)));
  if (a === 1 || !isFinite(a) || typeof a === 'undefined') {
    return 'rgb(' + [ r, g, b ].join(', ') + ')';
  } else {
    a = Math.max(0, Math.min(1, a));
    return 'rgba(' + [ r, g, b, a ].join(', ') + ')';
  }
}

function hslStyle (h, s, l, a) {
  h = wrap(h, 0, 360);
  h = Math.max(0, Math.min(360, Math.round(h)));
  s = Math.max(0, Math.min(100, Math.round(s)));
  l = Math.max(0, Math.min(100, Math.round(l)));
  if (a === 1 || !isFinite(a) || typeof a === 'undefined') {
    return 'hsl(' + [ h, s, l ].join(', ') + ')';
  } else {
    a = Math.max(0, Math.min(1, a));
    return 'hsla(' + [ h, s, l, a ].join(', ') + ')';
  }
}

},{"./css-color-names.json":"node_modules/canvas-sketch-util/lib/css-color-names.json","./hsl":"node_modules/canvas-sketch-util/lib/hsl.js","./hex-to-rgba":"node_modules/canvas-sketch-util/lib/hex-to-rgba.js","./rgba-to-hex":"node_modules/canvas-sketch-util/lib/rgba-to-hex.js","./wrap":"node_modules/canvas-sketch-util/lib/wrap.js"}],"node_modules/canvas-sketch-util/lib/relative-luminance.js":[function(require,module,exports) {
// Extracted from @tmcw / wcag-contrast
// https://github.com/tmcw/relative-luminance/blob/master/index.js

// # Relative luminance
// http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
// https://en.wikipedia.org/wiki/Luminance_(relative)
// https://en.wikipedia.org/wiki/Luminosity_function
// https://en.wikipedia.org/wiki/Rec._709#Luma_coefficients

// red, green, and blue coefficients
var rc = 0.2126;
var gc = 0.7152;
var bc = 0.0722;
// low-gamma adjust coefficient
var lowc = 1 / 12.92;

function adjustGamma (a) {
  return Math.pow((a + 0.055) / 1.055, 2.4);
}

module.exports = relativeLuminance;
function relativeLuminance (rgb) {
  var rsrgb = rgb[0] / 255;
  var gsrgb = rgb[1] / 255;
  var bsrgb = rgb[2] / 255;
  var r = rsrgb <= 0.03928 ? rsrgb * lowc : adjustGamma(rsrgb);
  var g = gsrgb <= 0.03928 ? gsrgb * lowc : adjustGamma(gsrgb);
  var b = bsrgb <= 0.03928 ? bsrgb * lowc : adjustGamma(bsrgb);
  return r * rc + g * gc + b * bc;
}

},{}],"node_modules/canvas-sketch-util/color.js":[function(require,module,exports) {
var cssColor = require('./lib/css-color');
var names = require('./lib/css-color-names.json');
var rgbLuminance = require('./lib/relative-luminance');
var HSLUtil = require('./lib/hsl');
var hexToRGBA = require('./lib/hex-to-rgba');
var RGBAToHex = require('./lib/rgba-to-hex');

module.exports.parse = cssColor.parse;
module.exports.style = cssColor.style;
module.exports.names = names;

module.exports.relativeLuminance = function relativeLuminance (color) {
  var result = module.exports.parse(color);
  if (!result) return null;
  return rgbLuminance(result.rgb);
};

// Extracted from @tmcw / wcag-contrast
// https://github.com/tmcw/wcag-contrast
module.exports.contrastRatio = function contrastRatio (colorA, colorB) {
  var a = module.exports.relativeLuminance(colorA);
  var b = module.exports.relativeLuminance(colorB);
  if (a == null || b == null) return null;
  var l1 = Math.max(a, b);
  var l2 = Math.min(a, b);
  return (l1 + 0.05) / (l2 + 0.05);
};

module.exports.offsetHSL = function (color, h, s, l) {
  var result = module.exports.parse(color);
  if (!result) return null;
  result.hsla[0] += h || 0;
  result.hsla[1] = Math.max(0, Math.min(100, result.hsla[1] + (s || 0)));
  result.hsla[2] = Math.max(0, Math.min(100, result.hsla[2] + (l || 0)));
  return module.exports.parse({ hsla: result.hsla });
};

module.exports.blend = function (background, foreground, opacity) {
  var bg = module.exports.parse(background);
  var fg = module.exports.parse(foreground);
  if (bg == null || fg == null) return null;

  var c0 = bg.rgba;
  var c1 = fg.rgba;
  opacity = typeof opacity === 'number' && isFinite(opacity) ? opacity : 1.0;
  var alpha = opacity * c1[3];
  if (alpha >= 1) {
    // foreground is opaque so no blend required
    return fg;
  }
  for (var i = 0; i < 3; i++) {
    c1[i] = c1[i] * alpha + c0[i] * (c0[3] * (1 - alpha));
  }
  c1[3] = Math.max(0, Math.min(1, alpha + c0[3] * (1 - alpha)));
  return module.exports.parse(c1); // re-parse to get new metadata
};

// Exposed but not yet documented
module.exports.hexToRGBA = hexToRGBA;
module.exports.RGBAToHex = RGBAToHex;
module.exports.RGBAToHSLA = HSLUtil.RGBAToHSLA;
module.exports.HSLAToRGBA = HSLUtil.HSLAToRGBA;

},{"./lib/css-color":"node_modules/canvas-sketch-util/lib/css-color.js","./lib/css-color-names.json":"node_modules/canvas-sketch-util/lib/css-color-names.json","./lib/relative-luminance":"node_modules/canvas-sketch-util/lib/relative-luminance.js","./lib/hsl":"node_modules/canvas-sketch-util/lib/hsl.js","./lib/hex-to-rgba":"node_modules/canvas-sketch-util/lib/hex-to-rgba.js","./lib/rgba-to-hex":"node_modules/canvas-sketch-util/lib/rgba-to-hex.js"}],"src/shaders/water.frag.js":[function(require,module,exports) {
module.exports = "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec2 vTextureUv;\nvarying vec2 vSurfUv;\nvarying vec3 vWorldPosition;\n\nuniform sampler2D worldDataMap;\n\nuniform vec3 centroidPosition;\nuniform sampler2D waterDistortMap;\nuniform sampler2D waterNoiseMap;\nuniform sampler2D dataMapColor;\nuniform sampler2D dataMapLake;\nuniform sampler2D dataMapLakeBlur;\nuniform sampler2D groundMap;\nuniform vec3 colorA;\nuniform vec3 colorB;\nuniform float lakeSize;\nuniform float time;\nvarying float vAngle;\nvarying vec2 vDataUv;\nvarying vec2 vGroundUv;\n\n#define distortionScale 1.0\n#define waterScale 2.5\n\n// #define WATER 1\n\nvoid main2 () {\n  float lake = 1.0-texture2D(dataMapLake, vUv).r;\n  float lakeBlur = 1.0-texture2D(dataMapLakeBlur, vUv).r;\n  vec3 groundColor = texture2D(dataMapColor, vUv).rgb;\n  vec4 wakeData = texture2D(worldDataMap, vDataUv).rgba;\n\n  vec4 tex = texture2D(waterNoiseMap, vTextureUv * waterScale).rgba;\n\n  gl_FragColor = vec4(vec3(colorB.rgb), 1.0);\n}\n\nvoid main () {\n  // float lake = texture2D(dataMapLake, vUv).r;\n  float lake = 1.0-texture2D(dataMapLake, vUv).r;\n  float lakeBlur = 1.0-texture2D(dataMapLakeBlur, vUv).r;\n  // vec3 groundColor = texture2D(dataMapColor, vUv).rgb;\n  vec3 groundColor = texture2D(groundMap, vGroundUv).rgb;\n\n  vec4 wakeData = texture2D(worldDataMap, vDataUv).rgba;\n  // float foam = smoothstep(1.0, 0.85, lake);\n\n  // float ld = 0.2 + sin(time + vAngle) * 0.1;\n  // float foam = smoothstep(1.0, ld, lake);\n  // gl_FragColor = vec4(color + vec3(foam), 1.0);\n\n  float dst = smoothstep(0.0, 0.5, lake);\n  // float off = 0.0;\n  // // float off = sin(vAngle + time) * (1.0 / steps) * 0.1;\n  // dst = abs(fract((dst + 0.05 * time + off) * steps) - 0.5)*2.0;\n  // dst *= smoothstep(0.1, 0.75, lake);\n\n  vec2 uvDistort = vec2(0.0);\n\n  float wakeStrength = wakeData.r;\n\n  \n  #ifdef WATER\n  vec2 wakeDirection = wakeData.gb * 0.2 * wakeStrength;\n  uvDistort -= wakeDirection;\n  float timeOff = time;\n  #else\n  vec2 wakeDirection = vec2(0.0);\n  float timeOff = 0.0;\n  #endif\n\n  vec2 uvDistortOff = vec2(timeOff * 0.1, timeOff * -0.1);\n  vec2 distortion = texture2D(waterDistortMap, uvDistortOff + vTextureUv * distortionScale).rg * 2.0 - 1.0;\n  uvDistort += distortion.rg * 0.05;\n\n  vec4 waterColorMap = texture2D(waterNoiseMap, vTextureUv * waterScale + uvDistort);\n  float foam = waterColorMap.r;\n\n  float lakeCentroidDepth = distance(centroidPosition, vWorldPosition)/lakeSize;\n  lakeCentroidDepth = smoothstep(0.0, 1.0, lakeCentroidDepth);\n\n  float lakeBlurDepth = lakeBlur;\n  // float lakeBlurDepth = smoothstep(0.0, 1.0, lakeBlur);\n\n  float depth = smoothstep(0.0, 0.75, lake);\n  vec3 col = mix(colorA, colorB, lakeBlurDepth);\n\n  vec2 edgeOff2D = texture2D(waterDistortMap, vec2(0.0, 0.0) + vTextureUv * distortionScale + distortion.rg * 0.02 - wakeDirection).rg * 2.0 - 1.0;\n  float edgeOff = edgeOff2D.r;\n  float strongEdge = smoothstep(0.4, 0.55, lake + edgeOff2D.g * 0.05);\n\n  float ft0 = 0.4;\n  float ftf = 0.3;\n  // float edgeFalloff = 1.0 - smoothstep(0.8, 0.0, lake);\n  float edgeFalloff = smoothstep(ft0-ftf, ft0+ftf, lake + edgeOff2D.r * 0.05);\n\n  #ifdef WATER\n  col += foam * 0.1 * lakeBlurDepth + foam * 0.2 * wakeStrength;\n  col = mix(col, groundColor, edgeFalloff);\n  #else\n  col += foam * mix(0.0, 0.1, lakeBlurDepth) + foam * 0.2 * wakeStrength;\n  col = mix(col, groundColor, edgeFalloff);\n  #endif\n\n  col *= (1.0 - wakeStrength * 0.05);\n  // col = mix(col, groundColor, strongEdge);\n  // col = mix(col, col + 0.1, strongEdge);\n  \n\n  float steps = 4.0 + edgeOff2D.g * 0.2;\n  // float waves = sin(distortion.r * 0.25 + edgeOff2D. + timeOff * -0.05);\n  float worldOff = 0.0;\n  float waves = fract(edgeOff2D.r * 0.1 + edgeOff2D.g * 0.1 + timeOff * 0.1 + worldOff);\n  // waves -= sin(length(vUv - 0.5) * 10.0 + timeOff);\n  float movingDst = smoothstep(0.0, 0.7, lake + edgeOff2D.r * 0.05);\n  movingDst = smoothstep(0.5, 0.0, abs(fract((movingDst + waves) * steps) - 0.5) * 2.0);\n  movingDst *= depth;\n  // movingDst *= sin(length(vUv - 0.5) * 10.0 + timeOff);\n\n  // movingDst = mix(movingDst, 1.0, strongEdge);\n  // movingDst = mix(movingDst, 1.0, smoothstep(0.5, 0.55, lake + edgeOff2D.g * 0.05));\n\n  float et = 0.4;\n  float ef = 0.05;\n  float sharpFoam = smoothstep(et-ef,et+ef, movingDst + edgeOff2D.r * 0.6) * smoothstep(et-ef,et+ef, movingDst + edgeOff2D.g * 0.6);\n  sharpFoam = clamp(sharpFoam, 0.0, 1.0);\n  // sharpFoam *= smoothstep(-0.2, -0.0, edgeOff2D.r);\n  // sharpFoam *= smoothstep(-0.3, -0.2, edgeOff2D.g);\n\n  #ifdef WATER\n  float et0 = 0.4;\n  float ef0 = 0.05;\n  col = mix(col, vec3(col + 0.4 *(edgeOff2D.r*0.5+0.5)), (1.0-strongEdge) * sharpFoam);\n  #else\n  float et0 = 0.4;\n  float ef0 = 0.05;\n  col += 1.0 * mix(col, vec3(col + 0.4 *(edgeOff2D.r*0.5+0.5)), (1.0-strongEdge) * sharpFoam) * foam;\n  #endif\n  // col = mix(col, mix(col, vec3(0.8), smoothstep(et0+ef0, et0-ef0, lake)), sharpFoam);\n  \n  float strongEdge2 = smoothstep(0.4, 0.55, lake +edgeOff2D.r * 0.1);\n  // col = mix(col, groundColor, strongEdge2);\n  \n  // col += sharpFoam * 0.5 * (smoothstep(0.5, 0.3, lake));\n  // col += step(0.4, lake + edgeOff2D.r * 0.6) * step(0.4, lake + edgeOff2D.g * 0.6);\n  // col += smoothstep(et-ef, et+ef, edgeOff2D.g) * movingDst * depth;\n  // col = vec3(movingDst);\n  // col += step(0.6, lake + edgeOff);\n\n  // float edgeFoam01 = step(0.5, lake + distortion.r);\n  // float edgeFoam02 = step(0.5, lake + distortion.g);\n  // col += edgeFoam01 * edgeFoam02;\n\n  // col = vec3(smoothstep(0.0, 0.7, lake));\n  // col += smoothstep(0.1, 0.5, lake);\n\n  // col = vec3(lakeBlurDepth);\n\n   \n  #ifdef WATER\n  ft0 = 0.5;\n  ftf = 0.1;\n  float edgeAlpha = smoothstep(ft0+ftf, ft0-ftf, lake + edgeOff2D.r * 0.05);\n  gl_FragColor = vec4(mix(groundColor, col, edgeAlpha), 1.0);\n  #else\n  ftf = 0.4;\n  ft0 = 0.1;\n  float edgeAlpha = smoothstep(ftf+ft0, ftf-ft0, lake + (waterColorMap.g*2.0-1.0) * 0.25);\n  // gl_FragColor = vec4(vec3(step(0.25, lake)), 1.0);\n  gl_FragColor = vec4(col, edgeAlpha);\n  // gl_FragColor = vec4(mix(groundColor, col, edgeAlpha), 1.0);\n  #endif\n  \n  // gl_FragColor = vec4(vec3(col), edgeAlpha);\n  gl_FragColor = clamp(gl_FragColor.rgba, 0.0, 1.0);\n  // vec3 distortion = texture2D(mapWaterNormal, vTextureUv * distortionScale).rgb * 2.0 - 1.0;\n\n  // gl_FragColor = vec4(vec3(wakeData.r), 1.0);\n  // dst *= sin(vTextureUv.x * 4.0 + timeOff);\n\n  // gl_FragColor = vec4(vec3(distortion.r), 1.0);\n  // gl_FragColor = vec4(vec3(1.0-lake), 1.0);\n}";
},{}],"node_modules/rbush/rbush.min.js":[function(require,module,exports) {
var define;
!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?module.exports=i():"function"==typeof define&&define.amd?define(i):(t=t||self).RBush=i()}(this,function(){"use strict";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});

},{}],"node_modules/tinyqueue/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

class TinyQueue {
  constructor(data = [], compare = defaultCompare) {
    this.data = data;
    this.length = this.data.length;
    this.compare = compare;

    if (this.length > 0) {
      for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
    }
  }

  push(item) {
    this.data.push(item);
    this.length++;

    this._up(this.length - 1);
  }

  pop() {
    if (this.length === 0) return undefined;
    const top = this.data[0];
    const bottom = this.data.pop();
    this.length--;

    if (this.length > 0) {
      this.data[0] = bottom;

      this._down(0);
    }

    return top;
  }

  peek() {
    return this.data[0];
  }

  _up(pos) {
    const {
      data,
      compare
    } = this;
    const item = data[pos];

    while (pos > 0) {
      const parent = pos - 1 >> 1;
      const current = data[parent];
      if (compare(item, current) >= 0) break;
      data[pos] = current;
      pos = parent;
    }

    data[pos] = item;
  }

  _down(pos) {
    const {
      data,
      compare
    } = this;
    const halfLength = this.length >> 1;
    const item = data[pos];

    while (pos < halfLength) {
      let left = (pos << 1) + 1;
      let best = data[left];
      const right = left + 1;

      if (right < this.length && compare(data[right], best) < 0) {
        left = right;
        best = data[right];
      }

      if (compare(best, item) >= 0) break;
      data[pos] = best;
      pos = left;
    }

    data[pos] = item;
  }

}

exports.default = TinyQueue;

function defaultCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
},{}],"node_modules/robust-predicates/umd/orient2d.min.js":[function(require,module,exports) {
var define;
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).predicates={})}(this,(function(t){"use strict";const e=134217729;function n(t,e,n,o,r){let f,i,u,s,c=e[0],l=o[0],a=0,d=0;l>c==l>-c?(f=c,c=e[++a]):(f=l,l=o[++d]);let p=0;if(a<t&&d<n)for(l>c==l>-c?(i=c+f,u=f-(i-c),c=e[++a]):(i=l+f,u=f-(i-l),l=o[++d]),f=i,0!==u&&(r[p++]=u);a<t&&d<n;)l>c==l>-c?(i=f+c,s=i-f,u=f-(i-s)+(c-s),c=e[++a]):(i=f+l,s=i-f,u=f-(i-s)+(l-s),l=o[++d]),f=i,0!==u&&(r[p++]=u);for(;a<t;)i=f+c,s=i-f,u=f-(i-s)+(c-s),c=e[++a],f=i,0!==u&&(r[p++]=u);for(;d<n;)i=f+l,s=i-f,u=f-(i-s)+(l-s),l=o[++d],f=i,0!==u&&(r[p++]=u);return 0===f&&0!==p||(r[p++]=f),p}function o(t){return new Float64Array(t)}const r=o(4),f=o(8),i=o(12),u=o(16),s=o(4);t.orient2d=function(t,o,c,l,a,d){const p=(o-d)*(c-a),b=(t-a)*(l-d),h=p-b;if(0===p||0===b||p>0!=b>0)return h;const y=Math.abs(p+b);return Math.abs(h)>=33306690738754716e-32*y?h:-function(t,o,c,l,a,d,p){let b,h,y,M,x,g,j,m,T,_,v,w,A,F,O,P,k,q;const z=t-a,B=c-a,C=o-d,D=l-d;F=z*D,g=e*z,j=g-(g-z),m=z-j,g=e*D,T=g-(g-D),_=D-T,O=m*_-(F-j*T-m*T-j*_),P=C*B,g=e*C,j=g-(g-C),m=C-j,g=e*B,T=g-(g-B),_=B-T,k=m*_-(P-j*T-m*T-j*_),v=O-k,x=O-v,r[0]=O-(v+x)+(x-k),w=F+v,x=w-F,A=F-(w-x)+(v-x),v=A-P,x=A-v,r[1]=A-(v+x)+(x-P),q=w+v,x=q-w,r[2]=w-(q-x)+(v-x),r[3]=q;let E=function(t,e){let n=e[0];for(let o=1;o<t;o++)n+=e[o];return n}(4,r),G=22204460492503146e-32*p;if(E>=G||-E>=G)return E;if(x=t-z,b=t-(z+x)+(x-a),x=c-B,y=c-(B+x)+(x-a),x=o-C,h=o-(C+x)+(x-d),x=l-D,M=l-(D+x)+(x-d),0===b&&0===h&&0===y&&0===M)return E;if(G=11093356479670487e-47*p+33306690738754706e-32*Math.abs(E),E+=z*M+D*b-(C*y+B*h),E>=G||-E>=G)return E;F=b*D,g=e*b,j=g-(g-b),m=b-j,g=e*D,T=g-(g-D),_=D-T,O=m*_-(F-j*T-m*T-j*_),P=h*B,g=e*h,j=g-(g-h),m=h-j,g=e*B,T=g-(g-B),_=B-T,k=m*_-(P-j*T-m*T-j*_),v=O-k,x=O-v,s[0]=O-(v+x)+(x-k),w=F+v,x=w-F,A=F-(w-x)+(v-x),v=A-P,x=A-v,s[1]=A-(v+x)+(x-P),q=w+v,x=q-w,s[2]=w-(q-x)+(v-x),s[3]=q;const H=n(4,r,4,s,f);F=z*M,g=e*z,j=g-(g-z),m=z-j,g=e*M,T=g-(g-M),_=M-T,O=m*_-(F-j*T-m*T-j*_),P=C*y,g=e*C,j=g-(g-C),m=C-j,g=e*y,T=g-(g-y),_=y-T,k=m*_-(P-j*T-m*T-j*_),v=O-k,x=O-v,s[0]=O-(v+x)+(x-k),w=F+v,x=w-F,A=F-(w-x)+(v-x),v=A-P,x=A-v,s[1]=A-(v+x)+(x-P),q=w+v,x=q-w,s[2]=w-(q-x)+(v-x),s[3]=q;const I=n(H,f,4,s,i);F=b*M,g=e*b,j=g-(g-b),m=b-j,g=e*M,T=g-(g-M),_=M-T,O=m*_-(F-j*T-m*T-j*_),P=h*y,g=e*h,j=g-(g-h),m=h-j,g=e*y,T=g-(g-y),_=y-T,k=m*_-(P-j*T-m*T-j*_),v=O-k,x=O-v,s[0]=O-(v+x)+(x-k),w=F+v,x=w-F,A=F-(w-x)+(v-x),v=A-P,x=A-v,s[1]=A-(v+x)+(x-P),q=w+v,x=q-w,s[2]=w-(q-x)+(v-x),s[3]=q;const J=n(I,i,4,s,u);return u[J-1]}(t,o,c,l,a,d,y)},t.orient2dfast=function(t,e,n,o,r,f){return(e-f)*(n-r)-(t-r)*(o-f)},Object.defineProperty(t,"__esModule",{value:!0})}));

},{}],"src/util/concaveman.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fastConvexHull = fastConvexHull;
exports.default = void 0;

var _rbush = _interopRequireDefault(require("rbush"));

var _tinyqueue = _interopRequireDefault(require("tinyqueue"));

var _pointInPolygon = _interopRequireDefault(require("point-in-polygon"));

var Orient = _interopRequireWildcard(require("robust-predicates/umd/orient2d.min.js"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const orient = Orient.orient2d;
var _default = concaveman; // module.exports = concaveman;
// module.exports.default = concaveman;

exports.default = _default;

function concaveman(points, concavity, lengthThreshold) {
  // a relative measure of concavity; higher value means simpler hull
  concavity = Math.max(0, concavity === undefined ? 2 : concavity); // when a segment goes below this length threshold, it won't be drilled down further

  lengthThreshold = lengthThreshold || 0; // start with a convex hull of the points

  var hull = fastConvexHull(points); // index the points with an R-tree

  var tree = new _rbush.default(16);

  tree.toBBox = function (a) {
    return {
      minX: a[0],
      minY: a[1],
      maxX: a[0],
      maxY: a[1]
    };
  };

  tree.compareMinX = function (a, b) {
    return a[0] - b[0];
  };

  tree.compareMinY = function (a, b) {
    return a[1] - b[1];
  };

  tree.load(points); // turn the convex hull into a linked list and populate the initial edge queue with the nodes

  var queue = [];

  for (var i = 0, last; i < hull.length; i++) {
    var p = hull[i];
    tree.remove(p);
    last = insertNode(p, last);
    queue.push(last);
  } // index the segments with an R-tree (for intersection checks)


  var segTree = new _rbush.default(16);

  for (i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));

  var sqConcavity = concavity * concavity;
  var sqLenThreshold = lengthThreshold * lengthThreshold; // process edges one by one

  while (queue.length) {
    var node = queue.shift();
    var a = node.p;
    var b = node.next.p; // skip the edge if it's already short enough

    var sqLen = getSqDist(a, b);
    if (sqLen < sqLenThreshold) continue;
    var maxSqLen = sqLen / sqConcavity; // find the best connection point for the current edge to flex inward to

    p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree); // if we found a connection and it satisfies our concavity measure

    if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {
      // connect the edge endpoints through this point and add 2 new edges to the queue
      queue.push(node);
      queue.push(insertNode(p, node)); // update point and segment indexes

      tree.remove(p);
      segTree.remove(node);
      segTree.insert(updateBBox(node));
      segTree.insert(updateBBox(node.next));
    }
  } // convert the resulting hull linked list to an array of points


  node = last;
  var concave = [];

  do {
    concave.push(node.p);
    node = node.next;
  } while (node !== last);

  concave.push(node.p);
  return concave;
}

function findCandidate(tree, a, b, c, d, maxDist, segTree) {
  var queue = new _tinyqueue.default([], compareDist);
  var node = tree.data; // search through the point R-tree with a depth-first search using a priority queue
  // in the order of distance to the edge (b, c)

  while (node) {
    for (var i = 0; i < node.children.length; i++) {
      var child = node.children[i];
      var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);
      if (dist > maxDist) continue; // skip the node if it's farther than we ever need

      queue.push({
        node: child,
        dist: dist
      });
    }

    while (queue.length && !queue.peek().node.children) {
      var item = queue.pop();
      var p = item.node; // skip all points that are as close to adjacent edges (a,b) and (c,d),
      // and points that would introduce self-intersections when connected

      var d0 = sqSegDist(p, a, b);
      var d1 = sqSegDist(p, c, d);
      if (item.dist < d0 && item.dist < d1 && noIntersections(b, p, segTree) && noIntersections(c, p, segTree)) return p;
    }

    node = queue.pop();
    if (node) node = node.node;
  }

  return null;
}

function compareDist(a, b) {
  return a.dist - b.dist;
} // square distance from a segment bounding box to the given one


function sqSegBoxDist(a, b, bbox) {
  if (inside(a, bbox) || inside(b, bbox)) return 0;
  var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.maxX, bbox.minY);
  if (d1 === 0) return 0;
  var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.minX, bbox.maxY);
  if (d2 === 0) return 0;
  var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY);
  if (d3 === 0) return 0;
  var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY);
  if (d4 === 0) return 0;
  return Math.min(d1, d2, d3, d4);
}

function inside(a, bbox) {
  return a[0] >= bbox.minX && a[0] <= bbox.maxX && a[1] >= bbox.minY && a[1] <= bbox.maxY;
} // check if the edge (a,b) doesn't intersect any other edges


function noIntersections(a, b, segTree) {
  var minX = Math.min(a[0], b[0]);
  var minY = Math.min(a[1], b[1]);
  var maxX = Math.max(a[0], b[0]);
  var maxY = Math.max(a[1], b[1]);
  var edges = segTree.search({
    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY
  });

  for (var i = 0; i < edges.length; i++) {
    if (intersects(edges[i].p, edges[i].next.p, a, b)) return false;
  }

  return true;
}

function cross(p1, p2, p3) {
  return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
} // check if the edges (p1,q1) and (p2,q2) intersect


function intersects(p1, q1, p2, q2) {
  return p1 !== q2 && q1 !== p2 && cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 && cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;
} // update the bounding box of a node's edge


function updateBBox(node) {
  var p1 = node.p;
  var p2 = node.next.p;
  node.minX = Math.min(p1[0], p2[0]);
  node.minY = Math.min(p1[1], p2[1]);
  node.maxX = Math.max(p1[0], p2[0]);
  node.maxY = Math.max(p1[1], p2[1]);
  return node;
} // speed up convex hull by filtering out points inside quadrilateral formed by 4 extreme points


function fastConvexHull(points) {
  var left = points[0];
  var top = points[0];
  var right = points[0];
  var bottom = points[0]; // find the leftmost, rightmost, topmost and bottommost points

  for (var i = 0; i < points.length; i++) {
    var p = points[i];
    if (p[0] < left[0]) left = p;
    if (p[0] > right[0]) right = p;
    if (p[1] < top[1]) top = p;
    if (p[1] > bottom[1]) bottom = p;
  } // filter out points that are inside the resulting quadrilateral


  var cull = [left, top, right, bottom];
  var filtered = cull.slice();

  for (i = 0; i < points.length; i++) {
    if (!(0, _pointInPolygon.default)(points[i], cull)) filtered.push(points[i]);
  } // get convex hull around the filtered points


  return convexHull(filtered);
} // create a new node in a doubly linked list


function insertNode(p, prev) {
  var node = {
    p: p,
    prev: null,
    next: null,
    minX: 0,
    minY: 0,
    maxX: 0,
    maxY: 0
  };

  if (!prev) {
    node.prev = node;
    node.next = node;
  } else {
    node.next = prev.next;
    node.prev = prev;
    prev.next.prev = node;
    prev.next = node;
  }

  return node;
} // square distance between 2 points


function getSqDist(p1, p2) {
  var dx = p1[0] - p2[0],
      dy = p1[1] - p2[1];
  return dx * dx + dy * dy;
} // square distance from a point to a segment


function sqSegDist(p, p1, p2) {
  var x = p1[0],
      y = p1[1],
      dx = p2[0] - x,
      dy = p2[1] - y;

  if (dx !== 0 || dy !== 0) {
    var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

    if (t > 1) {
      x = p2[0];
      y = p2[1];
    } else if (t > 0) {
      x += dx * t;
      y += dy * t;
    }
  }

  dx = p[0] - x;
  dy = p[1] - y;
  return dx * dx + dy * dy;
} // segment to segment distance, ported from http://geomalgorithms.com/a07-_distance.html by Dan Sunday


function sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {
  var ux = x1 - x0;
  var uy = y1 - y0;
  var vx = x3 - x2;
  var vy = y3 - y2;
  var wx = x0 - x2;
  var wy = y0 - y2;
  var a = ux * ux + uy * uy;
  var b = ux * vx + uy * vy;
  var c = vx * vx + vy * vy;
  var d = ux * wx + uy * wy;
  var e = vx * wx + vy * wy;
  var D = a * c - b * b;
  var sc, sN, tc, tN;
  var sD = D;
  var tD = D;

  if (D === 0) {
    sN = 0;
    sD = 1;
    tN = e;
    tD = c;
  } else {
    sN = b * e - c * d;
    tN = a * e - b * d;

    if (sN < 0) {
      sN = 0;
      tN = e;
      tD = c;
    } else if (sN > sD) {
      sN = sD;
      tN = e + b;
      tD = c;
    }
  }

  if (tN < 0.0) {
    tN = 0.0;
    if (-d < 0.0) sN = 0.0;else if (-d > a) sN = sD;else {
      sN = -d;
      sD = a;
    }
  } else if (tN > tD) {
    tN = tD;
    if (-d + b < 0.0) sN = 0;else if (-d + b > a) sN = sD;else {
      sN = -d + b;
      sD = a;
    }
  }

  sc = sN === 0 ? 0 : sN / sD;
  tc = tN === 0 ? 0 : tN / tD;
  var cx = (1 - sc) * x0 + sc * x1;
  var cy = (1 - sc) * y0 + sc * y1;
  var cx2 = (1 - tc) * x2 + tc * x3;
  var cy2 = (1 - tc) * y2 + tc * y3;
  var dx = cx2 - cx;
  var dy = cy2 - cy;
  return dx * dx + dy * dy;
}

function compareByX(a, b) {
  return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
}

function convexHull(points) {
  points.sort(compareByX);
  var lower = [];

  for (var i = 0; i < points.length; i++) {
    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {
      lower.pop();
    }

    lower.push(points[i]);
  }

  var upper = [];

  for (var ii = points.length - 1; ii >= 0; ii--) {
    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0) {
      upper.pop();
    }

    upper.push(points[ii]);
  }

  upper.pop();
  lower.pop();
  return lower.concat(upper);
}
},{"rbush":"node_modules/rbush/rbush.min.js","tinyqueue":"node_modules/tinyqueue/index.js","point-in-polygon":"node_modules/point-in-polygon/index.js","robust-predicates/umd/orient2d.min.js":"node_modules/robust-predicates/umd/orient2d.min.js"}],"node_modules/gl-vec2/scaleAndAdd.js":[function(require,module,exports) {
module.exports = scaleAndAdd

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function scaleAndAdd(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale)
    out[1] = a[1] + (b[1] * scale)
    return out
}
},{}],"node_modules/gl-vec2/rotate.js":[function(require,module,exports) {
module.exports = rotate

/**
 * Rotates a vec2 by an angle
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to rotate
 * @param {Number} angle the angle of rotation (in radians)
 * @returns {vec2} out
 */
function rotate(out, a, angle) {
  var c = Math.cos(angle),
      s = Math.sin(angle)
  var x = a[0],
      y = a[1]

  out[0] = x * c - y * s
  out[1] = x * s + y * c

  return out
}


},{}],"node_modules/stackblur/index.js":[function(require,module,exports) {
/*

StackBlur - a fast almost Gaussian Blur For Canvas

Version: 	0.5
Author:		Mario Klingemann
Contact: 	mario@quasimondo.com
Website:	http://www.quasimondo.com/StackBlurForCanvas
Twitter:	@quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr: 
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

var mul_table = [
        512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
        454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
        482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
        437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
        497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
        320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
        446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
        329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
        505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
        399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
        324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
        268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
        451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
        385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
        332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
        289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];
        
   
var shg_table = [
	     9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 
		17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 
		19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
		23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];

function blur( pixels, width, height, radius )
{
	if ( isNaN(radius) || radius < 1 ) return;
	radius |= 0;

	var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, 
	r_out_sum, g_out_sum, b_out_sum, a_out_sum,
	r_in_sum, g_in_sum, b_in_sum, a_in_sum, 
	pr, pg, pb, pa, rbs;
			
	var div = radius + radius + 1;
	var w4 = width << 2;
	var widthMinus1  = width - 1;
	var heightMinus1 = height - 1;
	var radiusPlus1  = radius + 1;
	var sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;
	
	var stackStart = new BlurStack();
	var stack = stackStart;
	for ( i = 1; i < div; i++ )
	{
		stack = stack.next = new BlurStack();
		if ( i == radiusPlus1 ) var stackEnd = stack;
	}
	stack.next = stackStart;
	var stackIn = null;
	var stackOut = null;
	
	yw = yi = 0;
	
	var mul_sum = mul_table[radius];
	var shg_sum = shg_table[radius];
	
	for ( y = 0; y < height; y++ )
	{
		r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
		
		r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
		g_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );
		b_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );
		a_out_sum = radiusPlus1 * ( pa = pixels[yi+3] );
		
		r_sum += sumFactor * pr;
		g_sum += sumFactor * pg;
		b_sum += sumFactor * pb;
		a_sum += sumFactor * pa;
		
		stack = stackStart;
		
		for( i = 0; i < radiusPlus1; i++ )
		{
			stack.r = pr;
			stack.g = pg;
			stack.b = pb;
			stack.a = pa;
			stack = stack.next;
		}
		
		for( i = 1; i < radiusPlus1; i++ )
		{
			p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
			r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
			g_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;
			b_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;
			a_sum += ( stack.a = ( pa = pixels[p+3])) * rbs;
			
			r_in_sum += pr;
			g_in_sum += pg;
			b_in_sum += pb;
			a_in_sum += pa;
			
			stack = stack.next;
		}
		
		
		stackIn = stackStart;
		stackOut = stackEnd;
		for ( x = 0; x < width; x++ )
		{
			pixels[yi+3] = pa = (a_sum * mul_sum) >> shg_sum;
			if ( pa != 0 )
			{
				pa = 255 / pa;
				pixels[yi]   = ((r_sum * mul_sum) >> shg_sum) * pa;
				pixels[yi+1] = ((g_sum * mul_sum) >> shg_sum) * pa;
				pixels[yi+2] = ((b_sum * mul_sum) >> shg_sum) * pa;
			} else {
				pixels[yi] = pixels[yi+1] = pixels[yi+2] = 0;
			}
			
			r_sum -= r_out_sum;
			g_sum -= g_out_sum;
			b_sum -= b_out_sum;
			a_sum -= a_out_sum;
			
			r_out_sum -= stackIn.r;
			g_out_sum -= stackIn.g;
			b_out_sum -= stackIn.b;
			a_out_sum -= stackIn.a;
			
			p =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;
			
			r_in_sum += ( stackIn.r = pixels[p]);
			g_in_sum += ( stackIn.g = pixels[p+1]);
			b_in_sum += ( stackIn.b = pixels[p+2]);
			a_in_sum += ( stackIn.a = pixels[p+3]);
			
			r_sum += r_in_sum;
			g_sum += g_in_sum;
			b_sum += b_in_sum;
			a_sum += a_in_sum;
			
			stackIn = stackIn.next;
			
			r_out_sum += ( pr = stackOut.r );
			g_out_sum += ( pg = stackOut.g );
			b_out_sum += ( pb = stackOut.b );
			a_out_sum += ( pa = stackOut.a );
			
			r_in_sum -= pr;
			g_in_sum -= pg;
			b_in_sum -= pb;
			a_in_sum -= pa;
			
			stackOut = stackOut.next;

			yi += 4;
		}
		yw += width;
	}

	
	for ( x = 0; x < width; x++ )
	{
		g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
		
		yi = x << 2;
		r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
		g_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);
		b_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);
		a_out_sum = radiusPlus1 * ( pa = pixels[yi+3]);
		
		r_sum += sumFactor * pr;
		g_sum += sumFactor * pg;
		b_sum += sumFactor * pb;
		a_sum += sumFactor * pa;
		
		stack = stackStart;
		
		for( i = 0; i < radiusPlus1; i++ )
		{
			stack.r = pr;
			stack.g = pg;
			stack.b = pb;
			stack.a = pa;
			stack = stack.next;
		}
		
		yp = width;
		
		for( i = 1; i <= radius; i++ )
		{
			yi = ( yp + x ) << 2;
			
			r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
			g_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;
			b_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;
			a_sum += ( stack.a = ( pa = pixels[yi+3])) * rbs;
		   
			r_in_sum += pr;
			g_in_sum += pg;
			b_in_sum += pb;
			a_in_sum += pa;
			
			stack = stack.next;
		
			if( i < heightMinus1 )
			{
				yp += width;
			}
		}
		
		yi = x;
		stackIn = stackStart;
		stackOut = stackEnd;
		for ( y = 0; y < height; y++ )
		{
			p = yi << 2;
			pixels[p+3] = pa = (a_sum * mul_sum) >> shg_sum;
			if ( pa > 0 )
			{
				pa = 255 / pa;
				pixels[p]   = ((r_sum * mul_sum) >> shg_sum ) * pa;
				pixels[p+1] = ((g_sum * mul_sum) >> shg_sum ) * pa;
				pixels[p+2] = ((b_sum * mul_sum) >> shg_sum ) * pa;
			} else {
				pixels[p] = pixels[p+1] = pixels[p+2] = 0;
			}
			
			r_sum -= r_out_sum;
			g_sum -= g_out_sum;
			b_sum -= b_out_sum;
			a_sum -= a_out_sum;
		   
			r_out_sum -= stackIn.r;
			g_out_sum -= stackIn.g;
			b_out_sum -= stackIn.b;
			a_out_sum -= stackIn.a;
			
			p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;
			
			r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
			g_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));
			b_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));
			a_sum += ( a_in_sum += ( stackIn.a = pixels[p+3]));
		   
			stackIn = stackIn.next;
			
			r_out_sum += ( pr = stackOut.r );
			g_out_sum += ( pg = stackOut.g );
			b_out_sum += ( pb = stackOut.b );
			a_out_sum += ( pa = stackOut.a );
			
			r_in_sum -= pr;
			g_in_sum -= pg;
			b_in_sum -= pb;
			a_in_sum -= pa;
			
			stackOut = stackOut.next;
			
			yi += width;
		}
	}
}

function BlurStack()
{
	this.r = 0;
	this.g = 0;
	this.b = 0;
	this.a = 0;
	this.next = null;
}

module.exports = blur;
},{}],"src/systems/environment/EnvironmentGrid.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EnvironmentGrid = exports.GridBounds = exports.EnvironmentCell = void 0;

var MathUtil = _interopRequireWildcard(require("../../util/math"));

var _Random = _interopRequireDefault(require("../../util/Random"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import { quadtree as Quadtree } from "d3-quadtree";
// import { findQuadtreeDataInCircle } from "../../util/tree-find";
// import boundPoints from "bound-points";
class EnvironmentCell {
  constructor(seed, x, y, cx, cy) {
    this.samples = [];
    this.waterSamples = [];
    this.patches = [];
    this.tokens = [];
    this.seed = seed;
    this.moisture = 0;
    this.elevation = 0;
    this.path = 0;
    this.colorIndex = 0;
    this.x = x;
    this.y = y;
    this.cx = cx;
    this.cy = cy;
    this.entity = null;
  }

}

exports.EnvironmentCell = EnvironmentCell;

class GridBounds {
  constructor(minX, minY, maxX, maxY) {
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }

}

exports.GridBounds = GridBounds;

class EnvironmentGrid {
  constructor(random, colors, size, cellTileSize, colorTileSize) {
    this.size = size;
    this.cellDivisions = Math.ceil(this.size / cellTileSize);
    this.colorDivisions = Math.ceil(this.size / colorTileSize);
    this.cellTileSize = this.size / this.cellDivisions;
    this.colorTileSize = this.size / this.colorDivisions;
    this.colors = colors;
    this.colorIndices = new Uint8Array(this.colorDivisions * this.colorDivisions);
    this.cells = new Array(this.cellDivisions * this.cellDivisions);

    for (let i = 0; i < this.cells.length; i++) {
      const seed = new Uint16Array(4);

      for (let i = 0; i < 4; i++) {
        seed[i] = random.value() * 0x10000;
      }

      const x = Math.floor(i % this.cellDivisions);
      const y = Math.floor(i / this.cellDivisions);
      const cx = -this.size / 2 + x * this.cellTileSize + this.cellTileSize / 2;
      const cy = -this.size / 2 + y * this.cellTileSize + this.cellTileSize / 2;
      this.cells[i] = new EnvironmentCell(seed, x, y, cx, cy);
    }
  }

  box3ToBounds(box3, bounds = new GridBounds()) {
    const min = box3.min;
    const max = box3.max;
    const minU = MathUtil.inverseLerp(-this.size / 2, this.size / 2, min.x);
    const minV = MathUtil.inverseLerp(-this.size / 2, this.size / 2, min.z);
    const maxU = MathUtil.inverseLerp(-this.size / 2, this.size / 2, max.x);
    const maxV = MathUtil.inverseLerp(-this.size / 2, this.size / 2, max.z);
    bounds.minX = MathUtil.clamp(Math.floor(minU * this.cellDivisions), 0, this.cellDivisions - 1);
    bounds.minY = MathUtil.clamp(Math.floor(minV * this.cellDivisions), 0, this.cellDivisions - 1);
    bounds.maxX = MathUtil.clamp(Math.floor(maxU * this.cellDivisions), 0, this.cellDivisions - 1);
    bounds.maxY = MathUtil.clamp(Math.floor(maxV * this.cellDivisions), 0, this.cellDivisions - 1);
    return bounds;
  }

  forEachCellInBounds(bounds, cb) {
    const {
      maxX,
      maxY,
      minX,
      minY
    } = bounds;
    const xCells = maxX - minX;
    const yCells = maxY - minY;

    for (let x = minX; x <= maxX; x++) {
      for (let y = minY; y <= maxY; y++) {
        const idx = x + y * this.cellDivisions;
        const cell = this.cells[idx];
        cb(cell);
      }
    }
  }

  isCellInBounds(cell, bounds) {
    const {
      maxX,
      maxY,
      minX,
      minY
    } = bounds;
    return cell.x >= minX && cell.x <= maxX && cell.y >= minY && cell.y <= maxY;
  }

  getCellAt(x, z) {
    const u = MathUtil.inverseLerp(-this.size / 2, this.size / 2, x);
    const v = MathUtil.inverseLerp(-this.size / 2, this.size / 2, z);
    const ix = Math.floor(u * this.cellDivisions);
    const iy = Math.floor(v * this.cellDivisions);
    const idx = ix + iy * this.cellDivisions;
    return this.cells[idx];
  }

  getColorAt(x, z) {
    const u = MathUtil.inverseLerp(-this.size / 2, this.size / 2, x);
    const v = MathUtil.inverseLerp(-this.size / 2, this.size / 2, z);
    const ix = Math.floor(u * this.colorDivisions);
    const iy = Math.floor(v * this.colorDivisions);
    const idx = ix + iy * this.colorDivisions;
    return this.colors[this.colorIndices[idx] % this.colors.length];
  }

}

exports.EnvironmentGrid = EnvironmentGrid;
},{"../../util/math":"src/util/math.js","../../util/Random":"src/util/Random.js"}],"src/systems/environment/createEnvironmentEntity.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createEnvironmentEntity;

var Tags = _interopRequireWildcard(require("../../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _d3Polygon = require("d3-polygon");

var _color = _interopRequireDefault(require("canvas-sketch-util/color"));

var _fast2dPoissonDiskSampling = _interopRequireDefault(require("fast-2d-poisson-disk-sampling"));

var _water = _interopRequireDefault(require("../../shaders/water.frag"));

var _Random = _interopRequireDefault(require("../../util/Random"));

var _mst = require("../../util/mst");

var _squared = _interopRequireDefault(require("euclidean-distance/squared"));

var _d3Delaunay = require("d3-delaunay");

var _simplexNoise = _interopRequireDefault(require("simplex-noise"));

var _concaveman = _interopRequireDefault(require("../../util/concaveman"));

var Helpers = _interopRequireWildcard(require("../../util/helpers"));

var _simplifyPath = _interopRequireDefault(require("simplify-path"));

var _pointInPolygon = _interopRequireDefault(require("point-in-polygon"));

var _boundPoints = _interopRequireDefault(require("bound-points"));

var _scaleAndAdd = _interopRequireDefault(require("gl-vec2/scaleAndAdd"));

var _rotate = _interopRequireDefault(require("gl-vec2/rotate"));

var _stackblur = _interopRequireDefault(require("stackblur"));

var _geometry = require("../../util/geometry");

var ShaderManager = _interopRequireWildcard(require("../../util/ShaderManager"));

var _RefGLTFLoader = require("../../util/RefGLTFLoader");

var _d3Quadtree = require("d3-quadtree");

var _earcut = _interopRequireDefault(require("earcut"));

var MathUtil = _interopRequireWildcard(require("../../util/math"));

var _euclideanDistance = _interopRequireDefault(require("euclidean-distance"));

var _load = require("../../util/load");

var _EnvironmentGrid = require("./EnvironmentGrid");

var _tokens = require("../../util/tokens");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import { ConvexHull } from "three/examples/jsm/math/ConvexHull";
// import fragmentShader from "../../shaders/ground-simple.frag";
const ignoreCenterSampleRadius = 25;
const ignoreCenterTokenRadius = 45;
const ignoreCenterTokenRadiusSq = ignoreCenterTokenRadius * ignoreCenterTokenRadius;

function createEnvironmentEntity(world, {
  biome = "forest",
  biomeData,
  width,
  height,
  bounds,
  renderer,
  uvMat,
  repeatX,
  repeatY,
  mapGround,
  mapOverlay,
  mapGroundPath,
  waterDistortMap,
  waterNoiseMap,
  waterVertexShader
}) {
  // console.profile("gen");
  const tmp2DArray = [0, 0];
  const curBiomeData = biomeData[biome];
  const hasLakes = curBiomeData.hasLakes;
  const hasIce = curBiomeData.hasIce;
  const colors = curBiomeData.colors;
  const waterColors = curBiomeData.waterColors;
  const state = new Uint16Array(curBiomeData.seed); //Random.getRandomState();

  const random = (0, _Random.default)(state);
  const noise01 = new _simplexNoise.default(random.value);
  const noise02 = new _simplexNoise.default(random.value);
  const featureRadius = 20;
  const rootObject = new THREE.Group();
  rootObject.name = `Environment-${biome}`;
  const g = createGeo(colors, random, featureRadius, hasLakes, noise01, noise02);
  convertCellPolysToColorIndex(g);

  if (hasLakes) {// g.polys;
  }

  const tokensAwayFromCenter = random.shuffle(g.tokens.filter(t => {
    const lenSq = (0, _squared.default)(t.position, [0, 0]);
    return random.chance(0.7) && lenSq >= ignoreCenterTokenRadiusSq;
  }));
  const maxPatches = Math.round(0.75 * tokensAwayFromCenter.length);
  const patches = [];
  const cellTileSize = 40;
  const colorTileSize = 10;
  const grid = new _EnvironmentGrid.EnvironmentGrid(random, colors, Math.min(width, height), cellTileSize, colorTileSize);
  const quadtree = (0, _d3Quadtree.quadtree)().x(d => d.centroid[0]).y(d => d.centroid[1]);
  quadtree.extent(bounds);
  quadtree.addAll(g.cells);
  getGridPixels(quadtree, grid);
  const patchNames = Object.keys(_RefGLTFLoader.MetaData).filter(key => {
    return _RefGLTFLoader.MetaData[key].type === biome && !key.includes("items");
  });
  const patchDeck = random.deck(patchNames);

  for (let i = 0; i < tokensAwayFromCenter.length && patches.length < maxPatches; i++) {
    const t = tokensAwayFromCenter[i];

    if (!intersectsAnyLake(g, t.position, 4)) {
      const pos = t.position.slice();
      const curColor = grid.getColorAt(pos[0], pos[1]);
      const name = patchDeck.current;
      const patchInfo = _RefGLTFLoader.MetaData[name];
      const circlePoints = MathUtil.linspace(8).map(t => {
        const angle = Math.PI * 2 * t;
        return [Math.cos(angle) * patchInfo.boundingCircle.radius + pos[0], Math.sin(angle) * patchInfo.boundingCircle.radius + pos[1]];
      }); // if (biome === 'grasslands') {
      // }
      // if any of the circle points hit a lake

      if (circlePoints.some(o => intersectsAnyLake(g, o, 4))) {
        continue;
      } // const h = Helpers.circleHelper2D(
      //   patchInfo.boundingCircle.center,
      //   patchInfo.boundingCircle.radius,
      //   "white"
      // );
      // h.position.x += t.position[0];
      // h.position.z += t.position[1];
      // h.position.y = 0.1;
      // world.entity().add(Tags.Object3D, h);


      const patch = {
        name,
        position: pos
      };
      patches.push(patch);
      const offset = patchInfo.boundingCircle.radius * 0.85; // t.position[0] += offset;

      t.position[1] += offset; // if (random.chance(0.5)) t.active = false;

      patchDeck.next();
    }
  }

  const activeTokens = tokensAwayFromCenter.filter(t => t.active !== false && (0, _geometry.point2DInsideBounds)(t.position, bounds) && !intersectsAnyLake(g, t.position, 4)); // !intersectsAnyLake(geo, p, 4) &&

  let allSamples = createSamples(patches, g, activeTokens, random, noise01, noise02);
  let samples = [];
  let waterSamples = [];
  allSamples.forEach(s => {
    if (intersectsAnyLake(g, s, 1)) {// waterSamples.push(s);
    } else {
      if (hasIce && random.chance(0.5)) return;
      samples.push(s);
    }
  });

  if (hasLakes) {
    g.lakeBounds.forEach((bounds, i) => {
      const [min, max] = bounds;
      const w = max[0] - min[0];
      const h = max[1] - min[1];
      const disk = new _fast2dPoissonDiskSampling.default({
        shape: [w, h],
        tries: 10,
        radius: 10
      }, random.value);
      const lakeSamplePoints = disk.fill().map(p => {
        return [min[0] + p[0], min[1] + p[1]];
      }).filter(p => {
        const isInLake = (0, _geometry.point2DInsideBounds)(p, bounds) && (0, _pointInPolygon.default)(p, g.lakes[i]);

        if (isInLake) {
          const ptDist = 2.5;
          const ptSq = ptDist * ptDist; // only if none hit edge

          if (!g.lakes[i].some(o => (0, _squared.default)(o, p) < ptSq)) {
            return true;
          }
        }

        return false;
      });
      lakeSamplePoints.forEach(s => {
        waterSamples.push(s);
      });
    });
  } // for (let i = 0; i < totalPatchesToShow && i < tokensAwayFromCenter.length; i++) {
  //   const token = tokensAwayFromCenter[i];
  //   patchDeck.current()
  // }
  // console.log("total patches", patches.length);
  // console.log("total patches to show", totalPatchesToShow);
  // now let's place some special samples that hold the different
  // "patches" that we want to spawn


  const textures = createChannelTextures(renderer, g, colors, waterColors);
  const [texData, texColor, texLake, texLakeBlur, texLakeHard] = textures;
  const meshes = createWaterMeshes(g, textures);
  getGridSamples(quadtree, grid, samples, waterSamples);
  const features = _tokens.BiomeFeatures[biome].tokens;
  const tokens = activeTokens.filter(p => {
    const [min, max] = bounds; // console.log(p.position, min, max);
    // p.position[0] = -min[0];

    const edist = 15;
    return Math.abs(p.position[0] - min[0]) > edist && Math.abs(p.position[1] - min[1]) > edist && Math.abs(p.position[0] - max[0]) > edist && Math.abs(p.position[1] - max[1]) > edist;
  }).map(p => {
    return {
      position: p.position,
      type: random.pick(features)
    };
  }); // console.log("total tokens", tokens);

  const bestIdlePatches = patches.filter(p => {
    const d = (0, _euclideanDistance.default)(p.position, [0, 0]);
    return d >= 25 && d < 512 / 2 * 0.75;
  });
  const idleViewPatch = random.pick(bestIdlePatches);
  const idleViewPatchInfo = _RefGLTFLoader.MetaData[idleViewPatch.name];
  const idleViewPoint = new THREE.Vector3(idleViewPatch.position[0] - idleViewPatchInfo.boundingCircle.radius * 0.75, 0, idleViewPatch.position[1] - idleViewPatchInfo.boundingCircle.radius * 0.75); // console.log("patches", bestIdlePatches.length);
  // console.log("idleViewPoint", idleViewPatch, idleViewPoint);

  tokens.forEach((t, i) => {
    const [x, y] = t.position;
    const cell = grid.getCellAt(x, y);
    cell.tokens.push(i);
  });
  patches.push({
    name: "origin-patch-0",
    position: [0, 0]
  });
  patches.forEach((p, i) => {
    const [x, y] = p.position;
    const cell = grid.getCellAt(x, y);
    cell.patches.push(i);
  }); // console.profileEnd("gen");

  return world.entity().add(Tags.EnvironmentState, { ...curBiomeData,
    data: {
      width,
      height
    },
    waterMeshes: meshes,
    name: biome,
    haikusTotal: curBiomeData.haikusTotal,
    patches,
    tokens,
    group: rootObject,
    lakes: g.lakes.map((poly, i) => {
      return {
        bounds: g.lakeBounds[i],
        polygon: poly
      };
    }),
    idleViewPoint,
    colors,
    textures,
    waterMap: texLakeHard,
    grid,
    samples,
    waterSamples
  });

  function getGridSamples(quadtree, grid, samples, waterSamples) {
    samples.forEach((s, i) => {
      const cell = grid.getCellAt(s[0], s[1]);
      if (cell) cell.samples.push(i);
    });
    waterSamples.forEach((s, i) => {
      const cell = grid.getCellAt(s[0], s[1]);
      if (cell) cell.waterSamples.push(i);
    });

    for (let y = 0; y < grid.cellDivisions; y++) {
      for (let x = 0; x < grid.cellDivisions; x++) {
        const u = x / (grid.cellDivisions - 1);
        const v = y / (grid.cellDivisions - 1);
        const wx = MathUtil.lerp(-width / 2, width / 2, u);
        const wz = MathUtil.lerp(-height / 2, height / 2, v);
        const cell = quadtree.find(wx, wz);
        const c = grid.cells[x + y * grid.cellDivisions];
        c.elevation = cell.elevation;
        c.moisture = cell.moisture;
        c.path = cell.distance;
        c.colorIndex = cell.colorIndex;
      }
    }
  }

  function getGridPixels(quadtree, grid) {
    for (let y = 0; y < grid.colorDivisions; y++) {
      for (let x = 0; x < grid.colorDivisions; x++) {
        const u = x / (grid.colorDivisions - 1);
        const v = y / (grid.colorDivisions - 1);
        const wx = MathUtil.lerp(-width / 2, width / 2, u);
        const wz = MathUtil.lerp(-height / 2, height / 2, v);
        const cell = quadtree.find(wx, wz);
        grid.colorIndices[x + y * grid.colorDivisions] = cell.colorIndex;
      }
    }
  }

  function createWaterMeshes(geo, textures) {
    const dataTarget = world.findTag(Tags.GroundDataRenderTarget);
    const groundView = world.findTag(Tags.GroundPlaneView);
    return g.lakes.map((poly, i) => {
      const [min, max] = g.lakeBounds[i];
      const w = max[0] - min[0];
      const h = max[1] - min[1];
      const lakeSize = Math.sqrt(w * w + h * h) / 2;
      const centroid = (0, _d3Polygon.polygonCentroid)(poly);
      const verts = poly.flat(Infinity);
      const cells = (0, _earcut.default)(verts, [], 2);
      const geom = new THREE.BufferGeometry();
      const uvs = [];
      const verts3D = [];
      const angles = [];
      const surfUVs = [];
      poly.forEach((p, i, list) => {
        angles.push(i / (list.length - 1) * Math.PI * 2);
        verts3D.push(p[0], 0, p[1]);
        const u = MathUtil.inverseLerp(-width / 2, width / 2, p[0]);
        const v = MathUtil.inverseLerp(height / 2, -height / 2, p[1]);
        uvs.push(u, v);
        const su = MathUtil.inverseLerp(min[0], max[0], p[0]);
        const sv = MathUtil.inverseLerp(min[1], max[1], p[1]);
        surfUVs.push(su, sv);
      });
      geom.setAttribute("position", new THREE.Float32BufferAttribute(verts3D, 3));
      geom.setAttribute("uv", new THREE.Float32BufferAttribute(uvs, 2));
      geom.setAttribute("surfUv", new THREE.Float32BufferAttribute(surfUVs, 2));
      geom.setAttribute("angle", new THREE.Float32BufferAttribute(angles, 1));
      geom.setIndex(new THREE.Uint16BufferAttribute(cells, 1));
      const material = ShaderManager.create({
        name: "WaterShader",
        uniforms: {
          uvScale: {
            value: new THREE.Vector2(repeatX, repeatY)
          },
          time: {
            value: 0
          },
          centroidPosition: {
            value: new THREE.Vector3(centroid[0], 0, centroid[1])
          },
          uvTransform: {
            value: uvMat
          },
          environmentSize: {
            value: new THREE.Vector2(width, height)
          },
          worldDataMap: {
            value: dataTarget ? dataTarget.target.texture : getEmptyTexture()
          },
          worldDataProjection: {
            value: dataTarget ? dataTarget.projection : new THREE.Matrix4()
          },
          worldDataView: {
            value: dataTarget ? dataTarget.view : new THREE.Matrix4()
          },
          waterDistortMap: {
            value: waterDistortMap
          },
          waterNoiseMap: {
            value: waterNoiseMap
          },
          lakeSize: {
            value: lakeSize
          },
          colorA: {
            value: new THREE.Color(hasIce ? "#698193" : "#163d84")
          },
          colorB: {
            value: new THREE.Color(hasIce ? "#a8bec4" : "#49c2ff")
          },
          groundMap: {
            value: groundView.target.texture
          },
          dataMapBiome: {
            value: textures[0]
          },
          dataMapColor: {
            value: textures[1]
          },
          dataMapLake: {
            value: textures[2]
          },
          dataMapLakeBlur: {
            value: textures[3]
          },
          uvRepeatScale: {
            value: 1
          }
        },
        side: THREE.BackSide,
        vertexShader: waterVertexShader,
        transparent: true,
        defines: {
          WATER: !hasIce,
          HAS_GROUND_MAP: true,
          HAS_DATA_MAP: true,
          HAS_ANGLE: true,
          HAS_SURF_UV: true
        },
        fragmentShader: _water.default
      });
      const mesh = new THREE.Mesh(geom, material);
      mesh.userData.colorA = material.uniforms.colorA.value.clone();
      mesh.userData.colorB = material.uniforms.colorB.value.clone();
      rootObject.add(mesh);
      world.entity().add(Tags.ShaderUniformTime, {
        uniform: material.uniforms.time
      });
      mesh.layers.set(world.findTag(Tags.RenderLayers).water);
      mesh.renderOrder = -1;
      mesh.position.y = 0.05;
      return mesh;
    });
  }

  function createSamples(patches, geo, activeTokens, random, noise01, noise02) {
    const sampleRadius = 1.5;
    const sampleDisk = new _fast2dPoissonDiskSampling.default({
      shape: [width, height],
      tries: 10,
      radius: sampleRadius * 2
    }, random.value); // const points = sampleDisk.fill();

    const tmpNormal = [0, 0];
    const tmpPerp = [0, 0];
    const tmpPoint = [0, 0];
    const tmpSample = [0, 0];
    const tmpRotNorm = [0, 0];
    const tmpOffset2D = [0, 0];
    geo.segments.forEach(([a, b]) => {
      getSegmentNormal(tmpNormal, a, b);
      getPerpendicular(tmpPerp, tmpNormal);
      const len = (0, _euclideanDistance.default)(a, b);
      const {
        elevation,
        moisture
      } = createTerrain(width, height, noise01, noise02, (a[0] + b[0]) / 2, (a[1] + b[1]) / 2);
      const spacing = MathUtil.lerp(0.25, 20, elevation);
      const count = Math.max(2, Math.ceil(len / spacing));

      for (let i = 0; i < count; i++) {
        // if (random.gaussian(0, 1) > 0) continue;
        let t = i / (count - 1);
        t = MathUtil.lerp(0.0, 1, t);
        const steps = random.rangeFloor(1, 6);

        for (let k = 0; k < steps; k++) {
          const p = MathUtil.lerpArray(a, b, t, tmpPoint);
          p[0] += width / 2;
          p[1] += height / 2;
          const radius = Math.abs(random.gaussian(1, 1));
          (0, _scaleAndAdd.default)(p, p, random.insideCircle(radius, tmpOffset2D), 1); // const dist = random.gaussian(20, 10);

          const dist = random.range(15, 20) + Math.abs(random.gaussian(0, 5));

          for (let j = 0; j < 2; j++) {
            // if (random.gaussian(0, 1) > 0) continue;
            const x = j === 0 ? -1 : 1;
            const angleOff = 45;
            (0, _rotate.default)(tmpRotNorm, tmpPerp, MathUtil.degToRad(random.range(-angleOff, angleOff)));
            (0, _scaleAndAdd.default)(tmpSample, p, tmpRotNorm, dist * x);

            if (!sampleDisk.inNeighbourhood(tmpSample)) {
              (0, _scaleAndAdd.default)(tmpSample, tmpSample, random.insideCircle(random.range(0.0 * sampleRadius, 1 * sampleRadius), tmpOffset2D), 1);
              sampleDisk.addPoint(tmpSample);
            }
          }
        }
      }
    });
    const centerRadius = ignoreCenterSampleRadius;
    const centerSq = centerRadius * centerRadius;
    const samples = sampleDisk.samplePoints.map(p => {
      return [-width / 2 + p[0], -height / 2 + p[1]];
    });
    return samples.filter(p => {
      const tokenRadius = 4;
      const tokenRadiusSq = tokenRadius * tokenRadius;
      return !activeTokens.some(t => (0, _squared.default)(t.position, p) < tokenRadiusSq) && !patches.some(patch => {
        const patchInfo = patch.name in _RefGLTFLoader.MetaData ? _RefGLTFLoader.MetaData[patch.name] : false;

        if (patchInfo) {
          const radius = patchInfo.boundingCircle.radius;
          return (0, _geometry.circlesIntersect)(p, 1, patch.position, radius);
        } else {
          return false;
        }
      }) && (0, _squared.default)(p, [0, 0]) > centerSq;
    });
  }

  function intersectsAnyLake(geo, p, radius = 2) {
    for (let i = 0; i < geo.lakeBounds.length; i++) {
      if (intersectsLakeIndex(geo, p, i, radius)) {
        return true;
      }
    }

    return false;
  }

  function intersectsLakeIndex(geo, p, i, radius = 2) {
    const ptSq = radius * radius;
    const b = geo.lakeBounds[i];

    if ((0, _geometry.point2DInsideBounds)(p, b)) {
      if ((0, _pointInPolygon.default)(p, geo.lakes[i])) {
        return true;
      }
    }

    if (geo.lakes[i].some(o => (0, _squared.default)(o, p) < ptSq)) {
      return true;
    }

    return false;
  }

  function drawCanvas(canvas, context, textureSize, drawFn) {
    context.fillStyle = "black";
    context.clearRect(0, 0, textureSize, textureSize);
    context.fillRect(0, 0, textureSize, textureSize);
    const [min, max] = bounds;
    const fw = max[0] - min[0];
    const fh = max[1] - min[1];
    const sx = canvas.width / fw;
    const sy = canvas.height / fh;
    const zoom = 1.0;
    context.save();
    context.scale(sx, sy);
    context.translate(width / 2, height / 2);
    context.scale(zoom, zoom);
    drawFn({
      context,
      canvas
    });
    context.restore();
    return {
      context,
      canvas
    };
  }

  function createChannelTextures(renderer, geo, groundColors, waterColors) {
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    return [0, 1, 2, 3, 4].map((c, i) => {
      let textureSize = c >= 2 ? 256 : 512;
      if (c === 4) textureSize = 128;
      canvas.width = textureSize;
      canvas.height = textureSize;
      drawCanvas(canvas, context, textureSize, ({
        canvas,
        context
      }) => drawChannelTexture({
        c,
        i,
        canvas,
        context,
        geo,
        groundColors,
        waterColors
      }));
      let iters = 2;
      let radius = 4;

      if (c === 2) {
        iters = 1;
        radius = 2;
      } else if (c === 3) {
        iters = 2;
        radius = 8;
      } else if (c === 4) {
        iters = 0;
        radius = 0;
      }

      if (iters > 0) {
        blur(context, textureSize, textureSize, iters, radius);
      }

      const tex = new THREE.Texture(canvas);
      tex.needsUpdate = true;
      renderer.initTexture(tex);
      tex.image = null;
      return tex;
    });
  }

  function drawChannelTexture({
    c,
    i,
    canvas,
    context,
    geo,
    groundColors,
    waterColors
  }) {
    const baseColor = new THREE.Color(); // const offPathColorObj = new THREE.Color(offPathColor);

    if (c === 0 || c === 1) {
      geo.cells.forEach(p => {
        let color;

        if (c === 0) {
          const r0 = random.range(-1, 1) * 0.2;
          const r1 = random.range(-1, 1) * 0.2;
          const r2 = random.range(-1, 1) * 0.2;
          baseColor.setRGB(MathUtil.clamp01(p.moisture + r0), MathUtil.clamp01(p.elevation + r1), MathUtil.clamp01(p.distance + r2)); // baseColor.setHSL(0, 0, p.moisture);
          // baseColor.offsetHSL(0, 0, (p.elevation * 2 - 1) * 0.1);
          // baseColor.offsetHSL(0, 0, (p.moisture * 2 - 1) * 0.1);
          // baseColor.offsetHSL(0, 0, (p.distance * 2 - 1) * 0.1);

          color = baseColor.getStyle(); // const g = p.colorIndex / 4;
          // color = `hsl(0, 0%, ${(g * 100).toFixed(2)}%)`;
          // baseColor.set(groundColors[p.colorIndex].color);
          // baseColor.lerp(offPathColorObj, 1 - p.distance);
          // baseColor.offsetHSL(0, 0, (p.distance * 2 - 1) * 0.1);
          // // baseColor.offsetHSL(0, 0, (p.elevation * 2 - 1) * 0.05);
          // // baseColor.offsetHSL(0, 0, (p.moisture * 2 - 1) * 0.1);
          // color = baseColor.getStyle();
        } else {
          color = p.color.getStyle();
        }

        context.fillStyle = context.strokeStyle = color;
        context.beginPath();
        p.polygon.forEach(pt => context.lineTo(...pt));
        context.lineJoin = "round";
        context.lineWidth = 1;
        context.fill();
        context.stroke();
      }); // if (c === 1) {
      //   geo.lakes.forEach((p) => {
      //     context.fillStyle = random.pick(waterColors).color;
      //     context.beginPath();
      //     p.forEach((pt) => context.lineTo(...pt));
      //     context.fill();
      //   });
      // }
    } else {
      geo.lakes.forEach((p, i) => {
        context.fillStyle = "white";
        context.strokeStyle = c === 4 ? "white" : "black";
        context.beginPath();
        p.forEach(pt => context.lineTo(...pt));
        context.lineJoin = "round";
        context.closePath();
        context.lineWidth = c === 4 ? 0.5 : 2;
        context.fill();
        context.stroke();
      });
    }
  }

  function blur(context, width, height, iters = 1, radius = 8) {
    const imgData = context.getImageData(0, 0, width, height);

    for (let i = 0; i < iters; i++) {
      (0, _stackblur.default)(imgData.data, width, height, radius);
    }

    context.putImageData(imgData, 0, 0);
  }

  function convertCellPolysToColorIndex(g) {
    g.cells.forEach(p => {
      const {
        distance,
        moisture,
        elevation,
        lakeDistance
      } = p;
      const m = moisture;
      const e = elevation;
      let colorIndex = 0;

      if (hasLakes) {
        const lakeWetland = 10;

        if (p.lengthFromCenter > lakeWetland && (intersectsAnyLake(g, p.centroid, lakeWetland) || p.polygon.some(pt => intersectsAnyLake(g, p.centroid, lakeWetland)))) {
          // water
          colorIndex = 3;
        } else {
          // non-water
          if (m < 0.5 && e >= 0.5) {
            // dry, high
            colorIndex = 0;
          } else if (m < 0.5 && e < 0.5) {
            // dry, low
            colorIndex = 1;
          } else {
            // wet, low/high
            colorIndex = 2;
          }
        }
      } else {
        if (m < 0.5 && e >= 0.5) {
          // dry, high
          colorIndex = 0;
        } else if (m < 0.5 && e < 0.5) {
          // dry, low
          colorIndex = 1;
        } else if (m >= 0.5 && e >= 0.5) {
          // wet, high
          colorIndex = 2;
        } else {
          // wet, low
          colorIndex = 3;
        }
      }

      p.colorIndex = colorIndex;
      const pt = 0.5;
      const pf = 0.5;
      const color = new THREE.Color();
      color.set(colors[p.colorIndex % colors.length].color);
      color.offsetHSL(0, 0, (p.elevation * 2 - 1) * 0.05);
      color.offsetHSL(0, 0, (p.moisture * 2 - 1) * 0.1);
      color.offsetHSL(random.range(-1, 1) * 0.01, random.range(-1, 1) * 0.01, (MathUtil.smoothstep(pt - pf, pt + pf, p.distance) * 2 - 1) * 0.1);
      p.color = color;
    });
  }

  function createGeo(colors, random, featureRadius, hasLakes, noise01, noise02) {
    const tokenZones = random.shuffle(getRandomFeatures(width, height, featureRadius, random));
    let tokens = tokenZones.map(feature => {
      const position = feature.slice();
      const offset = random.insideCircle(featureRadius * 0.5, tmp2DArray);
      position[0] += offset[0];
      position[1] += offset[1];
      return {
        center: feature,
        radius: featureRadius,
        position
      };
    });
    const lakeSpacing = featureRadius * 4;
    const lakeGap = lakeSpacing;
    const maxLakes = 8;
    let lakes = [];

    if (hasLakes) {
      lakes = getRandomFeatures(width, height, lakeSpacing, random);
      lakes = random.shuffle(lakes.filter(t => {
        return (0, _euclideanDistance.default)(t, [0, 0]) > featureRadius * 4;
      })).slice(0, maxLakes);
    }

    tokens = tokens.filter(t => {
      const d = (0, _euclideanDistance.default)(t.position, [0, 0]);

      for (let i = 0; i < lakes.length; i++) {
        const dlake = (0, _euclideanDistance.default)(t.position, lakes[i]);
        if (dlake < lakeGap / 2) return false;
      }

      const absX = Math.abs(t.position[0]);
      const absY = Math.abs(t.position[1]);
      const margin = 0.95; // if (d > width / 2) return random.chance(0.5);
      // if (d > width / 4) return random.chance(0.9);

      return absX < width / 2 * margin && absY < height / 2 * margin;
    });
    const connections = (0, _mst.getMinimumSpanningTree)(tokens.map(t => t.position), (a, b) => (0, _squared.default)(a, b)).map(c => c.indices);
    const segments = connections.map(c => {
      const connection = c.map(i => tokens[i]);
      return connection.map(t => t.position);
    });
    const flatBounds = bounds.flat(); // const bds = Helpers.boundsHelper2D(
    //   [
    //     [flatBounds[0], flatBounds[1]],
    //     [flatBounds[2], flatBounds[3]],
    //   ],
    //   { color: "yellow" }
    // );
    // world.entity().add(Tags.Object3D, bds);

    const dpoints = segments.map(segment => {
      const count = random.rangeFloor(5, 5);
      const points = [];

      for (let i = 0; i < count; i++) {
        const t = i / count;
        const p = MathUtil.lerpArray(segment[0], segment[1], t);
        random.insideCircle(featureRadius / 8, tmp2DArray);
        p[0] += tmp2DArray[0];
        p[1] += tmp2DArray[1];
        points.push(p);
      }

      return points;
    }).flat();
    const delaunayPoints = generateRandomPointsFast(width, height, 1, random);

    const delaunay = _d3Delaunay.Delaunay.from(delaunayPoints);

    const relaxations = 2;

    for (let i = 0; i < relaxations; i++) {
      relax(flatBounds, delaunay, 0.5);
    }

    const voronoi = delaunay.voronoi(flatBounds);
    const cells = Array.from(voronoi.cellPolygons()).map((polygon, i) => {
      const index = polygon.index;
      if (index !== i) console.error("ERR! poly index doesn't match");
      polygon = Array.from(polygon).slice(0, polygon.length - 1);
      return polygon;
    }); // const polys = Helpers.multiPoly2D(cells);
    // world.entity().add(Tags.Object3D, polys);
    // const tokenPositions = tokens.map((t) => t.position);

    const centroids = cells.map(c => (0, _d3Polygon.polygonCentroid)(c));
    const distances = centroids.map(c => {
      return metaballDistance(c[0], c[1], dpoints, featureRadius);
    });
    const lakeDistances = centroids.map(c => {
      return metaballDistance(c[0], c[1], lakes, lakeGap / 4, 1, 1.5);
    });
    const polys = cells.map((c, i) => {
      const centroid = centroids[i];
      const {
        elevation,
        moisture
      } = createTerrain(width, height, noise01, noise02, centroid[0], centroid[1]);
      const d = distances[i];
      const lakeDistance = lakeDistances[i];
      return {
        polygon: c,
        connections,
        segments,
        distance: d,
        lakeDistance,
        moisture,
        elevation
      };
    });
    normalizeAttr(polys, "moisture");
    normalizeAttr(polys, "elevation");
    normalizeAttr(polys, "lakeDistance");
    normalizeAttr(polys, "distance");
    const lakePolys = new Set();
    polys.forEach((p, i) => {
      const {
        distance,
        moisture,
        elevation,
        lakeDistance
      } = p;
      const m = moisture;
      const e = elevation;
      const length = (0, _euclideanDistance.default)([0, 0], centroids[i]);
      p.centroid = centroids[i];
      p.lengthFromCenter = length;

      if (hasLakes && length > 40 && distance < 0.25 && (m > 0.5 && e < 0.5 || lakeDistance > 0.5)) {
        lakePolys.add(i);
      } // const objects = Helpers.filledPoly2D(p.polygon, { color });
      // world.entity().add(Tags.Object3D, objects);

    });
    const lakeSets = convertLakeIndicesToSets(voronoi, lakePolys);
    const lakeHulls = lakeSets.filter(set => {
      return set.length > 2;
    }).map(set => convertSetToHull(polys, set));
    const lakeContours = lakeHulls.map(hull => {
      const p = (0, _simplifyPath.default)(hull, 1);
      if (p.length) p.pop(); // remove closing point

      return p;
    }).filter(c => {
      return c.length > 4;
    }).map(c => {
      const points3D = c.map(p => new THREE.Vector3(p[0], 0, p[1]));
      return new THREE.CatmullRomCurve3(points3D, true, "chordal", 0.5).getSpacedPoints(c.length * 8).map(t => [t.x, t.z]);
    });
    return {
      lakes: lakeContours,
      lakeBounds: lakeContours.map(c => (0, _boundPoints.default)(c)),
      tokens: tokens,
      segments,
      cells: polys
    };
  }

  function getPerpendicular(out = [], a) {
    out[0] = -a[1];
    out[1] = a[0];
    return out;
  }

  function getSegmentNormal(out = [], a, b) {
    let dx = b[0] - a[0];
    let dy = b[1] - a[1];
    const mlen2 = dx * dx + dy * dy;

    if (mlen2 !== 0) {
      // normalize vector to unit length
      const len = Math.sqrt(mlen2);
      dx /= len;
      dy /= len;
    }

    out[0] = dx;
    out[1] = dy;
    return out;
  }

  function convertLakeIndicesToSets(voronoi, indices) {
    const touchedPolys = new Set();
    const lakeSets = new Set();
    indices.forEach(i => {
      if (!touchedPolys.has(i)) {
        const allTouching = findAllLakeNeighbors(voronoi, indices, i, touchedPolys); // const lakeCandidates = [];

        allTouching.forEach(j => {
          // mark all these as touched
          touchedPolys.add(j);
        });
        lakeSets.add([...allTouching]);
      }
    });
    return [...lakeSets];
  }

  function convertSetToHull(polys, set) {
    const verts = [];
    set.forEach(i => {
      const [min, max] = (0, _boundPoints.default)(polys[i].polygon);
      const w = max[0] - min[0];
      const h = max[1] - min[1];
      const r = Math.min(w, h) * 0.5;
      const angleOff = random.range(-1, 1) * Math.PI * 2;
      const newPoints = MathUtil.linspace(8).map(t => {
        const angle = t * 2 * Math.PI + angleOff;
        const x = min[0] + w / 2 + Math.cos(angle) * r;
        const y = min[1] + h / 2 + Math.sin(angle) * r;
        verts.push([x, y]);
      }); // polys[i].polygon.forEach((v) => {
      //   verts.push(v);
      // });
    }); // const points = verts.map((v) => new THREE.Vector3(v[0], 0, v[1]));
    // const hull = new ConvexHull().setFromPoints(points);
    // console.log(hull.faces);
    // const hull = fastConvexHull(verts);
    // console.log(hull);

    return (0, _concaveman.default)(verts);
  }

  function findAllLakeNeighbors(voronoi, lakePolys, i, excluding) {
    const set = new Set();
    const polysToTest = [i];

    while (polysToTest.length > 0) {
      // add this node to the set
      const t = polysToTest.shift();
      set.add(t); // now find its neighbors

      for (let j of voronoi.neighbors(t)) {
        // if the neighbor is a lake and we haven't seen it yet
        if (lakePolys.has(j) && !set.has(j) && !excluding.has(j)) {
          // add it to our set
          set.add(j); // also we have to now walk its neighbors to see if any more match

          polysToTest.push(j);
        }
      }
    }

    return set;
  }

  function normalizeAttr(cells, attr) {
    const max = cells.reduce((max, cell) => Math.max(max, cell[attr]), -Infinity);
    const min = cells.reduce((min, cell) => Math.min(min, cell[attr]), Infinity);

    if (max !== min) {
      cells.forEach(c => {
        c[attr] = MathUtil.mapRange(c[attr], min, max, 0, 1, true);
      });
    }
  }

  function metaballDistance(x, y, centroids, radius, minScale = 1, maxScale = 1.5, power = 0.5) {
    let sum = 0;

    for (let i = 0; i < centroids.length; i++) {
      const c = centroids[i]; // if (c[0] === x && c[1] === y) continue;

      const dx = x - c[0];
      const dy = y - c[1];
      const d2 = dx * dx + dy * dy; // if (d2 === 0) continue;

      let dst = d2 === 0 ? 0 : Math.sqrt(d2); // if (dst > featureRadius * 2) continue;
      // if (dst > featureRadius) continue;
      // if (dst < featureRadius / 2) dst = featureRadius;
      // if (dst < featureRadius / 4) dst = featureRadius / 4;
      // sum += featureRadius / dst;

      const minDist = radius * minScale;
      const maxDist = radius * maxScale;
      const alpha = MathUtil.clamp01(MathUtil.inverseLerp(minDist, maxDist, dst));
      sum += 1 - Math.pow(alpha, power);
    }

    return sum;
  }

  function relax(flatBounds, delaunay, relaxationParameter = 0.5) {
    const voronoi = delaunay.voronoi(flatBounds);

    for (let i = 0; i < delaunay.points.length; i += 2) {
      const cell = voronoi.cellPolygon(i >> 1);
      if (cell === null) continue;
      const x0 = delaunay.points[i];
      const y0 = delaunay.points[i + 1];
      const [x1, y1] = (0, _d3Polygon.polygonCentroid)(cell);
      delaunay.points[i] = x0 + (x1 - x0) * relaxationParameter;
      delaunay.points[i + 1] = y0 + (y1 - y0);
    }

    delaunay.update();
  }

  function getRandomFeatures(width, height, radius, random) {
    const disk = new _fast2dPoissonDiskSampling.default({
      shape: [width, height],
      tries: 10,
      radius: radius * 2
    }, random.value);
    disk.addPoint([width / 2, height / 2]);
    return disk.fill().map(p => {
      return [-width / 2 + p[0], -height / 2 + p[1]];
    });
  }

  function generateRandomPointsFast(width, height, spacing, random) {
    const aspect = width / height;
    const countWidth = Math.max(1, Math.ceil(width / spacing));
    const countHeight = Math.max(1, Math.ceil(height / spacing));
    const factor = 5;
    const N = Math.round(Math.max(countWidth, countHeight) * factor);
    return MathUtil.linspace(N).map(() => {
      return [random.range(-width / 2, width / 2), random.range(-height / 2, height / 2)];
    });
  }
}

function createTerrain(width, height, noise01, noise02, x, y) {
  const params = {
    f1: 2,
    t1: 4,
    k1: 0.5,
    f2: 2,
    t2: 4,
    k2: 0.25
  };
  const {
    t1,
    f1,
    k1,
    t2,
    f2,
    k2
  } = params;
  const aspect = width / height;
  let u = MathUtil.inverseLerp(-width / 2, width / 2, x);
  let v = MathUtil.inverseLerp(-height / 2, height / 2, y);
  u *= aspect;
  const elevation = MathUtil.lerp(Math.pow(layeredNoise3D(noise01, u, v, 0, t1), 1.2), noise01.noise2D(u * f1, v * f1) * 0.5 + 0.5, k1);
  const moisture = MathUtil.lerp(Math.pow(layeredNoise3D(noise02, u, v, 0, t2), 1), noise02.noise2D(u * f2, v * f2) * 0.5 + 0.5, k2);
  return {
    elevation,
    moisture
  };
}

function layeredNoise3D(simplex, px, py, z = 0, uvFreq = 0.1) {
  // This uses many layers of noise to create a more organic pattern
  const nx = px * uvFreq;
  const ny = py * uvFreq;
  let e = 1.0 * (simplex.noise3D(1 * nx, 1 * ny, z) * 0.5 + 0.5) + 0.5 * (simplex.noise3D(2 * nx, 2 * ny, z) * 0.5 + 0.5) + 0.25 * (simplex.noise3D(4 * nx, 4 * ny, z) * 0.5 + 0.5) + 0.13 * (simplex.noise3D(8 * nx, 8 * ny, z) * 0.5 + 0.5) + 0.06 * (simplex.noise3D(16 * nx, 16 * ny, z) * 0.5 + 0.5) + 0.03 * (simplex.noise3D(32 * nx, 32 * ny, z) * 0.5 + 0.5);
  e /= 1.0 + 0.5 + 0.25 + 0.13 + 0.06 + 0.03;
  return e;
}
},{"../../tags":"src/tags/index.js","three":"src/vendor/three.module.js","d3-polygon":"node_modules/d3-polygon/src/index.js","canvas-sketch-util/color":"node_modules/canvas-sketch-util/color.js","fast-2d-poisson-disk-sampling":"node_modules/fast-2d-poisson-disk-sampling/src/fast-poisson-disk-sampling.js","../../shaders/water.frag":"src/shaders/water.frag.js","../../util/Random":"src/util/Random.js","../../util/mst":"src/util/mst.js","euclidean-distance/squared":"node_modules/euclidean-distance/squared.js","d3-delaunay":"node_modules/d3-delaunay/src/index.js","simplex-noise":"node_modules/simplex-noise/simplex-noise.js","../../util/concaveman":"src/util/concaveman.js","../../util/helpers":"src/util/helpers.js","simplify-path":"node_modules/simplify-path/index.js","point-in-polygon":"node_modules/point-in-polygon/index.js","bound-points":"node_modules/bound-points/bounds.js","gl-vec2/scaleAndAdd":"node_modules/gl-vec2/scaleAndAdd.js","gl-vec2/rotate":"node_modules/gl-vec2/rotate.js","stackblur":"node_modules/stackblur/index.js","../../util/geometry":"src/util/geometry.js","../../util/ShaderManager":"src/util/ShaderManager.js","../../util/RefGLTFLoader":"src/util/RefGLTFLoader.js","d3-quadtree":"node_modules/d3-quadtree/src/index.js","earcut":"node_modules/earcut/src/earcut.js","../../util/math":"src/util/math.js","euclidean-distance":"node_modules/euclidean-distance/index.js","../../util/load":"src/util/load.js","./EnvironmentGrid":"src/systems/environment/EnvironmentGrid.js","../../util/tokens":"src/util/tokens.js"}],"src/shaders/ground-simple.vert.js":[function(require,module,exports) {
module.exports = "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying vec2 vTextureUv;\n#ifdef HAS_ANGLE\nattribute float angle;\nvarying float vAngle;\n#endif\n#ifdef HAS_GROUND_MAP\nvarying vec2 vGroundUv;\n#endif\n#ifdef HAS_SURF_UV\nattribute vec2 surfUv;\nvarying vec2 vSurfUv;\n#endif\nvarying vec3 vWorldPosition;\n#ifdef HAS_DATA_MAP\nvarying vec2 vDataUv;\nuniform mat4 worldDataProjection;\nuniform mat4 worldDataView;\nuniform vec2 environmentSize;\n#endif\n#ifdef HAS_SHADOW_MAP\nvarying vec2 vShadowUv;\nvarying vec3 vShadowClipPos;\nuniform mat4 shadowProjection;\n#endif\nuniform mat3 uvTransform;\nuniform vec2 uvScale;\n\nuniform float uvRepeatScale;\n\nvoid main () {\n  vec4 worldPos = modelMatrix * vec4(position.xyz, 1.0);\n\n  #ifdef HAS_ANGLE\n  vAngle = angle;\n  #endif\n  #ifdef HAS_SURF_UV\n  vSurfUv = surfUv;\n  #endif\n\n  #ifdef HAS_SHADOW_MAP\n  // vec4 vShadowPos = shadowProjection * vec4(position.xyz, 1.0);\n  // vec2 vShadowScreen = vShadowPos.xy / vShadowPos.w;\n  // vShadowUv = vShadowScreen.xy * 0.5 + 0.5;\n\n  vec4 baseClipPos = shadowProjection * vec4(worldPos.xyz, 1.0);\n  vShadowClipPos = vec3(baseClipPos.xy, baseClipPos.w);\n  // vShadowUv = (baseClipPos.xy / baseClipPos.w) * 0.5 + 0.5;\n  #endif\n\n  #ifdef HAS_DATA_MAP\n  vec2 worldPosUV = uv;\n  worldPosUV.y = 1.0 - worldPosUV.y;\n  vec2 dataWorldPos = (worldPosUV * 2.0 - 1.0) * environmentSize / 2.0;\n  vec4 vDataUvPos4 = worldDataProjection * worldDataView * vec4(dataWorldPos.xy, 0.0, 1.0);\n  vec2 vDataScreen = vDataUvPos4.xy / vDataUvPos4.w;\n  vDataUv = vDataScreen.xy * 0.5 + 0.5;\n  #endif\n\n  vUv = uv;\n  vTextureUv = uv * uvScale * uvRepeatScale;\n  vTextureUv = (uvTransform * vec3(vTextureUv, 1.0)).xy;\n  vWorldPosition = worldPos.xyz;\n\n  gl_Position = projectionMatrix * viewMatrix * worldPos;\n\n  #ifdef HAS_GROUND_MAP\n  vGroundUv = gl_Position.xy / gl_Position.w * 0.5 + 0.5;\n  #endif\n}";
},{}],"src/shaders/ground-simple.frag.js":[function(require,module,exports) {
module.exports = "#define GLSLIFY 1\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendOverlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n\nvarying vec2 vUv;\nvarying vec2 vDataUv;\nvarying vec2 vShadowUv;\nvarying vec2 vTextureUv;\nvarying vec3 vShadowClipPos;\nuniform sampler2D dataMapBiome;\nuniform sampler2D dataMapColor;\nuniform sampler2D dataMapLake;\nuniform float overlayOpacity;\n\nuniform float time;\n\n#ifdef USE_MAP_OVERRIDE\nuniform sampler2D overrideMap;\n#endif\n\nuniform sampler2D shadowMap;\n\nuniform mat4 worldFogProjection;\nuniform sampler2D worldFogMap;\nuniform vec3 clearColor;\n\n#ifdef USE_MAP_OVERRIDE\nuniform bool useOverrideMap;\n#endif\n\nuniform bool useOverrideColor;\nuniform vec3 overrideColor;\nuniform float solved;\nuniform vec3 originColor;\nuniform sampler2D worldDataMap;\n\n// uniform sampler2D map0;\n// uniform sampler2D map1;\n// uniform sampler2D map2;\n// uniform sampler2D map3;\n// uniform sampler2D mapPath;\nuniform sampler2D mapGround;\nuniform sampler2D mapGroundPath;\nuniform sampler2D mapOverlay;\n\nuniform float tutorial;\n\n// vec3 blend(vec4 texture1, float a1, vec4 texture2, float a2) {\n//     float depth = 0.2;\n//     float ma = max(texture1.a + a1, texture2.a + a2) - depth;\n\n//     float b1 = max(texture1.a + a1 - ma, 0);\n//     float b2 = max(texture2.a + a2 - ma, 0);\n\n//     return (texture1.rgb * b1 + texture2.rgb * b2) / (b1 + b2);\n// }\n\nvec3 blend(vec4 texture1, float a1, vec4 texture2, float a2) {\n  return texture1.a > texture2.a ? texture1.rgb : texture2.rgb;\n}\n\nvec4 textureLuma(sampler2D tex, vec2 uv) {\n  vec3 rgb = texture2D(tex, uv).rgb;\n  float d = dot(rgb, vec3(0.299, 0.587, 0.114));\n  return vec4(rgb, d);\n}\n\n// vec3 splat (float m, float e, float p, vec2 uv) {\n//   vec3 tex0 = texture2D(map0, uv).rgb;\n//   vec3 tex1 = texture2D(map1, uv).rgb;\n//   vec3 tex2 = texture2D(map2, uv).rgb;\n//   vec3 tex3 = texture2D(map3, uv).rgb;\n//   vec3 texPath = texture2D(mapPath, uv).rgb;\n//   //   mix(tex0, tex1, m),\n//   //   mix(tex2, tex3, e),\n//   //   p);\n//   // return tex;\n\n//   // vec3 tex;\n//   // if (m < 0.5 && e >= 0.5) {\n//   //   // dry, high\n//   //   tex = tex0;\n//   // } else if (m < 0.5 && e < 0.5) {\n//   //   // dry, low\n//   //   tex = tex1;\n//   // } else if (m >= 0.5 && e >= 0.5) {\n//   //   // wet, high\n//   //   tex = tex2;\n//   // } else {\n//   //   // wet, low\n//   //   tex = tex3;\n//   // }\n//   // return mix(tex, texPath, step(0.4, p));\n\n//   float w0 = 0.0;\n//   float w1 = 0.0;\n//   float w2 = 0.0;\n//   float w3 = 0.0;\n//   float feather = 0.1;\n//   float t = 0.5;\n//   w0 = smoothstep(t + feather, t - feather, m) * smoothstep(t - feather, t + feather, e);\n//   w1 = smoothstep(t + feather, t - feather, m) * smoothstep(t + feather, t - feather, e);\n//   w2 = smoothstep(t - feather, t + feather, m) * smoothstep(t - feather, t + feather, e);\n//   w3 = smoothstep(t - feather, t + feather, m) * smoothstep(t + feather, t - feather, e);\n//   vec3 tex = vec3(0.0);\n//   // tex = tex0 * w0;\n//   tex += tex0 * w0 + tex1 * w1;\n//   tex += tex2 * w2 + tex3 * w3;\n//   float pt = 0.35;\n//   float pf = 0.5;\n//   return mix(tex * 0.5, tex, smoothstep(pt - pf, pt + pf, p));\n//   // return mix(mix(tex, texPath.r * tex, 0.15), tex, smoothstep(pt - pf, pt + pf, p));\n//   // return mix(tex, texPath.rgb, smoothstep(pt - pf, pt + pf, p));\n// }\n\n// void main () {\n//   vec3 dataColor = texture2D(worldDataMap, vDataUv).rgb;\n//   vec3 biome = texture2D(dataMapBiome, vUv).rgb;\n//   vec3 worldColor = texture2D(dataMapColor, vUv).rgb;\n//   if (useOverrideColor) {\n//     worldColor = overrideColor;\n//   }\n//   vec3 overlay = texture2D(mapOverlay, vTextureUv).rgb;\n//   vec3 groundTex = texture2D(mapGround, vTextureUv).rgb;\n//   vec3 pathTex = texture2D(mapGroundPath, vTextureUv * 2.0).rgb;\n//   gl_FragColor.rgb = vec3(worldColor);\n\n//   vec3 worldFogColor = texture2D(worldFogMap, vUv).rgb;\n//   gl_FragColor.rgb *= worldFogColor;\n//   gl_FragColor.a = 1.0;\n// }\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid main2 () {\n  vec3 dataColor = texture2D(worldDataMap, vDataUv).rgb;\n  vec3 biome = texture2D(dataMapBiome, vUv).rgb;\n  vec3 worldColor = texture2D(dataMapColor, vUv).rgb;\n  gl_FragColor.rgb = worldColor;\n  gl_FragColor.a = 1.0;\n}\n\nvoid main () {\n  vec3 dataColor = texture2D(worldDataMap, vDataUv).rgb;\n  vec3 biome = texture2D(dataMapBiome, vUv).rgb;\n  vec3 worldColor = texture2D(dataMapColor, vUv).rgb;\n  vec3 oWorldColor = worldColor;\n  if (useOverrideColor) {\n    worldColor = overrideColor;\n  }\n\n  vec3 overlay = texture2D(mapOverlay, vTextureUv).rgb;\n  vec3 groundTex = texture2D(mapGround, vTextureUv).rgb;\n  vec3 pathTex = texture2D(mapGroundPath, vTextureUv * 2.0).rgb;\n\n  float wdist = 0.04;\n  float wd = distance(vUv, vec2(0.5, 0.5)) / wdist;\n  float wt = 0.5 + ((groundTex.x*2.0-1.0) * 0.5) + ((pathTex.x*2.0-1.0) * 0.5);\n  float wg = 0.45;\n  wd = smoothstep(wt - wg, wt + wg, wd);\n  float distFromCenter = 1.0 - clamp(wd, 0.0, 1.0);\n  // worldColor = mix(worldColor, vec3(0.45), distFromCenter);\n  worldColor = mix(mix(worldColor, vec3(originColor), tutorial), vec3(originColor), distFromCenter);\n\n  // worldColor = mix(worldColor, vec3(originColor), distFromCenter);\n  \n  // float boxLen = abs(vUv.x - 0.5) + abs(vUv.y - 0.5);\n  float edgeThreshold = 0.5;\n  float edgeGlow = 0.025;\n  // worldColor = vec3(boxLen);\n  // worldColor *= step(boxLen, 0.48);\n\n  float edge0 = smoothstep(edgeThreshold, edgeThreshold-edgeGlow, abs(vUv.x - 0.5));\n  float edge1 = smoothstep(edgeThreshold, edgeThreshold-edgeGlow, abs(vUv.y - 0.5));\n  // worldColor = originColor;\n  // worldColor = mix(originColor, worldColor, distFromCenter);\n\n  // vec3 worldFogColor = texture2D(worldFogMap, vUv).rgb;\n  // worldColor.rgb *= mix(1.0, 0.0, (1.0-distFromCenter) * (1.0-worldFogColor.r));\n\n  float lake = texture2D(dataMapLake, vUv).r;\n\n  float pathEdge = smoothstep(0.4, 0.75, biome.b + (biome.r * 2.0 - 1.0) * 0.1);\n  pathEdge = clamp(pathEdge, 0.0, 1.0);\n  vec3 tex = mix(groundTex, pathTex, pathEdge);\n\n  vec3 col = worldColor;\n\n  // #ifdef USE_MAP_OVERRIDE\n  // vec3 overrideRGB = texture2D(overrideMap, vTextureUv).rgb;\n  // if (useOverrideMap) {\n  //   col *= overrideRGB;\n  // } else {\n    float darken = 0.45; //0.66;\n    col = blendSoftLight(col, col + overlay, overlayOpacity * 0.3 * biome.b * (1.0 - darken * dataColor.r));\n    col = mix(col, col * (1.0 - overlay), 0.075 * (biome.b));\n    //blendSoftLight(col, col + overlay, overlayOpacity * biome.b * (1.0 - darken * dataColor.r));\n    col = blendSoftLight(col, tex, 1.0 - darken * dataColor.r);\n    // col = blendSoftLight(col, col + overlay, overlayOpacity * biome.b * 0.075);\n    // col = blendSoftLight(col, tex, 1.0);\n  // }\n\n  // col = vec3(gl_FragCoord.x / 800.0);\n  // vec2 shadowUv = (vShadowClipPos.xy / vShadowClipPos.z) * 0.5 + 0.5;\n  // col *= 1.0 - 0.25 * texture2D(shadowMap, shadowUv).r;\n  \n  // col = texture2D(mapGround, vShadowUv).rgb;\n  // float pt = 0.4;\n  // float pf = 0.4;\n  // float pathEdge = smoothstep(pt-pf, pt+pf, biome.b  );\n  // col = mix(col * 0.75, col * 1.0, pathEdge);\n  // col = vec3(pathEdge);\n  gl_FragColor = vec4(vec3(col), 1.0);\n  gl_FragColor = clamp(gl_FragColor, 0.0, 1.0);\n  gl_FragColor.rgb = mix(clearColor, gl_FragColor.rgb, edge0 * edge1);\n  // gl_FragColor.rgb = vec3(edge0);\n\n  // gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(1.0), lake);\n}";
},{}],"src/systems/SimpleEnvironmentSystem.js":[function(require,module,exports) {
var process = require("process");
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SimpleEnvironmentSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var Helpers = _interopRequireWildcard(require("../util/helpers"));

var _d3Polygon = require("d3-polygon");

var _fast2dPoissonDiskSampling = _interopRequireDefault(require("fast-2d-poisson-disk-sampling"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _mst = require("../util/mst");

var _squared = _interopRequireDefault(require("euclidean-distance/squared"));

var _d3Delaunay = require("d3-delaunay");

var _simplexNoise = _interopRequireDefault(require("simplex-noise"));

var _simplifyPath = _interopRequireDefault(require("simplify-path"));

var _pointInPolygon = _interopRequireDefault(require("point-in-polygon"));

var _queryString = _interopRequireDefault(require("../util/query-string"));

var ShaderManager = _interopRequireWildcard(require("../util/ShaderManager"));

var _RefGLTFLoader = require("../util/RefGLTFLoader");

var _d3Quadtree = require("d3-quadtree");

var _boundPoints = _interopRequireDefault(require("bound-points"));

var _earcut = _interopRequireDefault(require("earcut"));

var _load = require("../util/load");

var _config = _interopRequireDefault(require("../config"));

var _createEnvironmentEntity = _interopRequireDefault(require("./environment/createEnvironmentEntity"));

var _groundSimple = _interopRequireDefault(require("../shaders/ground-simple.vert"));

var _groundSimple2 = _interopRequireDefault(require("../shaders/ground-simple.frag"));

var _threeUtil = require("../util/three-util");

var _Assets = _interopRequireDefault(require("../util/Assets"));

var _materials = require("../util/materials");

var _resetPlayerPos = _interopRequireWildcard(require("../util/resetPlayerPos"));

var _AnimationSystem = require("./AnimationSystem");

var _nfb = require("../nfb");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import concaveman, { fastConvexHull } from "../util/concaveman";
// import { ConvexHull } from "three/examples/jsm/math/ConvexHull";
// import floorOverlayUrl from "../assets/textures/environment/floor_overlay.png";
// import groundTextureUrl from "../assets/textures/environment/floor.jpg";
// import waterDistortMapUrl from "../assets/textures/WaterDistortion.png";
// import waterNoiseMapUrl from "../assets/textures/WaterNoise.png";
// import groundPathTextureUrl from "../assets/textures/environment/floor-path.jpg";
const WATER_DISTORT = "image/data/water-distort";
const WATER_MAP = "image/data/water-noise";
const ICE_MAP = "image/opaque/ice";
const FLOOR_OVERLAY = "image/opaque/floor-overlay";
const FLOOR_PATH = "image/opaque/floor-path";
const FLOOR = "image/opaque/floor";
const FLOOR_TUNDRA = "image/opaque/floor-tundra"; // prepare some of the assets that we will see immediately

_Assets.default.prepare([FLOOR, FLOOR_PATH, FLOOR_OVERLAY]);

function SimpleEnvironmentSystem(world) {
  const renderer = world.findTag(Tags.Renderer);
  const waterDistortMap = new THREE.Texture();
  const waterNoiseMap = new THREE.Texture();
  const repeat = {
    wrapS: THREE.RepeatWrapping,
    wrapT: THREE.RepeatWrapping
  };
  const [mapGround, mapOverlay, mapGroundPath] = [FLOOR, FLOOR_OVERLAY, FLOOR_PATH].map(id => {
    const [tex] = _Assets.default.createGPUTextureTask(renderer, id, {
      wrapS: THREE.RepeatWrapping,
      wrapT: THREE.RepeatWrapping
    });

    return tex;
  });
  let hasLoadedWaterDistort = false;
  const onOutroEvent = world.listen([Tags.EndGameState, Tags.ResetToCameraDrift]);
  const quadGeo = new THREE.PlaneBufferGeometry(1, 1, 1, 1);
  quadGeo.rotateX(-Math.PI / 2);
  const width = 512;
  const height = 512;
  const bounds = [[-width / 2, -height / 2], [width / 2, height / 2]];
  const uvMat = new THREE.Matrix3();
  const texRepeat = 1024 / 60;
  const repeatX = 1 * texRepeat;
  const repeatY = 1.0 / (width / height) * texRepeat * -1.0;
  uvMat.setUvTransform(0, 0, 1, 1, THREE.MathUtils.degToRad(-45), 0, 0);
  const haikusTotal = (0, _config.default)().haikusPerBiome; // const haikusTotal =
  //   typeof queryString.maxHaikus === "number" ? queryString.maxHaikus : 2;

  const biomeData = {
    forest: {
      grassInstanceCount: 700,
      grassScale: 0.6,
      grassTipFactor: 1.5,
      colors: [{
        name: "forest-items-triangle",
        color: "#9D9166"
      }, {
        name: "forest-items-dry",
        color: "#59622a"
      }, {
        name: "forest-items-autumn",
        color: "#745C13"
      }, {
        name: "forest-items-triangle",
        color: "#766D43"
      }],
      waterId: "forest-items-water",
      haikusTotal,
      waterColors: [],
      seed: [18632, 45808, 21972, 11421],
      hasLakes: false
    },
    grasslands: {
      grassInstanceCount: 1000,
      grassScale: 1,
      grassTipFactor: 1.5,
      hasLakes: true,
      haikusTotal,
      seed: [23005, 20871, 29486, 37533],
      colors: [{
        name: "grasslands-items-field",
        color: "#556325"
      }, {
        name: "grasslands-items-yellow",
        color: "#8D7721"
      }, {
        name: "grasslands-items-field",
        color: "#486b25"
      }, {
        name: "grasslands-items-wet",
        color: "#605e41"
      } // { name: "grasslands-items-field", color: "#ff0000" },
      // { name: "grasslands-items-field", color: "#00ff00" },
      // { name: "grasslands-items-field", color: "#0000ff" },
      // { name: "grasslands-items-field", color: "#00ffff" },
      // { name: "grasslands-items-wet", color: "#556325" },
      ],
      waterId: "grasslands-items-water",
      waterColors: [{
        name: "lake",
        color: "#072d17"
      }]
    },
    tundra: {
      grassInstanceCount: 500,
      grassScale: 0.6,
      grassTipFactor: 0.5,
      hasLakes: true,
      hasIce: true,
      haikusTotal,
      seed: [13005, 27871, 29486, 37533],
      overlayOpacity: 0,
      colors: [{
        name: "tundra-items-basic",
        color: "#797f84"
      } // { name: "tundra-items-basic", color: "#898e91" },
      // { name: "tundra-items-snow", color: "#d9d9d9" },
      // { name: "grasslands-field", color: "#5a823a" },
      // { name: "grasslands-yellow", color: "#8D7721" },
      ],
      waterId: "tundra-items-ice",
      waterColors: [{
        name: "lake",
        color: "#072d17"
      }]
    }
  };
  const depthMesh = new THREE.Mesh(quadGeo, new THREE.MeshBasicMaterial({
    // color: "red",
    colorWrite: false
  }));
  depthMesh.layers.set(world.findTag(Tags.RenderLayers).groundDepth);
  depthMesh.scale.set(width, 1, height);
  depthMesh.position.y = 0.0;
  depthMesh.name = "env-depth-mesh";
  world.entity().add(Tags.Object3D, depthMesh);
  const meshEntity = createMesh(); // meshEntity.get(Tags.Object3D).visible = false;

  const config = (0, _config.default)();
  const ignoreOrigin = false; // if (!config.embed) {
  //   world.entity().add(Tags.GLTFRefAsset, {
  //     position: [0, 0],
  //     name: "origin-0",
  //   });
  // }

  const barrenGroundEvents = world.listen(Tags.TutorialBarrenGround);
  const tweenColor = {
    value: 0,
    lastValue: 0,
    colorA: meshEntity.get(Tags.Object3D).material.uniforms.originColor.value.clone(),
    colorB: new THREE.Color("#59622a")
  };
  const finalResolutionEvents = world.listen(Tags.FinalBiomeResolution);
  const groundAssetView = world.view([Tags.GroundAsset, Tags.GroundAssetData]);
  const envCellView = world.view(Tags.EnvironmentCell);
  const cellView = world.view([Tags.GroundAsset, Tags.GroundAssetData]);
  const gltfAssetView = world.view(Tags.GLTFRefAsset);
  const environments = world.view(Tags.EnvironmentState);
  const envStateCurrent = world.view([Tags.EnvironmentState, Tags.ActiveEnvironmentState]);
  const envList = ["forest", "grasslands", "tundra"];
  const hasSeenBiome = {};
  let envEntityLast = null;
  let envStart = "forest";
  if (_queryString.default.biome === "grasslands") envStart = "grasslands";else if (_queryString.default.biome === "tundra") envStart = "tundra";
  let env = null;
  setTimeout(() => {
    function getSwapper() {
      const env0 = env;
      const env1 = createEnvironment("grasslands");
      let currentEnv = env0;
      env0.name = "forest";
      env1.name = "grasslands";
      return () => {
        const newEnv = currentEnv === env0 ? env1 : env0;
        currentEnv.remove(Tags.ActiveEnvironmentState);
        newEnv.add(Tags.ActiveEnvironmentState);
        currentEnv = newEnv;
      };
    }

    let swapper;

    window.swapEnv = () => {
      swapper = swapper || getSwapper();
      swapper();
    };
  }, 0); // const activeTokens = world.view(Tags.GroundSpawnTokenTag);

  const swapView = world.view(Tags.SafeToSwapBiomes);
  const shadowAssetView = world.view(Tags.ShadowCaster);
  const transitionEvents = world.listen(Tags.TransitionToNextBiome);
  const transitionWithCameraStoppingView = world.view([Tags.TransitionToNextBiome, Tags.CameraStopUserMovement]);
  createInitialEnvironment();
  let oldOverrideColor = null;
  return {
    process,
    // Since this is an expensive operation that leads to 'jank'
    // we want to expose exactly when to call this, in between the NFB
    // logo animating in / out basically...
    createInitialEnvironment
  };

  function createInitialEnvironment() {
    if (!env) {
      env = createEnvironment(envStart);
      env.add(Tags.ActiveEnvironmentState);

      if (_queryString.default.testwater) {
        const lakes = env.get(Tags.EnvironmentState).lakes;

        if (lakes && lakes.length) {
          const lake = lakes[Math.floor(Math.random() * lakes.length)].polygon;
          const point = lake[Math.floor(Math.random() * lake.length)];
          (0, _resetPlayerPos.setPlayerPos)(world, new THREE.Vector3(point[0], 0, point[1]));
        }
      } else if (_queryString.default.testfox) {
        const patches = env.get(Tags.EnvironmentState).patches;
        const patch = patches.find(p => p.name.includes("patch-17"));

        if (patch) {
          (0, _resetPlayerPos.setPlayerPos)(world, new THREE.Vector3(patch.position[0], 0, patch.position[1]));
        }
      }
    }
  }

  function process(dt) {
    transitionEvents.added.forEach(e => {
      e.add(Tags.CameraStopUserMovement);
    });

    if (onOutroEvent.added.length > 0) {
      world.entity().add(Tags.TransitionToNextBiome).add(Tags.SafeToSwapBiomes); // env.reomve(Tags.ActiveEnvironmentState);
      // env.add(Tags.ActiveEnvironmentState);
      // const env1 = createEnvironment("grasslands");
      // let currentEnv = env0;
      // env0.name = "forest";
      // env1.name = "grasslands";
      // return () => {
      //   const newEnv = currentEnv === env0 ? env1 : env0;
      //   currentEnv.remove(Tags.ActiveEnvironmentState);
      //   newEnv.add(Tags.ActiveEnvironmentState);
      //   currentEnv = newEnv;
      // };
      // world.entity()
      //   .add(Tags.SafeToSwapBiomes)
      //   .add()
    }

    if (swapView.length > 0) {
      transitionWithCameraStoppingView.forEach(e => {
        e.remove(Tags.CameraStopUserMovement);
      });
      swapView.forEach(e => {
        // remove each
        e.remove(Tags.SafeToSwapBiomes);
      }); // reset player to origin

      (0, _resetPlayerPos.default)(world);
      oldOverrideColor = null;
      const activeEnvEntity = envStateCurrent.length ? envStateCurrent[0] : null;
      const curEnv = activeEnvEntity ? activeEnvEntity.get(Tags.EnvironmentState).name : "forest";
      const curIdx = envList.indexOf(curEnv);

      if (curIdx >= 0) {
        let newIdx = curIdx + 1;

        if (newIdx >= envList.length) {
          // special case: tundra to grasslands
          newIdx = 1;
        }

        if (newIdx < envList.length) {
          const name = envList[newIdx]; // activeEnvEntity.remove(Tags.ActiveEnvironmentState);

          envCellView.forEach(e => e.kill());
          groundAssetView.forEach(e => e.kill());
          environments.forEach(e => e.kill());
          const env = createEnvironment(name);
          env.add(Tags.ActiveEnvironmentState);
          world.query(Tags.TransitionToNextBiome).entities.forEach(e => {
            e.remove(Tags.TransitionToNextBiome);
          });

          if (!hasSeenBiome[name]) {
            hasSeenBiome[name] = true;
            (0, _nfb.sendAnalytics)({
              event: "biome_visited",
              eventLabel: name
            });
          }
        } else {
          console.log("VIEW LAYER END STATE");
        }
      }
    }

    const mesh = meshEntity.get(Tags.Object3D);
    const data = meshEntity.get(Tags.GroundMeshEditableData);
    mesh.material.uniforms.uvRepeatScale.value = data.uvRepeatScale;
    mesh.material.uniforms.useOverrideColor.value = data.useOverrideColor;
    mesh.material.uniforms.useOverrideMap.value = data.useOverrideMap;
    mesh.material.uniforms.overrideMap.value = data.overrideMap;

    if (oldOverrideColor !== data.overrideColor) {
      mesh.material.uniforms.overrideColor.value.set(data.overrideColor);
      oldOverrideColor = data.overrideColor;
    }

    let newEnvEntity = null;

    if (envStateCurrent.length > 0) {
      const curEntity = envStateCurrent[0];
      const current = curEntity.get(Tags.EnvironmentState);
      newEnvEntity = curEntity;
      mesh.material.uniforms.solved.value = ignoreOrigin || config.embed ? 1 : current.solved;
      mesh.material.uniforms.dataMapBiome.value = current.textures[0];
      mesh.material.uniforms.dataMapColor.value = current.textures[1];
      mesh.material.uniforms.dataMapLake.value = current.textures[2];
      mesh.material.uniforms.overlayOpacity.value = current.overlayOpacity;

      for (let i = 0; i < current.waterMeshes.length; i++) {
        const wmesh = current.waterMeshes[i];
        wmesh.material.uniforms.waterNoiseMap.value = data.useOverrideWater ? data.overrideWater : waterNoiseMap;
        wmesh.material.uniforms.colorA.value.set(data.useOverrideWaterColor ? data.overrideWaterColorA : wmesh.userData.colorA);
        wmesh.material.uniforms.colorB.value.set(data.useOverrideWaterColor ? data.overrideWaterColorB : wmesh.userData.colorB);
      }
    }

    if (newEnvEntity !== envEntityLast) {
      // remove old environment
      if (envEntityLast && envEntityLast.has(Tags.Object3D)) {
        const object = envEntityLast.get(Tags.Object3D);
        (0, _threeUtil.detachObject)(object);
        console.log("Killing previous environment"); // remove all old tokens
        // activeTokens.forEach((e) => e.kill());

        envEntityLast.remove(Tags.Object3D);
      }

      envEntityLast = newEnvEntity; // attach new environment

      if (newEnvEntity) {
        const envState = newEnvEntity.get(Tags.EnvironmentState);
        const group = envState.group;
        newEnvEntity.add(Tags.Object3D, group);
        gltfAssetView.forEach(e => {
          const p = e.get(Tags.GLTFRefAsset);

          if (p.biome !== envState.name) {
            e.kill();
          }
        }); // shadowAssetView.forEach((e) => {
        //   e.kill();
        // });

        envState.patches.forEach(p => {
          const e = world.entity().add(Tags.GLTFRefAsset, {
            position: p.position,
            name: p.name,
            biome: envState.name
          });
        }); // envState.tokens.forEach((t) => {
        //   const pos = t;
        //   const e = world
        //     .entity()
        //     .add(Tags.GroundSpawnPosition2D, pos)
        //     .add(Tags.GroundSpawnTokenTag);
        // });
      }
    }

    if (finalResolutionEvents.changed) {
      const uniforms = meshEntity.get(Tags.Object3D).material.uniforms;
      const target = uniforms.tutorial;

      if (finalResolutionEvents.added.length > 0) {
        tweenColor.colorA.copy(uniforms.originColor.value);
        (0, _AnimationSystem.tweenFromTo)(world, tweenColor, "value", 0, 1, 8, "sineOut");
        (0, _AnimationSystem.tweenFromTo)(world, target, "value", target.value, 1, 8, "sineOut");
      } else if (finalResolutionEvents.removing.length > 0) {
        tweenColor.value = 0;
        target.value = 0;
      }
    }

    if (tweenColor.value !== tweenColor.lastValue) {
      tweenColor.lastValue = tweenColor.value;
      const uniforms = meshEntity.get(Tags.Object3D).material.uniforms;
      uniforms.originColor.value.copy(tweenColor.colorA).lerp(tweenColor.colorB, tweenColor.value);
    }

    if (barrenGroundEvents.changed) {
      if (barrenGroundEvents.added.length > 0) {
        if (meshEntity.has(Tags.Object3D)) {
          meshEntity.get(Tags.Object3D).material.uniforms.tutorial.value = 1;
        }
      } else if (barrenGroundEvents.removing.length > 0) {
        if (meshEntity.has(Tags.Object3D)) {
          const target = meshEntity.get(Tags.Object3D).material.uniforms.tutorial;
          (0, _AnimationSystem.tweenFromTo)(world, target, "value", target.value, 0, 2, "sineOut");
        }
      }
    } // const tutorialStateEntity = world.findEntity(Tags.TutorialAnimationState);
    // if (tutorialStateEntity && meshEntity.has(Tags.Object3D)) {
    //   const state = tutorialStateEntity.get(Tags.TutorialAnimationState);
    //   meshEntity.get(Tags.Object3D).material.uniforms.tutorial.value = state;
    // }

  }

  function createEnvironment(name) {
    if ((name === "grasslands" || name === "tundra") && !hasLoadedWaterDistort) {
      hasLoadedWaterDistort = true;

      _Assets.default.loadGPUTexture(renderer, waterDistortMap, WATER_DISTORT, repeat);
    }

    if (name === "grasslands") {
      _Assets.default.loadGPUTexture(renderer, waterNoiseMap, WATER_MAP, repeat);
    } else if (name === "tundra") {
      console.log("CREATE ENV");

      _Assets.default.loadGPUTexture(renderer, waterNoiseMap, ICE_MAP, repeat);

      _Assets.default.loadGPUTexture(renderer, mapGround, FLOOR_TUNDRA, repeat); // Assets.loadGPUTexture(renderer, mapGroundPath, FLOOR_TUNDRA, repeat);

    } // if ((name === "grasslands" || name === "tundra") && !hasLoadedGrasslands) {
    //   hasLoadedGrasslands = true;
    //   // We load these outside of blocking anything
    //   // But we will hit some async issues where the water might need to render
    //   // before texture finishes loading.. this should block the transition page instead
    //   // This could be done with Assets.prepare + loadQueued in transition page
    //   const repeat = {
    //     wrapS: THREE.RepeatWrapping,
    //     wrapT: THREE.RepeatWrapping,
    //   };
    // Assets.loadGPUTexture(renderer, waterDistortMap, WATER_DISTORT, repeat);
    // Assets.loadGPUTexture(renderer, waterNoiseMap, WATER_NOISE, repeat);
    // }
    // if (name === 'tundra' && !hasLoadedTundra) {
    //   hasLoadedTundra = true;
    //   const repeat = {
    //     wrapS: THREE.RepeatWrapping,
    //     wrapT: THREE.RepeatWrapping,
    //   };
    //   Assets.loadGPUTexture(renderer, waterDistortMap, WATER_DISTORT, repeat);
    //   Assets.loadGPUTexture(renderer, waterNoiseMap, WATER_NOISE, repeat);
    // }


    return (0, _createEnvironmentEntity.default)(world, {
      biome: name,
      biomeData,
      width,
      height,
      bounds,
      renderer,
      uvMat,
      waterVertexShader: _groundSimple.default,
      repeatX,
      repeatY,
      mapGround,
      mapOverlay,
      mapGroundPath,
      waterDistortMap,
      waterNoiseMap
    });
  }

  function createMesh() {
    const dataTarget = world.findTag(Tags.GroundDataRenderTarget); // const fogTarget = world.findTag(Tags.GroundFogRenderTarget);

    const shader = ShaderManager.create({
      depthWrite: false,
      depthTest: false,
      name: "GroundShader",
      uniforms: {
        solved: {
          value: 0
        },
        uvRepeatScale: {
          value: 1
        },
        clearColor: {
          value: new THREE.Color("#130904")
        },
        uvScale: {
          value: new THREE.Vector2(repeatX, repeatY)
        },
        uvTransform: {
          value: uvMat
        },
        environmentSize: {
          value: new THREE.Vector2(width, height)
        },
        // worldFogMap: {
        //   value: fogTarget ? fogTarget.target.texture : getEmptyTexture(),
        // },
        // worldFogProjection: {
        //   value: fogTarget ? fogTarget.projection : new THREE.Matrix4(),
        // },
        worldDataMap: {
          value: dataTarget ? dataTarget.target.texture : (0, _materials.getEmptyTexture)()
        },
        worldDataProjection: {
          value: dataTarget ? dataTarget.projection : new THREE.Matrix4()
        },
        worldDataView: {
          value: dataTarget ? dataTarget.view : new THREE.Matrix4()
        },
        dataMapBiome: {
          value: (0, _materials.getEmptyTexture)()
        },
        dataMapColor: {
          value: (0, _materials.getEmptyTexture)()
        },
        dataMapLake: {
          value: (0, _materials.getEmptyTexture)()
        },
        overrideColor: {
          value: new THREE.Color("red")
        },
        originColor: {
          value: new THREE.Color("#969492")
        },
        useOverrideColor: {
          value: true,
          type: "b"
        },
        useOverrideMap: {
          value: true,
          type: "b"
        },
        overrideMap: {
          value: (0, _materials.getEmptyTexture)()
        },
        time: {
          value: 0
        },
        tutorial: {
          value: 0
        },
        outro: {
          value: 0
        },
        // map0: { value: maps[0] },
        // map1: { value: maps[1] },
        // map2: { value: maps[2] },
        // map3: { value: maps[3] },
        // mapPath: { value: maps[4] },
        mapOverlay: {
          value: mapOverlay
        },
        mapGroundPath: {
          value: mapGroundPath
        },
        mapGround: {
          value: mapGround
        },
        overlayOpacity: {
          value: 0.3
        }
      },
      defines: {
        HAS_DATA_MAP: true
      },
      fragmentShader: _groundSimple2.default,
      vertexShader: _groundSimple.default
    });
    const quadMesh = new THREE.Mesh(quadGeo, shader);
    quadMesh.scale.set(width, 1, height);
    quadMesh.layers.set(world.findTag(Tags.RenderLayers).ground);
    quadMesh.name = "ground-quad";
    return world.entity().add(Tags.Object3D, quadMesh).add(Tags.ShaderUniformTime, {
      uniform: quadMesh.material.uniforms.time
    }).add(Tags.GroundMeshEditableData).add(Tags.GroundPlaneLayer, quadMesh);
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/helpers":"src/util/helpers.js","d3-polygon":"node_modules/d3-polygon/src/index.js","fast-2d-poisson-disk-sampling":"node_modules/fast-2d-poisson-disk-sampling/src/fast-poisson-disk-sampling.js","../util/Random":"src/util/Random.js","../util/mst":"src/util/mst.js","euclidean-distance/squared":"node_modules/euclidean-distance/squared.js","d3-delaunay":"node_modules/d3-delaunay/src/index.js","simplex-noise":"node_modules/simplex-noise/simplex-noise.js","simplify-path":"node_modules/simplify-path/index.js","point-in-polygon":"node_modules/point-in-polygon/index.js","../util/query-string":"src/util/query-string.js","../util/ShaderManager":"src/util/ShaderManager.js","../util/RefGLTFLoader":"src/util/RefGLTFLoader.js","d3-quadtree":"node_modules/d3-quadtree/src/index.js","bound-points":"node_modules/bound-points/bounds.js","earcut":"node_modules/earcut/src/earcut.js","../util/load":"src/util/load.js","../config":"src/config.js","./environment/createEnvironmentEntity":"src/systems/environment/createEnvironmentEntity.js","../shaders/ground-simple.vert":"src/shaders/ground-simple.vert.js","../shaders/ground-simple.frag":"src/shaders/ground-simple.frag.js","../util/three-util":"src/util/three-util.js","../util/Assets":"src/util/Assets.js","../util/materials":"src/util/materials.js","../util/resetPlayerPos":"src/util/resetPlayerPos.js","./AnimationSystem":"src/systems/AnimationSystem.js","../nfb":"src/nfb.js","process":"node_modules/process/browser.js"}],"src/systems/SimpleEnvironmentCellSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SimpleEnvironmentCellSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _ObjectPool = _interopRequireDefault(require("../util/ObjectPool"));

var _threeUtil = require("../util/three-util");

var _EnvironmentGrid = require("./environment/EnvironmentGrid");

var _waterUtil = require("../util/water-util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function SimpleEnvironmentCellSystem(world) {
  const environments = world.view([Tags.ActiveEnvironmentState, Tags.EnvironmentState]);
  const defaultSeed = new Uint16Array(4);
  const randomPool = new _ObjectPool.default({
    initialCapacity: 12,

    create() {
      return (0, _Random.default)(defaultSeed);
    }

  });
  const tmp2DArray = [0, 0];
  const tmpBox = new THREE.Box3();
  const raycaster = new THREE.Raycaster();
  const mousePlane = new THREE.Plane(new THREE.Vector3(-0, -1, -0), -0);
  const pos2D = new THREE.Vector2();
  const pos3D = new THREE.Vector3();
  const tmp3D = new THREE.Vector3();
  const corners = [[-1, 1], [1, 1], [1, -1], [-1, -1]];
  const activeCells = world.view(Tags.EnvironmentCell);
  const underPlayer = world.tag(Tags.EnvironmentUnderPlayerState);
  const gridBounds = new _EnvironmentGrid.GridBounds();
  return function envCellSystem(dt) {
    const target = world.findTag(Tags.UserTarget).position;
    const camera = world.findTag(Tags.MainCamera);
    camera.updateProjectionMatrix(); // get min and max points on screen

    const maxRadialDistance = 80;
    const maxAssetHeight = 12;
    tmpBox.makeEmpty();

    for (let i = 0; i < corners.length; i++) {
      const uv = corners[i];
      pos2D.fromArray(uv);
      raycaster.setFromCamera(pos2D, camera);
      const hit = raycaster.ray.intersectPlane(mousePlane, pos3D);
      if (!hit) return; // why??

      const delta = tmp3D.copy(pos3D).sub(target);
      const dist = delta.length();
      if (dist !== 0) delta.divideScalar(dist); // normalize

      if (dist > maxRadialDistance) {
        pos3D.copy(target).addScaledVector(tmp3D, maxRadialDistance);
      }

      tmpBox.expandByPoint(pos3D);
    }

    tmpBox.min.y = 0;
    tmpBox.max.y = maxAssetHeight;
    underPlayer.water = false;
    underPlayer.lake = null; // check each active environment...

    if (environments.length > 0) {
      const state = environments[0].get(Tags.EnvironmentState);
      matchAgainstEnvironment(state);
    }
  };

  function matchAgainstEnvironment(state) {
    const grid = state.grid;
    grid.box3ToBounds(tmpBox, gridBounds);
    const padding = 0;
    const padBottom = 1;
    gridBounds.minX = THREE.MathUtils.clamp(gridBounds.minX - padding, 0, grid.cellDivisions - 1);
    gridBounds.minY = THREE.MathUtils.clamp(gridBounds.minY - padding, 0, grid.cellDivisions - 1);
    gridBounds.maxX = THREE.MathUtils.clamp(gridBounds.maxX + padding, 0, grid.cellDivisions - 1);
    gridBounds.maxY = THREE.MathUtils.clamp(gridBounds.maxY + padding + padBottom, 0, grid.cellDivisions - 1); // go through all active cells and remove any out of bounds

    activeCells.forEach(e => {
      const c = e.get(Tags.EnvironmentCell); // cell has disappeared from view, turn it off

      if (c.environmentState !== state || !grid.isCellInBounds(c.cell, gridBounds)) {
        // console.log("kill cell");
        randomPool.release(c.random); // release random func

        c.cell.entity = null; // release

        c.environmentState = null;
        c.cell = null;
        e.kill();
      }
    }); // go through all the cells in view and add any entities that appeared

    let cellsInViewCount = 0;
    grid.forEachCellInBounds(gridBounds, cell => {
      cellsInViewCount++;

      if (!cell.entity) {
        // console.log("make cell");
        cell.entity = world.entity().add(Tags.EnvironmentCell);
        const t = cell.entity.get(Tags.EnvironmentCell);
        t.cell = cell;
        t.environmentState = state;
        t.random = randomPool.next();
        t.random.seed(cell.seed);
      }
    });
    const position = world.findTag(Tags.UserCharacter).position;
    tmp2DArray[0] = position.x;
    tmp2DArray[1] = position.z;
    const playerShowing = !world.findTag(Tags.HideCharacter) && !world.findTag(Tags.AnimateOutCharacter);

    if (!underPlayer.water && playerShowing) {
      const lake = (0, _waterUtil.getLakeObject)(state, tmp2DArray);
      underPlayer.water = Boolean(lake);
      underPlayer.lake = lake;
    }
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/Random":"src/util/Random.js","../util/ObjectPool":"src/util/ObjectPool.js","../util/three-util":"src/util/three-util.js","./environment/EnvironmentGrid":"src/systems/environment/EnvironmentGrid.js","../util/water-util":"src/util/water-util.js"}],"src/systems/environment/AssetSprites.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AssetSprites;

var Tags = _interopRequireWildcard(require("../../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _ObjectPool = _interopRequireDefault(require("../../util/ObjectPool"));

var _SpriteManager = _interopRequireDefault(require("../../util/SpriteManager"));

var _threeUtil = require("../../util/three-util");

var _load = require("../../util/load");

var MathUtil = _interopRequireWildcard(require("../../util/math"));

var _AnimationSystem = require("../AnimationSystem");

var _materials = require("../../util/materials");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import { Assets as AssetsOld } from "../AssetLoaderSystem";
// TODO: resolve this to asset-loaded png
// import noiseMapUrl from "../../assets/textures/HDR_RGBA_0.png";
// import sheetData01 from "../../assets/spritesheets/temp_sprites-0.sheet";
// import sheetData02 from "../../assets/spritesheets/temp_sprites-1.sheet";
// import sheetData03 from "../../assets/spritesheets/temp_sprites-2.sheet";
// import sheetUrl01 from "../../assets/spritesheets/temp_sprites-0.png";
// import sheetUrl02 from "../../assets/spritesheets/temp_sprites-1.png";
// import sheetUrl03 from "../../assets/spritesheets/temp_sprites-2.png";
// import Assets from "../../util/Assets";
// Assets.prepare(["spritesheets/temp_sprites"]);
// const sheets = [
//   { data: sheetData01, url: sheetUrl01 },
//   { data: sheetData02, url: sheetUrl02 },
//   { data: sheetData03, url: sheetUrl03 },
// ];
const MAX_HEIGHT = 20;
const TREE_DATA = {
  height: 15
};
const spriteData = {
  tree_naked2: { ...TREE_DATA,
    ignoreFlip: true,
    shadow: true,
    shadowScale: 0.7,
    shadowOffsetX: -0.35,
    shadowOffsetY: 0.05,
    varianceStd: 0.5,
    useMapDiscard: true
  },
  "forest-twig1": {
    minSize: 0.5,
    maxSize: 0.75
  },
  "forest-twig2": {
    minSize: 0.5,
    maxSize: 0.75
  },
  "forest-twig3": {
    minSize: 0.5,
    maxSize: 0.75
  },
  tree1: { ...TREE_DATA,
    ignoreFlip: true,
    minSize: 8,
    useMapDiscard: true
  },
  tree2: { ...TREE_DATA,
    ignoreFlip: true,
    useMapDiscard: true
  },
  "origin-tree": {
    ignoreFlip: true,
    height: 10,
    useMapDiscard: true
  },
  tree3: { ...TREE_DATA,
    ignoreFlip: true,
    useMapDiscard: true
  },
  tree5: { ...TREE_DATA,
    ignoreFlip: true,
    varianceStd: 0.25,
    useMapDiscard: true
  },
  acorns1: {
    height: 0.5
  },
  fallen_wood1: {
    height: 0.5
  },
  fallen_wood2: {
    height: 0.5
  },
  tree_naked1: { ...TREE_DATA,
    ignoreFlip: true,
    shadow: true,
    shadowScale: 0.7,
    shadowOffsetX: -0.3,
    shadowOffsetY: -0.6,
    varianceStd: 0.5
  },
  tree_naked3: { ...TREE_DATA,
    ignoreFlip: true,
    height: 7,
    shadow: true,
    shadowScale: 0.5,
    shadowOffsetX: -0.2,
    varianceStd: 0.5,
    useMapDiscard: true
  },
  smalltree1: {
    useMapDiscard: false,
    minSize: 3
  },
  tree_naked2: { ...TREE_DATA,
    ignoreFlip: true,
    shadow: true,
    shadowScale: 0.6,
    shadowOffsetX: -0.35,
    shadowOffsetY: 0.1,
    varianceStd: 0.5,
    useMapDiscard: true
  },
  decayed_stump1: {
    ignoreFlip: true,
    height: 1.5,
    minSize: 1.5,
    maxSize: 2.25,
    varianceStd: 0.25,
    shadow: true,
    shadowScale: 1.0,
    shadowOffsetX: -0.25,
    shadowOffsetY: -0.5,
    useMapDiscard: true
  },
  decayed_twig1: {
    minSize: 1,
    height: 1.25,
    maxSize: 1.5,
    useMapDiscard: false
  },
  decayed_twig2: {
    minSize: 1,
    height: 1.25,
    maxSize: 1.5,
    useMapDiscard: false
  },
  decayed_twig3: {
    minSize: 1,
    height: 1.25,
    maxSize: 1.5,
    useMapDiscard: false
  },
  decayed_twig4: {
    minSize: 1,
    height: 1.25,
    maxSize: 1.5,
    useMapDiscard: false
  },
  "oat-shadow1": {
    minSize: 1,
    height: 1.5,
    maxSize: 2,
    useMapDiscard: false,
    ignoreFlip: true
  },
  "small-rock1": {
    minSize: 0.35,
    height: 0.5,
    maxSize: 0.65,
    useMapDiscard: false,
    ignoreFlip: true
  },
  "small-rock2": {
    minSize: 0.35,
    height: 0.5,
    maxSize: 0.65,
    useMapDiscard: false,
    ignoreFlip: true
  },
  "wetland-plant1": {
    minSize: 1,
    height: 1.25,
    maxSize: 1.5,
    useMapDiscard: false
  },
  "wetland-plant2": {
    minSize: 1,
    height: 1.25,
    maxSize: 1.5,
    useMapDiscard: false
  },
  "wetland-grass1": {
    minSize: 1,
    height: 1.25,
    maxSize: 1.5,
    useMapDiscard: false
  }
};
const treeLushType = { ...TREE_DATA,
  ignoreFlip: true,
  minSize: 8,
  useMapDiscard: true
};
const grasslandGrassType = {
  minSize: 1.5,
  height: 1.5,
  maxSize: 2.25,
  useMapDiscard: false
};

async function AssetSprites(world) {
  const renderer = world.findTag(Tags.Renderer); // const sprites = await SpriteManager("spritesheets/temp_sprites", renderer);

  const dataTarget = world.findTag(Tags.GroundDataRenderTarget);
  const groundView = world.findTag(Tags.GroundPlaneView);
  const emptyTexture = (0, _materials.getEmptyTexture)();
  const planeGeo = (0, _materials.getSpriteGeometry)(); // const spriteMaterial = createSpriteMaterial(world, noiseMap);
  //     const sprite = new THREE.Mesh(planeGeo, spriteMaterial);
  //     sprite.frustumCulled = false;
  //     sprite.name = "environment-sprite";
  //     return sprite;

  return {
    next: nextSprite,

    release(entity) {
      const data = entity.get(Tags.GroundAssetData);

      if (data.instance && data.instance.userData._pool) {
        data.instance.userData._pool.release(data.instance);
      } // data.instance.traverse((child) => {
      //   if (child.userData._entity) {
      //     child.userData._entity.kill();
      //   }
      // });


      (0, _threeUtil.detachObject)(data.instance);
      data.instance = null; // if (entity.has(Tags.Object3D)) {
      //   const s = entity.get(Tags.Object3D);
      //   detachObject(s);
      // }
      // if (
      //   s &&
      //   s.material &&
      //   s.material.uniforms.map &&
      //   s.material.uniforms.map.value._pool
      // ) {
      //   s.material.uniforms.map.value._pool.release(
      //     s.material.uniforms.map.value
      //   );
      //   s.material.uniforms.map.value = emptyTexture;
      // }
      // if (s && s.userData._pool) {
      //   s.userData._pool.release(s);
      // }
    },

    update(e) {
      if (!e.has(Tags.Object3D)) return; // const object = e.get(Tags.Object3D);
      // if (!object) return;
      // const scalar = object.userData.scalarSize;
      // const spriteWidth = object.userData.spriteWidth;
      // const spriteHeight = object.userData.spriteHeight;
      // let curSize = 1;
      // object.scale.set(
      //   spriteWidth * scalar * curSize,
      //   spriteHeight * scalar * curSize,
      //   1
      // );
      // object.material.uniforms.spin.value = 1 - curSize;
      // object.visible = curSize > 1e-5;
    }

  };

  function nextSprite(e) {
    if (!e.has(Tags.GroundAssetData)) return;
    const sample = e.get(Tags.GroundAsset);
    const cellData = sample.cellEntity.get(Tags.EnvironmentCell);
    const sampleData = e.get(Tags.GroundAssetData);
    const random = cellData.random;
    const instance = sampleData.instance;
    if (!instance) return;
    instance.position.set(sample.x, 0, sample.z);
    const isSprite = instance.isMesh && instance.userData.type === "WayfinderSprite";
    const minScale = 0.95;
    const maxScale = 1.05;
    let curScale = MathUtil.clamp(Math.abs(sampleData.variance), minScale, maxScale);
    instance.scale.multiplyScalar(curScale);
    sampleData.scale.copy(instance.scale);

    if (isSprite) {
      const isFlip = sampleData.flip && !sampleData.ignoreFlip;
      instance.material.uniforms.flip.value = isFlip ? -1 : 1;
      instance.material.side = isFlip ? THREE.BackSide : THREE.FrontSide;
      let useMapDiscard = false;

      if (typeof sampleData.useMapDiscard === "boolean") {
        useMapDiscard = sampleData.useMapDiscard;
      }

      instance.material.uniforms.useMapDiscard.value = useMapDiscard;
      const aspect = instance.scale.x / instance.scale.y;
      instance.material.uniforms.aspect.value = aspect;
      instance.material.uniforms.spriteHeight.value = instance.scale.y;
      const spriteEntity = instance.userData._entity;

      if (spriteEntity) {
        if (!spriteEntity.has(Tags.ShaderUniformTime)) {
          spriteEntity.add(Tags.ShaderUniformTime);
        }

        const timeUniform = spriteEntity.get(Tags.ShaderUniformTime);
        timeUniform.uniform = instance.material.uniforms.time;
      }
    } else {
      instance.rotation.y = sampleData.rotation;
    } // const mesh = instance.clone(true);
    // e.add(Tags.Object3D, object);
    // e.add(Tags.ShadowCaster);
    // e.get(Tags.ShadowCaster).sprite = true;
    // e.add(Tags.ShaderUniformTime);
    // const sprite = sprites.map[sampleData.key];

  }

  function nextSpriteOld(e) {
    if (!e.has(Tags.GroundAssetData)) return;
    const sample = e.get(Tags.GroundAsset);
    const cellData = sample.cellEntity.get(Tags.EnvironmentCell);
    const sampleData = e.get(Tags.GroundAssetData);
    const random = cellData.random;
    const sprite = sprites.map[sampleData.key];

    if (!sprite) {
      console.warn("no sprite for", sampleData.key);
      return;
    }

    const object = spritePool.next();
    const tex = texturePools[sprite.sheetIndex].next();
    (0, _threeUtil.shareAtlasTexture)(renderer, sprite.atlas, tex);
    object.material.uniforms.map.value = tex;
    object.material.uniforms.repeat.value.copy(sprite.repeat);
    object.material.uniforms.offset.value.copy(sprite.offset); // const isFlip = false;

    const isFlip = sampleData.flip && !sampleData.ignoreFlip;
    object.material.uniforms.flip.value = isFlip ? -1 : 1;
    object.material.side = isFlip ? THREE.BackSide : THREE.FrontSide;
    let useMapDiscard = false;

    if (typeof sampleData.useMapDiscard === "boolean") {
      useMapDiscard = sampleData.useMapDiscard;
    }

    object.material.uniforms.useMapDiscard.value = useMapDiscard; // object.material.side = THREE.BackSide;

    let spriteHeight = 1;
    let varianceMean = 1;
    let varianceStd = 0.25;
    let minSize = 0.5;
    let maxSize = 12;
    if (sampleData.height != null) spriteHeight = sampleData.height;
    if (sampleData.varianceMean != null) varianceMean = sampleData.varianceMean;
    if (sampleData.varianceStd != null) varianceStd = sampleData.varianceStd;
    if (sampleData.minSize != null) minSize = sampleData.minSize;
    if (sampleData.maxSize != null) maxSize = sampleData.maxSize;
    const variance = varianceMean + sampleData.variance * varianceStd;
    spriteHeight *= variance;
    spriteHeight = MathUtil.clamp(spriteHeight, minSize, Math.min(MAX_HEIGHT, maxSize));
    const aspect = sprite.width / sprite.height;
    const spriteWidth = spriteHeight * aspect;
    object.userData.scalarSize = 1;
    object.userData.spriteName = sprite.name;
    object.userData.spriteWidth = spriteWidth;
    object.userData.spriteHeight = spriteHeight;
    object.position.set(sample.x, 0, sample.z);
    e.add(Tags.Object3D, object);
    e.add(Tags.ShadowCaster);
    e.get(Tags.ShadowCaster).sprite = true;
    e.add(Tags.ShaderUniformTime);
    const timeUniform = e.get(Tags.ShaderUniformTime);
    timeUniform.uniform = object.material.uniforms.time;
    object.material.uniforms.aspect.value = aspect;
    object.material.uniforms.spriteHeight.value = spriteHeight;
  }
}
},{"../../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../../util/ObjectPool":"src/util/ObjectPool.js","../../util/SpriteManager":"src/util/SpriteManager.js","../../util/three-util":"src/util/three-util.js","../../util/load":"src/util/load.js","../../util/math":"src/util/math.js","../AnimationSystem":"src/systems/AnimationSystem.js","../../util/materials":"src/util/materials.js"}],"src/systems/SimpleEnvironmentAssetsSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SimpleEnvironmentAssetsSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _AssetSprites = _interopRequireDefault(require("./environment/AssetSprites"));

var _assetTypes = require("./environment/asset-types");

var _threeUtil = require("../util/three-util");

var _AnimationSystem = require("./AnimationSystem");

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _Random = _interopRequireDefault(require("../util/Random"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import { AssetGLTFs } from "./environment/AssetGLTFs";
// const classes = ["rock", "tree", "branch", "stump"];
const _box = new THREE.Box3();

const worldScale = new THREE.Vector3();

function patchSpriteBox3(box, sprite) {
  sprite.getWorldScale(worldScale);
  const scaleY = worldScale.y;
  box.max.y += scaleY * 0.4; // more as it's not axis-aligned but camera-aligned
  // box.min.z -= 1; // more for shadow
  // box.max.z += 1; // more for shadow

  box.min.x -= 2; // more for shadow

  box.max.x += 0; // more for some edge ../
}

async function SimpleEnvironmentAssetsSystem(world) {
  const sprites = await (0, _AssetSprites.default)(world); // const gltfs = AssetGLTFs(world);

  let gltfs;
  const container = new THREE.Group();
  container.name = "assets";
  world.entity().add(Tags.Object3D, container);
  const cellView = world.view(Tags.EnvironmentCell);
  const cellEvents = world.listen(Tags.EnvironmentCell);
  const frustum = world.findTag(Tags.MainCameraFrustum);
  const groundAssetEvents = world.listen([Tags.GroundAsset, Tags.GroundAssetData]);
  const groundAssetView = world.view([Tags.GroundAsset, Tags.GroundAssetData]);
  const groundAssetAllView = world.view([Tags.GroundAsset, Tags.GroundAssetData, Tags.Object3D]);
  const includeGLTF = Boolean(gltfs); // const geom = new THREE.SphereGeometry(1, 16, 16);

  const tmp2D = new THREE.Vector2();
  const tmpBox = new THREE.Box3();
  const itemsMap = world.findTag(Tags.GLTFSpawnItemsMap); // const helpers = world.view([Tags.BoxHelper, Tags.Object3D]);

  const sysRandom = (0, _Random.default)(); // let globalAssetTween = { scale: 1 };

  const barrenGroundEvents = world.listen(Tags.TutorialBarrenGround);
  const finalBiomeEvents = world.listen(Tags.FinalBiomeResolution);
  const barrenGroundView = world.view(Tags.TutorialBarrenGround);
  const activeEnvChanged = world.listen(Tags.ActiveEnvironmentState);
  let time = 0;
  return function envAssetSystem(dt) {
    if (activeEnvChanged.changed) {// cellView.forEach((e) => e.kill());
      // groundAssetView.forEach((e) => e.kill());
    }

    time += dt;

    for (let j = 0; j < cellEvents.added.length; j++) {
      const e = cellEvents.added[j];
      const c = e.get(Tags.EnvironmentCell);
      const cell = c.cell;
      const random = c.random;
      const colorData = c.environmentState.colors[cell.colorIndex % c.environmentState.colors.length];
      const cellClass = colorData ? colorData.name : null;
      c.children.length = 0; // if (true) {
      //   //hasCellClass(cellClass)

      for (let i = 0; i < cell.samples.length; i++) {
        const idx = cell.samples[i];
        const assetEntity = world.entity().add(Tags.GroundAsset);
        const t = assetEntity.get(Tags.GroundAsset);
        const pos = c.environmentState.samples[idx];
        t.x = pos[0];
        t.z = pos[1];
        t.cellEntity = e;
        const child = (0, _assetTypes.addSampleData)(container, itemsMap, assetEntity, cellClass, random);

        if (child) {
          // container.add(child);
          assetEntity.add(Tags.Object3D, child);
        }

        c.children.push(assetEntity);
      }

      for (let i = 0; i < cell.waterSamples.length; i++) {
        const idx = cell.waterSamples[i];
        const assetEntity = world.entity().add(Tags.GroundAsset);
        const t = assetEntity.get(Tags.GroundAsset);
        const pos = c.environmentState.waterSamples[idx];
        t.x = pos[0];
        t.z = pos[1];
        t.cellEntity = e;

        if (random.chance(0.5)) {
          const child = (0, _assetTypes.addSampleData)(container, itemsMap, assetEntity, c.environmentState.waterId, random);

          if (child) {
            // container.add(child);
            assetEntity.add(Tags.Object3D, child);
          }
        } else {
          assetEntity.add(Tags.WaterFishPlaceholderTag);
        }

        c.children.push(assetEntity);
      } // } else {
      //   c.children.length = 0;
      //   if (colorData) console.log(`no data for ${colorData.name}`);
      //   else console.log(`no color data for ${cell.colorIndex}`);
      // }


      for (let i = 0; i < cell.tokens.length; i++) {
        const idx = cell.tokens[i];
        const assetEntity = world.entity().add(Tags.GroundAsset).add(Tags.GroundAssetData).add(Tags.GroundAssetToken);
        assetEntity.get(Tags.GroundAssetData).type = "token";
        const token = c.environmentState.tokens[idx];
        const tokenData = assetEntity.get(Tags.GroundAssetToken);
        tokenData.type = token.type;
        const t = assetEntity.get(Tags.GroundAsset);
        t.x = token.position[0];
        t.z = token.position[1];
        t.cellEntity = e;
        c.children.push(assetEntity);
      } // cell.patches.forEach((idx) => {
      //   const assetEntity = world.entity().add(Tags.GroundAsset);
      //   assetEntity.add(Tags.GroundAssetData);
      //   assetEntity.get(Tags.GroundAssetData).type = "patch";
      //   const patch = c.environmentState.patches[idx];
      //   // assetEntity.add(Tags.GLTFRefAsset);
      //   // const ref = assetEntity.get(Tags.GLTFRefAsset);
      //   // ref.position[0] = patch.position[0];
      //   // ref.position[1] = patch.position[1];
      //   // ref.name = patch.name;
      //   // ref.biome = c.environmentState.name;
      // const pos = patch.position;
      // const t = assetEntity.get(Tags.GroundAsset);
      // t.x = pos[0];
      // t.z = pos[1];
      // t.cellEntity = e;
      // c.children.push(assetEntity);
      // });

    }

    for (let i = 0; i < groundAssetEvents.added.length; i++) {
      const e = groundAssetEvents.added[i];
      const t = e.get(Tags.GroundAsset);
      const d = e.get(Tags.GroundAssetData);
      const c = t.cellEntity.get(Tags.EnvironmentCell);

      if (barrenGroundView.length > 0) {
        d.sizeFactor = 0;
      } // const box = new THREE.BoxHelper();
      // e.add(Tags.BoxHelper, {
      //   box,
      //   entity: world.entity().add(Tags.Object3D, box),
      // });


      if (d.type === "sprite") sprites.next(e);
    } // const camera = world.findTag(Tags.MainCamera);
    // const upX = camera.matrixWorldInverse.elements[4];
    // const upY = camera.matrixWorldInverse.elements[5];
    // const upZ = camera.matrixWorldInverse.elements[6];
    // const rightX = camera.matrixWorldInverse.elements[0];
    // const rightY = camera.matrixWorldInverse.elements[1];
    // const rightZ = camera.matrixWorldInverse.elements[2];
    // const camUpWorld = new THREE.Vector3(upX, upY, upZ);
    // const camRightWorld = new THREE.Vector3(rightX, rightY, rightZ);


    for (let i = 0; i < groundAssetAllView.length; i++) {
      const e = groundAssetAllView[i];
      const t = e.get(Tags.GroundAsset);
      const d = e.get(Tags.GroundAssetData); // can't frustum test patches as they might not be
      // loaded yet...

      if (d.type !== "patch") {
        const obj = e.get(Tags.Object3D);
        tmpBox.setFromObject(obj);

        if (d.type === "sprite") {
          patchSpriteBox3(tmpBox, obj);
        }

        const visible = frustum.intersectsBox(tmpBox);
        const curVisible = e.has(Tags.GroundAssetInsideFrustum);

        if (curVisible !== visible) {
          if (visible && !curVisible) {
            e.add(Tags.GroundAssetInsideFrustum);
          } else if (!visible && curVisible) {
            e.remove(Tags.GroundAssetInsideFrustum);
          }
        }
      }
    }

    if (finalBiomeEvents.changed) {
      if (finalBiomeEvents.added.length > 0) {
        groundAssetView.forEach(e => {
          const d = e.get(Tags.GroundAssetData);

          if (d.type !== "token" && d.type !== "patch" && d.sizeFactor > 0) {
            const sample = e.get(Tags.GroundAsset);
            const delayOff = MathUtil.clamp01(tmp2D.set(sample.x, sample.z).length() / 50);
            const delay = delayOff * 1 + sysRandom.range(0, 0.5);
            const tweenEntity = (0, _AnimationSystem.tweenFromTo)(world, d, "sizeFactor", d.sizeFactor, 0, 1, "sineOut", delay);
          }
        });
      } else if (finalBiomeEvents.removing.length > 0) {
        groundAssetView.forEach(e => {
          const d = e.get(Tags.GroundAssetData);

          if (d.type !== "token" && d.type !== "patch" && d.sizeFactor > 0) {
            d.sizeFactor = 1;
          }
        });
      }
    }

    if (barrenGroundEvents.changed) {
      if (barrenGroundEvents.added.length > 0) {
        groundAssetView.forEach(e => {
          e.get(Tags.GroundAssetData).sizeFactor = 0;
        });
      } else if (barrenGroundEvents.removing.length > 0) {
        groundAssetView.forEach(e => {
          const d = e.get(Tags.GroundAssetData);

          if (d.type !== "token" && d.type !== "patch" && d.sizeFactor <= 0) {
            const sample = e.get(Tags.GroundAsset);
            const delayOff = MathUtil.clamp01(tmp2D.set(sample.x, sample.z).length() / 50);
            const delay = delayOff * 1 + sysRandom.range(0, 0.5);
            const tweenEntity = (0, _AnimationSystem.tweenFromTo)(world, d, "sizeFactor", 0, 1, 1, "sineOut", delay);
          }
        });
      }
    }

    for (let i = 0; i < groundAssetView.length; i++) {
      const e = groundAssetView[i];
      const d = e.get(Tags.GroundAssetData);

      if (d.type === "sprite") {
        sprites.update(e);
      }

      if (d.type !== "token" && d.type !== "patch") {
        const t = d.sizeFactor; // Math.sin(time) * 0.5 + 0.5;

        const instance = d.instance;

        if (instance && instance.material && instance.material.uniforms.spin) {
          instance.material.uniforms.spin.value = 1 - t;
        }

        instance.scale.copy(d.scale).multiplyScalar(t);
      } // only do this for non-patches at the moment
      // NOTE: This only really happens for tokens as
      // sprite/3D ground assets don't have Object3D on their entity
      // (a single ground asset might be multiple Object3Ds)


      if (d.type !== "patch" && e.has(Tags.Object3D)) {
        const obj = e.get(Tags.Object3D);
        obj.visible = e.has(Tags.GroundAssetInsideFrustum);
      }
    }

    for (let i = 0; i < groundAssetEvents.removing.length; i++) {
      const e = groundAssetEvents.removing[i];
      const d = e.get(Tags.GroundAssetData);
      if (d.type === "sprite") sprites.release(e);
    }

    for (let i = 0; i < cellEvents.removing.length; i++) {
      const e = cellEvents.removing[i];
      const c = e.get(Tags.EnvironmentCell);
      c.children.forEach(child => {
        if (child.alive) {
          if (child.has(Tags.Object3D)) {
            const e = child.get(Tags.Object3D);
            (0, _threeUtil.detachObject)(e);
          }

          child.kill();
        }
      });
      c.children.length = 0;
    }
  };
}

function chooseAssetClass(cell, random) {}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","./environment/AssetSprites":"src/systems/environment/AssetSprites.js","./environment/asset-types":"src/systems/environment/asset-types.js","../util/three-util":"src/util/three-util.js","./AnimationSystem":"src/systems/AnimationSystem.js","../util/math":"src/util/math.js","../util/Random":"src/util/Random.js"}],"src/systems/ShadowMapSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ShadowMapSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _materials = require("../util/materials");

var _threeUtil = require("../util/three-util");

var ShaderManager = _interopRequireWildcard(require("../util/ShaderManager"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ShadowMapSystem(world) {
  const shadowCasterView = world.view([Tags.Object3D, Tags.ShadowCaster]);
  const shadowCasterEvents = world.listen([Tags.Object3D, Tags.ShadowCaster]);
  const renderLayers = world.findTag(Tags.RenderLayers); // const MAP_WIDTH = 1024;
  // const renderTarget = new THREE.WebGLRenderTarget(MAP_WIDTH, MAP_WIDTH);
  // renderTarget.texture.generateMipmaps = false;
  // renderTarget.depthBuffer = false;
  // renderTarget.texture.minFilter = THREE.LinearFilter;
  // renderTarget.texture.magFilter = THREE.LinearFilter;
  // renderTarget.texture.wrapS = renderTarget.texture.wrapT =
  //   THREE.ClampToEdgeWrapping;
  // world.entity().add(Tags.DebugRenderTarget, { target: renderTarget });

  const clearColor = new THREE.Vector3(0, 0, 0);
  const tmpColor = new THREE.Vector3(0, 0, 0);
  const lightCamera = new THREE.PerspectiveCamera(); // const lightCamera = new THREE.OrthographicCamera();

  const projection = new THREE.Matrix4();
  const view = new THREE.Matrix4(); // world.tag(Tags.ShadowMapRenderTarget, {
  //   target: renderTarget,
  //   projection,
  // });

  const silhouetteMeshMaterial = ShaderManager.create({
    name: "ShadowSilhouetteMesh",
    vertexShader:
    /*glsl*/
    `
      #include <common>
      uniform mat4 projection;
      uniform mat4 view;
      varying vec3 vCenterPos;
      varying vec3 vRealWorldPos;

      void main () {
        vec4 realWorldPos = modelMatrix * vec4(position.xyz, 1.0);
        vRealWorldPos = realWorldPos.xyz;
        vec3 camRightWorld = vec3(viewMatrix[0].x, viewMatrix[1].x, viewMatrix[2].x);
        vec3 camUpWorld = vec3(viewMatrix[0].y, viewMatrix[1].y, viewMatrix[2].y);
        vec3 camBack = cross(camUpWorld, camRightWorld);
        float xSkew = -60.0 * (PI/180.0);
        float ySkew = 0.0;

        // Create a transform that will skew our texture coords
        mat3 trans = mat3(
          1.0       , tan(xSkew), 0.0,
          tan(ySkew), 1.0,        0.0,
          0.0       , 0.0,        1.0
        );
        
        vec4 worldSpace = modelMatrix * vec4(position.xyz, 1.0);
        worldSpace.y *= 0.25;
        // worldSpace.xyz *= trans;
        worldSpace.xyz += realWorldPos.y * camRightWorld * -0.5;

        worldSpace.z += -0.25;
        worldSpace.x += -0.1;
        vec4 camSpace = view * worldSpace;

        vCenterPos = (modelMatrix * vec4(vec3(0.0), 1.0)).xyz;

        gl_Position = projectionMatrix * viewMatrix * worldSpace;
        // gl_Position.y += 0.4;
        // gl_Position.x -= 0.4;
      }
    `,
    fragmentShader:
    /*glsl*/
    `
      uniform float opacity;
      uniform vec3 color;
      varying vec3 vCenterPos;
      varying vec3 vRealWorldPos;
      void main () {
        gl_FragColor = vec4(color, 1.0);

        // float falloff = 1.0 - clamp(pow(distance(vRealWorldPos, vCenterPos) / 1.0, 0.5), 0.0, 1.0);
        float falloff = 1.0 - clamp(pow(vRealWorldPos.y / 2.0, 1.0), 0.0, 1.0);
        float shadowOpacity = 0.25;
        gl_FragColor.rgb = mix(vec3(1.0), gl_FragColor.rgb, shadowOpacity * falloff);
      }
    `,
    transparent: true,
    // depthTest: false,
    depthWrite: false,
    side: THREE.DoubleSide,
    blending: THREE.MultiplyBlending,
    uniforms: {
      color: {
        value: new THREE.Color("#280422")
      },
      projection: {
        value: projection
      },
      view: {
        value: view
      }
    }
  });
  const camOffset = new THREE.Vector3().set(1, 1, 0.25).normalize(); // const angle = THREE.MathUtils.degToRad(45 * -1);
  // const r = 1;
  // const camOffset = new THREE.Vector3(1, 1, 1);
  // camOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);

  return function shadowMapSystem(dt) {
    // const renderer = world.findTag(Tags.Renderer);
    // const state = world.findTag(Tags.AppState);
    // const canvas = renderer.domElement;
    // const width = canvas.width;
    // const height = canvas.height;
    // if (canvas.width === 0 || canvas.height === 0) return;
    // let newAspect = width / height;
    // let aspect = renderTarget.width / renderTarget.height;
    // const rWidth = MAP_WIDTH;
    // const rHeight = Math.round(rWidth / newAspect);
    // if (renderTarget.width !== rWidth || renderTarget.height !== rHeight) {
    //   renderTarget.setSize(rWidth, rHeight);
    // }
    shadowCasterEvents.added.forEach(e => {
      const sprite = e.get(Tags.ShadowCaster).sprite;
      const obj = e.get(Tags.Object3D);
      obj.traverse(child => {
        if (child.layers) child.layers.enable(renderLayers.shadow);

        if (child.isMesh) {
          child.userData.__shadowEnabled = true;
          child.userData.__shadowMaterial = sprite ? child.material : silhouetteMeshMaterial;
        }
      });
    });
    const mainCamera = world.findTag(Tags.MainCamera); // const mainScene = world.findTag(Tags.MainScene);
    // mainCamera.getWorldPosition(lightCamera.position);
    // mainCamera.getWorldQuaternion(lightCamera.quaternion);

    const d = 20;
    const yoff = 0; // lightCamera.left = -d;
    // lightCamera.right = d;
    // lightCamera.top = d + yoff;
    // lightCamera.bottom = -d + yoff;
    // lightCamera.zoom = 1;
    // lightCamera.near = -50;
    // lightCamera.far = 50;

    (0, _threeUtil.fastCopyCameraData)(mainCamera, lightCamera); // lightCamera.zoom = mainCamera.zoom - 0.25;

    const target = world.findTag(Tags.UserFollow).currentTarget; // lightCamera.position.copy(target);
    // lightCamera.position.addScaledVector(camOffset, 1);
    // lightCamera.translateX(0.5);
    // lightCamera.translateY(0.75);
    // lightCamera.lookAt(target);
    // lightCamera.fov = 45;
    // lightCamera.translateX(4);
    // lightCamera.translateY(-2);
    // lightCamera.lookAt(target);

    lightCamera.updateProjectionMatrix();
    lightCamera.updateMatrixWorld();
    projection.copy(lightCamera.projectionMatrix);
    view.copy(lightCamera.matrixWorldInverse); // const camRightWorld = new THREE.Vector3(
    //   view.elements[0],
    //   view.elements[4],
    //   view.elements[8]
    // );
    // lightCamera.position.addScaledVector(camRightWorld, 1);
    // lightCamera.updateMatrixWorld();
    // view.copy(lightCamera.matrixWorldInverse);
    // vec3 camRightWorld = vec3(viewMatrix[0].x, viewMatrix[1].x, viewMatrix[2].x);
    // vec3 camUpWorld = vec3(viewMatrix[0].y, viewMatrix[1].y, viewMatrix[2].y);
    // tmpColor.copy(renderer.getClearColor());
    // renderer.setRenderTarget(renderTarget);
    // renderer.setClearColor(clearColor);
    // lightCamera.layers.set(renderLayers.shadow);
    // shadowCasterView.forEach((e) => {
    //   const obj = e.get(Tags.Object3D);
    //   obj.traverse((child) => {
    //     if (child.isMesh) {
    //       child.userData.__material = child.material;
    //       child.userData.__frustumCulled = child.frustumCulled;
    //       // child.frustumCulled = false;
    //       child.material = child.userData.__shadowMaterial;
    //       if (child.material.uniforms && child.material.uniforms.silhouette) {
    //         child.material.uniforms.silhouette.value = true;
    //       }
    //     }
    //   });
    // });
    // renderer.render(mainScene, lightCamera);
    // renderer.setRenderTarget(null);
    // renderer.setClearColor(tmpColor);
    // shadowCasterView.forEach((e) => {
    //   const obj = e.get(Tags.Object3D);
    //   obj.traverse((child) => {
    //     if (child.isMesh) {
    //       child.material = child.userData.__material;
    //       child.frustumCulled = child.userData.__frustumCulled;
    //       if (child.material.uniforms && child.material.uniforms.silhouette) {
    //         child.material.uniforms.silhouette.value = false;
    //       }
    //     }
    //   });
    // });
  };
} // function createShader
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/materials":"src/util/materials.js","../util/three-util":"src/util/three-util.js","../util/ShaderManager":"src/util/ShaderManager.js"}],"src/systems/LoadRefGLTFSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = LoadRefGLTFSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var Helpers = _interopRequireWildcard(require("../util/helpers"));

var _deepClone = _interopRequireDefault(require("deep-clone"));

var _threeUtil = require("../util/three-util");

var _EditorWayfinderSprite = require("../util/EditorWayfinderSprite");

var _RefGLTFLoader = _interopRequireWildcard(require("../util/RefGLTFLoader"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _geometry = require("../util/geometry");

var _ObjectPool = _interopRequireDefault(require("../util/ObjectPool"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import { Assets } from "./AssetLoaderSystem";
//
async function LoadRefGLTFSystem(world) {
  const container = new THREE.Group();
  container.name = "loadrefgroup";
  world.entity().add(Tags.Object3D, container); // container.visible = false;

  const loader = await (0, _RefGLTFLoader.default)(world);
  const refEvents = world.listen(Tags.GLTFRefAsset);
  const activeEnv = world.listen(Tags.ActiveEnvironmentState);
  const refView = world.view(Tags.GLTFRefAsset);
  const frustum = world.findTag(Tags.MainCameraFrustum);
  const tmpBox = new THREE.Box3();
  const p3d = new THREE.Vector3();
  const userPos2D = [0, 0];
  const tmpBounds = new THREE.Box3();
  const groupPool = new _ObjectPool.default({
    initialCapacity: 50,

    create() {
      const g = new THREE.Group();
      g.userData._pool = this; // container.add(g);

      return g;
    },

    release(g) {
      // container.remove(g);
      (0, _threeUtil.clearGroup)(g);
    }

  }); // const random = Random(Random.getRandomState());
  // (async () => {
  //   const names = Object.keys(MetaData);
  //   const object = await loader.loadSceneByName(names[9]);
  //   group.add(object);
  //   // object.rotation.y = random.range(-1, 1) * Math.PI * 2;
  // })();
  // let a = true;
  // setInterval(() => {
  //   a = !a;
  //   load(a ? scene0 : scene1);
  // }, 1000);
  // (async () => {
  //   const resp = await fetch(testsceneUrl);
  //   const json = await resp.json();
  //   load(json);
  // })();
  // load(testscene);
  // window.printVisible = () => {
  //   const mainScene = world.findTag(Tags.MainScene);
  //   let vis = 0;
  //   mainScene.traverse((child) => {
  //     if (child.visible) {
  //       vis++;
  //       // if (!child.name) {
  //       //   if (child.isMesh) {
  //       //     console.log("untitled child", child.material.name);
  //       //   } else {
  //       //     console.log("untitled");
  //       //   }
  //       // } else {
  //       //   console.log(child.name);
  //       // }
  //     }
  //   });
  //   console.log("total visible", vis);
  // };

  return function loadRefGLTFSystem(dt) {
    if (!world.findTag(Tags.AppState).ready) return;
    const userPos = world.findTag(Tags.UserTarget).position;
    userPos2D[0] = userPos.x;
    userPos2D[1] = userPos.z;

    if (activeEnv.changed) {
      refView.forEach(e => {
        const r = e.get(Tags.GLTFRefAsset);
        release(e, r);
        refView.forEach(e => e.kill());
      });
    }

    refEvents.removing.forEach(e => {
      const r = e.get(Tags.GLTFRefAsset);

      if (e.has(Tags.Object3D)) {
        const g = e.get(Tags.Object3D);
        (0, _threeUtil.detachObject)(g);
        e.remove(Tags.Object3D);
      } // console.log("removing", r);


      if (r.group) {
        if (r.group.parent) {
          console.warn("GLTF Ref still has parent");
        }

        releaseLoaded(r.group);
        r.group = null;
      }
    });
    refView.forEach(e => {
      const r = e.get(Tags.GLTFRefAsset);
      const p = r.position;
      const name = r.name;
      const data = _RefGLTFLoader.MetaData[name];
      const x = p[0];
      const y = p[1];
      const patchRadius = data.boundingCircle.radius;
      const nearby = (0, _geometry.circlesIntersect)(p, patchRadius, userPos2D, 50);
      let inFrustum = false;

      if (nearby) {
        // TODO: Currently, any item within a circle radius is 'in frustum'
        // for our purposes here, but in reality it might not be in frustum.
        // However ThreeJS will catch those during its render step, so we can just
        // set it to true and let ThreeJS cull away anything not in frustum.
        inFrustum = true; // Alternatively we might want to do manual frustum culling for some reason?
        // if (r.boundsSet) {
        //   tmpBox.min.copy(r.boundsMin);
        //   tmpBox.max.copy(r.boundsMax);
        // } else {
        //   p3d.set(p[0], 0, p[1]);
        //   tmpBox.min.fromArray(data.boundingBox[0]).add(p3d);
        //   tmpBox.max.fromArray(data.boundingBox[1]).add(p3d);
        // }
        // inFrustum = frustum.intersectsBox(tmpBox);
        // Another thing we can do is prepare scenes once they are in range
        // This reduces the chance of objects 'popping' into view,
        // but may create jank as you move.
        // loader.prepareSceneByName(name);
      }

      const curInFrustum = e.has(Tags.IsInFrustum);

      if (inFrustum !== curInFrustum) {
        // update visibility tag
        if (inFrustum) {
          e.add(Tags.IsInFrustum);
        } else {
          if (e.has(Tags.IsInFrustum)) {
            e.remove(Tags.IsInFrustum);
            release(e, r);
          }
        } // if in frustum, make sure we have something loaded
        // or if we need to load group initially


        if (e.has(Tags.IsInFrustum)) {
          // no object yet assigned
          if (!e.has(Tags.Object3D)) {
            next(e, r, name, x, y);
          }
        }

        if (e.has(Tags.Object3D)) {
          const d = e.get(Tags.Object3D);
          d.visible = inFrustum;
        }
      }
    });
  };

  function release(e, r) {
    if (r.group) {
      releaseLoaded(r.group);
    }

    if (e.has(Tags.Object3D)) {
      const g = e.get(Tags.Object3D);
      (0, _threeUtil.detachObject)(g);
      e.remove(Tags.Object3D);
    }

    if (r.promise) {
      r.promise.then(releaseLoaded);
    }

    r.group = null;
    r.promise = null;
  }

  function releaseLoaded(object) {
    if (object && object.userData._pool) {
      object.userData._pool.release(object);
    }
  }

  function next(e, r, name, x, y) {
    if (r.group) {
      console.error("Group already exists");
      releaseLoaded(r.group);
      (0, _threeUtil.detachObject)(r.group);
    }

    const parent = groupPool.next(); // if (parent.parent) throw new Error("has parent!");
    // container.add(parent);

    r.group = parent;
    parent.name = name;
    r.promise = loader.nextPooledByName(name, true).then(object => {
      // in case the object was destroyed before loading completed
      if (!r.group) {
        console.log("Early release", object);
        releaseLoaded(object);
        return null; // already released
      }

      const p = r.group;
      p.position.x = x;
      p.position.z = y;
      p.add(object);
      tmpBounds.setFromObject(p);
      r.boundsMin.copy(tmpBounds.min);
      r.boundsMax.copy(tmpBounds.max);
      r.boundsSet = true; // const data = MetaData[name];
      // const tmpBox = new THREE.Box3();
      // p3d.set(x, 0, y);
      // tmpBox.min.fromArray(data.boundingBox[0]).add(p3d);
      // tmpBox.max.fromArray(data.boundingBox[1]).add(p3d);
      // const box1 = new THREE.Box3Helper(tmpBox, "blue");
      // world.entity().add(Tags.Object3D, box1);
      // const box = new THREE.BoxHelper(p);
      // world.entity().add(Tags.Object3D, box);

      return object; // return object for future promise thens()
    });
    const object = r.group;
    e.add(Tags.Object3D, object);
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/helpers":"src/util/helpers.js","deep-clone":"node_modules/deep-clone/index.js","../util/three-util":"src/util/three-util.js","../util/EditorWayfinderSprite":"src/util/EditorWayfinderSprite.js","../util/RefGLTFLoader":"src/util/RefGLTFLoader.js","../util/Random":"src/util/Random.js","../util/geometry":"src/util/geometry.js","../util/ObjectPool":"src/util/ObjectPool.js"}],"src/systems/PoemCollectionSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = PoemCollectionSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var _store = require("svelte/store");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import PoemCollectionOverlay from "../overlays/PoemCollectionOverlay.svelte";
// import HaikuPopup from "../overlays/HaikuPopup.svelte"; // Get access to poem state
function PoemCollectionSystem(world) {
  const entity = world.entity().add(Tags.ViewLayer, {
    id: "poem-collection" // component: PoemCollectionOverlay,

  });
}
},{"../tags":"src/tags/index.js","svelte/store":"node_modules/svelte/store/index.mjs"}],"src/systems/HaikuCollectionSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = HaikuCollectionSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _locale = require("../util/locale");

var _haikugen = _interopRequireDefault(require("../util/haikugen"));

var _AnimationSystem = require("./AnimationSystem");

var _queryString = _interopRequireDefault(require("../util/query-string"));

var _tokens = require("../util/tokens");

var _Random = _interopRequireDefault(require("../util/Random"));

var _resetPlayerPos = _interopRequireWildcard(require("../util/resetPlayerPos"));

var _nfb = require("../nfb");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import { generateStanza } from "../test/haiku-gen";
// import EndStateOverlay from "../overlays/EndStateOverlay.svelte";
// when you collect 5, show something to
// bring the user back to the home tree
// and then when you get within tree range,
// trigger a 'resolve' + transition to new world
function HaikuCollectionSystem(world) {
  // const collectedTokenView = world.view(Tags.CollectedToken);
  // const collectedTokenEvents = world.listen(Tags.CollectedToken);
  // const collectedHaikuEvents = world.listen(Tags.FinishedPoem);
  const random = (0, _Random.default)();

  window.addPoem = (tokens, lines) => {
    const haiku = (0, _haikugen.default)();

    if (!tokens) {
      tokens = random.shuffle(_tokens.AllTokens).slice(0, 3);
    }

    lines = lines || tokens.map((t, i) => {
      return haiku.generateStanza({
        stanza: i,
        token: t
      });
    });
    console.log(lines, tokens);
    const poem = world.entity().add(Tags.FinishedPoem, {
      lines: lines.slice(),
      tokens: tokens.slice()
    });
    console.log(tokens);
    console.log(lines.map(e => e.en).join(" / "));
  };

  window.addTestPoem = () => {
    window.addPoem(random.shuffle(_tokens.AllTokens).slice(0, 3));
  };

  const collectedHaikuEvents = world.listen(Tags.FinishedPoem);
  const haikuInventoryEvents = world.listen(Tags.HaikuInInventory);
  const haikuAddingToInventoryView = world.view(Tags.HaikuAddingToInventory);
  const haikuInventoryView = world.view(Tags.HaikuInInventory);
  const entity = world.entity();
  const cardSavedEvents = world.listen(Tags.HaikuCardSaved);
  let lastEnv;
  const envStates = world.view(Tags.ActiveEnvironmentState);
  const envStateEvents = world.listen(Tags.ActiveEnvironmentState);
  const originTrees = world.view([Tags.SpriteAnimation, Tags.SpriteAnimationOriginTreeTag]);
  let isAboutToAnimate = false;
  let isAboutToTransition = false;
  let animateTime = 0;
  let animateDelay = 4;
  let tundraAnimateDelay = 17;
  let transitionTime = 0;
  let transitionDelay = 10;
  let tundraTransitionDelay = 23;
  let animatingOutChar = false;
  let animOutCharDelay = 3;
  const endGameView = world.view(Tags.EndGameState);
  const biomes = ["forest", "grasslands", "tundra"];
  let hasSeenResolveMessage = false;
  const allTextView = world.view(Tags.TextHint);
  setTimeout(() => {
    const numTestPoems = _queryString.default.poems;

    if (typeof numTestPoems === "number") {
      for (let i = 0; i < numTestPoems; i++) window.addTestPoem();
    }
  }, 0);
  const finalBiomeFinish = world.listen(Tags.ResetToCameraDrift);
  const autoCapeEffects = world.view(Tags.AutoRemoveCapeMagicalEffect); // const endEntity = world.entity().add(Tags.ViewLayer, {
  //   id: "end-state",
  //   component: EndStateOverlay,
  //   props: {
  //     onIntroEnd() {
  //       // world.findTag(Tags.AppState).running = false;
  //     },
  //   },
  // });

  return function haikuCollectSystem(dt) {
    const curEnvState = envStates[0];
    const envState = curEnvState ? curEnvState.get(Tags.EnvironmentState) : null;
    const envName = envState ? envState.name : null;

    if (finalBiomeFinish.changed && finalBiomeFinish.added.length > 0) {
      entity.remove(Tags.FinalBiomeResolution);
      const activeEnv = world.findEntity(Tags.ActiveEnvironmentState);

      if (activeEnv) {
        const state = activeEnv.get(Tags.EnvironmentState);
        (0, _resetPlayerPos.setPlayerPos)(world, state.idleViewPoint);
      } // clear previous environment tags


      entity.tagOff(Tags.DirectUserToOrigin);
      entity.tagOff(Tags.CapeMagicalEffect);
      entity.tagOff(Tags.AutoRemoveCapeMagicalEffect);
      entity.tagOff(Tags.WaitingForBiomeResolution);
      entity.tagOff(Tags.ShowBiomeResolution);
      entity.tagOff(Tags.CameraFocusOnTarget);
      entity.tagOff(Tags.MoveUserToOrigin);
      const endEntity = world.entity();
      endEntity.tagOn(Tags.GameLandingCameraDrift);
      endEntity.tagOn(Tags.CameraZoomOut);
      endEntity.tagOn(Tags.BlockTokenCollection);
      endEntity.tagOn(Tags.HideCharacter);
      endEntity.tagOn(Tags.HideHUD);
      endEntity.tagOn(Tags.BlockUserMove);
      endEntity.tagOn(Tags.CameraStopUserMovement);
      endEntity.tagOn(Tags.ModalStoppingUserMovement);
      let e = world.entity().add(Tags.ScreenFade);
      const fade = e.get(Tags.ScreenFade);
      fade.from = 1;
      fade.to = 0;
    }

    if (envStateEvents.changed) {
      entity.remove(Tags.DirectUserToOrigin);
      entity.tagOff(Tags.CapeMagicalEffect);
      entity.tagOff(Tags.AutoRemoveCapeMagicalEffect);
      entity.remove(Tags.WaitingForBiomeResolution);
      entity.remove(Tags.ShowBiomeResolution);
      entity.remove(Tags.CameraFocusOnTarget);
      entity.remove(Tags.MoveUserToOrigin);
      entity.remove(Tags.TriggerTreeTransitionAudio); // entity.remove(Tags.CameraStopUserMovement);

      haikuInventoryView.forEach(e => {
        e.remove(Tags.HaikuInInventory);
      });
      originTrees.forEach(e => {
        const anim = e.get(Tags.SpriteAnimation);
        anim.reset();
      });
      lastEnv = envName; // NOTE: This kills ALL text in the world ! maybe we should place this in env

      allTextView.forEach(e => e.kill());
    }

    const totalForEnv = envState ? envState.haikusTotal : 2;
    const currentInView = haikuInventoryView.length; // console.log(collectedHaikuEvents.changed, collectedHaikuEvents.added);

    if (collectedHaikuEvents.changed) {
      // add each to inventory
      const remaining = Math.max(0, totalForEnv - currentInView);

      for (let i = 0; i < remaining && i < collectedHaikuEvents.added.length; i++) {
        collectedHaikuEvents.added[i].add(Tags.HaikuAddingToInventory);
      }
    }

    haikuAddingToInventoryView.forEach(e => {
      const t = e.get(Tags.HaikuAddingToInventory);
      t.time += dt;

      if (t.time >= t.delay) {
        e.remove(Tags.HaikuAddingToInventory);
        e.add(Tags.HaikuInInventory);
      }
    });

    if (haikuInventoryView.length >= totalForEnv) {
      if (!entity.has(Tags.DirectUserToOrigin)) {
        entity.add(Tags.DirectUserToOrigin);
        autoCapeEffects.forEach(e => {
          const d = e.get(Tags.AutoRemoveCapeMagicalEffect);
          d.elapsed = 0;
          e.remove(Tags.AutoRemoveCapeMagicalEffect);
        });
        entity.add(Tags.CapeMagicalEffect);
        entity.add(Tags.WaitingForBiomeResolution);
      }
    }

    const canResolve = !world.findTag(Tags.IsGameUIActive);
    const isResolving = Boolean(world.findTag(Tags.DirectUserToOrigin));

    if (isResolving && canResolve && cardSavedEvents.added.length && cardSavedEvents.changed && !hasSeenResolveMessage) {
      if (!_queryString.default.resolve) {
        hasSeenResolveMessage = true;
        world.entity().add(Tags.TutorialMessage, {
          id: "resolve",
          message: _locale.localize.get().tutorialResolve,
          iconMode: "tree",
          delay: 0,
          duration: 6
        });
      }
    }

    if (envState && entity.has(Tags.DirectUserToOrigin) && canResolve && entity.has(Tags.WaitingForBiomeResolution)) {
      // we are ready to resolve the biome
      const user = world.findTag(Tags.UserCharacter).position;
      const threshold = 20;
      const thresholdSq = threshold * threshold;
      const distSq = user.lengthSq();

      if (distSq < thresholdSq) {
        (0, _AnimationSystem.tweenFromTo)(world, envState, "solved", 0, 1, 4, "sineInOut", 0);
        entity.remove(Tags.WaitingForBiomeResolution);
        entity.add(Tags.CameraFocusOnTarget);
        entity.add(Tags.MoveUserToOrigin);
        entity.add(Tags.ShowBiomeResolution);
        entity.tagOff(Tags.CapeMagicalEffect);
        entity.tagOff(Tags.AutoRemoveCapeMagicalEffect);

        if (envName === "tundra") {
          animatingOutChar = true;
          entity.add(Tags.FinalBiomeResolution);
        } // entity.add(Tags.CameraStopUserMovement);


        const camFocus = entity.get(Tags.CameraFocusOnTarget);
        camFocus.target.set(0, 4, 0); // haikuInventoryView.forEach((e) => {
        //   e.remove(Tags.HaikuInInventory);
        // });

        isAboutToTransition = true;
        isAboutToAnimate = true;
        animateTime = 0;
        transitionTime = 0; // addTextHints(envName);
      }
    }

    if (isAboutToAnimate) {
      animateTime += dt;
      const delay = envName === "tundra" ? tundraAnimateDelay : animateDelay;

      if (animateTime >= delay) {
        isAboutToAnimate = false; // entity.add(Tags.UserHitAudioTrigger);
        // const t = entity.get(Tags.UserHitAudioTrigger);
        // t.type = "origin_tree";

        originTrees.forEach(e => {
          const anim = e.get(Tags.SpriteAnimation);
          anim.start();
        });
        entity.add(Tags.TriggerTreeTransitionAudio);
      }
    }

    if (isAboutToTransition) {
      transitionTime += dt;

      if (animatingOutChar && transitionTime >= animOutCharDelay) {
        animatingOutChar = false;
        entity.add(Tags.AnimateOutCharacter);
      }

      const delay = envName === "tundra" ? tundraTransitionDelay : transitionDelay;

      if (transitionTime >= delay) {
        isAboutToTransition = false;
        haikuInventoryView.forEach(e => {
          e.remove(Tags.HaikuInInventory);
        });

        if (envName === "tundra") {
          // const endEntity = world
          //   .entity()
          //   .add(Tags.ViewLayer, {
          //     id: "end-state",
          //     component: EndStateOverlay,
          //     props: {
          //       onIntroEnd() {
          //         // world.findTag(Tags.AppState).running = false;
          //       },
          //     },
          //   })
          //   .add(Tags.EndGameState);
          const endEntity = world.entity();
          endEntity.add(Tags.EndGameState);
          let e = world.entity().add(Tags.ScreenFade);
          const fade = e.get(Tags.ScreenFade);
          fade.from = 0;
          fade.to = 1;

          fade.callbackOnFinish = () => {
            endEntity.add(Tags.ResetToCameraDrift);
            endEntity.add(Tags.OutroFinished); // store.update((d) => ({ ...d, ...opts, state }));
          };

          (0, _nfb.sendAnalytics)({
            event: "completed",
            eventLabel: "end"
          });
        } else {
          entity.add(Tags.TransitionToNextBiome);
        }
      }
    }
  };

  function addTextHints(biome) {
    addText({
      forest: "below the old wood trees",
      grasslands: "below the old wood trees",
      tundra: "below the old wood trees"
    }[biome], -10, 3, -5, 1);
    addText("forgotten memories made whole", -8, 3, -3.5, 2.5);
  }

  function addText(text, x, y, z, delay = 0) {
    const e = world.entity();
    e.add(Tags.TextHint);
    const t = e.get(Tags.TextHint);
    t.text = text;
    t.position.set(x, y, z);
    t.killing = true;
    t.duration = 15;
    t.delay = delay;
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/locale":"src/util/locale.js","../util/haikugen":"src/util/haikugen.js","./AnimationSystem":"src/systems/AnimationSystem.js","../util/query-string":"src/util/query-string.js","../util/tokens":"src/util/tokens.js","../util/Random":"src/util/Random.js","../util/resetPlayerPos":"src/util/resetPlayerPos.js","../nfb":"src/nfb.js"}],"src/systems/StanzaLineSpawningGrowthSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = StanzaLineSpawningGrowthSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _materials = require("../util/materials");

var _EditorWayfinderSprite = require("../util/EditorWayfinderSprite");

var _load = require("../util/load");

var _AnimationSystem = require("./AnimationSystem");

var _Random = _interopRequireDefault(require("../util/Random"));

var _Assets = _interopRequireDefault(require("../util/Assets"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import grassUrl1 from "../assets/textures/grass/GRASSLAND-FLOWER-1.png";
// import grassUrl2 from "../assets/textures/grass/GRASSLAND-FLOWER-2.png";
// import grassUrl3 from "../assets/textures/grass/GRASSLAND-FLOWER-white-1.png";
// import grassUrl4 from "../assets/textures/grass/GRASSLAND-FLOWER-white-2.png";
function StanzaLineSpawningGrowthSystem(world) {
  const random = (0, _Random.default)();
  const ids = ["GRASSLAND-FLOWER-1", "GRASSLAND-FLOWER-2", "GRASSLAND-FLOWER-white-1", "GRASSLAND-FLOWER-white-2"].map(id => {
    return `image/stanza-spawn/${id}`;
  });
  const renderer = world.findTag(Tags.Renderer);
  const textures = ids.map(id => {
    const [tex] = _Assets.default.createGPUTextureTask(renderer, id);

    return tex;
  });
  const assetView = world.view(Tags.StanzaLineSpawningAsset);
  const assetEvents = world.listen(Tags.StanzaLineSpawningAsset);
  return function stanzaLineGrowthSystem(dt) {
    assetEvents.added.forEach(e => {
      const assetData = e.get(Tags.StanzaLineSpawningAsset);
      const height = random.gaussian(1, 1 / 4);
      const tex = random.pick(textures);

      if (tex && tex.image && tex.image.width > 0 && tex.image.height > 0) {
        const sprite = (0, _EditorWayfinderSprite.createSprite)(world, tex, height);
        sprite.position.set(assetData.x, 0, assetData.z);
        sprite.scale.y = 0;
        e.add(Tags.Object3D, sprite).add(Tags.ShaderUniformTime, {
          uniform: sprite.material.uniforms.time
        }).add(Tags.ShadowCaster, {
          sprite: true
        });
        (0, _AnimationSystem.tweenFromTo)(world, sprite.scale, "y", 0, height, 1, "sineOut", random.range(0, 1));
      }
    });
    assetView.forEach(e => {
      if (e.has(Tags.Object3D)) {
        const sprite = e.get(Tags.Object3D);
        const map = sprite.material.uniforms.map.value;
        const aspect = map.image.width / map.image.height;
        const height = sprite.scale.y;
        const width = height * aspect;
        sprite.scale.x = width;
      }
    });
  };
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/materials":"src/util/materials.js","../util/EditorWayfinderSprite":"src/util/EditorWayfinderSprite.js","../util/load":"src/util/load.js","./AnimationSystem":"src/systems/AnimationSystem.js","../util/Random":"src/util/Random.js","../util/Assets":"src/util/Assets.js"}],"src/systems/WaterCollectionSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = WaterCollectionSystem;

var MathUtil = _interopRequireWildcard(require("../util/math"));

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _ObjectPool = _interopRequireDefault(require("../util/ObjectPool"));

var _Random = _interopRequireDefault(require("../util/Random"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
Skim the water to get water bubbles on your cape/character
Then you can collect a token

Carry snow flakes behind you into melting areas
*/
function WaterCollectionSystem(world) {
  const underPlayer = world.findTag(Tags.EnvironmentUnderPlayerState);
  const waterCarryEntity = world.entity();
  const random = (0, _Random.default)();
  const sphere0 = new THREE.SphereBufferGeometry(1, 8, 8);
  const sphere1 = new THREE.SphereBufferGeometry(1, 8, 8);
  sphere1.scale(1, 0.75, 1);
  const baseColor = new THREE.Color("#3ea7e0");
  const material = new THREE.MeshBasicMaterial({// blending: THREE.AdditiveBlending,
  });
  const waterMesh = new THREE.Mesh(sphere0, material);
  const pool = new _ObjectPool.default({
    maxCapacity: 100,
    initialCapacity: 50,

    create() {
      const m = waterMesh.clone();
      m.geometry = random.boolean() ? sphere0 : sphere1;
      m.material = material.clone();
      m.userData.velocity = new THREE.Vector3();
      m.material.color.copy(baseColor);
      m.material.color.offsetHSL(random.range(-1, 1) * 0.0, random.range(-1, 1) * 0.0, random.range(-1, 1) * 0.1);
      m.material.color.multiplyScalar(random.range(0.2, 1));
      const bloom = 1;
      m.material.color.r += bloom;
      m.material.color.g += bloom;
      m.material.color.b += bloom;
      m.userData.time = 0;
      m.userData.scale = 1;
      m.userData.duration = 1;
      m.userData.delay = 1;
      m.userData.speed = 1;
      m.visible = false;
      return m;
    },

    renew(m) {
      m.visible = true;
    },

    release(m) {}

  });

  const newSpawnDelay = () => random.range(0.1, 0.2);

  let spawnDelay = newSpawnDelay();
  let spawnTime = random.range(0, spawnDelay);
  const tmpArr2D = [0, 0];
  const tmpArr4D = [0, 0, 0, 0];
  const activeMeshes = world.view(Tags.WaterFollowParticle);

  const newCooldownDelay = () => random.range(1, 2);

  let hitCooldownDelay = newCooldownDelay();
  let hitCooldownTime = 0;
  const activeEnv = world.view([Tags.EnvironmentState, Tags.ActiveEnvironmentState]);
  const hitSoundEntity = world.entity();
  const particleEmitters = world.view(Tags.ParticleEmit);
  let lastPos = null;
  const soundThreshold = 2;
  const soundThresholdSq = soundThreshold * soundThreshold;
  return function waterCollectSystem(dt) {
    if (underPlayer.water && !waterCarryEntity.has(Tags.UserCarryingTokenCollectionFeature)) {
      waterCarryEntity.add(Tags.UserCarryingTokenCollectionFeature);
    }

    const userCharData = world.findTag(Tags.UserCharacter);
    const userVelocity = userCharData.velocity;
    const userPos = userCharData.position;
    const hasMovedFarEnough = !lastPos || userPos.distanceToSquared(lastPos) >= soundThresholdSq;

    if (hitSoundEntity.has(Tags.UserHitAudioTrigger)) {
      hitCooldownTime += dt;

      if (hitCooldownTime >= hitCooldownDelay) {
        hitCooldownTime %= hitCooldownDelay;
        hitCooldownDelay = newCooldownDelay();
        hitSoundEntity.remove(Tags.UserHitAudioTrigger);
      }
    }

    const showWater = underPlayer.water;
    const showEffect = particleEmitters.length > 0;

    if (showWater) {
      spawnTime += dt;

      if (spawnTime >= spawnDelay) {
        spawnTime %= spawnDelay;
        spawnDelay = newSpawnDelay();
        const n = random.rangeFloor(1, 5);

        for (let i = 0; i < n; i++) {
          if (!spawnOne(userPos, userVelocity)) break;
        }
      }

      if (hasMovedFarEnough && showWater && !hitSoundEntity.has(Tags.UserHitAudioTrigger)) {
        if (!lastPos) {
          lastPos = new THREE.Vector3();
        }

        lastPos.copy(userPos);
        hitSoundEntity.add(Tags.UserHitAudioTrigger);
        const audioData = hitSoundEntity.get(Tags.UserHitAudioTrigger);
        const hasIce = activeEnv.length ? activeEnv[0].get(Tags.EnvironmentState).name === "tundra" : false;
        audioData.type = hasIce ? "ice" : "water";
      }
    } else if (showEffect) {
      spawnTime += dt;

      if (spawnTime >= spawnDelay) {
        spawnTime %= spawnDelay;
        spawnDelay = newSpawnDelay();

        outer: for (let i = 0; i < particleEmitters.length; i++) {
          const e = particleEmitters[i];
          const pos = e.get(Tags.ParticleEmit).position;
          const n = random.rangeFloor(1, 5);

          for (let i = 0; i < n; i++) {
            if (!spawnOne(userPos, userVelocity, true)) break outer;
          }
        }
      }
    }

    particleEmitters.forEach(e => {
      const p = e.get(Tags.ParticleEmit);
      p.elapsed += dt;

      if (p.elapsed >= p.duration) {
        e.tagOff(Tags.ParticleEmit);
      }
    });
    activeMeshes.forEach(e => {
      const m = e.get(Tags.Object3D);
      m.userData.time += dt;
      const curTime = m.userData.time - m.userData.delay;

      if (!m.visible && curTime >= 0) {
        m.visible = true;
      }

      const curElapsed = Math.max(0, curTime);
      const curAlpha = MathUtil.clamp01(curElapsed / m.userData.duration);
      const scl = Math.max(1e-5, Math.sin(curAlpha * Math.PI));
      m.scale.setScalar(m.userData.scale * scl);
      m.position.addScaledVector(m.userData.velocity, m.userData.speed);
      m.position.y += dt;

      if (curElapsed >= m.userData.duration) {
        m.visible = false;
        e.kill();
        m.userData._entity = null;
        pool.release(m);
      }
    });
  };

  function spawnOne(userPos, userVelocity, big) {
    const m = pool.next();
    if (!m) return false;
    m.userData._entity = world.entity().add(Tags.WaterFollowParticle).add(Tags.Object3D, m);
    m.userData.velocity.copy(userVelocity);
    m.quaternion.fromArray(random.quaternion(tmpArr4D));
    m.position.copy(userPos);
    random.insideCircle(random.range(1, 2), tmpArr2D);
    m.position.x += tmpArr2D[0];
    m.position.z += tmpArr2D[1];
    m.position.y = random.range(0.01, 0.25);
    m.visible = false;
    m.userData.scale = (big ? 0.6 : 0.4) * random.gaussian(0.1, 0.1 / 3);
    m.userData.time = 0;
    m.userData.delay = random.range(0, 0.5);
    m.userData.speed = random.range(0.05, 0.5);
    m.userData.duration = random.range(1, 1.5);
    return m;
  }
}
},{"../util/math":"src/util/math.js","../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/ObjectPool":"src/util/ObjectPool.js","../util/Random":"src/util/Random.js"}],"src/systems/DevTutorialSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = DevTutorialSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _Random = _interopRequireDefault(require("../util/Random"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*

A simple system that shows off the basic ECS approach.
Each interval, a square emits from the character and floats up,
until it dies away.

*/
// Set up a new tag/data/value
// Usually this would be in "tags.js" but you can also just
// keep it entirely within your system if you want
class MyFloatingBox extends Tags.Data {
  static data = {
    speed: Tags.Types.Ref(1)
  };
} // Systems are functions that accept a 'world' fragment
// make sure you name this function when you create a new system


function DevTutorialSystem(world) {
  let time = 0;
  let delay = 1;
  const material = new THREE.MeshBasicMaterial();
  const geometry = new THREE.BoxGeometry(1, 1, 1);
  const random = (0, _Random.default)(); // query a view of the particles

  const view = world.view([Tags.Object3D, MyFloatingBox]); // we can also listen for events
  // these aren't callbacks (which happen immediately) but deferred until
  // this tick, so that everything still happens in a linear way in order of system execution

  const events = world.listen(MyFloatingBox); // the return value of a system is a function that
  // is called on each tick

  return dt => {
    // Do something every N ms
    time += dt;

    if (time >= delay) {
      time %= delay; // trigger a new entity

      spawn();
    } // A list of matching entities that have been added since last frame


    events.added.forEach(e => {
      // for example, you could 'init' a mesh now that you know
      // it's about to be rendered
      console.log("Box initialized");
    }); // Update all currenly active entities
    // a view is an array reference into a list of
    // Entities that match your query, and they are updated
    // once before each tick of this system

    view.forEach(e => {
      const mesh = e.get(Tags.Object3D);
      const body = e.get(MyFloatingBox);
      mesh.position.y += body.speed * dt; // kill the entity if it's too high,
      // once it's fully processed (after this frame)
      // it will be removed from the view

      if (mesh.position.y > 5) {
        e.kill();
      }
    }); // This is a list of entities that are waiting to be removed

    events.removing.forEach(e => {
      // for example, you could dispose of things here
      // like geometry/textures if needed
      console.log("Removing box");
    });
  }; // Triggers a new entity in the world

  function spawn() {
    // You can use findTag to get singleton tags (i.e. we only expect 1 of this in the world)
    const user = world.findTag(Tags.UserCharacter);
    const position = user.position; // Usually you would use ObjectPool or similar instead of creating new meshes

    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.copy(position);
    mesh.quaternion.fromArray(random.quaternion()); // create the entity, this will just give us an inactive one from our entity pool

    const e = world.entity(); // now add tags to it, Object3D will cause its value (mesh) to be added to the scene

    e.add(Tags.Object3D, mesh); // let's give each particle a different speed

    const speed = random.range(1, 2);
    e.add(MyFloatingBox, {
      speed
    });
    /*
    ^^ note: Also usually I avoid the { } pattern as it creates a new object (i.e. GC thrashing)
       you often will see this instead:
            e.add(MyFlatingBoxTag); // make sure tag exists
          const data = e.get(MyFloatingBox); // get the tag data
          data.speed = speed; // assign your data
         This is better as it will create zero new allocations.
    */
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/Random":"src/util/Random.js"}],"src/util/SpriteAnimation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _three = require("three");

function NOOP() {}

const vs = `
#include <common>
varying vec2 vUv;
uniform bool uLeft;
uniform float uRotation;

void main() {


  // vec3 centerWorldPos = (modelMatrix * vec4(vec3(0.0), 1.0)).xyz;
  // vec3 camRightWorld = vec3(viewMatrix[0].x, viewMatrix[1].x, viewMatrix[2].x);
  // vec3 camUpWorld = vec3(viewMatrix[0].y, viewMatrix[1].y, viewMatrix[2].y);

  // vec2 scale;
  // scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
  // scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
  
  // vec3 vertexWorldPos = centerWorldPos
  //   + camRightWorld * position.x * scale.x
  //   + camUpWorld * position.y * scale.y;

  vec2 center = vec2(0.5);
  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
  if (uLeft) scale.x *= -1.0;

  vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

  vec2 rotatedPosition;
  float rot = uRotation * (uLeft ? -1.0 : 1.0);
  rotatedPosition.x = cos( rot ) * alignedPosition.x - sin( rot ) * alignedPosition.y;
  rotatedPosition.y = sin( rot ) * alignedPosition.x + cos( rot ) * alignedPosition.y;

  mvPosition.xy += rotatedPosition;

  gl_Position = projectionMatrix * mvPosition;
  vUv = uv;
  // if (uLeft) vUv.x = 1.0 - vUv.x;
}
`;
const fs = `
uniform sampler2D tSprite;

uniform vec2 uSize;
uniform vec2 uOffset;

varying vec2 vUv;

void main() {

  // get single sprite UV
  vec2 newUV = vUv * uSize;
  newUV += uOffset;
  newUV.y -= uSize.y;

  vec4 spriteColor = texture2D(tSprite, newUV);

  if ( spriteColor.a < 0.5 ) discard;

  gl_FragColor = vec4(spriteColor.rgb, spriteColor.a);
}
`;
const texLoader = new _three.TextureLoader();

class SpriteAnimation {
  /**
   * @param {JSON} data - data from texture packer
   * @param {String} spriteURL - spritesheet url
   * @param {Object} opts
   *   @param {Number} framerate
   *   @param {Boolean} loop
   *   @param {Array} skipFrames
   */
  constructor(data, spriteURL, opts) {
    this.data = data;
    this.spriteURL = spriteURL;
    this.texture = null;
    this.isLoaded = false;
    this.isPlaying = true;
    this.elapsed = 0;
    this.framerate = opts && opts.framerate || 1 / 12;
    this.loop = opts && opts.loop || true;
    this.skipFrames = opts && opts.skipFrames || [];
    this.currentFrame = 0;
    this.currentFrameData = this.data.frames[0];
    this.material = null;
    window.addEventListener("keyup", () => {// this.update(0.16);
      // console.log(this.currentFrame)
    });
  }

  async load() {
    return new Promise((resolve, reject) => {
      texLoader.load( // url
      this.spriteURL, // success
      texture => {
        this.texture = texture;
        this.onLoaded();
        resolve();
      }, // progress
      NOOP, // error
      evt => {
        reject(evt);
      });
    });
  }

  onLoaded() {
    this.isLoaded = true;
    this.material = this.makeMaterial();
  }

  play() {
    this.isPlaying = true;
  }

  pause() {
    this.isPlaying = false;
  }

  stop() {
    this.pause();
    this.currentFrame = 0;
  }

  gotoFrame(frame) {
    this.currentFrame = frame;
  }

  update(dt) {
    // if (!this.isLoaded || !this.isPlaying) return
    if (!this.isPlaying) return;
    let hasUpdated = false;
    this.elapsed += dt;
    const totalFrames = this.data.frames.length;
    const endFrame = this.loop && this.loopEnd ? this.loopEnd : totalFrames - 1;

    if (this.elapsed >= this.framerate) {
      this.elapsed = 0;
      this.currentFrame++;
      hasUpdated = true;
      if (this.isFrameValid(this.currentFrame)) this.currentFrameData = this.data.frames[this.currentFrame];
    }

    if (this.currentFrame >= endFrame && this.loop) {
      this.currentFrame = this.loopStart ? this.loopStart : 0;
      this.currentFrameData = this.data.frames[this.currentFrame];
    }

    this.currentFrame = Math.max(0, Math.min(this.currentFrame, totalFrames));
    const data = this.data;
    const currentFrameData = this.currentFrameData;

    if (currentFrameData && this.currentFrame != 0) {
      this.material.uniforms.uSize.value.x = currentFrameData.sourceSize.w / data.meta.size.w;
      this.material.uniforms.uSize.value.y = currentFrameData.sourceSize.h / data.meta.size.h;
      this.material.uniforms.uOffset.value.x = currentFrameData.frame.x / data.meta.size.w;
      this.material.uniforms.uOffset.value.y = 1 - currentFrameData.frame.y / data.meta.size.h;
    } // console.log(this.currentFrame,currentFrameData)
    // console.log(this.material.uniforms.uOffset.value.x, this.material.uniforms.uOffset.value.y)


    return hasUpdated;
  }

  isFrameValid(frameIdx) {
    let res = true;

    for (let i = 0; i < this.skipFrames.length; i++) {
      if (this.skipFrames[i] == frameIdx) res = false;
    }

    return res;
  }

  makeMaterial() {
    this.texture.minFilter = _three.LinearFilter;
    this.texture.magFilter = _three.LinearFilter;
    const m = new _three.ShaderMaterial({
      uniforms: {
        tSprite: {
          value: this.texture
        },
        uSize: {
          value: new _three.Vector2()
        },
        uOffset: {
          value: new _three.Vector2()
        },
        uFlip: {
          value: 0
        },
        uRotation: {
          value: 0
        },
        uLeft: {
          value: true,
          type: "i"
        }
      },
      side: _three.DoubleSide,
      vertexShader: vs,
      fragmentShader: fs // transparent: true,
      // depthTest: false,
      // depthWrite: false,

    });
    this.material = m;
    return m;
  }

  getMaterial() {
    return this.material;
  }

}

var _default = SpriteAnimation;
exports.default = _default;
},{"three":"src/vendor/three.module.js"}],"src/assets/spritesheets/bird_fly.sheet.json":[function(require,module,exports) {
module.exports = module.exports = {
  frames: [{
    filename: "BIRD_FLY_1_0000.png",
    frame: {
      x: 1,
      y: 1,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0001.png",
    frame: {
      x: 166,
      y: 1,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0002.png",
    frame: {
      x: 331,
      y: 1,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0003.png",
    frame: {
      x: 1,
      y: 166,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0004.png",
    frame: {
      x: 166,
      y: 166,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0005.png",
    frame: {
      x: 331,
      y: 166,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0006.png",
    frame: {
      x: 1,
      y: 331,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0007.png",
    frame: {
      x: 166,
      y: 331,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0008.png",
    frame: {
      x: 331,
      y: 331,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0009.png",
    frame: {
      x: 1,
      y: 496,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0010.png",
    frame: {
      x: 166,
      y: 496,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0011.png",
    frame: {
      x: 166,
      y: 1,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0012.png",
    frame: {
      x: 331,
      y: 1,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0013.png",
    frame: {
      x: 331,
      y: 496,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0014.png",
    frame: {
      x: 1,
      y: 661,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0015.png",
    frame: {
      x: 166,
      y: 661,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0016.png",
    frame: {
      x: 331,
      y: 661,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0017.png",
    frame: {
      x: 166,
      y: 331,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0018.png",
    frame: {
      x: 331,
      y: 331,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0019.png",
    frame: {
      x: 1,
      y: 496,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }, {
    filename: "BIRD_FLY_1_0020.png",
    frame: {
      x: 1,
      y: 1,
      w: 163,
      h: 163
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 163,
      h: 163
    },
    sourceSize: {
      w: 163,
      h: 163
    }
  }],
  meta: {
    app: "https://www.codeandweb.com/texturepacker",
    version: "1.0",
    image: "bird-fly.png",
    format: "RGBA8888",
    size: {
      w: 495,
      h: 825
    },
    scale: "0.25",
    smartupdate: "$TexturePacker:SmartUpdate:f0f421fcb3358c8b88a64ecc25121c3b:72b4781501fa14a996a7799bb788d834:7c301bb00a7c24e9cfe7ed7518c7859d$"
  }
};
;
},{}],"src/systems/BirdFlyingSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = BirdFlyingSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _bird_fly = _interopRequireDefault(require("../assets/spritesheets/bird_fly.png"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _SpriteAnimation = _interopRequireDefault(require("../util/SpriteAnimation"));

var _bird_fly2 = _interopRequireDefault(require("../assets/spritesheets/bird_fly.sheet"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NOOP = () => {};

const texLoader = new THREE.TextureLoader();
/*

A simple system that shows off the basic ECS approach.
Each interval, a square emits from the character and floats up,
until it dies away.

*/
// Set up a new tag/data/value
// Usually this would be in "tags.js" but you can also just
// keep it entirely within your system if you want

class FlyingBird extends Tags.Data {
  static data = {
    // constant time increase
    time: Tags.Types.Ref(0),
    // animate from zero to 1.0 initially
    animateInDuration: Tags.Types.Ref(0.25),
    // how big to make it
    size: Tags.Types.Ref(0.6),
    animation: Tags.Types.Ref(null),
    left: Tags.Types.Ref(false),
    speed: Tags.Types.Ref(1),
    velocity: Tags.Types.Vector3()
  };
} // Systems are functions that accept a 'world' fragment
// make sure you name this function when you create a new system


async function BirdFlyingSystem(world) {
  // const lat = MathUtil.degToRad(45);
  // const long = MathUtil.degToRad(90);
  // const velocityLeft = new THREE.Vector3(-0.25, 0, -0.25);
  // const velocityRight = new THREE.Vector3(0.25, 0, -0.25);
  // const velocityLeft = MathUtil.sphericalToCartesian(lat, long);
  // const velocityRight = velocityLeft;
  // const velocityRight = new THREE.Vector3(0.25, 0, -0.25);
  const flyingTexture = await loadTexture(_bird_fly.default); // const material = anim.getMaterial()
  // const spriteSizeW = anim.currentFrameData.sourceSize.w
  // const spriteSizeH = anim.currentFrameData.sourceSize.h

  const geometry = new THREE.PlaneBufferGeometry(1, 1);
  const random = (0, _Random.default)(); // query a view of the particles

  const view = world.view([Tags.Object3D, FlyingBird]); // we can also listen for events
  // these aren't callbacks (which happen immediately) but deferred until
  // this tick, so that everything still happens in a linear way in order of system execution

  const events = world.listen(FlyingBird); // listen for events on sprite-hit trigger (@Matt TODO: make this not specific to audio triggers...)

  const treeEvents = world.listen([Tags.Object3D, Tags.UserHitAudioTrigger]);
  const tmpPos3 = new THREE.Vector3();
  const tmpBox = new THREE.Box3();
  let gameTime = 0;
  let lastBirdTime = null;
  let birdThrottle = 2; // no more than 1 bird every N seconds

  let maxBirdsOnScreen = 4; // no more than N active entities
  // the return value of a system is a function that
  // is called on each tick

  return function birdFlyingSystem(dt) {
    const camera = world.findTag(Tags.MainCamera);
    const frustum = world.findTag(Tags.MainCameraFrustum); // small thing here - it's a bit visually distracting to have
    // birds spawn at the same moment that the user is resolving / writing
    // so we can ignore spawn when some tags are present

    const ignoreSpawn = Boolean(world.findTag(Tags.ShowBiomeResolution) || world.findTag(Tags.WrittenStanzaLineActive) || world.findTag(Tags.HaikuAddingToInventory));
    gameTime += dt; // Here we spawn new entities

    treeEvents.added.forEach(e => {
      if (ignoreSpawn) return;
      const type = e.get(Tags.UserHitAudioTrigger).type;
      const moreToSpawn = view.length < maxBirdsOnScreen;
      const spawnThrottle = lastBirdTime == null || gameTime - lastBirdTime >= birdThrottle;

      if (type === "tree" && random.chance(0.5) && moreToSpawn && spawnThrottle) {
        const obj = e.get(Tags.Object3D);
        tmpPos3.copy(obj.position); // part way up the tree?

        const offset = Math.min(obj.scale.y, random.range(4, 5));
        tmpPos3.y += offset;
        spawn(camera, tmpPos3);
        lastBirdTime = gameTime;
      }
    }); // Here we update all spawned entities
    // This way we can have multiple birds on screen at once with different
    // values (i.e. different frames of their animation)

    view.forEach(e => {
      const d = e.get(FlyingBird);
      const speed = d.speed;
      const mesh = e.get(Tags.Object3D);
      const material = mesh.material;
      d.animation.update(dt);
      d.time += dt; // size to animate it in

      const t = MathUtil.clamp01(d.time / d.animateInDuration);
      mesh.scale.setScalar(t * d.size); // always update this mesh position?

      mesh.position.addScaledVector(d.velocity, dt * speed);
      material.uniforms.uLeft.value = d.left;
      material.uniforms.uRotation.value = MathUtil.degToRad(0);
      tmpBox.setFromObject(mesh);

      if (!frustum.intersectsBox(tmpBox)) {
        // kill the bird once it's out of frame
        e.kill();
      }
    });
  }; // Triggers a new entity in the world

  function spawn(camera, position) {
    const flyingAnim = new _SpriteAnimation.default(_bird_fly2.default, null);
    flyingAnim.texture = flyingTexture;
    flyingAnim.makeMaterial();
    const material = flyingAnim.getMaterial();
    const mesh = new THREE.Mesh(geometry, flyingAnim.getMaterial());
    mesh.position.copy(position); // create the entity, this will just give us an inactive one from our entity pool

    const e = world.entity(); // now add tags to it, Object3D will cause its value (mesh) to be added to the scene

    e.add(Tags.Object3D, mesh);
    e.add(Tags.AnimalSound, "birdChirp"); // can give each particle a different speed

    const speed = 7; //random.range(6, 8);

    e.add(FlyingBird);
    const d = e.get(FlyingBird);
    const left = random.boolean();
    d.animation = flyingAnim;
    d.velocity.set(left ? -0.5 : 0.5, 0.25, -0.5).normalize(); // uncomment to visualize the flight direction in world space
    // const helper = new THREE.ArrowHelper(
    //   d.velocity,
    //   new THREE.Vector3(),
    //   4,
    //   "red",
    //   2,
    //   1
    // );
    // helper.position.copy(position);
    // world.entity().add(Tags.Object3D, helper);

    d.left = left;
    d.size = 2;
    d.speed = speed;
  }

  async function loadTexture(url) {
    return new Promise((resolve, reject) => {
      texLoader.load(url, // ok
      texture => {
        resolve(texture);
      }, // progress
      NOOP, // ko
      evt => {
        reject(evt);
      });
    });
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/Random":"src/util/Random.js","../assets/spritesheets/bird_fly.png":"src/assets/spritesheets/bird_fly.png","../util/math":"src/util/math.js","../util/SpriteAnimation":"src/util/SpriteAnimation.js","../assets/spritesheets/bird_fly.sheet":"src/assets/spritesheets/bird_fly.sheet.json"}],"src/assets/spritesheets/bird_still.sheet.json":[function(require,module,exports) {
module.exports = module.exports = {
  frames: [{
    filename: "BIRD-STILL-0000.png",
    frame: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0001.png",
    frame: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0002.png",
    frame: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0003.png",
    frame: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0004.png",
    frame: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0005.png",
    frame: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0006.png",
    frame: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0007.png",
    frame: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0008.png",
    frame: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0009.png",
    frame: {
      x: 0,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0010.png",
    frame: {
      x: 0,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0011.png",
    frame: {
      x: 0,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0012.png",
    frame: {
      x: 0,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0013.png",
    frame: {
      x: 0,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0014.png",
    frame: {
      x: 0,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0015.png",
    frame: {
      x: 0,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0016.png",
    frame: {
      x: 0,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0017.png",
    frame: {
      x: 0,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0018.png",
    frame: {
      x: 0,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0019.png",
    frame: {
      x: 0,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0020.png",
    frame: {
      x: 160,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0021.png",
    frame: {
      x: 160,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0022.png",
    frame: {
      x: 160,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0023.png",
    frame: {
      x: 160,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0024.png",
    frame: {
      x: 160,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0025.png",
    frame: {
      x: 160,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0026.png",
    frame: {
      x: 160,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0027.png",
    frame: {
      x: 160,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0028.png",
    frame: {
      x: 160,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0029.png",
    frame: {
      x: 160,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0030.png",
    frame: {
      x: 160,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0031.png",
    frame: {
      x: 160,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0032.png",
    frame: {
      x: 160,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0033.png",
    frame: {
      x: 160,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0034.png",
    frame: {
      x: 160,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0035.png",
    frame: {
      x: 320,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0036.png",
    frame: {
      x: 320,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0037.png",
    frame: {
      x: 320,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0038.png",
    frame: {
      x: 320,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0039.png",
    frame: {
      x: 320,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0040.png",
    frame: {
      x: 320,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0041.png",
    frame: {
      x: 320,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0042.png",
    frame: {
      x: 320,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0043.png",
    frame: {
      x: 0,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0044.png",
    frame: {
      x: 0,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0045.png",
    frame: {
      x: 0,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0046.png",
    frame: {
      x: 0,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0047.png",
    frame: {
      x: 0,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0048.png",
    frame: {
      x: 0,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0049.png",
    frame: {
      x: 0,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0050.png",
    frame: {
      x: 320,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0051.png",
    frame: {
      x: 320,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0052.png",
    frame: {
      x: 320,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0053.png",
    frame: {
      x: 320,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0054.png",
    frame: {
      x: 480,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0055.png",
    frame: {
      x: 480,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0056.png",
    frame: {
      x: 480,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0057.png",
    frame: {
      x: 480,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0058.png",
    frame: {
      x: 480,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0059.png",
    frame: {
      x: 480,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0060.png",
    frame: {
      x: 480,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0061.png",
    frame: {
      x: 480,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0062.png",
    frame: {
      x: 480,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0063.png",
    frame: {
      x: 480,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0064.png",
    frame: {
      x: 480,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0065.png",
    frame: {
      x: 480,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0066.png",
    frame: {
      x: 640,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0067.png",
    frame: {
      x: 800,
      y: 0,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0068.png",
    frame: {
      x: 640,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0069.png",
    frame: {
      x: 320,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0070.png",
    frame: {
      x: 320,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0071.png",
    frame: {
      x: 320,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0072.png",
    frame: {
      x: 640,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0073.png",
    frame: {
      x: 640,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0074.png",
    frame: {
      x: 640,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0075.png",
    frame: {
      x: 640,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0076.png",
    frame: {
      x: 640,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0077.png",
    frame: {
      x: 640,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0078.png",
    frame: {
      x: 640,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0079.png",
    frame: {
      x: 640,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0080.png",
    frame: {
      x: 640,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0081.png",
    frame: {
      x: 640,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0082.png",
    frame: {
      x: 640,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0083.png",
    frame: {
      x: 640,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0084.png",
    frame: {
      x: 640,
      y: 300,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0085.png",
    frame: {
      x: 800,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0086.png",
    frame: {
      x: 800,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0087.png",
    frame: {
      x: 800,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }, {
    filename: "BIRD-STILL-0088.png",
    frame: {
      x: 800,
      y: 150,
      w: 160,
      h: 150
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 160,
      h: 150
    },
    sourceSize: {
      w: 160,
      h: 150
    }
  }],
  meta: {
    app: "https://www.codeandweb.com/texturepacker",
    version: "1.0",
    image: "bird_still.png",
    format: "RGBA8888",
    size: {
      w: 960,
      h: 450
    },
    scale: "1",
    smartupdate: "$TexturePacker:SmartUpdate:1c195fab3f9fa70597046d6840707ff0:134ce8759e0ad3bea10d9e63432d9745:851287a48f709fb1b9488bdebbcefbcb$"
  }
};
;
},{}],"src/systems/GroundBirdsSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = GroundBirdSystem;

var MathUtil = _interopRequireWildcard(require("../util/math"));

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _bird_still = _interopRequireDefault(require("../assets/spritesheets/bird_still.png"));

var _bird_fly = _interopRequireDefault(require("../assets/spritesheets/bird_fly.png"));

var _SpriteAnimation = _interopRequireDefault(require("../util/SpriteAnimation"));

var _waterUtil = require("../util/water-util");

var _bird_still2 = _interopRequireDefault(require("../assets/spritesheets/bird_still.sheet"));

var _bird_fly2 = _interopRequireDefault(require("../assets/spritesheets/bird_fly.sheet"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NOOP = () => {};

const texLoader = new THREE.TextureLoader();
/*

A simple system that shows off the basic ECS approach.
Each interval, a square emits from the character and floats up,
until it dies away.

*/
// enum GroundBirdStates {
//   IDLE,
//   FLYING
// }
// Set up a new tag/data/value
// Usually this would be in "tags.js" but you can also just
// keep it entirely within your system if you want

class GroundBird extends Tags.Data {
  static data = {
    time: Tags.Types.Ref(0),
    size: Tags.Types.Ref(1.4),
    animateInDuration: Tags.Types.Ref(0.25),
    duration: Tags.Types.Ref(5),
    speed: Tags.Types.Ref(7),
    left: Tags.Types.Ref(true),
    state: Tags.Types.Ref("idle"),
    // idle || flying
    idleAnimation: Tags.Types.Ref(null),
    flyingAnimation: Tags.Types.Ref(null),
    velocity: Tags.Types.Vector3(0, 0, 0)
  };
} // Systems are functions that accept a 'world' fragment
// make sure you name this function when you create a new system


async function GroundBirdSystem(world) {
  const tmpBox = new THREE.Box3();
  const geometry = new THREE.PlaneBufferGeometry(1, 1);
  const idleTexture = await loadTexture(_bird_still.default);
  const flyingTexture = await loadTexture(_bird_fly.default);
  const frustum = world.findTag(Tags.MainCameraFrustum);
  const random = (0, _Random.default)(); // query a view of the particles

  const view = world.view([Tags.Object3D, GroundBird]); // we can also listen for events
  // these aren't callbacks (which happen immediately) but deferred until
  // this tick, so that everything still happens in a linear way in order of system execution

  const events = world.listen(GroundBird);
  const spawnEvents = world.listen(Tags.AnimalSpawn);
  const maxBirds = 2;
  const activeEnvEvents = world.listen(Tags.ActiveEnvironmentState); // the return value of a system is a function that
  // is called on each tick

  return function groundBirdSystem(dt) {
    spawnEvents.added.forEach(e => {
      const s = e.get(Tags.AnimalSpawn);

      if (view.length < maxBirds && s.biome === "forest" && s.animal === "bird" && !s.lake) {
        spawnOne(s.position); // finally 'consume' the event by killing it so that other systems
        // won't spawn an animal here

        e.kill();
      }
    });

    if (activeEnvEvents.changed) {
      // when environment changes, kill each bird
      view.forEach(e => e.kill());
    } // console.log(view[0])
    // anim.update(dt)


    const user = world.findTag(Tags.UserCharacter);
    const userPosition = user.position; // A list of matching entities that have been added since last frame
    // events.added.forEach((e) => {
    //   // for example, you could 'init' a mesh now that you know
    //   // it's about to be rendered
    //   console.log("Box initialized");
    // });
    // Update all currenly active entities
    // a view is an array reference into a list of
    // Entities that match your query, and they are updated
    // once before each tick of this system

    view.forEach(e => {
      const mesh = e.get(Tags.Object3D);
      const data = e.get(GroundBird);
      data.time += dt; // detect if close to user
      // switch to flying state if close to user

      const distToUser = mesh.position.distanceTo(userPosition);

      if (distToUser < 4 && data.state == "idle") {
        e.add(Tags.AnimalSound, "birdFlap");
        data.state = "flying";
        mesh.material = data.flyingAnimation.getMaterial();
        mesh.material.uniforms.uRotation.value = MathUtil.degToRad(0);
        const left = data.left;
        mesh.material.uniforms.uLeft.value = left;
        data.velocity.x = left ? -0.5 : 0.5;
        data.velocity.y = 0.25;
        data.velocity.z = -0.5;
        data.velocity.normalize();
        data.size = 2;
      } // update current animation


      const currentAnimation = data.state == "idle" ? data.idleAnimation : data.flyingAnimation;
      const hasUpdated = currentAnimation.update(dt); // set scale

      data.time += dt; // size to animate it in

      const t = MathUtil.clamp01(data.time / data.animateInDuration);
      mesh.scale.setScalar(t * data.size); // mesh.scale.setScalar(data.size);
      // update position

      mesh.position.addScaledVector(data.velocity, dt * data.speed);

      if (data.time >= data.duration) {
        tmpBox.setFromObject(mesh);

        if (!frustum.intersectsBox(tmpBox)) {
          // kill the bird once it's out of frame and after living for a while
          e.kill();
        }
      }
    }); // This is a list of entities that are waiting to be removed

    events.removing.forEach(e => {// for example, you could dispose of things here
      // like geometry/textures if needed
    });
  }; // Triggers a new entity in the world

  function spawnOne(position) {
    // You can use findTag to get singleton tags (i.e. we only expect 1 of this in the world)
    // const user = world.findTag(Tags.UserCharacter);
    // const position = user.position;
    // First check if we can 'steal' one from out of frame
    // for (let i = 0; i < view.length; i++) {
    //   const e = view[i];
    //   const mesh = e.get(Tags.Object3D);
    //   tmpBox.setFromObject(mesh);
    //   if (!frustum.intersectsBox(tmpBox)) {
    //     console.log("stealing");
    //     resetBird(e, position);
    //     return e;
    //   }
    // }
    // make idle anim
    const idleAnim = new _SpriteAnimation.default(_bird_still2.default, null, {
      skipFrames: [67]
    });
    idleAnim.texture = idleTexture;
    idleAnim.makeMaterial(); // make flying anim

    const flyingAnim = new _SpriteAnimation.default(_bird_fly2.default, null);
    flyingAnim.texture = flyingTexture;
    flyingAnim.makeMaterial();
    const material = idleAnim.getMaterial();
    const spriteSizeW = idleAnim.currentFrameData.sourceSize.w;
    const spriteSizeH = idleAnim.currentFrameData.sourceSize.h; // const geometry = new THREE.PlaneBufferGeometry(1, 1/(spriteSizeW/spriteSizeH));
    // Usually you would use ObjectPool or similar instead of creating new meshes

    const mesh = new THREE.Mesh(geometry, material); // create the entity, this will just give us an inactive one from our entity pool

    const e = world.entity(); // now add tags to it, Object3D will cause its value (mesh) to be added to the scene

    e.add(Tags.Object3D, mesh);
    e.add(GroundBird);
    e.add(Tags.Animal);
    const data = e.get(GroundBird);
    data.idleAnimation = idleAnim;
    data.flyingAnimation = flyingAnim;
    resetBird(e, position);
    return e;
  }

  function resetBird(e, position) {
    const left = random.boolean();
    const data = e.get(GroundBird);
    data.state = "idle";
    data.velocity.set(0, 0, 0);
    data.left = left;
    const idleAnim = data.idleAnimation;
    const flyingAnim = data.flyingAnimation;
    idleAnim.currentFrame = Math.floor(random.range(0, 20));
    flyingAnim.currentFrame = Math.floor(random.range(0, 20));
    flyingAnim.elapsed = 0;
    idleAnim.elapsed = 0;
    const mesh = e.get(Tags.Object3D);
    mesh.material = idleAnim.getMaterial();
    mesh.position.copy(position);
    mesh.position.y += 0.5;
    mesh.material.uniforms.uLeft.value = left;
  }

  async function loadTexture(url) {
    return new Promise((resolve, reject) => {
      texLoader.load(url, // ok
      texture => {
        resolve(texture);
      }, // progress
      NOOP, // ko
      evt => {
        reject(evt);
      });
    });
  }
}
},{"../util/math":"src/util/math.js","../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/Random":"src/util/Random.js","../assets/spritesheets/bird_still.png":"src/assets/spritesheets/bird_still.png","../assets/spritesheets/bird_fly.png":"src/assets/spritesheets/bird_fly.png","../util/SpriteAnimation":"src/util/SpriteAnimation.js","../util/water-util":"src/util/water-util.js","../assets/spritesheets/bird_still.sheet":"src/assets/spritesheets/bird_still.sheet.json","../assets/spritesheets/bird_fly.sheet":"src/assets/spritesheets/bird_fly.sheet.json"}],"src/systems/animals/ButterflySystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ButterflySystem;

var _simplexNoise = _interopRequireDefault(require("simplex-noise"));

var Tags = _interopRequireWildcard(require("../../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _Random = _interopRequireDefault(require("../../util/Random"));

var _SpriteAnimation = _interopRequireDefault(require("../../util/SpriteAnimation"));

var _butterfly = _interopRequireDefault(require("../../assets/spritesheets/butterfly.png"));

var _butterfly2 = _interopRequireDefault(require("../../assets/spritesheets/butterfly.sheet"));

var _math = require("canvas-sketch-util/math");

var MathUtil = _interopRequireWildcard(require("../../util/math"));

var _EditorWayfinderSprite = require("../../util/EditorWayfinderSprite");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const NOOP = () => {};

const texLoader = new THREE.TextureLoader();
const V3 = new THREE.Vector3();
const V3A = new THREE.Vector3();
const V3B = new THREE.Vector3();
let tintColor = new THREE.Color("hsl(50, 100%, 100%)");
/*

A simple system that shows off the basic ECS approach.
Each interval, a square emits from the character and floats up,
until it dies away.

*/
// enum ButterflyStates {
//   IDLE,
//   FLYING
// }
// class
// Set up a new tag/data/value
// Usually this would be in "tags.js" but you can also just
// keep it entirely within your system if you want

class Butterfly extends Tags.Data {
  static data = {
    time: Tags.Types.Ref(0),
    animateInDuration: Tags.Types.Ref(0.25),
    // kill after N seconds if still out of frame
    duration: Tags.Types.Ref(5),
    outOfScreenElapsed: Tags.Types.Ref(0),
    outOfScreenLimit: Tags.Types.Ref(5),
    size: Tags.Types.Ref(0.65),
    state: Tags.Types.Ref("flying"),
    // idle || flying
    flyingAnimation: Tags.Types.Ref(null),
    velocity: Tags.Types.Vector3(0, 0, 0),
    // flip?
    left: Tags.Types.Ref(false),
    // origin position
    restPosition: Tags.Types.Vector3(0, 0, 0),
    // target
    tgtPosition: Tags.Types.Vector3(0, 0, 0),
    tgtAngle: Tags.Types.Ref(0),
    tgtSpeed: Tags.Types.Ref(0),
    tgtAngleRadius: Tags.Types.Ref(0),
    // flee
    fleeThreshold: Tags.Types.Ref(0),
    followSpeed: Tags.Types.Ref(0),
    inRadiusElapsed: Tags.Types.Ref(0),
    // can get annoyed
    canGetAnnoyed: Tags.Types.Ref(false),
    isAnnoyed: Tags.Types.Ref(false),
    annoyedElapsed: Tags.Types.Ref(0)
  };
} // Systems are functions that accept a 'world' fragment
// make sure you name this function when you create a new system


async function ButterflySystem(world) {
  const tmpBox = new THREE.Box3();
  const geometry = new THREE.PlaneBufferGeometry(1, 1);
  const flyingTexture = await loadTexture(_butterfly.default);
  const random = (0, _Random.default)();
  const noise = new _simplexNoise.default(random.value); // query a view of the particles

  const view = world.view([Tags.Object3D, Butterfly]); // we can also listen for events
  // these aren't callbacks (which happen immediately) but deferred until
  // this tick, so that everything still happens in a linear way in order of system execution

  const events = world.listen(Butterfly);
  const pos = new THREE.Vector3(-10, 0, -10);
  const spawnEvents = world.listen(Tags.AnimalSpawn);
  const maxButterflies = 25;
  const audioEntity = world.entity();
  const activeEnvEvents = world.listen(Tags.ActiveEnvironmentState); // the return value of a system is a function that
  // is called on each tick

  return dt => {
    if (activeEnvEvents.changed) {
      view.forEach(e => e.kill());
    }

    spawnEvents.added.forEach(e => {
      const s = e.get(Tags.AnimalSpawn);

      if (view.length < maxButterflies && s.biome === "grasslands" && s.animal === "butterfly" && !s.lake) {
        spawn(s.position); // finally 'consume' the event by killing it so that other systems
        // won't spawn an animal here

        e.kill();
      }
    });
    const frustum = world.findTag(Tags.MainCameraFrustum); // console.log(view[0])
    // anim.update(dt)

    const user = world.findTag(Tags.UserCharacter);
    const userPosition = user.position; // A list of matching entities that have been added since last frame
    // events.added.forEach((e) => {
    //   // for example, you could 'init' a mesh now that you know
    //   // it's about to be rendered
    //   // console.log("Box initialized");
    // });
    // Update all currenly active entities
    // a view is an array reference into a list of
    // Entities that match your query, and they are updated
    // once before each tick of this system

    const restPosThreshold = 4;
    const restPosThresholdSq = restPosThreshold * restPosThreshold;
    let userNearButterflies = false;
    view.forEach(e => {
      const mesh = e.get(Tags.Object3D);
      const data = e.get(Butterfly);
      data.time += dt;
      const distToUser = mesh.position.distanceTo(userPosition);
      const distUserToRestposSq = data.restPosition.distanceToSquared(userPosition);

      if (distToUser <= restPosThreshold) {
        userNearButterflies = true;
      }

      if (distUserToRestposSq <= restPosThresholdSq) {
        data.inRadiusElapsed += dt;
      } else {
        data.inRadiusElapsed *= 0.5;
      }

      if (data.inRadiusElapsed >= 1 && data.canGetAnnoyed && !data.isAnnoyed && distUserToRestposSq <= restPosThresholdSq) {
        data.isAnnoyed = true;
      }

      if (data.isAnnoyed && distUserToRestposSq > restPosThresholdSq) {
        data.annoyedElapsed += dt;

        if (data.annoyedElapsed > 2) {
          data.isAnnoyed = false;
          data.annoyedElapsed = 0;
        }
      } // update current animation


      const fleethresh = data.fleeThreshold;
      let animSpeed = (0, _math.mapRange)(distToUser / fleethresh, 0, fleethresh, 5, 1);
      animSpeed = Math.max(1, animSpeed);
      data.angle += data.angleSpeed * dt;
      data.tgtPosition.x = data.restPosition.x + Math.cos(data.angle) * data.angleRadius;
      data.tgtPosition.z = data.restPosition.z + Math.sin(data.angle) * data.angleRadius; // mesh.position.x += pertub * .05

      if (data.isAnnoyed) {
        data.tgtPosition.x = userPosition.x + Math.cos(data.angle) * data.angleRadius;
        data.tgtPosition.z = userPosition.z + Math.sin(data.angle) * data.angleRadius;
      } // set scale
      // size to animate it in


      const t = MathUtil.clamp01(data.time / data.animateInDuration);
      mesh.scale.setScalar(t * data.size); // ----- follow target

      V3.copy(data.tgtPosition);
      V3.sub(mesh.position); //
      // V3.normalize();
      // V3.multiplyScalar(0.1 * data.followSpeed);

      const v3len = Math.min(6, V3.length());
      V3.normalize();
      V3.multiplyScalar(v3len * 0.01 * data.followSpeed); // if (data.isAnnoyed) {
      //   V3.multiplyScalar(0.01 * data.followSpeed);
      // } else {
      // }
      // ----- flee character

      const thresh = data.fleeThreshold;
      let force = (0, _math.mapRange)(distToUser / thresh, 0, thresh, 0.15, 0);
      force = Math.max(0, Math.min(0.08, force));
      V3A.copy(mesh.position);
      V3A.sub(userPosition);
      V3A.normalize();
      V3A.multiplyScalar(force);
      V3.add(V3A); // update position

      mesh.position.add(V3);
      mesh.position.y = 1 + Math.sin(data.time * data.angleSpeed) * 0.4;
      (0, _EditorWayfinderSprite.setSpriteFlip)(mesh, data.left); // if (data.state == 'flying') {

      if (data.time >= data.duration) {
        tmpBox.setFromObject(mesh);

        if (!frustum.intersectsBox(tmpBox)) {
          data.outOfScreenElapsed += dt;

          if (data.outOfScreenElapsed > data.outOfScreenLimit) {
            // kill the bird once it's out of frame
            e.kill();
          }
        }
      } // }

    });

    if (userNearButterflies) {
      if (!audioEntity.has(Tags.AnimalSound)) audioEntity.add(Tags.AnimalSound, "butterfly");
    } else {
      audioEntity.tagOff(Tags.AnimalSound);
    } // This is a list of entities that are waiting to be removed
    // events.removing.forEach((e) => {
    //   // for example, you could dispose of things here
    //   // like geometry/textures if needed
    // });

  };

  function spawn(position) {
    const nb = random.rangeFloor(3, 8);
    const hueDeg = random.pick([0, 30, 50, 330]);
    const hue = hueDeg / 360;
    const baseSat = hueDeg === 330 ? 0.5 : 0.75;
    const baseLight = 0.5;

    for (let i = 0; i < nb; i++) {
      const sprite = (0, _EditorWayfinderSprite.createSprite)(world, new THREE.Texture());
      sprite.position.set(position.x, 0, position.z);
      const e = world.entity().add(Tags.Object3D, sprite).add(Tags.ShaderUniformTime, {
        uniform: sprite.material.uniforms.time
      }).add(Tags.ShadowCaster, {
        sprite: true
      }).add(Tags.Animal).add(Butterfly); //
      // data
      //

      const butterfly = e.get(Butterfly);
      butterfly.left = i % 2 == 0;
      butterfly.state = "flying";
      (0, _EditorWayfinderSprite.setSpriteFlip)(sprite, butterfly.left);
      const angle = random.range(0, Math.PI * 2);
      butterfly.angle = angle;
      butterfly.angleSpeed = random.range(-2, 2);
      butterfly.angleRadius = random.range(0.3, 1); // restPosition

      const radius = random.range(0.8, 1.2);
      butterfly.restPosition.y = 1;
      butterfly.restPosition.x -= random.range(-radius, radius);
      butterfly.restPosition.z -= random.range(-radius, radius);
      butterfly.restPosition.add(position);
      butterfly.tgtPosition.x = 0;
      butterfly.tgtPosition.y = 1;
      butterfly.tgtPosition.z = 0;
      butterfly.tgtPosition.add(position); // flee

      butterfly.fleeThreshold = random.range(1.5, 2);
      butterfly.followSpeed = random.range(1, 2); // scale

      const scl = random.range(0.4, 0.65);
      butterfly.size = scl;
      sprite.scale.x = scl;
      sprite.scale.y = scl; // Add sprite animation to it

      e.add(Tags.SpriteAnimation);
      const anim = e.get(Tags.SpriteAnimation);
      anim.looping = true; // tint

      const mesh = e.get(Tags.Object3D);
      const hueVariation = random.range(-20, 20) / 360;
      const lVariation = random.range(0, 0.1);
      tintColor.setHSL(MathUtil.mod(hue + hueVariation, 1), baseSat, baseLight + lVariation);
      mesh.material.uniforms.tintColor.value.copy(tintColor); // mesh.material.needsUpdate = true;
      // can get annoyed

      butterfly.canGetAnnoyed = random.chance(0.5); // Lazily load sprite sheet based on when it's first added to scene

      e.add(Tags.SpriteAnimationLazyLoadSheet);
      const lazy = e.get(Tags.SpriteAnimationLazyLoadSheet);
      lazy.id = "spritesheets/butterfly";
    }
  }

  function resetEntity(e) {}

  async function loadTexture(url) {
    return new Promise((resolve, reject) => {
      texLoader.load(url, // ok
      texture => {
        resolve(texture);
      }, // progress
      NOOP, // ko
      evt => {
        reject(evt);
      });
    });
  }
}
},{"simplex-noise":"node_modules/simplex-noise/simplex-noise.js","../../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../../util/Random":"src/util/Random.js","../../util/SpriteAnimation":"src/util/SpriteAnimation.js","../../assets/spritesheets/butterfly.png":"src/assets/spritesheets/butterfly.png","../../assets/spritesheets/butterfly.sheet":"src/assets/spritesheets/butterfly.sheet","canvas-sketch-util/math":"node_modules/canvas-sketch-util/math.js","../../util/math":"src/util/math.js","../../util/EditorWayfinderSprite":"src/util/EditorWayfinderSprite.js"}],"src/assets/spritesheets/rabbit.sheet.json":[function(require,module,exports) {
module.exports = module.exports = {
  frames: [{
    filename: "rabbit.png",
    frame: {
      x: 1,
      y: 1,
      w: 128,
      h: 130
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 128,
      h: 130
    },
    sourceSize: {
      w: 128,
      h: 130
    }
  }],
  meta: {
    app: "https://www.codeandweb.com/texturepacker",
    version: "1.0",
    image: "rabbit.png",
    format: "RGBA8888",
    size: {
      w: 130,
      h: 132
    },
    scale: "0.125",
    smartupdate: "$TexturePacker:SmartUpdate:08b128059a6a4415147d59821ae0430b:9bf3f0adc5d3336c983fe6c591567cb0:728f3986df73c95a11c23983e61158cd$"
  }
};
;
},{}],"src/systems/animals/RabbitSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rabbitSystem;

var Tags = _interopRequireWildcard(require("../../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _Random = _interopRequireDefault(require("../../util/Random"));

var _rabbit = _interopRequireDefault(require("../../assets/spritesheets/rabbit.png"));

var MathUtil = _interopRequireWildcard(require("../../util/math"));

var _SpriteAnimation = _interopRequireDefault(require("../../util/SpriteAnimation"));

var _rabbitSheet = _interopRequireDefault(require("../../assets/spritesheets/rabbit.sheet.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NOOP = () => {};

const texLoader = new THREE.TextureLoader();
/*

A simple system that shows off the basic ECS approach.
Each interval, a square emits from the character and floats up,
until it dies away.

*/
// Set up a new tag/data/value
// Usually this would be in "tags.js" but you can also just
// keep it entirely within your system if you want

class Rabbit extends Tags.Data {
  static data = {
    // constant time increase
    time: Tags.Types.Ref(0),
    // animate from zero to 1.0 initially
    animateInDuration: Tags.Types.Ref(0.25),
    // how big to make it
    size: Tags.Types.Ref(1.2),
    animation: Tags.Types.Ref(null),
    left: Tags.Types.Ref(false),
    speed: Tags.Types.Ref(1),
    velocity: Tags.Types.Vector3(),
    state: Tags.Types.Ref("")
  };
} // Systems are functions that accept a 'world' fragment
// make sure you name this function when you create a new system


async function rabbitSystem(world) {
  const texture = await loadTexture(_rabbit.default);
  const geometry = new THREE.PlaneBufferGeometry(1, 1);
  const random = (0, _Random.default)(); // query a view of the particles

  const view = world.view([Tags.Object3D, Rabbit]); // we can also listen for events
  // these aren't callbacks (which happen immediately) but deferred until
  // this tick, so that everything still happens in a linear way in order of system execution

  const events = world.listen(Rabbit); // listen for events on sprite-hit trigger (@Matt TODO: make this not specific to audio triggers...)

  const tmpBox = new THREE.Box3();
  let gameTime = 0;
  let lastBirdTime = null;
  let maxOnScreen = 20; // no more than N active entities

  const spawnEvents = world.listen(Tags.AnimalSpawn);
  const pos = new THREE.Vector3(-8, 1, -6); // spawn(null, pos);
  // the return value of a system is a function that
  // is called on each tick

  return function RabbitSystem(dt) {
    const camera = world.findTag(Tags.MainCamera);
    const frustum = world.findTag(Tags.MainCameraFrustum);
    spawnEvents.added.forEach(e => {
      const s = e.get(Tags.AnimalSpawn);

      if (view.length < maxOnScreen && s.biome === "grasslands" && s.animal === "rabbit" && !s.lake) {
        spawn(camera, s.position); // // finally 'consume' the event by killing it so that other systems
        // // won't spawn an animal here

        e.kill();
      }
    }); // small thing here - it's a bit visually distracting to have
    // birds spawn at the same moment that the user is resolving / writing
    // so we can ignore spawn when some tags are present

    const ignoreSpawn = Boolean(world.findTag(Tags.ShowBiomeResolution) || world.findTag(Tags.WrittenStanzaLineActive) || world.findTag(Tags.HaikuAddingToInventory));
    gameTime += dt; // Here we update all spawned entities
    // This way we can have multiple birds on screen at once with different
    // values (i.e. different frames of their animation)

    view.forEach(e => {
      const d = e.get(Rabbit);
      const speed = d.speed;
      const mesh = e.get(Tags.Object3D);
      const material = mesh.material;
      d.animation.update(dt);
      d.time += dt; // size to animate it in

      const t = MathUtil.clamp01(d.time / d.animateInDuration);
      mesh.scale.setScalar(t * d.size);
      material.uniforms.uLeft.value = d.left;
      material.uniforms.uRotation.value = MathUtil.degToRad(0);
    });
  }; // Triggers a new entity in the world

  function spawn(camera, position) {
    const anim = new _SpriteAnimation.default(_rabbitSheet.default, null);
    anim.texture = texture;
    anim.makeMaterial();
    const material = anim.getMaterial();
    const mesh = new THREE.Mesh(geometry, anim.getMaterial());
    mesh.position.copy(position);
    mesh.position.y += 0.5; // create the entity, this will just give us an inactive one from our entity pool

    const e = world.entity(); // now add tags to it, Object3D will cause its value (mesh) to be added to the scene

    e.add(Tags.Object3D, mesh); // can give each particle a different speed

    const speed = 7; //random.range(6, 8);

    e.add(Rabbit);
    const d = e.get(Rabbit);
    const left = random.boolean();
    d.animation = anim;
    d.velocity.set(left ? -0.1 : 0.1, 0, -0.1).normalize();
    d.left = left;
    d.speed = speed;
  }

  async function loadTexture(url) {
    return new Promise((resolve, reject) => {
      texLoader.load(url, // ok
      texture => {
        resolve(texture);
      }, // progress
      NOOP, // ko
      evt => {
        reject(evt);
      });
    });
  }
}
},{"../../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../../util/Random":"src/util/Random.js","../../assets/spritesheets/rabbit.png":"src/assets/spritesheets/rabbit.png","../../util/math":"src/util/math.js","../../util/SpriteAnimation":"src/util/SpriteAnimation.js","../../assets/spritesheets/rabbit.sheet.json":"src/assets/spritesheets/rabbit.sheet.json"}],"src/assets/spritesheets/seal.sheet.json":[function(require,module,exports) {
module.exports = module.exports = {
  frames: [{
    filename: "seal_1.png",
    frame: {
      x: 1,
      y: 1,
      w: 103,
      h: 75
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 103,
      h: 75
    },
    sourceSize: {
      w: 103,
      h: 75
    }
  }],
  meta: {
    app: "https://www.codeandweb.com/texturepacker",
    version: "1.0",
    image: "seal.png",
    format: "RGBA8888",
    size: {
      w: 105,
      h: 77
    },
    scale: "0.125",
    smartupdate: "$TexturePacker:SmartUpdate:4459159640a2f3aa7d478805520d49fb:a1c6057bb18b47b8b1c34c942fb3eb96:77441584f386b1802c776f35e0e1106e$"
  }
};
;
},{}],"src/systems/animals/SealSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SealSystem;

var Tags = _interopRequireWildcard(require("../../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _Random = _interopRequireDefault(require("../../util/Random"));

var _seal = _interopRequireDefault(require("../../assets/spritesheets/seal.png"));

var MathUtil = _interopRequireWildcard(require("../../util/math"));

var _SpriteAnimation = _interopRequireDefault(require("../../util/SpriteAnimation"));

var _sealSheet = _interopRequireDefault(require("../../assets/spritesheets/seal.sheet.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NOOP = () => {};

const texLoader = new THREE.TextureLoader();
/*

A simple system that shows off the basic ECS approach.
Each interval, a square emits from the character and floats up,
until it dies away.

*/
// Set up a new tag/data/value
// Usually this would be in "tags.js" but you can also just
// keep it entirely within your system if you want

class Seal extends Tags.Data {
  static data = {
    // constant time increase
    time: Tags.Types.Ref(0),
    // animate from zero to 1.0 initially
    animateInDuration: Tags.Types.Ref(0.25),
    // how big to make it
    size: Tags.Types.Ref(2),
    animation: Tags.Types.Ref(null),
    left: Tags.Types.Ref(false),
    speed: Tags.Types.Ref(1),
    velocity: Tags.Types.Vector3(),
    state: Tags.Types.Ref("")
  };
} // Systems are functions that accept a 'world' fragment
// make sure you name this function when you create a new system


async function SealSystem(world) {
  const texture = await loadTexture(_seal.default);
  const geometry = new THREE.PlaneBufferGeometry(1.07, 0.77);
  const random = (0, _Random.default)(); // query a view of the particles

  const view = world.view([Tags.Object3D, Seal]); // we can also listen for events
  // these aren't callbacks (which happen immediately) but deferred until
  // this tick, so that everything still happens in a linear way in order of system execution

  const events = world.listen(Seal); // listen for events on sprite-hit trigger (@Matt TODO: make this not specific to audio triggers...)

  const tmpBox = new THREE.Box3();
  let gameTime = 0;
  let lastBirdTime = null;
  let maxOnScreen = 20; // no more than N active entities

  const spawnEvents = world.listen(Tags.AnimalSpawn);
  const pos = new THREE.Vector3(-10, 1, -10); // spawn(null, pos);
  // the return value of a system is a function that
  // is called on each tick

  return function sealSystem(dt) {
    const camera = world.findTag(Tags.MainCamera);
    const frustum = world.findTag(Tags.MainCameraFrustum);
    spawnEvents.added.forEach(e => {
      const s = e.get(Tags.AnimalSpawn);

      if (view.length < maxOnScreen && s.biome === "grasslands" && s.animal === "seal" && !s.lake) {
        spawn(camera, s.position); // // finally 'consume' the event by killing it so that other systems
        // // won't spawn an animal here

        e.kill();
      }
    }); // small thing here - it's a bit visually distracting to have
    // birds spawn at the same moment that the user is resolving / writing
    // so we can ignore spawn when some tags are present

    const ignoreSpawn = Boolean(world.findTag(Tags.ShowBiomeResolution) || world.findTag(Tags.WrittenStanzaLineActive) || world.findTag(Tags.HaikuAddingToInventory));
    gameTime += dt; // Here we update all spawned entities
    // This way we can have multiple birds on screen at once with different
    // values (i.e. different frames of their animation)

    view.forEach(e => {
      const d = e.get(Seal);
      const speed = d.speed;
      const mesh = e.get(Tags.Object3D);
      const material = mesh.material;
      d.animation.update(dt);
      d.time += dt; // size to animate it in

      const t = MathUtil.clamp01(d.time / d.animateInDuration);
      mesh.scale.setScalar(t * d.size);
      material.uniforms.uLeft.value = d.left;
      material.uniforms.uRotation.value = MathUtil.degToRad(0);
    });
  }; // Triggers a new entity in the world

  function spawn(camera, position) {
    const anim = new _SpriteAnimation.default(_sealSheet.default, null);
    anim.texture = texture;
    anim.makeMaterial();
    const material = anim.getMaterial();
    const mesh = new THREE.Mesh(geometry, anim.getMaterial());
    mesh.position.copy(position);
    mesh.position.y = 1; // create the entity, this will just give us an inactive one from our entity pool

    const e = world.entity(); // now add tags to it, Object3D will cause its value (mesh) to be added to the scene

    e.add(Tags.Object3D, mesh); // can give each particle a different speed

    const speed = 7; //random.range(6, 8);

    e.add(Seal);
    const d = e.get(Seal);
    const left = random.boolean();
    d.animation = anim;
    d.velocity.set(left ? -0.1 : 0.1, 0, -0.1).normalize();
    d.left = left;
    d.speed = speed;
  }

  async function loadTexture(url) {
    return new Promise((resolve, reject) => {
      texLoader.load(url, // ok
      texture => {
        resolve(texture);
      }, // progress
      NOOP, // ko
      evt => {
        reject(evt);
      });
    });
  }
}
},{"../../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../../util/Random":"src/util/Random.js","../../assets/spritesheets/seal.png":"src/assets/spritesheets/seal.png","../../util/math":"src/util/math.js","../../util/SpriteAnimation":"src/util/SpriteAnimation.js","../../assets/spritesheets/seal.sheet.json":"src/assets/spritesheets/seal.sheet.json"}],"src/assets/spritesheets/owl_sleep.sheet.json":[function(require,module,exports) {
module.exports = module.exports = {
  frames: [{
    filename: "OWL-1_0000.png",
    frame: {
      x: 1,
      y: 1,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }],
  meta: {
    app: "https://www.codeandweb.com/texturepacker",
    version: "1.0",
    image: "owl_sleep.png",
    format: "RGBA8888",
    size: {
      w: 142,
      h: 142
    },
    scale: "1",
    smartupdate: "$TexturePacker:SmartUpdate:21eaf86d4169e0ddc4011243b75b342b:dcc49444f38700aee47bfd37a7041e0a:6bc02c8c74c6acf003ca8634b6b6245d$"
  }
};
;
},{}],"src/assets/spritesheets/owl_wakeup.sheet.json":[function(require,module,exports) {
module.exports = module.exports = {
  frames: [{
    filename: "OWL-1_0000.png",
    frame: {
      x: 1,
      y: 1,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0001.png",
    frame: {
      x: 143,
      y: 1,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0002.png",
    frame: {
      x: 285,
      y: 1,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0003.png",
    frame: {
      x: 1,
      y: 143,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0004.png",
    frame: {
      x: 143,
      y: 143,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0005.png",
    frame: {
      x: 285,
      y: 143,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0006.png",
    frame: {
      x: 1,
      y: 285,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0007.png",
    frame: {
      x: 143,
      y: 285,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0008.png",
    frame: {
      x: 285,
      y: 285,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0009.png",
    frame: {
      x: 1,
      y: 427,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0010.png",
    frame: {
      x: 1,
      y: 1,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0011.png",
    frame: {
      x: 143,
      y: 427,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0012.png",
    frame: {
      x: 285,
      y: 427,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0013.png",
    frame: {
      x: 285,
      y: 427,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0014.png",
    frame: {
      x: 285,
      y: 427,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0015.png",
    frame: {
      x: 285,
      y: 427,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0016.png",
    frame: {
      x: 285,
      y: 427,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0017.png",
    frame: {
      x: 285,
      y: 427,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0018.png",
    frame: {
      x: 285,
      y: 427,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0019.png",
    frame: {
      x: 285,
      y: 427,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0020.png",
    frame: {
      x: 285,
      y: 427,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0021.png",
    frame: {
      x: 285,
      y: 427,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0022.png",
    frame: {
      x: 285,
      y: 427,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0023.png",
    frame: {
      x: 285,
      y: 427,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0024.png",
    frame: {
      x: 1,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0025.png",
    frame: {
      x: 1,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0026.png",
    frame: {
      x: 1,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0027.png",
    frame: {
      x: 1,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0028.png",
    frame: {
      x: 1,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0029.png",
    frame: {
      x: 1,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0030.png",
    frame: {
      x: 1,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0031.png",
    frame: {
      x: 1,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0032.png",
    frame: {
      x: 1,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0033.png",
    frame: {
      x: 1,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0034.png",
    frame: {
      x: 1,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0035.png",
    frame: {
      x: 1,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0036.png",
    frame: {
      x: 1,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0037.png",
    frame: {
      x: 1,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0038.png",
    frame: {
      x: 143,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0039.png",
    frame: {
      x: 143,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0040.png",
    frame: {
      x: 143,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0041.png",
    frame: {
      x: 143,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0042.png",
    frame: {
      x: 143,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0043.png",
    frame: {
      x: 143,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0044.png",
    frame: {
      x: 143,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0045.png",
    frame: {
      x: 143,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0046.png",
    frame: {
      x: 143,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0047.png",
    frame: {
      x: 285,
      y: 569,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }, {
    filename: "OWL-1_0048.png",
    frame: {
      x: 1,
      y: 1,
      w: 140,
      h: 140
    },
    rotated: !1,
    trimmed: !1,
    spriteSourceSize: {
      x: 0,
      y: 0,
      w: 140,
      h: 140
    },
    sourceSize: {
      w: 140,
      h: 140
    }
  }],
  meta: {
    app: "https://www.codeandweb.com/texturepacker",
    version: "1.0",
    image: "owl_wakeup.png",
    format: "RGBA8888",
    size: {
      w: 426,
      h: 710
    },
    scale: "1",
    smartupdate: "$TexturePacker:SmartUpdate:72e1158335e3a375f958ba9c57f12e1b:7ae100e830d5001477212dfd1b1f81c1:4803889c0639208641360bc38f21b5a2$"
  }
};
;
},{}],"src/systems/animals/OwlSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = OwlSystem;

var Tags = _interopRequireWildcard(require("../../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _Random = _interopRequireDefault(require("../../util/Random"));

var _owl_sleep = _interopRequireDefault(require("../../assets/spritesheets/owl_sleep.png"));

var _owl_wakeup = _interopRequireDefault(require("../../assets/spritesheets/owl_wakeup.png"));

var MathUtil = _interopRequireWildcard(require("../../util/math"));

var _SpriteAnimation = _interopRequireDefault(require("../../util/SpriteAnimation"));

var _owl_sleepSheet = _interopRequireDefault(require("../../assets/spritesheets/owl_sleep.sheet.json"));

var _owl_wakeupSheet = _interopRequireDefault(require("../../assets/spritesheets/owl_wakeup.sheet.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NOOP = () => {};

const texLoader = new THREE.TextureLoader();
/*

A simple system that shows off the basic ECS approach.
Each interval, a square emits from the character and floats up,
until it dies away.

*/
// Set up a new tag/data/value
// Usually this would be in "tags.js" but you can also just
// keep it entirely within your system if you want

class Owl extends Tags.Data {
  static data = {
    // constant time increase
    time: Tags.Types.Ref(0),
    // animate from zero to 1.0 initially
    animateInDuration: Tags.Types.Ref(0.25),
    // how big to make it
    size: Tags.Types.Ref(1),
    left: Tags.Types.Ref(false),
    state: Tags.Types.Ref("sleep"),
    // idle || flying
    currentAnimation: Tags.Types.Ref(null),
    sleepAnimation: Tags.Types.Ref(null),
    wakeupAnimation: Tags.Types.Ref(null)
  };
} // Systems are functions that accept a 'world' fragment
// make sure you name this function when you create a new system


async function OwlSystem(world) {
  const wakeupTexture = await loadTexture(_owl_wakeup.default);
  const sleepTexture = await loadTexture(_owl_sleep.default);
  const geometry = new THREE.PlaneBufferGeometry(1, 1);
  const random = (0, _Random.default)(); // query a view of the particles

  const view = world.view([Tags.Object3D, Owl]); // we can also listen for events
  // these aren't callbacks (which happen immediately) but deferred until
  // this tick, so that everything still happens in a linear way in order of system execution

  const events = world.listen(Owl); // listen for events on sprite-hit trigger (@Matt TODO: make this not specific to audio triggers...)

  const tmpBox = new THREE.Box3();
  let gameTime = 0;
  let lastBirdTime = null;
  let maxOnScreen = 20; // no more than N active entities

  const spawnEvents = world.listen(Tags.AnimalSpawn);
  const pos = new THREE.Vector3(-5, 1, -5); // spawn(null, pos);
  // the return value of a system is a function that
  // is called on each tick

  return function owlSystem(dt) {
    const camera = world.findTag(Tags.MainCamera);
    const frustum = world.findTag(Tags.MainCameraFrustum);
    const user = world.findTag(Tags.UserCharacter);
    const userPosition = user.position;
    spawnEvents.added.forEach(e => {
      const s = e.get(Tags.AnimalSpawn);

      if (view.length < maxOnScreen && s.biome === "forest" && s.animal === "owl" && !s.lake) {
        spawn(camera, s.position); // // finally 'consume' the event by killing it so that other systems
        // // won't spawn an animal here

        e.kill();
      }
    }); // small thing here - it's a bit visually distracting to have
    // birds spawn at the same moment that the user is resolving / writing
    // so we can ignore spawn when some tags are present

    const ignoreSpawn = Boolean(world.findTag(Tags.ShowBiomeResolution) || world.findTag(Tags.WrittenStanzaLineActive) || world.findTag(Tags.HaikuAddingToInventory));
    gameTime += dt; // Here we update all spawned entities
    // This way we can have multiple birds on screen at once with different
    // values (i.e. different frames of their animation)

    view.forEach(e => {
      const d = e.get(Owl);
      const mesh = e.get(Tags.Object3D);
      const distToUser = mesh.position.distanceTo(userPosition);

      if (distToUser < 14 && d.state == "sleep") {
        d.state = "wakeup";
        d.currentAnimation = d.wakeupAnimation;
        d.currentAnimation.stop();
        d.currentAnimation.play();
        mesh.material = d.currentAnimation.getMaterial();
      } else if (distToUser > 4 && d.state == "wakeup" && d.currentAnimation.currentFrame > 47) {
        d.state = "sleep";
        d.currentAnimation = d.sleepAnimation;
        d.currentAnimation.stop();
        d.currentAnimation.play();
        mesh.material = d.currentAnimation.getMaterial();
      }

      d.currentAnimation.update(dt);
      d.time += dt; // size to animate it in

      const t = MathUtil.clamp01(d.time / d.animateInDuration);
      mesh.scale.setScalar(t * d.size);
      const material = mesh.material;
      material.uniforms.uLeft.value = d.left;
      material.uniforms.uRotation.value = MathUtil.degToRad(0);
    });
  }; // Triggers a new entity in the world

  function spawn(camera, position) {
    // make anims
    const sleepAnim = new _SpriteAnimation.default(_owl_sleepSheet.default, null);
    sleepAnim.texture = sleepTexture;
    sleepAnim.makeMaterial();
    const wakeupAnim = new _SpriteAnimation.default(_owl_wakeupSheet.default, null);
    wakeupAnim.texture = wakeupTexture;
    wakeupAnim.loop = false;
    wakeupAnim.makeMaterial();
    const mesh = new THREE.Mesh(geometry, sleepAnim.getMaterial());
    mesh.position.copy(position);
    mesh.position.y += 0.5; // create the entity, this will just give us an inactive one from our entity pool

    const e = world.entity(); // now add tags to it, Object3D will cause its value (mesh) to be added to the scene

    e.add(Tags.Object3D, mesh); // can give each particle a different speed

    const speed = 7; //random.range(6, 8);

    e.add(Owl);
    const d = e.get(Owl);
    d.state = "sleep";
    const left = random.boolean();
    d.sleepAnimation = sleepAnim;
    d.wakeupAnimation = wakeupAnim;
    d.currentAnimation = sleepAnim;
    d.left = left;
    d.speed = speed;
  }

  async function loadTexture(url) {
    return new Promise((resolve, reject) => {
      texLoader.load(url, // ok
      texture => {
        resolve(texture);
      }, // progress
      NOOP, // ko
      evt => {
        reject(evt);
      });
    });
  }
}
},{"../../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../../util/Random":"src/util/Random.js","../../assets/spritesheets/owl_sleep.png":"src/assets/spritesheets/owl_sleep.png","../../assets/spritesheets/owl_wakeup.png":"src/assets/spritesheets/owl_wakeup.png","../../util/math":"src/util/math.js","../../util/SpriteAnimation":"src/util/SpriteAnimation.js","../../assets/spritesheets/owl_sleep.sheet.json":"src/assets/spritesheets/owl_sleep.sheet.json","../../assets/spritesheets/owl_wakeup.sheet.json":"src/assets/spritesheets/owl_wakeup.sheet.json"}],"src/systems/animals/FoxSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = foxSystem;

var Tags = _interopRequireWildcard(require("../../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _Random = _interopRequireDefault(require("../../util/Random"));

var MathUtil = _interopRequireWildcard(require("../../util/math"));

var _SpriteAnimation = _interopRequireDefault(require("../../util/SpriteAnimation"));

var _EditorWayfinderSprite = require("../../util/EditorWayfinderSprite");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const VA = new THREE.Vector3();
const VB = new THREE.Vector3();

class Fox extends Tags.Data {
  static data = {
    state: Tags.Types.Ref("sleep"),
    // sleep || awake
    canPlayHmSound: Tags.Types.Ref(true)
  };
}

let soundHmTimer; // Systems are functions that accept a 'world' fragment
// make sure you name this function when you create a new system

function foxSystem(world) {
  const random = (0, _Random.default)();
  const events = world.listen([Tags.Object3D, Tags.FoxSpriteTag]);
  const view = world.view([Tags.Object3D, Tags.FoxSpriteTag]);
  const foxHmEvent = world.listen(Tags.FoxHm);
  const distThreshold = 13;
  const user = world.findTag(Tags.UserCharacter);
  const distThresholdSq = distThreshold * distThreshold;
  const tmpBox = new THREE.Box3(); // The "patch" loading system will actually emit these entities for us
  // const testFakeAdd = () => {
  //   const sprite = createSprite(world, new THREE.Texture());
  //   sprite.position.set(random.range(6, 8) * random.sign(), 0, -2);
  //   world
  //     .entity()
  //     .add(Tags.Object3D, sprite)
  //     .add(Tags.ShaderUniformTime, {
  //       uniform: sprite.material.uniforms.time,
  //     })
  //     .add(Tags.ShadowCaster, { sprite: true })
  //     .add(Tags.FoxSpriteTag);
  // };
  // testFakeAdd();
  // the return value of a system is a function that
  // is called on each tick

  return function FoxSystem(dt) {
    events.added.forEach((e, idx) => {
      const object = e.get(Tags.Object3D);
      e.add(Fox); // randomly flip the sprite

      (0, _EditorWayfinderSprite.setSpriteFlip)(object, random.boolean()); // Scale for all fox sprites

      object.scale.y = 1.5; // Add sprite animation to it

      e.add(Tags.SpriteAnimation);
      const anim = e.get(Tags.SpriteAnimation);
      anim.looping = true;
      anim.loopStart = 0;
      anim.loopEnd = 29; // anim.onLoopEnd = (e) => {
      //   const fox = e.get(Fox)
      //   console.log(fox)
      //   if (fox.state == 'awake' && fox.canPlayHmSound) {
      //     console.log(anim.frame)
      //     // fox.canPlayHmSound = false
      //     e.add(Tags.FoxHm)
      //     anim.loopStart = 29;
      //     anim.loopEnd = 68;
      //   }
      // }

      e.add(Tags.SpriteAnimationLazyLoadSheet);
      const lazy = e.get(Tags.SpriteAnimationLazyLoadSheet);
      lazy.id = "spritesheets/fox";
    });
    const frustum = world.findTag(Tags.MainCameraFrustum);
    const userPosition = user.position;
    VA.x = userPosition.x;
    VA.z = userPosition.z;
    view.forEach((e, idx) => {
      const mesh = e.get(Tags.Object3D);
      const anim = e.get(Tags.SpriteAnimation);
      const fox = e.get(Fox);
      VB.setFromMatrixPosition(mesh.matrixWorld); // can also do this but it includes an additional unnecessary update
      // mesh.getWorldPosition(VB);

      const dx = VA.x - VB.x;
      const dz = VA.z - VB.z;
      const dstSq = dx * dx + dz * dz;

      if (dstSq < distThresholdSq) {
        fox.state = 'awake';
        anim.loopStart = 29;
        anim.loopEnd = 68;

        if (anim.frame >= 30 && anim.frame <= 33 && fox.canPlayHmSound) {
          fox.canPlayHmSound = false;
          e.add(Tags.FoxHm);
          e.remove(Tags.FoxPurring);
          soundHmTimer = setTimeout(() => {
            e.remove(Tags.FoxHm);
            fox.canPlayHmSound = true;
          }, 5000);
        }
      } else {
        fox.state = 'sleep';
        anim.loopStart = 0;
        anim.loopEnd = 29; // in camera view

        tmpBox.setFromObject(mesh);

        if (frustum.intersectsBox(tmpBox)) {
          e.add(Tags.FoxPurring);
        } else {
          e.remove(Tags.FoxHm);
          e.remove(Tags.FoxPurring);
        }
      }
    });
  };
}
},{"../../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../../util/Random":"src/util/Random.js","../../util/math":"src/util/math.js","../../util/SpriteAnimation":"src/util/SpriteAnimation.js","../../util/EditorWayfinderSprite":"src/util/EditorWayfinderSprite.js"}],"src/systems/animals/FishSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = FishSystem;

var Tags = _interopRequireWildcard(require("../../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _Random = _interopRequireDefault(require("../../util/Random"));

var _fish = _interopRequireDefault(require("../../assets/spritesheets/fish.png"));

var MathUtil = _interopRequireWildcard(require("../../util/math"));

var _SpriteAnimation = _interopRequireDefault(require("../../util/SpriteAnimation"));

var _EditorWayfinderSprite = require("../../util/EditorWayfinderSprite");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import sheetData from "../../assets/spritesheets/fish.sheet.json";
class FishTag extends Tags.Data {
  static data = {
    spawnEntity: Tags.Types.Ref(null)
  };
}

class FishVisible extends Tags.Tag {} // Systems are functions that accept a 'world' fragment
// make sure you name this function when you create a new system


function FishSystem(world) {
  const random = (0, _Random.default)();
  const waterPlaceholders = world.view(Tags.WaterFishPlaceholderTag);
  const character = world.findTag(Tags.UserCharacter);
  const spawnRadius = 8;
  const DEBUG = false;
  const geo = DEBUG ? new THREE.SphereGeometry(1, 32, 32) : null;
  const spawnRadiusSq = spawnRadius * spawnRadius;
  const fishView = world.view([Tags.SpriteAnimation, FishTag]);
  const envState = world.view([Tags.EnvironmentState, Tags.ActiveEnvironmentState]); // spawnOne(new THREE.Vector3(-6, 0, -2));
  // the return value of a system is a function that
  // is called on each tick

  return function FishSystem(dt) {
    if (envState.length && envState[0].get(Tags.EnvironmentState).name !== "grasslands") {
      return;
    }

    const userPos = character.position; // kill fish after loop is done

    fishView.forEach(e => {
      if (e.get(Tags.SpriteAnimation).finished) {
        e.get(FishTag).spawnEntity.remove(FishVisible);
        e.kill();
      }
    });
    waterPlaceholders.forEach(e => {
      // check to see if we should spawn
      const a = e.get(Tags.GroundAsset);
      const dx = a.x - userPos.x;
      const dz = a.z - userPos.z;
      const dSq = dx * dx + dz * dz;
      const isInside = dSq <= spawnRadiusSq;

      if (isInside) {
        if (!e.has(Tags.UserHasHit)) {
          e.add(Tags.UserHasHit);

          if (!e.has(FishVisible)) {
            e.add(FishVisible);
            spawnOne(e, a.x, a.z);
          }
        }
      } else {
        if (e.has(Tags.UserHasHit)) {
          e.remove(Tags.UserHasHit);
        }
      } // TODO: DEBUG CODE TO HIGHLIGHT HIT AREA, REMOVE LATER


      if (DEBUG) {
        if (!e.has(Tags.Object3D)) {
          const m = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({
            color: "red",
            wireframe: true
          }));
          m.scale.setScalar(spawnRadius);
          m.position.y = 0;
          const asset = e.get(Tags.GroundAsset);
          m.position.x = asset.x;
          m.position.z = asset.z;
          e.add(Tags.Object3D, m);
        }

        e.get(Tags.Object3D).material.color.set(e.has(Tags.UserHasHit) ? "green" : "red");
      }
    });
  };

  function spawnOne(linked, x, z) {
    const sprite = (0, _EditorWayfinderSprite.createSprite)(world, new THREE.Texture());
    sprite.position.set(x, 0, z);
    const e = world.entity().add(Tags.Object3D, sprite).add(Tags.ShaderUniformTime, {
      uniform: sprite.material.uniforms.time
    }).add(Tags.ShadowCaster, {
      sprite: true
    }).add(Tags.AnimalSound, "fish").add(FishTag, {
      spawnEntity: linked
    }); // randomly flip the sprite

    (0, _EditorWayfinderSprite.setSpriteFlip)(sprite, random.boolean()); // Scale for all fish sprites

    const scl = 4;
    sprite.scale.x = scl;
    sprite.scale.y = scl * 0.6666; // Add sprite animation to it

    e.add(Tags.SpriteAnimation);
    const anim = e.get(Tags.SpriteAnimation); // Lazily load sprite sheet based on when it's first added to scene

    e.add(Tags.SpriteAnimationLazyLoadSheet);
    const lazy = e.get(Tags.SpriteAnimationLazyLoadSheet);
    lazy.id = "spritesheets/fish";
  }
}
},{"../../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../../util/Random":"src/util/Random.js","../../assets/spritesheets/fish.png":"src/assets/spritesheets/fish.png","../../util/math":"src/util/math.js","../../util/SpriteAnimation":"src/util/SpriteAnimation.js","../../util/EditorWayfinderSprite":"src/util/EditorWayfinderSprite.js"}],"src/systems/animals/JumpingRabbitSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = JumpingRabbitSystem;

var MathUtil = _interopRequireWildcard(require("../../util/math"));

var Tags = _interopRequireWildcard(require("../../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _Random = _interopRequireDefault(require("../../util/Random"));

var _waterUtil = require("../../util/water-util");

var _math2 = require("canvas-sketch-util/math");

var _EditorWayfinderSprite = require("../../util/EditorWayfinderSprite");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const VA = new THREE.Vector3();

const NOOP = () => {};

const texLoader = new THREE.TextureLoader();
const tintColor = new THREE.Color("#ffffff");
/*

A simple system that shows off the basic ECS approach.
Each interval, a square emits from the character and floats up,
until it dies away.

*/
// enum JumpingRabbitStates {
//   IDLE,
//   FLYING
// }
// Set up a new tag/data/value
// Usually this would be in "tags.js" but you can also just
// keep it entirely within your system if you want

class JumpingRabbit extends Tags.Data {
  static data = {
    time: Tags.Types.Ref(0),
    size: Tags.Types.Ref(2.5),
    animateInDuration: Tags.Types.Ref(0.25),
    duration: Tags.Types.Ref(10),
    speed: Tags.Types.Ref(7),
    left: Tags.Types.Ref(true),
    newLeft: Tags.Types.Ref(null),
    state: Tags.Types.Ref("idle"),
    // idle || running
    animation: Tags.Types.Ref(null),
    jumpSpeed: Tags.Types.Ref(1)
  };
} // Systems are functions that accept a 'world' fragment
// make sure you name this function when you create a new system


async function JumpingRabbitSystem(world) {
  const tmpBox = new THREE.Box3();
  const tmpBox2 = new THREE.Box3();
  const geometry = new THREE.PlaneBufferGeometry(1, 1); // const texture = await loadTexture(spriteURL);

  const frustum = world.findTag(Tags.MainCameraFrustum);
  const random = (0, _Random.default)(); // query a view of the particles

  const view = world.view([Tags.Object3D, JumpingRabbit]); // world ground assets

  const groundAssets = world.view([Tags.GroundAsset, Tags.GroundAssetData]); // we can also listen for events
  // these aren't callbacks (which happen immediately) but deferred until
  // this tick, so that everything still happens in a linear way in order of system execution
  // const events = world.listen(JumpingRabbit);

  const spawnEvents = world.listen(Tags.AnimalSpawn);
  const maxEntity = 10;
  const radiusThresh = 10; // spawnOne(new THREE.Vector3(-5, 0, -5));
  // the return value of a system is a function that
  // is called on each tick

  return function jumpingRabbitSystem(dt) {
    spawnEvents.added.forEach(e => {
      const s = e.get(Tags.AnimalSpawn);

      if (view.length < maxEntity && s.biome === "tundra" && s.animal === "jumpingrabbit" && !s.lake) {
        let canSpawn = true;
        groundAssets.forEach((e, idx) => {
          const asset = e.get(Tags.GroundAsset);
          VA.x = asset.x;
          VA.z = asset.z;
          const dist = VA.distanceTo(s.position);

          if (dist < 5) {
            canSpawn = false;
          }
        });

        if (random.chance(0.4)) {
          spawnOne(s.position);
        } // finally 'consume' the event by killing it so that other systems
        // won't spawn an animal here


        e.kill();
      }
    }); // console.log(view[0])
    // anim.update(dt)

    const user = world.findTag(Tags.UserCharacter);
    const userPosition = user.position; // A list of matching entities that have been added since last frame
    // events.added.forEach((e) => {
    //   // for example, you could 'init' a mesh now that you know
    //   // it's about to be rendered
    //   console.log("Box initialized");
    // });
    // Update all currenly active entities
    // a view is an array reference into a list of
    // Entities that match your query, and they are updated
    // once before each tick of this system

    view.forEach(e => {
      const mesh = e.get(Tags.Object3D);
      const data = e.get(JumpingRabbit);
      const anim = e.get(Tags.SpriteAnimation);
      data.time += dt;
      const isJumpClip = anim.frame >= 18 && anim.frame < 35;
      anim.speed = isJumpClip ? data.jumpSpeed : 1; // switch to jumping state if close to user ?

      const distToUser = mesh.position.distanceTo(userPosition);
      let jumpDir = userPosition.x - mesh.position.x > 0 ? 1 : -1; // reverse direction because the rabbit is about to hit an asset?

      groundAssets.forEach((e, idx) => {
        const asset = e.get(Tags.GroundAsset);
        const assetMesh = e.get(Tags.Object3D);

        if (assetMesh.geometry && assetMesh.geometry.boundingSphere) {
          VA.x = assetMesh.matrixWorld.elements[12];
          VA.z = assetMesh.matrixWorld.elements[14];
          const dist = VA.distanceTo(mesh.position);
          let assetRadius = assetMesh.geometry ? assetMesh.geometry.boundingSphere.radius * 2 : 4;

          if (dist < assetRadius) {
            jumpDir *= -1;
          }
        } // if (userPosition.distanceTo(VA) < 2) {
        //   console.log('uh oh')
        // }

      }); // the new left position for when the rabbit 'lands' from a hop

      data.newLeft = jumpDir == 1 ? false : true; // waiting for jump

      if (distToUser < radiusThresh && data.state == "idle") {
        console.log("start running away");
        data.state = "jumping"; // we can set the jump points immediately to make it snappier

        anim.loopStart = 18;
        anim.loopEnd = 35;
        anim.frame = anim.loopStart;
        anim.dirty = true;
      } // if we are currently in jumping state, maybe go back to idle?


      if (data.state === "jumping" && distToUser > radiusThresh) {
        data.state = "idle";
      } // size to animate it in


      const t = MathUtil.clamp01(data.time / data.animateInDuration);
      mesh.scale.setScalar(t * data.size);
      mesh.scale.y *= 62 / 128;

      if (data.time >= data.duration) {
        tmpBox.setFromObject(mesh);

        if (!frustum.intersectsBox(tmpBox)) {
          // kill the bird once it's out of frame and after living for a while
          e.kill();
        }
      }
    }); // This is a list of entities that are waiting to be removed
    // events.removing.forEach((e) => {
    //   // for example, you could dispose of things here
    //   // like geometry/textures if needed
    // });
  }; // Triggers a new entity in the world

  function spawnOne(position) {
    const sprite = (0, _EditorWayfinderSprite.createSprite)(world, new THREE.Texture());
    sprite.position.set(position.x, 0, position.z);
    const e = world.entity().add(Tags.Object3D, sprite).add(Tags.ShaderUniformTime, {
      uniform: sprite.material.uniforms.time
    }).add(Tags.ShadowCaster, {
      sprite: true
    }).add(JumpingRabbit); // randomly flip the sprite

    const rabbit = e.get(JumpingRabbit);
    rabbit.left = random.boolean();
    (0, _EditorWayfinderSprite.setSpriteFlip)(sprite, rabbit.left); // Scale for all fish sprites

    const scl = 4;
    sprite.scale.x = scl;
    sprite.scale.y *= 62 / 128; // jump speed

    rabbit.jumpSpeed = random.range(3, 4.5); // Add sprite animation to it

    e.add(Tags.SpriteAnimation);
    const anim = e.get(Tags.SpriteAnimation);
    anim.looping = true;
    anim.loopStart = 0;
    anim.loopEnd = 18;
    const mesh = e.get(Tags.Object3D);
    mesh.material.uniforms.tintColor.value.r = tintColor.r;
    mesh.material.uniforms.tintColor.value.g = tintColor.g;
    mesh.material.uniforms.tintColor.value.b = tintColor.b;
    mesh.material.needsUpdate = true;

    anim.onLoopEnd = e => {
      const mesh = e.get(Tags.Object3D);
      const animState = e.get(Tags.SpriteAnimation);
      const rabbitState = e.get(JumpingRabbit);
      const isJumpClip = animState.frame >= 18 && animState.frame < 35;

      if (isJumpClip) {
        // if we are in a 'hopping' clip, make sure to move
        mesh.position.x += rabbitState.left ? rabbitState.size * 0.43 : -rabbitState.size * 0.43;
      } // determine if next clip should be another jump or idle


      if (rabbitState.state === "jumping") {
        animState.loopStart = 18;
        animState.loopEnd = 35;
      } else if (rabbitState.state === "idle") {
        animState.loopStart = 0;
        animState.loopEnd = 18;
      }

      animState.frame = animState.loopStart;
      animState.dirty = true; // also at this point turn the rabbit if we haven't already

      if (rabbitState.left !== rabbitState.newLeft) {
        rabbitState.left = rabbitState.newLeft;
        (0, _EditorWayfinderSprite.setSpriteFlip)(mesh, rabbitState.left);
        mesh.position.x += rabbitState.left ? rabbitState.size * 0.43 : -rabbitState.size * 0.43;
      }
    }; // Lazily load sprite sheet based on when it's first added to scene


    e.add(Tags.SpriteAnimationLazyLoadSheet);
    const lazy = e.get(Tags.SpriteAnimationLazyLoadSheet);
    lazy.id = "spritesheets/jumpingrabbit";
  }
}
},{"../../util/math":"src/util/math.js","../../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../../util/Random":"src/util/Random.js","../../util/water-util":"src/util/water-util.js","canvas-sketch-util/math":"node_modules/canvas-sketch-util/math.js","../../util/EditorWayfinderSprite":"src/util/EditorWayfinderSprite.js"}],"src/systems/OriginTreeSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = OriginTreeSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _Assets = _interopRequireDefault(require("../util/Assets"));

var ShaderManager = _interopRequireWildcard(require("../util/ShaderManager"));

var _array = require("../util/array");

var _queryString = _interopRequireDefault(require("../util/query-string"));

var _resetPlayerPos = require("../util/resetPlayerPos");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function PhysicsBody() {
  this.position = new THREE.Vector3(0, 0, 0);
  this.velocity = new THREE.Vector3(0, 0, 0);
  this.lastPosition = new THREE.Vector3(0, 0, 0);
  this.speed = 1;
  this.scale = 1;
  this.timeScale = 1;
  this.currentRotation = new THREE.Quaternion(0, 0, 0, 0);
  this.spinRotation = new THREE.Quaternion(0, 0, 0, 0); // this.targetRotation = new THREE.Quaternion(0, 0, 0, 0);

  this.flatRotation = new THREE.Quaternion(0, 0, 0, 0);
  this.rotationAxis = new THREE.Vector3(0, 0, 0);
  this.rotationSpeed = 1;
  this.rotationAngleOffset = 0;
}

function OriginTreeSystem(world) {
  const random = (0, _Random.default)();
  const tmpArray2 = [0, 0];
  const tmpVec3 = new THREE.Vector3(0, 0, 0);
  const tmpReflect3 = new THREE.Vector3(0, 0, 0);
  const tmpArr3 = [0, 0, 0];
  const renderer = world.findTag(Tags.Renderer);
  const anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy());

  const [leaf] = _Assets.default.createGPUTextureTask(renderer, "image/ui/ico_about", {
    anisotropy
  });

  const tmpQuat = new THREE.Quaternion(0, 0, 0, 1);
  const floorRotation = new THREE.Quaternion(0, 0, 0, 1);
  floorRotation.setFromEuler(new THREE.Euler(-Math.PI / 2, 0, 0));
  const N = 1000;
  const parentGroup = new THREE.Group();
  const velocityThreshold = 0.05;

  const newCooldownDelay = () => random.range(0.1, 0.3);

  let hitCooldownDelay = newCooldownDelay();
  let hitCooldownTime = 0;
  const geometry = new THREE.PlaneBufferGeometry(1, 1, 4, 4); // geometry.rotateX(-Math.PI / 2);

  const instancedBufferGeom = new THREE.InstancedBufferGeometry();
  instancedBufferGeom.instanceCount = N;
  instancedBufferGeom.setAttribute("position", geometry.getAttribute("position"));
  instancedBufferGeom.setAttribute("normal", geometry.getAttribute("normal"));
  instancedBufferGeom.setAttribute("uv", geometry.getAttribute("uv"));
  instancedBufferGeom.setIndex(geometry.getIndex());
  /*
  Per-instance stats:
  - Position3D
  - Quaternion4D
  - Color
  - Scale 1f
  - 3 + 4 + 3 + 1
  - 11 floats per instance
  Dynamic: position3, quaternion4
  - 7K floats need updating per frame
    Static: color3, scale1f
  */

  const buf_position = new Float32Array(3 * N);
  const buf_rotation = new Float32Array(4 * N);
  const buf_color = new Float32Array(3 * N);
  const buf_scaleAndTimeOffset = new Float32Array(2 * N);
  const tmpQuaternion = new THREE.Quaternion();
  const minY = 0.1;
  const spriteRadius = 0.1;
  const color = new THREE.Color();
  const baseColor = new THREE.Color("hsl(40, 100%, 50%)");
  const bodies = (0, _array.newArray)(N).map((_, i) => {
    color.copy(baseColor).offsetHSL(random.range(-1, 1) * (5 / 360), random.range(-1, 0) * (5 / 100), random.range(-1, 1) * (10 / 100));
    color.r = MathUtil.clamp(color.r, 0, 1);
    color.g = MathUtil.clamp(color.g, 0, 1);
    color.b = MathUtil.clamp(color.b, 0, 1);
    const curTime = random.range(0, N); // const material = createMaterial({
    //   minY,
    //   spriteRadius,
    //   map: leaf,
    //   time: curTime,
    //   timeOffset: curTime,
    //   // blending: THREE.CustomBlending,
    //   // blendEquation: THREE.AddEquation,
    //   // blendSrc: THREE.OneFactor,
    //   // blendDst: THREE.OneMinusSrcAlphaFactor,
    //   color,
    //   side: THREE.DoubleSide,
    //   // transparent: true,
    // });

    const r = 7;
    const [x, z] = random.onCircle(random.gaussian(r, 2), tmpArray2); // const [x, y, z] = random.insideSphere(r, tmpArr3);
    // const mesh = new THREE.Mesh(geometry, material);
    // parentGroup.add(mesh);
    // mesh.frustumCulled = false;
    // mesh.matrixAutoUpdate = false;
    // const e = world
    //   .entity()
    //   .add(Tags.Object3D, mesh)
    //   .add(Tags.GroundPhysicsBody);
    // const body = e.get(Tags.GroundPhysicsBody);

    const body = new PhysicsBody();
    body.timeScale = random.range(1, 1);
    body.position.set(x, random.range(0, 4), z);
    body.rotationAxis.fromArray(random.insideSphere(1, tmpArr3));
    body.rotationAngleOffset = random.range(-1, 1) * Math.PI * 2;
    body.rotationSpeed = random.range(0.1, 1);
    const euler = new THREE.Euler(0, 0, 0);
    euler.x = -Math.PI / 2 + random.range(-1, 1) * 0.1;
    euler.z = random.range(-1, 1) * Math.PI * 2;
    tmpQuaternion.setFromEuler(euler);
    body.spinRotation.copy(tmpQuaternion);
    body.flatRotation.copy(tmpQuaternion); // body.targetRotation.copy(tmpQuaternion);

    body.currentRotation.copy(tmpQuaternion);
    body.speed = random.range(0.5, 1.5);
    body.scale = Math.abs(random.gaussian(0.75, 0.1));
    body.velocity.copy(body.position).normalize().multiplyScalar(random.gaussian(1, 1 / 4)); // mesh.userData.entity = e;
    // mesh.visible = false;

    buf_color[i * 3 + 0] = color.r;
    buf_color[i * 3 + 1] = color.g;
    buf_color[i * 3 + 2] = color.b;
    buf_scaleAndTimeOffset[i * 2 + 0] = body.scale;
    buf_scaleAndTimeOffset[i * 2 + 1] = curTime;
    return {
      // mesh,
      body
    };
  });
  instancedBufferGeom.setAttribute("instanceColor", new THREE.InstancedBufferAttribute(buf_color, 3));
  const instancePosition = new THREE.InstancedBufferAttribute(buf_position, 3);
  instancedBufferGeom.setAttribute("instancePosition", instancePosition);
  const instanceRotation = new THREE.InstancedBufferAttribute(buf_rotation, 4);
  instancedBufferGeom.setAttribute("instanceRotation", instanceRotation);
  instancedBufferGeom.setAttribute("instanceScaleAndTime", new THREE.InstancedBufferAttribute(buf_scaleAndTimeOffset, 2));
  const material = createMaterial({
    minY,
    spriteRadius,
    map: leaf,
    time: 0,
    timeOffset: 0,
    side: THREE.DoubleSide
  });
  const instanceMesh = new THREE.Mesh(instancedBufferGeom, material);
  parentGroup.add(instanceMesh);
  parentGroup.name = "origin-tree-leaves";
  instanceMesh.frustumCulled = false;
  var Cd = 0.47; // Dimensionless

  var rho = 1.22; // kg / m^3

  var radius = 15;
  var A = Math.PI * radius * radius / 10000; // m^2

  var gravity = -9.81 * 0.1; // m / s^2

  var mass = 0.05;
  var restitution = -0.7;
  var maxVel = 4;
  const kickStrength = new THREE.Vector3(1, 1, 1);
  const EPSILON = 0.000001;
  const visibleDistanceMin = 40;
  const visibleDistanceMax = 45; // const visibleDistanceSq = visibleDistance * visibleDistance;
  // const bodies = world.view([Tags.Object3D, Tags.GroundPhysicsBody]);

  const parentEntity = world.entity();
  parentEntity.add(Tags.Object3D, parentGroup);
  const hitSoundEntity = world.entity();
  let fadeTime = 0;
  let fadeDuration = 2;
  return function originTreeSystem(dt) {
    if (!world.findTag(Tags.AppState).ready) return;
    const isStopping = world.findTag(Tags.CameraStopUserMovement);
    let hasHitAudio = false;

    if (hitSoundEntity.has(Tags.UserHitAudioTrigger)) {
      hasHitAudio = true;
      hitCooldownTime += dt;

      if (hitCooldownTime >= hitCooldownDelay) {
        hasHitAudio = false;
        hitCooldownTime %= hitCooldownDelay;
        hitCooldownDelay = newCooldownDelay();
        hitSoundEntity.remove(Tags.UserHitAudioTrigger);
      }
    }

    const user = world.findTag(Tags.UserCharacter);
    const userTarget = world.findTag(Tags.UserTarget);
    const userPos = user.position;
    const userVel = user.velocity;
    const userVelLengthSq = userVel.lengthSq();
    const userVelLength = Math.sqrt(userVelLengthSq);
    const hitDist = 2;
    const hitDistSq = hitDist * hitDist;
    const userDist = userTarget.position.length();
    const visibleSize = 1 - MathUtil.clamp01(MathUtil.smoothstep(visibleDistanceMin, visibleDistanceMax, userDist));
    let isVisible = true;

    if (userDist >= visibleDistanceMax) {
      if (parentEntity.has(Tags.Object3D)) parentEntity.remove(Tags.Object3D);
      isVisible = false;
    } else {
      if (!parentEntity.has(Tags.Object3D)) parentEntity.add(Tags.Object3D, parentGroup);
    }

    let audibleHits = 0;
    let resolving = world.findTag(Tags.FinalBiomeResolution);

    if (resolving) {
      fadeTime += dt;
      material.uniforms.fadeAway.value = -2 + fadeTime;
    } else {
      material.uniforms.fadeAway.value = 0;
    }

    for (let i = 0; isVisible && i < bodies.length; i++) {
      const e = bodies[i];
      const d = e.body; // apply user forces

      if (!isStopping && userVelLengthSq > EPSILON) {
        const distSq = d.position.distanceToSquared(userPos);

        if (distSq <= hitDistSq) {
          if (userVelLength > velocityThreshold && !hasHitAudio) {
            audibleHits++;
          }

          const dist = Math.sqrt(distSq);
          const alpha = 1 - MathUtil.clamp01(dist / hitDist);
          d.velocity.x += userVel.x * kickStrength.x;
          d.velocity.z += userVel.z * kickStrength.z;

          if (d.position.y - spriteRadius <= minY + EPSILON) {
            d.position.y = minY + EPSILON + spriteRadius;
          }

          const invLerp = MathUtil.clamp01(MathUtil.inverseLerp(minY, 1, d.position.y - spriteRadius));
          const heightStr = 1 - invLerp;
          d.velocity.y += random.range(0, 1) * kickStrength.y * userVelLength * heightStr;
          tmpVec3.fromArray(random.insideSphere(1, tmpArr3));
          d.velocity.addScaledVector(tmpVec3, random.range(0.5, 1));
        }
      } // clamp velocity


      d.velocity.x = MathUtil.clamp(d.velocity.x, -maxVel, maxVel);
      d.velocity.y = MathUtil.clamp(d.velocity.y, -maxVel, maxVel);
      d.velocity.z = MathUtil.clamp(d.velocity.z, -maxVel, maxVel); // now test against floor bounce

      let hit = false;

      if (d.position.y - spriteRadius < minY) {
        hit = true;
        d.position.y = minY + spriteRadius + EPSILON;
      }

      if (hit) {
        // bounce against ground
        const len2 = d.velocity.lengthSq();

        if (len2 > EPSILON) {
          // only bounce if moving enough
          const m = Math.sqrt(len2); // scale reflection by magnitude

          tmpReflect3.set(1, -1, 1);
          const friction = 0.25;
          tmpReflect3.multiplyScalar(m * friction); // normalize the velocity

          if (m !== 0) {
            d.velocity.divideScalar(m);
          } // bounce velocity back


          d.velocity.multiply(tmpReflect3);
        }
      }

      var vx = d.velocity.x;
      var vy = d.velocity.y;
      var vz = d.velocity.z;
      var Fx = -0.5 * Cd * A * rho * vx * vx * vx / Math.abs(vx);
      var Fy = -0.5 * Cd * A * rho * vy * vy * vy / Math.abs(vy);
      var Fz = -0.5 * Cd * A * rho * vz * vz * vz / Math.abs(vz);
      Fx = isNaN(Fx) ? 0 : Fx;
      Fy = isNaN(Fy) ? 0 : Fy;
      Fz = isNaN(Fz) ? 0 : Fz; // Calculate acceleration ( F = ma )

      var ax = Fx / mass;
      var ay = Fy / mass;
      var az = Fz / mass;
      ay += gravity; // Integrate to get velocity

      d.velocity.x += ax * dt;
      d.velocity.y += ay * dt;
      d.velocity.z += az * dt; // Integrate to get position

      const speed = d.speed;
      d.position.x += d.velocity.x * dt * speed;
      d.position.y += d.velocity.y * dt * speed;
      d.position.z += d.velocity.z * dt * speed;
      const curSpeed = MathUtil.clamp(d.velocity.length() / 0.1, 0, 7.5); // 1 = on floor, 0 = off floor

      const floorProximity = 1 - MathUtil.clamp01(MathUtil.inverseLerp(minY, 0.5, d.position.y - spriteRadius)); // apply world rotation to current

      tmpQuat.setFromAxisAngle(d.rotationAxis, curSpeed * d.rotationSpeed * dt);
      d.spinRotation.premultiply(tmpQuat);
      d.spinRotation.slerp(d.flatRotation, floorProximity * 0.5);
      d.currentRotation.copy(d.spinRotation);
      buf_position[i * 3 + 0] = d.position.x;
      buf_position[i * 3 + 1] = d.position.y;
      buf_position[i * 3 + 2] = d.position.z;
      buf_rotation[i * 4 + 0] = d.currentRotation.x;
      buf_rotation[i * 4 + 1] = d.currentRotation.y;
      buf_rotation[i * 4 + 2] = d.currentRotation.z;
      buf_rotation[i * 4 + 3] = d.currentRotation.w;
    }

    if (isVisible) {
      instanceRotation.needsUpdate = true;
      instancePosition.needsUpdate = true;
      material.uniforms.time.value += dt;
      material.uniforms.globalScale.value = visibleSize;
    }

    instanceMesh.visible = isVisible;

    if (audibleHits > 5) {
      hasHitAudio = true;

      if (!hitSoundEntity.has(Tags.UserHitAudioTrigger)) {
        hitSoundEntity.add(Tags.UserHitAudioTrigger);
        const audioData = hitSoundEntity.get(Tags.UserHitAudioTrigger);
        audioData.type = "leaf";
      } // console.log("audio hits", audibleHits);

    }
  };

  function createMaterial(opts = {}) {
    const {
      map,
      color = "white",
      opacity = 1,
      timeOffset = 0,
      time = 0,
      minY,
      spriteRadius
    } = opts;
    opts = { ...opts
    };
    delete opts.time;
    delete opts.opacity;
    delete opts.color;
    delete opts.map;
    delete opts.spriteRadius;
    delete opts.minY;
    delete opts.timeOffset;
    return ShaderManager.create({
      name: "origin-tree-leaves",
      uniforms: {
        color: {
          value: new THREE.Color(color)
        },
        map: {
          value: map
        },
        time: {
          value: time
        },
        globalScale: {
          value: 1
        },
        opacity: {
          value: opacity
        },
        straighten: {
          value: 0
        },
        minY: {
          value: minY
        },
        spriteRadius: {
          value: spriteRadius
        },
        fadeAway: {
          value: 0
        },
        timeOffset: {
          value: timeOffset
        }
      },
      ...opts,
      // blending: THREE.CustomBlending,
      // blendEquation: THREE.AddEquation,
      // blendSrc: THREE.OneFactor,
      // blendDst: THREE.OneMinusSrcAlphaFactor,
      vertexShader:
      /*glsl*/
      `
        attribute vec3 instancePosition;
        attribute vec4 instanceRotation;
        attribute vec3 instanceColor;
        attribute vec2 instanceScaleAndTime;
        varying vec2 vUv;
        varying vec3 vNormal;
        uniform float mapScale;
        // uniform float timeOffset;
        uniform float time;
        // uniform float straighten;
        varying float vStraighten;
        uniform float globalScale;
        uniform float spriteRadius;
        uniform float minY;
        uniform float fadeAway;
        varying vec3 vColor;

        mat3 rotation3dY(float angle) {
        	float s = sin(angle);
        	float c = cos(angle);

        	return mat3(
        		c, 0.0, -s,
        		0.0, 1.0, 0.0,
        		s, 0.0, c
        	);
        }

        float invLerp (float minV, float maxV, float t) {
          return (t - minV) / (maxV - minV);
        }

        vec3 rotate_vector( vec4 quat, vec3 vec ) {
          return vec + 2.0 * cross( cross( vec, quat.xyz ) + quat.w * vec, quat.xyz );
        }

        float ease (float t) {
          return 1.0 - pow(2.0, -10.0 * t);
        }

        // http://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/,
        vec3 applyTRS( vec3 position, vec3 translation, vec4 quaternion, vec3 scale ) {
        	position *= scale;
        	position += 2.0 * cross( quaternion.xyz, cross( quaternion.xyz, position ) + quaternion.w * position );
        	return position + translation;
        }

        void main () {
          vUv = uv;
          vec3 transformed = position.xyz;
          
          vColor = instanceColor;
          vec3 worldCenter = (modelMatrix * vec4(vec3(instancePosition), 1.0)).xyz;

          float straighten = 1.0 - clamp(invLerp(minY, 1.0, worldCenter.y - spriteRadius), 0.0, 1.0);
          vStraighten = straighten;

          float timeOffset = instanceScaleAndTime.y;
          float angle = 3.14 * sin(time + timeOffset + position.x);
          transformed *= rotation3dY(angle * (1.0 - straighten));

          vec3 transformedNormal = normal;
          vec4 invQuat = vec4(-instanceRotation.xyz, instanceRotation.w);
          float nAngle = (3.14 / -1.0 + 3.14 * sin(position.x)) * (1.0 - straighten);
          transformedNormal = normalize(transformedNormal * rotation3dY(nAngle));
          transformedNormal = normalize(rotate_vector(invQuat, transformedNormal));
          transformedNormal = normalize(normalMatrix * transformedNormal);

          vNormal = transformedNormal;

          float dFromCenter = 1.0 - length(instancePosition.xz) / 20.0;
          float disappear = 1.0 - min(1.0, ease(max(fadeAway - dFromCenter * 2.0, 0.0) / (4.0)));
          transformed = applyTRS(transformed, instancePosition, instanceRotation, vec3(disappear * globalScale * instanceScaleAndTime.x));

          gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
        }
      `,
      fragmentShader:
      /*glsl*/
      `
        varying vec2 vUv;
        varying float vStraighten;
        varying vec3 vNormal;
        varying vec3 vColor;
        uniform sampler2D map;
        uniform float opacity;
        // uniform vec3 color;
        void main () {
          gl_FragColor = vec4(vColor, opacity) * texture2D(map, vUv);
          // gl_FragColor.rgb *= 1.0 - (1.0 - (vNormal.y * 0.5 + 0.5)) * 0.25;
          // gl_FragColor.rgb += (1.0 - (vNormal.y * 0.5 + 0.5)) * 1.0 * (1.0 - vStraighten);
          float grad = (1.0 - (vNormal.y * 0.5 + 0.5));
          gl_FragColor.rgb += (1.0 - vStraighten) * 0.25 + grad * 0.5;
          if (!gl_FrontFacing) gl_FragColor.rgb *= 0.5;

          // gl_FragColor = vec4(vec3((1.0-(vNormal.y * 0.5 + 0.5))), 1.0);
          // gl_FragColor = vec4(vec3(vNormal.y * 0.5 + 0.5), 1.0);
          if (gl_FragColor.a < 0.5) discard;
        }
      `
    });
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/math":"src/util/math.js","../util/Random":"src/util/Random.js","../util/Assets":"src/util/Assets.js","../util/ShaderManager":"src/util/ShaderManager.js","../util/array":"src/util/array.js","../util/query-string":"src/util/query-string.js","../util/resetPlayerPos":"src/util/resetPlayerPos.js"}],"src/overlays/OriginTreeIntroOverlay.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _svelte = require("svelte");

var _store = require("svelte/store");

var _nfb = require("../nfb");

var _transitions = require("../animations/transitions");

var _AnimatedTextSpan = _interopRequireDefault(require("../components/AnimatedTextSpan.svelte"));

var _locale = require("../util/locale");

var _ImageButton = _interopRequireDefault(require("../components/ImageButton.svelte"));

var _globalIntroVideo = require("../util/globalIntroVideo");

var _objectFit = _interopRequireDefault(require("../util/objectFit"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* overlays/OriginTreeIntroOverlay.svelte generated by Svelte v3.31.0 */
const {
  window: window_1
} = _internal.globals;

function create_if_block_3(ctx) {
  let div;
  let t_value =
  /*$localize*/
  ctx[5][
  /*texts*/
  ctx[1][0].key] + "";
  let t;
  let div_intro;
  let div_outro;
  let current;
  return {
    c() {
      div = (0, _internal.element)("div");
      t = (0, _internal.text)(t_value);
      (0, _internal.attr)(div, "class", "text-container svelte-qit7e6");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.append)(div, t);
      current = true;
    },

    p(ctx, dirty) {
      if ((!current || dirty &
      /*$localize, texts*/
      34) && t_value !== (t_value =
      /*$localize*/
      ctx[5][
      /*texts*/
      ctx[1][0].key] + "")) (0, _internal.set_data)(t, t_value);
    },

    i(local) {
      if (current) return;
      (0, _internal.add_render_callback)(() => {
        if (div_outro) div_outro.end(1);
        if (!div_intro) div_intro = (0, _internal.create_in_transition)(div, _transitions.fadeInTransition, {
          duration: 1000,
          delay: 0
        });
        div_intro.start();
      });
      current = true;
    },

    o(local) {
      if (div_intro) div_intro.invalidate();
      div_outro = (0, _internal.create_out_transition)(div, _transitions.fadeInTransition, {
        duration: 1000,
        delay: 0
      });
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      if (detaching && div_outro) div_outro.end();
    }

  };
} // (201:2) {#if texts[1].visible}


function create_if_block_2(ctx) {
  let div;
  let t_value =
  /*$localize*/
  ctx[5][
  /*texts*/
  ctx[1][1].key] + "";
  let t;
  let div_intro;
  let div_outro;
  let current;
  return {
    c() {
      div = (0, _internal.element)("div");
      t = (0, _internal.text)(t_value);
      (0, _internal.attr)(div, "class", "text-container svelte-qit7e6");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.append)(div, t);
      current = true;
    },

    p(ctx, dirty) {
      if ((!current || dirty &
      /*$localize, texts*/
      34) && t_value !== (t_value =
      /*$localize*/
      ctx[5][
      /*texts*/
      ctx[1][1].key] + "")) (0, _internal.set_data)(t, t_value);
    },

    i(local) {
      if (current) return;
      (0, _internal.add_render_callback)(() => {
        if (div_outro) div_outro.end(1);
        if (!div_intro) div_intro = (0, _internal.create_in_transition)(div, _transitions.fadeInTransition, {
          duration: 1000,
          delay: 0
        });
        div_intro.start();
      });
      current = true;
    },

    o(local) {
      if (div_intro) div_intro.invalidate();
      div_outro = (0, _internal.create_out_transition)(div, _transitions.fadeInTransition, {
        duration: 1000,
        delay: 0
      });
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      if (detaching && div_outro) div_outro.end();
    }

  };
} // (217:2) {#if texts[2].visible}


function create_if_block_1(ctx) {
  let div;
  let t_value =
  /*$localize*/
  ctx[5][
  /*texts*/
  ctx[1][2].key] + "";
  let t;
  let div_intro;
  let div_outro;
  let current;
  return {
    c() {
      div = (0, _internal.element)("div");
      t = (0, _internal.text)(t_value);
      (0, _internal.attr)(div, "class", "text-container svelte-qit7e6");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.append)(div, t);
      current = true;
    },

    p(ctx, dirty) {
      if ((!current || dirty &
      /*$localize, texts*/
      34) && t_value !== (t_value =
      /*$localize*/
      ctx[5][
      /*texts*/
      ctx[1][2].key] + "")) (0, _internal.set_data)(t, t_value);
    },

    i(local) {
      if (current) return;
      (0, _internal.add_render_callback)(() => {
        if (div_outro) div_outro.end(1);
        if (!div_intro) div_intro = (0, _internal.create_in_transition)(div, _transitions.fadeInTransition, {
          duration: 1000,
          delay: 0
        });
        div_intro.start();
      });
      current = true;
    },

    o(local) {
      if (div_intro) div_intro.invalidate();
      div_outro = (0, _internal.create_out_transition)(div, _transitions.fadeInTransition, {
        duration: 1000,
        delay: 0
      });
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      if (detaching && div_outro) div_outro.end();
    }

  };
} // (250:2) {#if isWhite}


function create_if_block(ctx) {
  let div;
  let div_intro;
  return {
    c() {
      div = (0, _internal.element)("div");
      (0, _internal.attr)(div, "class", "white-overlay svelte-qit7e6");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
    },

    i(local) {
      if (!div_intro) {
        (0, _internal.add_render_callback)(() => {
          div_intro = (0, _internal.create_in_transition)(div, _transitions.fadeInTransition, {
            opacity: 0,
            delay: 0,
            duration: 500,
            y: 0
          });
          div_intro.start();
        });
      }
    },

    o: _internal.noop,

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
    }

  };
}

function create_fragment(ctx) {
  let div3;
  let div0;
  let div0_intro;
  let t0;
  let div1;
  let div1_intro;
  let t1;
  let t2;
  let t3;
  let t4;
  let div2;
  let imagebutton;
  let t5;
  let div3_outro;
  let current;
  let mounted;
  let dispose;
  let if_block0 =
  /*texts*/
  ctx[1][0].visible && create_if_block_3(ctx);
  let if_block1 =
  /*texts*/
  ctx[1][1].visible && create_if_block_2(ctx);
  let if_block2 =
  /*texts*/
  ctx[1][2].visible && create_if_block_1(ctx);
  imagebutton = new _ImageButton.default({
    props: {
      inTransition: (0, _transitions.transition)(_transitions.fadeInTransition, {
        delay: 2500
      }),
      mode: "normal_small",
      text:
      /*$localize*/
      ctx[5].skipButton
    }
  });
  imagebutton.$on("click",
  /*click_handler*/
  ctx[13]);
  let if_block3 =
  /*isWhite*/
  ctx[2] && create_if_block(ctx);
  return {
    c() {
      div3 = (0, _internal.element)("div");
      div0 = (0, _internal.element)("div");
      t0 = (0, _internal.space)();
      div1 = (0, _internal.element)("div");
      t1 = (0, _internal.space)();
      if (if_block0) if_block0.c();
      t2 = (0, _internal.space)();
      if (if_block1) if_block1.c();
      t3 = (0, _internal.space)();
      if (if_block2) if_block2.c();
      t4 = (0, _internal.space)();
      div2 = (0, _internal.element)("div");
      (0, _internal.create_component)(imagebutton.$$.fragment);
      t5 = (0, _internal.space)();
      if (if_block3) if_block3.c();
      (0, _internal.attr)(div0, "class", "black-overlay svelte-qit7e6");
      (0, _internal.attr)(div1, "class", "intro-video-container svelte-qit7e6");
      (0, _internal.attr)(div2, "class", "button-container svelte-qit7e6");
      (0, _internal.attr)(div3, "class", "intro svelte-qit7e6");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div3, anchor);
      (0, _internal.append)(div3, div0);
      /*div0_binding*/

      ctx[10](div0);
      (0, _internal.append)(div3, t0);
      (0, _internal.append)(div3, div1);
      /*div1_binding*/

      ctx[12](div1);
      (0, _internal.append)(div3, t1);
      if (if_block0) if_block0.m(div3, null);
      (0, _internal.append)(div3, t2);
      if (if_block1) if_block1.m(div3, null);
      (0, _internal.append)(div3, t3);
      if (if_block2) if_block2.m(div3, null);
      (0, _internal.append)(div3, t4);
      (0, _internal.append)(div3, div2);
      (0, _internal.mount_component)(imagebutton, div2, null);
      (0, _internal.append)(div3, t5);
      if (if_block3) if_block3.m(div3, null);
      current = true;

      if (!mounted) {
        dispose = [(0, _internal.listen)(window_1, "resize",
        /*onScreenResize*/
        ctx[6], {
          passive: true
        }), (0, _internal.listen)(div0, "introend",
        /*introend_handler*/
        ctx[11]), (0, _internal.listen)(div3, "outrostart",
        /*outrostart_handler*/
        ctx[14]), (0, _internal.listen)(div3, "outroend",
        /*outroend_handler*/
        ctx[15])];
        mounted = true;
      }
    },

    p(ctx, [dirty]) {
      if (
      /*texts*/
      ctx[1][0].visible) {
        if (if_block0) {
          if_block0.p(ctx, dirty);

          if (dirty &
          /*texts*/
          2) {
            (0, _internal.transition_in)(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx);
          if_block0.c();
          (0, _internal.transition_in)(if_block0, 1);
          if_block0.m(div3, t2);
        }
      } else if (if_block0) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        (0, _internal.check_outros)();
      }

      if (
      /*texts*/
      ctx[1][1].visible) {
        if (if_block1) {
          if_block1.p(ctx, dirty);

          if (dirty &
          /*texts*/
          2) {
            (0, _internal.transition_in)(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2(ctx);
          if_block1.c();
          (0, _internal.transition_in)(if_block1, 1);
          if_block1.m(div3, t3);
        }
      } else if (if_block1) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        (0, _internal.check_outros)();
      }

      if (
      /*texts*/
      ctx[1][2].visible) {
        if (if_block2) {
          if_block2.p(ctx, dirty);

          if (dirty &
          /*texts*/
          2) {
            (0, _internal.transition_in)(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1(ctx);
          if_block2.c();
          (0, _internal.transition_in)(if_block2, 1);
          if_block2.m(div3, t4);
        }
      } else if (if_block2) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        (0, _internal.check_outros)();
      }

      const imagebutton_changes = {};
      if (dirty &
      /*$localize*/
      32) imagebutton_changes.text =
      /*$localize*/
      ctx[5].skipButton;
      imagebutton.$set(imagebutton_changes);

      if (
      /*isWhite*/
      ctx[2]) {
        if (if_block3) {
          if (dirty &
          /*isWhite*/
          4) {
            (0, _internal.transition_in)(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block(ctx);
          if_block3.c();
          (0, _internal.transition_in)(if_block3, 1);
          if_block3.m(div3, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
    },

    i(local) {
      if (current) return;

      if (!div0_intro) {
        (0, _internal.add_render_callback)(() => {
          div0_intro = (0, _internal.create_in_transition)(div0, _transitions.fadeInTransition, {
            delay: 0,
            duration: 1000,
            y: 0
          });
          div0_intro.start();
        });
      }

      if (!div1_intro) {
        (0, _internal.add_render_callback)(() => {
          div1_intro = (0, _internal.create_in_transition)(div1, _transitions.fadeOpacityTransition, {
            delay: 1000,
            duration: 500
          });
          div1_intro.start();
        });
      }

      (0, _internal.transition_in)(if_block0);
      (0, _internal.transition_in)(if_block1);
      (0, _internal.transition_in)(if_block2);
      (0, _internal.transition_in)(imagebutton.$$.fragment, local);
      (0, _internal.transition_in)(if_block3);
      if (div3_outro) div3_outro.end(1);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(if_block0);
      (0, _internal.transition_out)(if_block1);
      (0, _internal.transition_out)(if_block2);
      (0, _internal.transition_out)(imagebutton.$$.fragment, local);
      div3_outro = (0, _internal.create_out_transition)(div3, _transitions.fadeOpacityTransition, {
        delay: 1250,
        duration: 1500
      });
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div3);
      /*div0_binding*/

      ctx[10](null);
      /*div1_binding*/

      ctx[12](null);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      (0, _internal.destroy_component)(imagebutton);
      if (if_block3) if_block3.d();
      if (detaching && div3_outro) div3_outro.end();
      mounted = false;
      (0, _internal.run_all)(dispose);
    }

  };
}

let showRotate = false; // setTimeout(() => {
//   texts[0].visible = false;
//   texts[1].visible = true;
// }, delay + texts[0].delay + texts[0].duration);

let time = 0;

function kill(e) {
  console.log("kill", e);
}

function instance($$self, $$props, $$invalidate) {
  let $localize;
  (0, _internal.component_subscribe)($$self, _locale.localize, $$value => $$invalidate(5, $localize = $$value));
  let {
    store
  } = $$props;
  let {
    delay = 0
  } = $$props;
  let {
    duration = 33
  } = $$props;
  const isMobile = /(Android|iOS|iPad|iPod|iPhone)/i.test(navigator.userAgent);
  let texts = [{
    visible: false,
    key: "introVideoLine0",
    timestamp: 2000,
    delay: 0,
    duration: 4250
  }, {
    visible: false,
    key: "introVideoLine1",
    timestamp: 14000,
    duration: 4500,
    delay: 0
  }, {
    visible: false,
    key: "introVideoLine2",
    timestamp: 23000,
    duration: 5000,
    delay: 0
  }];
  let isWhite = false;
  let videoContainer;
  let visible;
  let timer;
  let overlay;
  let unsub = store.subscribe(v => {
    visible = v.visible;
  });
  let textTimeout;
  let textYPosition;
  texts.forEach((t, i) => {
    setTimeout(() => {
      // t.visible = true;
      $$invalidate(1, texts[i].visible = true, texts);
      $$invalidate(1, texts);
      setTimeout(() => {
        $$invalidate(1, texts[i].visible = false, texts);
        $$invalidate(1, texts);
      }, t.duration);
    }, t.timestamp);
  });
  (0, _svelte.onMount)(() => {
    if (videoContainer) {
      const video = (0, _globalIntroVideo.getVideo)();
      videoContainer.appendChild(video);
      video.style.visibility = "";
      (0, _globalIntroVideo.getMetadata)().then(() => {
        resizeVideo();
      });
    } // store.update((d) => ({ ...d, visible: true }));
    // if (video) video.play();


    timer = setTimeout(() => {
      (0, _nfb.sendAnalytics)({
        event: "intro_finish",
        eventLabel: "finish"
      });
      stop();
    }, duration * 1000);
    return () => {
      unsub();
      (0, _globalIntroVideo.unmountVideo)(); // if (video) video.pause();

      clearTimeout(textTimeout);
      clearTimeout(timer);
    };
  });

  function resizeVideo() {
    const aspect = window.innerWidth / window.innerHeight;
    const video = (0, _globalIntroVideo.hasVideo)() ? (0, _globalIntroVideo.getVideo)() : null;

    if (video) {
      const [tx, ty, sw, sh] = (0, _objectFit.default)({
        parentWidth: window.innerWidth,
        parentHeight: window.innerHeight,
        childWidth: video.videoWidth,
        childHeight: video.videoHeight,
        fit: "cover"
      });
      Object.assign(video.style, {
        left: `${tx}px`,
        top: `${ty}px`,
        width: `${sw}px`,
        height: `${sh}px`
      });
      const fontHeight = 32;
    } // textYPosition = window.innerHeight * 0.895;

  }

  function onScreenResize() {
    if (!(0, _globalIntroVideo.hasVideo)()) return;
    const video = (0, _globalIntroVideo.getVideo)();

    if (video.readyState <= 0) {
      (0, _globalIntroVideo.getMetadata)().then(() => resizeVideo());
    } else {
      resizeVideo();
    }
  }

  function stop() {
    $$invalidate(2, isWhite = true);
    (0, _globalIntroVideo.pauseVideo)();
    clearTimeout(timer);
    store.update(d => ({ ...d,
      visible: false
    }));
  }

  function div0_binding($$value) {
    _internal.binding_callbacks[$$value ? "unshift" : "push"](() => {
      overlay = $$value;
      $$invalidate(4, overlay);
    });
  }

  const introend_handler = () => store.update(d => ({ ...d,
    covering: true
  }));

  function div1_binding($$value) {
    _internal.binding_callbacks[$$value ? "unshift" : "push"](() => {
      videoContainer = $$value;
      $$invalidate(3, videoContainer);
    });
  }

  const click_handler = () => {
    (0, _nfb.sendAnalytics)({
      event: "intro_skip",
      eventLabel: "skip"
    });
    stop();
  };

  const outrostart_handler = () => store.update(d => ({ ...d,
    covering: false
  }));

  const outroend_handler = () => store.update(d => ({ ...d,
    finished: true
  }));

  $$self.$$set = $$props => {
    if ("store" in $$props) $$invalidate(0, store = $$props.store);
    if ("delay" in $$props) $$invalidate(8, delay = $$props.delay);
    if ("duration" in $$props) $$invalidate(9, duration = $$props.duration);
  };

  return [store, texts, isWhite, videoContainer, overlay, $localize, onScreenResize, stop, delay, duration, div0_binding, introend_handler, div1_binding, click_handler, outrostart_handler, outroend_handler];
}

class OriginTreeIntroOverlay extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      store: 0,
      delay: 8,
      duration: 9
    });
  }

}

var _default = OriginTreeIntroOverlay;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","svelte":"node_modules/svelte/index.mjs","svelte/store":"node_modules/svelte/store/index.mjs","../nfb":"src/nfb.js","../animations/transitions":"src/animations/transitions.js","../components/AnimatedTextSpan.svelte":"src/components/AnimatedTextSpan.svelte.js","../util/locale":"src/util/locale.js","../components/ImageButton.svelte":"src/components/ImageButton.svelte.js","../util/globalIntroVideo":"src/util/globalIntroVideo.js","../util/objectFit":"src/util/objectFit.js"}],"src/systems/OriginTreeIntroSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = OriginTreeIntroSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _Assets = _interopRequireDefault(require("../util/Assets"));

var ShaderManager = _interopRequireWildcard(require("../util/ShaderManager"));

var _array = require("../util/array");

var _queryString = _interopRequireDefault(require("../util/query-string"));

var _resetPlayerPos = _interopRequireWildcard(require("../util/resetPlayerPos"));

var _OriginTreeIntroOverlay = _interopRequireDefault(require("../overlays/OriginTreeIntroOverlay.svelte"));

var _AnimationSystem = require("./AnimationSystem");

var _store = require("svelte/store");

var _nfb = require("../nfb");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function OriginTreeIntroSystem(world) {
  const entity = world.entity();
  const gameStartedEvents = world.listen(Tags.GameStarted);

  if (!_queryString.default.nointroseq && !_queryString.default.nolanding) {
    // TODO
    const activeEnv = world.findEntity(Tags.ActiveEnvironmentState);

    if (activeEnv) {
      const state = activeEnv.get(Tags.EnvironmentState);
      (0, _resetPlayerPos.setPlayerPos)(world, state.idleViewPoint);
    }

    entity.add(Tags.OriginTreeIntroSequence);
    entity.add(Tags.GameLandingCameraDrift);
    entity.tagOn(Tags.CameraZoomOut);
    entity.tagOn(Tags.HideCharacter);
    entity.tagOn(Tags.LetterboxBars);
    entity.tagOn(Tags.HideHUD);
    entity.tagOn(Tags.BlockUserMove);
    entity.tagOn(Tags.CameraStopUserMovement);
    entity.tagOn(Tags.ModalStoppingUserMovement);
    entity.tagOn(Tags.ClearInputPress);
  } else {
    entity.tagOn(Tags.CanSetIntroTags);
  }

  const fades = world.view(Tags.ScreenFade);
  const uiStore = (0, _store.writable)({
    finished: false,
    covering: false,
    visible: false
  });
  const appState = world.findTag(Tags.AppState);
  uiStore.subscribe(v => {
    if (v.covering) {
      appState.running = false;
    } else appState.running = true;

    if (!v.visible && entity.has(Tags.ViewLayer)) {
      entity.remove(Tags.ViewLayer);
      appState.running = true;
      entity.tagOn(Tags.CanSetIntroTags);
      entity.tagOff(Tags.HideHUD);
      entity.tagOff(Tags.OriginTreeIntroSequence);
      entity.tagOff(Tags.CameraStopUserMovement);
      entity.tagOff(Tags.OriginTreeIntroSequenceStarted);
      entity.tagOff(Tags.GameLandingCameraDrift);
      entity.tagOn(Tags.ClearInputPress);
    }

    if (v.finished) {
      entity.tagOff(Tags.HideCharacter);
      entity.tagOff(Tags.CameraZoomOut);
      entity.tagOff(Tags.LetterboxBars);
      entity.tagOff(Tags.BlockUserMove);
      entity.tagOff(Tags.CameraStopUserMovement);
      entity.tagOff(Tags.ModalStoppingUserMovement);
      entity.tagOn(Tags.ClearInputPress);
      entity.tagOn(Tags.AnimateInCharacter);
      (0, _nfb.sendAnalytics)({
        event: "playing",
        eventLabel: "playing"
      });
    }
  });
  let time = 0;
  let delay = 0;
  let isWaitingToKillView = false;
  return function originTreeIntroSystem(dt) {
    const isStopping = world.findTag(Tags.CameraStopUserMovement);
    if (!world.findTag(Tags.AppState).ready) return;
    const isIntroSeq = entity.has(Tags.OriginTreeIntroSequence);

    if (isIntroSeq && gameStartedEvents.changed && gameStartedEvents.added.length > 0) {
      (0, _nfb.hideHeader)();
      entity.add(Tags.OriginTreeIntroSequenceStarted); // entity.get(Tags.GameLandingCameraDrift).fixed = 0.05;
      // entity.tagOff(Tags.LetterboxBars);

      entity.add(Tags.ViewLayer, {
        component: _OriginTreeIntroOverlay.default,
        id: "origin-tree-intro-overlay",
        props: {
          delay: 1250,
          store: uiStore
        }
      });
      uiStore.update(d => ({ ...d,
        visible: true
      })); // fades.forEach((e) => e.kill());
      // const initialDelay = 0.25;
      // const holdOnBlack = 5;
      // isWaitingToKillView = true;
      // time = 0;
      // delay = holdOnBlack + 1;
      // const fadeOut = world.entity().add(Tags.ScreenFade);
      // const d = fadeOut.get(Tags.ScreenFade);
      // d.from = 0;
      // d.duration = 1;
      // d.to = 1;
      // d.delay = initialDelay;
      // d.callbackOnFinish = onBlack;
      // const fadeIn = world.entity().add(Tags.ScreenFade);
      // const d2 = fadeIn.get(Tags.ScreenFade);
      // const holdDelay = 0.5;
      // d2.from = 1;
      // d2.to = 0;
      // d2.duration = 1;
      // d2.callbackOnStart = enableCharacter;
      // d2.callbackOnFinish = disableIntro;
      // d2.delay = holdOnBlack + d.delay + d.duration + holdDelay;
    } // if (isWaitingToKillView) {
    //   time += dt;
    //   if (time >= delay) {
    //     isWaitingToKillView = false;
    //     entity.tagOff(Tags.ViewLayer);
    //   }
    // }

  };

  function clearZoom() {}

  function onBlack() {// resetPlayerPos(world);
  }

  function enableCharacter() {}

  function disableIntro() {
    console.log("DISABLE INTRO!");
    clearZoom();
    entity.tagOff(Tags.HideHUD);
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/math":"src/util/math.js","../util/Random":"src/util/Random.js","../util/Assets":"src/util/Assets.js","../util/ShaderManager":"src/util/ShaderManager.js","../util/array":"src/util/array.js","../util/query-string":"src/util/query-string.js","../util/resetPlayerPos":"src/util/resetPlayerPos.js","../overlays/OriginTreeIntroOverlay.svelte":"src/overlays/OriginTreeIntroOverlay.svelte.js","./AnimationSystem":"src/systems/AnimationSystem.js","svelte/store":"node_modules/svelte/store/index.mjs","../nfb":"src/nfb.js"}],"src/systems/IntroTutorialSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = IntroTutorialSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _resetPlayerPos = _interopRequireDefault(require("../util/resetPlayerPos"));

var _AnimationSystem = require("./AnimationSystem");

var _Line3D = _interopRequireDefault(require("./writing/Line3D"));

var _locale = require("../util/locale");

var _Assets = _interopRequireDefault(require("../util/Assets"));

var _queryString = _interopRequireDefault(require("../util/query-string"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function IntroTutorialSystem(world) {
  const entity = world.entity();
  const tapClickText = /(iOS|Android|iPhone|iPad)/i.test(navigator.userAgent) ? "Tap" : "Click";
  let started = false;
  let hasReset = false;
  let readyToShow = false;
  let waitingToShowCharacter = false;
  const showCharacterDelay = 2;
  let delayTimer = 0;
  let waitingForForce = false;
  let waitingForMovement = false;
  let waitingForVisibleToken = false;
  let waitingForTokenCollect = false;
  let waitingForTokenCollectionHint = false;
  let waitingForSecondToken = false;
  let waitingForHaiku = false;
  let skipIntroMessages = false;
  const tokenCollectionHintDelay = 1.5;
  const moveFromTreeRadius = 10;
  const moveFromTreeRadiusSq = moveFromTreeRadius * moveFromTreeRadius;
  const lastTargetPosition = new THREE.Vector3();
  const messages = world.view(Tags.TutorialMessage);
  const haikuCollectedEvents = world.listen(Tags.FinishedPoem);
  let hasSeenFirstResolve = false;
  const firstResolve = world.listen(Tags.DirectUserToOrigin);
  const cardSavedEvents = world.listen(Tags.HaikuCardSaved);

  const addMessage = (opts = {}) => {
    return world.entity().add(Tags.TutorialMessage, opts);
  };

  if (_queryString.default.resolve) skipIntroMessages = true;
  return dt => {
    const userTarget = world.findTag(Tags.UserTarget);
    const userPos = userTarget.position; // first we reset the character

    const readyToReset = world.findTag(Tags.CanSetIntroTags);

    if (!hasReset && readyToReset) {
      hasReset = true;
      world.findTag(Tags.UserTarget).position.set(0, 0, 0);
      entity.tagOn(Tags.BlockTokenCollection);
      entity.tagOn(Tags.TutorialState); // entity.tagOn(Tags.HideCharacter);
      // entity.tagOn(Tags.HideHUD);

      entity.tagOn(Tags.CameraZoomOut); // entity.tagOn(Tags.LetterboxBars);

      entity.tagOn(Tags.TutorialBarrenGround);
      entity.tagOn(Tags.ClearInputPress); // entity.tagOn(Tags.BlockUserMove);
      // entity.tagOn(Tags.CameraStopUserMovement);
      // entity.tagOn(Tags.ModalStoppingUserMovement);
    }

    const ready = world.findTag(Tags.GameStarted) && readyToReset && !world.findTag(Tags.OriginTreeIntroSequence);

    if (!started && ready) {
      started = true;
      waitingToShowCharacter = true;
    }

    if (waitingToShowCharacter) {
      delayTimer += dt;

      if (delayTimer >= showCharacterDelay) {
        delayTimer = 0;
        waitingToShowCharacter = false; // entity.tagOff(Tags.BlockUserMove);
        // entity.tagOff(Tags.CameraStopUserMovement);
        // entity.tagOff(Tags.ModalStoppingUserMovement);

        waitingForForce = true;

        if (!skipIntroMessages) {
          addMessage({
            id: "tap-to-move",
            // message: `${tapClickText} + Hold to Explore`,
            message: _locale.localize.get().tutorialTapHold,
            iconMode: "finger",
            delay: 1
          });
        }
      }
    }

    if (waitingForForce && userTarget.forceApplied) {
      entity.tagOff(Tags.CameraZoomOut);
      waitingForForce = false;
      waitingForMovement = true;
    }

    if (waitingForMovement) {
      const lenSq = userTarget.position.lengthSq();

      if (lenSq >= moveFromTreeRadiusSq || _queryString.default.resolve) {
        waitingForMovement = false; // messages.forEach((e) => e.kill()); // kill all

        entity.tagOff(Tags.TutorialBarrenGround);
        entity.tagOff(Tags.TutorialState);
        entity.tagOff(Tags.BlockTokenCollection);
        lastTargetPosition.copy(userPos); // addMessage(
        //   "find-token",
        //   "Connect the lost fragments to recover memories"
        // );

        if (!skipIntroMessages) {
          addMessage({
            id: "find-token",
            message: _locale.localize.get().tutorialCollect,
            iconMode: "token-random",
            delay: 3,
            duration: 6
          });
        } // addTextBeyondCharacter(userTarget, ["below the old-wood trees"]);

      }
    }

    if (haikuCollectedEvents.changed) {
      skipIntroMessages = true;
      messages.forEach(e => e.kill()); // kill all
    } // const isResolving = Boolean(world.findTag(Tags.DirectUserToOrigin));
    // if (
    //   !hasSeenFirstResolve &&
    //   isResolving &&
    //   cardSavedEvents.added.length &&
    //   cardSavedEvents.changed
    // ) {
    //   hasSeenFirstResolve = true;
    //   if (!queryString.resolve) {
    //     addMessage({
    //       id: "resolve",
    //       message: localize.get().tutorialResolve,
    //       iconMode: "tree",
    //       delay: 0,
    //       duration: 6,
    //     });
    //   }
    // }

  };
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/resetPlayerPos":"src/util/resetPlayerPos.js","./AnimationSystem":"src/systems/AnimationSystem.js","./writing/Line3D":"src/systems/writing/Line3D.js","../util/locale":"src/util/locale.js","../util/Assets":"src/util/Assets.js","../util/query-string":"src/util/query-string.js"}],"src/overlays/LetterboxBarsOverlay.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _eases = _interopRequireDefault(require("eases"));

var _transition = require("svelte/transition");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* overlays/LetterboxBarsOverlay.svelte generated by Svelte v3.31.0 */
function create_fragment(ctx) {
  let div0;
  let div0_transition;
  let t;
  let div1;
  let div1_transition;
  let current;
  return {
    c() {
      div0 = (0, _internal.element)("div");
      t = (0, _internal.space)();
      div1 = (0, _internal.element)("div");
      (0, _internal.attr)(div0, "class", "letterbox top svelte-1ui17ha");
      (0, _internal.set_style)(div0, "height",
      /*height*/
      ctx[2] + "px");
      (0, _internal.attr)(div1, "class", "letterbox bottom svelte-1ui17ha");
      (0, _internal.set_style)(div1, "height",
      /*height*/
      ctx[2] + "px");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div0, anchor);
      (0, _internal.insert)(target, t, anchor);
      (0, _internal.insert)(target, div1, anchor);
      current = true;
    },

    p(new_ctx, [dirty]) {
      ctx = new_ctx;

      if (!current || dirty &
      /*height*/
      4) {
        (0, _internal.set_style)(div0, "height",
        /*height*/
        ctx[2] + "px");
      }

      if (!current || dirty &
      /*height*/
      4) {
        (0, _internal.set_style)(div1, "height",
        /*height*/
        ctx[2] + "px");
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.add_render_callback)(() => {
        if (!div0_transition) div0_transition = (0, _internal.create_bidirectional_transition)(div0, _transition.fly, {
          delay:
          /*delay*/
          ctx[1],
          easing:
          /*easing*/
          ctx[3],
          duration:
          /*duration*/
          ctx[0],
          y: -
          /*height*/
          ctx[2],
          opacity: 1
        }, true);
        div0_transition.run(1);
      });
      (0, _internal.add_render_callback)(() => {
        if (!div1_transition) div1_transition = (0, _internal.create_bidirectional_transition)(div1, _transition.fly, {
          delay:
          /*delay*/
          ctx[1],
          easing:
          /*easing*/
          ctx[3],
          duration:
          /*duration*/
          ctx[0],
          y:
          /*height*/
          ctx[2],
          opacity: 1
        }, true);
        div1_transition.run(1);
      });
      current = true;
    },

    o(local) {
      if (!div0_transition) div0_transition = (0, _internal.create_bidirectional_transition)(div0, _transition.fly, {
        delay:
        /*delay*/
        ctx[1],
        easing:
        /*easing*/
        ctx[3],
        duration:
        /*duration*/
        ctx[0],
        y: -
        /*height*/
        ctx[2],
        opacity: 1
      }, false);
      div0_transition.run(0);
      if (!div1_transition) div1_transition = (0, _internal.create_bidirectional_transition)(div1, _transition.fly, {
        delay:
        /*delay*/
        ctx[1],
        easing:
        /*easing*/
        ctx[3],
        duration:
        /*duration*/
        ctx[0],
        y:
        /*height*/
        ctx[2],
        opacity: 1
      }, false);
      div1_transition.run(0);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div0);
      if (detaching && div0_transition) div0_transition.end();
      if (detaching) (0, _internal.detach)(t);
      if (detaching) (0, _internal.detach)(div1);
      if (detaching && div1_transition) div1_transition.end();
    }

  };
}

function instance($$self, $$props, $$invalidate) {
  let {
    duration = 1000
  } = $$props;
  let {
    delay = 0
  } = $$props;
  let {
    height = 12.5
  } = $$props;
  let {
    easing = _eases.default.quartOut
  } = $$props;

  $$self.$$set = $$props => {
    if ("duration" in $$props) $$invalidate(0, duration = $$props.duration);
    if ("delay" in $$props) $$invalidate(1, delay = $$props.delay);
    if ("height" in $$props) $$invalidate(2, height = $$props.height);
    if ("easing" in $$props) $$invalidate(3, easing = $$props.easing);
  };

  return [duration, delay, height, easing];
}

class LetterboxBarsOverlay extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      duration: 0,
      delay: 1,
      height: 2,
      easing: 3
    });
  }

}

var _default = LetterboxBarsOverlay;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","eases":"node_modules/eases/index.js","svelte/transition":"node_modules/svelte/transition/index.mjs"}],"src/systems/LetterboxBarsSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = LetterboxBarsSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _LetterboxBarsOverlay = _interopRequireDefault(require("../overlays/LetterboxBarsOverlay.svelte"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function LetterboxBarsSystem(world) {
  const uiEntity = world.entity();
  const letterboxView = world.view(Tags.LetterboxBars);
  return dt => {
    const addBars = world.findTag(Tags.ShowBiomeResolution);
    if (addBars) uiEntity.tagOn(Tags.LetterboxBars);else uiEntity.tagOff(Tags.LetterboxBars);
    const hasLetterboxes = letterboxView.length > 0;

    if (hasLetterboxes) {
      uiEntity.tagOn(Tags.CameraZoomOut);
      showUI();
    } else {
      uiEntity.tagOff(Tags.CameraZoomOut);
      hideUI();
    }
  };

  function showUI() {
    if (!uiEntity.has(Tags.ViewLayer)) {// uiEntity.add(Tags.ViewLayer, {
      //   component: LetterboxBarsOverlay,
      //   id: "letterbox-bars",
      //   props: {
      //   },
      // });
    }
  }

  function hideUI() {
    uiEntity.remove(Tags.ViewLayer);
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../overlays/LetterboxBarsOverlay.svelte":"src/overlays/LetterboxBarsOverlay.svelte.js"}],"src/systems/AnimalSpawnSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = AnimalSpawnSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _waterUtil = require("../util/water-util");

var _Random = _interopRequireDefault(require("../util/Random"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function AnimalSpawnSystem(world) {
  let spawnTimer = 0;
  let maxBirds = 2;
  const types = {
    forest: ["bird"],
    grasslands: ["butterfly"],
    tundra: ["jumpingrabbit"]
  };
  const random = (0, _Random.default)();

  const newSpawnDelay = () => random.range(5, 5);

  let spawnDelay = newSpawnDelay();
  const activeEnv = world.view(Tags.ActiveEnvironmentState);
  const tmpPos = new THREE.Vector3();
  const tmpArr2D = [0, 0];
  const maxAnimalsOnScreen = 2;
  const animalView = world.view(Tags.Animal);
  const animalSpawns = world.view(Tags.AnimalSpawn);
  const underPlayer = world.findTag(Tags.EnvironmentUnderPlayerState);
  const centerRadius = 15;
  const centerRadiusSq = centerRadius * centerRadius;
  const target = world.findTag(Tags.UserTarget);
  let lastPos = null;
  const moveSpawnRadius = 4;
  const moveSpawnRadiusSq = moveSpawnRadius * moveSpawnRadius;
  return dt => {
    const envState = activeEnv.length ? activeEnv[0].get(Tags.EnvironmentState) : null;
    const env = envState && envState.name;
    if (!env || !types[env].length) return;
    let userInWater = underPlayer.water;
    const drifting = world.findTag(Tags.GameLandingCameraDrift);
    const hasMoved = !lastPos || target.position.distanceToSquared(lastPos) >= moveSpawnRadiusSq; // When the user is in the water, trigger fish based on distance to placeholders

    if (!userInWater && !drifting && hasMoved) {
      spawnTimer += dt;

      if (spawnTimer >= spawnDelay) {
        spawnTimer %= spawnDelay;
        spawnDelay = newSpawnDelay();
        if (!lastPos) lastPos = new THREE.Vector3();
        lastPos.copy(target.position);

        if (!world.findTag(Tags.TutorialState)) {
          let valid = false;
          let positionInWater = false;
          let animalType;
          tmpPos.copy(target.position).addScaledVector(target.direction, 25);
          tmpArr2D[0] = tmpPos.x;
          tmpArr2D[1] = tmpPos.z;
          valid = true;
          const dstSq = tmpPos.x * tmpPos.x + tmpPos.z * tmpPos.z;
          if (dstSq < centerRadiusSq) valid = false;

          if (valid) {
            if ((0, _waterUtil.insideWaterPolys)(envState, tmpArr2D)) {
              valid = false;
            }
          }

          if (valid) animalType = random.pick(types[env]);

          if (valid && animalType) {
            console.log("Spawning animals!", animalType, positionInWater);
            const e = world.entity();
            e.add(Tags.AnimalSpawn);
            const s = e.get(Tags.AnimalSpawn);
            s.position.copy(tmpPos);
            s.lake = positionInWater;
            s.biome = env;
            s.animal = animalType;
          }
        }
      }
    } // remove spawns after they are picked up by other systems
    // since some spawns might not trigger any animals depending on conditions


    animalSpawns.forEach(e => {
      const s = e.get(Tags.AnimalSpawn);
      s.time += dt;
      if (s.time >= s.duration) e.kill();
    });
  };
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/water-util":"src/util/water-util.js","../util/Random":"src/util/Random.js"}],"node_modules/animejs/lib/anime.es.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/*
 * anime.js v3.2.1
 * (c) 2020 Julian Garnier
 * Released under the MIT license
 * animejs.com
 */
// Defaults
var defaultInstanceSettings = {
  update: null,
  begin: null,
  loopBegin: null,
  changeBegin: null,
  change: null,
  changeComplete: null,
  loopComplete: null,
  complete: null,
  loop: 1,
  direction: 'normal',
  autoplay: true,
  timelineOffset: 0
};
var defaultTweenSettings = {
  duration: 1000,
  delay: 0,
  endDelay: 0,
  easing: 'easeOutElastic(1, .5)',
  round: 0
};
var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective', 'matrix', 'matrix3d']; // Caching

var cache = {
  CSS: {},
  springs: {}
}; // Utils

function minMax(val, min, max) {
  return Math.min(Math.max(val, min), max);
}

function stringContains(str, text) {
  return str.indexOf(text) > -1;
}

function applyArguments(func, args) {
  return func.apply(null, args);
}

var is = {
  arr: function (a) {
    return Array.isArray(a);
  },
  obj: function (a) {
    return stringContains(Object.prototype.toString.call(a), 'Object');
  },
  pth: function (a) {
    return is.obj(a) && a.hasOwnProperty('totalLength');
  },
  svg: function (a) {
    return a instanceof SVGElement;
  },
  inp: function (a) {
    return a instanceof HTMLInputElement;
  },
  dom: function (a) {
    return a.nodeType || is.svg(a);
  },
  str: function (a) {
    return typeof a === 'string';
  },
  fnc: function (a) {
    return typeof a === 'function';
  },
  und: function (a) {
    return typeof a === 'undefined';
  },
  nil: function (a) {
    return is.und(a) || a === null;
  },
  hex: function (a) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a);
  },
  rgb: function (a) {
    return /^rgb/.test(a);
  },
  hsl: function (a) {
    return /^hsl/.test(a);
  },
  col: function (a) {
    return is.hex(a) || is.rgb(a) || is.hsl(a);
  },
  key: function (a) {
    return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes';
  }
}; // Easings

function parseEasingParameters(string) {
  var match = /\(([^)]+)\)/.exec(string);
  return match ? match[1].split(',').map(function (p) {
    return parseFloat(p);
  }) : [];
} // Spring solver inspired by Webkit Copyright © 2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js


function spring(string, duration) {
  var params = parseEasingParameters(string);
  var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
  var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
  var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
  var velocity = minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;

  function solver(t) {
    var progress = duration ? duration * t / 1000 : t;

    if (zeta < 1) {
      progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
    } else {
      progress = (a + b * progress) * Math.exp(-progress * w0);
    }

    if (t === 0 || t === 1) {
      return t;
    }

    return 1 - progress;
  }

  function getDuration() {
    var cached = cache.springs[string];

    if (cached) {
      return cached;
    }

    var frame = 1 / 6;
    var elapsed = 0;
    var rest = 0;

    while (true) {
      elapsed += frame;

      if (solver(elapsed) === 1) {
        rest++;

        if (rest >= 16) {
          break;
        }
      } else {
        rest = 0;
      }
    }

    var duration = elapsed * frame * 1000;
    cache.springs[string] = duration;
    return duration;
  }

  return duration ? solver : getDuration;
} // Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function


function steps(steps) {
  if (steps === void 0) steps = 10;
  return function (t) {
    return Math.ceil(minMax(t, 0.000001, 1) * steps) * (1 / steps);
  };
} // BezierEasing https://github.com/gre/bezier-easing


var bezier = function () {
  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  function C(aA1) {
    return 3.0 * aA1;
  }

  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX,
        currentT,
        i = 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;

      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > 0.0000001 && ++i < 10);

    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < 4; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }

  function bezier(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
      return;
    }

    var sampleValues = new Float32Array(kSplineTableSize);

    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function getTForX(aX) {
      var intervalStart = 0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample;
      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= 0.001) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    }

    return function (x) {
      if (mX1 === mY1 && mX2 === mY2) {
        return x;
      }

      if (x === 0 || x === 1) {
        return x;
      }

      return calcBezier(getTForX(x), mY1, mY2);
    };
  }

  return bezier;
}();

var penner = function () {
  // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)
  var eases = {
    linear: function () {
      return function (t) {
        return t;
      };
    }
  };
  var functionEasings = {
    Sine: function () {
      return function (t) {
        return 1 - Math.cos(t * Math.PI / 2);
      };
    },
    Circ: function () {
      return function (t) {
        return 1 - Math.sqrt(1 - t * t);
      };
    },
    Back: function () {
      return function (t) {
        return t * t * (3 * t - 2);
      };
    },
    Bounce: function () {
      return function (t) {
        var pow2,
            b = 4;

        while (t < ((pow2 = Math.pow(2, --b)) - 1) / 11) {}

        return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
      };
    },
    Elastic: function (amplitude, period) {
      if (amplitude === void 0) amplitude = 1;
      if (period === void 0) period = .5;
      var a = minMax(amplitude, 1, 10);
      var p = minMax(period, .1, 2);
      return function (t) {
        return t === 0 || t === 1 ? t : -a * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p);
      };
    }
  };
  var baseEasings = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];
  baseEasings.forEach(function (name, i) {
    functionEasings[name] = function () {
      return function (t) {
        return Math.pow(t, i + 2);
      };
    };
  });
  Object.keys(functionEasings).forEach(function (name) {
    var easeIn = functionEasings[name];
    eases['easeIn' + name] = easeIn;

    eases['easeOut' + name] = function (a, b) {
      return function (t) {
        return 1 - easeIn(a, b)(1 - t);
      };
    };

    eases['easeInOut' + name] = function (a, b) {
      return function (t) {
        return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 1 - easeIn(a, b)(t * -2 + 2) / 2;
      };
    };

    eases['easeOutIn' + name] = function (a, b) {
      return function (t) {
        return t < 0.5 ? (1 - easeIn(a, b)(1 - t * 2)) / 2 : (easeIn(a, b)(t * 2 - 1) + 1) / 2;
      };
    };
  });
  return eases;
}();

function parseEasings(easing, duration) {
  if (is.fnc(easing)) {
    return easing;
  }

  var name = easing.split('(')[0];
  var ease = penner[name];
  var args = parseEasingParameters(easing);

  switch (name) {
    case 'spring':
      return spring(easing, duration);

    case 'cubicBezier':
      return applyArguments(bezier, args);

    case 'steps':
      return applyArguments(steps, args);

    default:
      return applyArguments(ease, args);
  }
} // Strings


function selectString(str) {
  try {
    var nodes = document.querySelectorAll(str);
    return nodes;
  } catch (e) {
    return;
  }
} // Arrays


function filterArray(arr, callback) {
  var len = arr.length;
  var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
  var result = [];

  for (var i = 0; i < len; i++) {
    if (i in arr) {
      var val = arr[i];

      if (callback.call(thisArg, val, i, arr)) {
        result.push(val);
      }
    }
  }

  return result;
}

function flattenArray(arr) {
  return arr.reduce(function (a, b) {
    return a.concat(is.arr(b) ? flattenArray(b) : b);
  }, []);
}

function toArray(o) {
  if (is.arr(o)) {
    return o;
  }

  if (is.str(o)) {
    o = selectString(o) || o;
  }

  if (o instanceof NodeList || o instanceof HTMLCollection) {
    return [].slice.call(o);
  }

  return [o];
}

function arrayContains(arr, val) {
  return arr.some(function (a) {
    return a === val;
  });
} // Objects


function cloneObject(o) {
  var clone = {};

  for (var p in o) {
    clone[p] = o[p];
  }

  return clone;
}

function replaceObjectProps(o1, o2) {
  var o = cloneObject(o1);

  for (var p in o1) {
    o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p];
  }

  return o;
}

function mergeObjects(o1, o2) {
  var o = cloneObject(o1);

  for (var p in o2) {
    o[p] = is.und(o1[p]) ? o2[p] : o1[p];
  }

  return o;
} // Colors


function rgbToRgba(rgbValue) {
  var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
  return rgb ? "rgba(" + rgb[1] + ",1)" : rgbValue;
}

function hexToRgba(hexValue) {
  var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  var hex = hexValue.replace(rgx, function (m, r, g, b) {
    return r + r + g + g + b + b;
  });
  var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  var r = parseInt(rgb[1], 16);
  var g = parseInt(rgb[2], 16);
  var b = parseInt(rgb[3], 16);
  return "rgba(" + r + "," + g + "," + b + ",1)";
}

function hslToRgba(hslValue) {
  var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
  var h = parseInt(hsl[1], 10) / 360;
  var s = parseInt(hsl[2], 10) / 100;
  var l = parseInt(hsl[3], 10) / 100;
  var a = hsl[4] || 1;

  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }

    if (t > 1) {
      t -= 1;
    }

    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }

    if (t < 1 / 2) {
      return q;
    }

    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }

    return p;
  }

  var r, g, b;

  if (s == 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }

  return "rgba(" + r * 255 + "," + g * 255 + "," + b * 255 + "," + a + ")";
}

function colorToRgb(val) {
  if (is.rgb(val)) {
    return rgbToRgba(val);
  }

  if (is.hex(val)) {
    return hexToRgba(val);
  }

  if (is.hsl(val)) {
    return hslToRgba(val);
  }
} // Units


function getUnit(val) {
  var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);

  if (split) {
    return split[1];
  }
}

function getTransformUnit(propName) {
  if (stringContains(propName, 'translate') || propName === 'perspective') {
    return 'px';
  }

  if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) {
    return 'deg';
  }
} // Values


function getFunctionValue(val, animatable) {
  if (!is.fnc(val)) {
    return val;
  }

  return val(animatable.target, animatable.id, animatable.total);
}

function getAttribute(el, prop) {
  return el.getAttribute(prop);
}

function convertPxToUnit(el, value, unit) {
  var valueUnit = getUnit(value);

  if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) {
    return value;
  }

  var cached = cache.CSS[value + unit];

  if (!is.und(cached)) {
    return cached;
  }

  var baseline = 100;
  var tempEl = document.createElement(el.tagName);
  var parentEl = el.parentNode && el.parentNode !== document ? el.parentNode : document.body;
  parentEl.appendChild(tempEl);
  tempEl.style.position = 'absolute';
  tempEl.style.width = baseline + unit;
  var factor = baseline / tempEl.offsetWidth;
  parentEl.removeChild(tempEl);
  var convertedUnit = factor * parseFloat(value);
  cache.CSS[value + unit] = convertedUnit;
  return convertedUnit;
}

function getCSSValue(el, prop, unit) {
  if (prop in el.style) {
    var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
    return unit ? convertPxToUnit(el, value, unit) : value;
  }
}

function getAnimationType(el, prop) {
  if (is.dom(el) && !is.inp(el) && (!is.nil(getAttribute(el, prop)) || is.svg(el) && el[prop])) {
    return 'attribute';
  }

  if (is.dom(el) && arrayContains(validTransforms, prop)) {
    return 'transform';
  }

  if (is.dom(el) && prop !== 'transform' && getCSSValue(el, prop)) {
    return 'css';
  }

  if (el[prop] != null) {
    return 'object';
  }
}

function getElementTransforms(el) {
  if (!is.dom(el)) {
    return;
  }

  var str = el.style.transform || '';
  var reg = /(\w+)\(([^)]*)\)/g;
  var transforms = new Map();
  var m;

  while (m = reg.exec(str)) {
    transforms.set(m[1], m[2]);
  }

  return transforms;
}

function getTransformValue(el, propName, animatable, unit) {
  var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
  var value = getElementTransforms(el).get(propName) || defaultVal;

  if (animatable) {
    animatable.transforms.list.set(propName, value);
    animatable.transforms['last'] = propName;
  }

  return unit ? convertPxToUnit(el, value, unit) : value;
}

function getOriginalTargetValue(target, propName, unit, animatable) {
  switch (getAnimationType(target, propName)) {
    case 'transform':
      return getTransformValue(target, propName, animatable, unit);

    case 'css':
      return getCSSValue(target, propName, unit);

    case 'attribute':
      return getAttribute(target, propName);

    default:
      return target[propName] || 0;
  }
}

function getRelativeValue(to, from) {
  var operator = /^(\*=|\+=|-=)/.exec(to);

  if (!operator) {
    return to;
  }

  var u = getUnit(to) || 0;
  var x = parseFloat(from);
  var y = parseFloat(to.replace(operator[0], ''));

  switch (operator[0][0]) {
    case '+':
      return x + y + u;

    case '-':
      return x - y + u;

    case '*':
      return x * y + u;
  }
}

function validateValue(val, unit) {
  if (is.col(val)) {
    return colorToRgb(val);
  }

  if (/\s/g.test(val)) {
    return val;
  }

  var originalUnit = getUnit(val);
  var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;

  if (unit) {
    return unitLess + unit;
  }

  return unitLess;
} // getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744


function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function getCircleLength(el) {
  return Math.PI * 2 * getAttribute(el, 'r');
}

function getRectLength(el) {
  return getAttribute(el, 'width') * 2 + getAttribute(el, 'height') * 2;
}

function getLineLength(el) {
  return getDistance({
    x: getAttribute(el, 'x1'),
    y: getAttribute(el, 'y1')
  }, {
    x: getAttribute(el, 'x2'),
    y: getAttribute(el, 'y2')
  });
}

function getPolylineLength(el) {
  var points = el.points;
  var totalLength = 0;
  var previousPos;

  for (var i = 0; i < points.numberOfItems; i++) {
    var currentPos = points.getItem(i);

    if (i > 0) {
      totalLength += getDistance(previousPos, currentPos);
    }

    previousPos = currentPos;
  }

  return totalLength;
}

function getPolygonLength(el) {
  var points = el.points;
  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
} // Path animation


function getTotalLength(el) {
  if (el.getTotalLength) {
    return el.getTotalLength();
  }

  switch (el.tagName.toLowerCase()) {
    case 'circle':
      return getCircleLength(el);

    case 'rect':
      return getRectLength(el);

    case 'line':
      return getLineLength(el);

    case 'polyline':
      return getPolylineLength(el);

    case 'polygon':
      return getPolygonLength(el);
  }
}

function setDashoffset(el) {
  var pathLength = getTotalLength(el);
  el.setAttribute('stroke-dasharray', pathLength);
  return pathLength;
} // Motion path


function getParentSvgEl(el) {
  var parentEl = el.parentNode;

  while (is.svg(parentEl)) {
    if (!is.svg(parentEl.parentNode)) {
      break;
    }

    parentEl = parentEl.parentNode;
  }

  return parentEl;
}

function getParentSvg(pathEl, svgData) {
  var svg = svgData || {};
  var parentSvgEl = svg.el || getParentSvgEl(pathEl);
  var rect = parentSvgEl.getBoundingClientRect();
  var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
  var width = rect.width;
  var height = rect.height;
  var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);
  return {
    el: parentSvgEl,
    viewBox: viewBox,
    x: viewBox[0] / 1,
    y: viewBox[1] / 1,
    w: width,
    h: height,
    vW: viewBox[2],
    vH: viewBox[3]
  };
}

function getPath(path, percent) {
  var pathEl = is.str(path) ? selectString(path)[0] : path;
  var p = percent || 100;
  return function (property) {
    return {
      property: property,
      el: pathEl,
      svg: getParentSvg(pathEl),
      totalLength: getTotalLength(pathEl) * (p / 100)
    };
  };
}

function getPathProgress(path, progress, isPathTargetInsideSVG) {
  function point(offset) {
    if (offset === void 0) offset = 0;
    var l = progress + offset >= 1 ? progress + offset : 0;
    return path.el.getPointAtLength(l);
  }

  var svg = getParentSvg(path.el, path.svg);
  var p = point();
  var p0 = point(-1);
  var p1 = point(+1);
  var scaleX = isPathTargetInsideSVG ? 1 : svg.w / svg.vW;
  var scaleY = isPathTargetInsideSVG ? 1 : svg.h / svg.vH;

  switch (path.property) {
    case 'x':
      return (p.x - svg.x) * scaleX;

    case 'y':
      return (p.y - svg.y) * scaleY;

    case 'angle':
      return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
  }
} // Decompose value


function decomposeValue(val, unit) {
  // const rgx = /-?\d*\.?\d+/g; // handles basic numbers
  // const rgx = /[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
  var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation

  var value = validateValue(is.pth(val) ? val.totalLength : val, unit) + '';
  return {
    original: value,
    numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],
    strings: is.str(val) || unit ? value.split(rgx) : []
  };
} // Animatables


function parseTargets(targets) {
  var targetsArray = targets ? flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets)) : [];
  return filterArray(targetsArray, function (item, pos, self) {
    return self.indexOf(item) === pos;
  });
}

function getAnimatables(targets) {
  var parsed = parseTargets(targets);
  return parsed.map(function (t, i) {
    return {
      target: t,
      id: i,
      total: parsed.length,
      transforms: {
        list: getElementTransforms(t)
      }
    };
  });
} // Properties


function normalizePropertyTweens(prop, tweenSettings) {
  var settings = cloneObject(tweenSettings); // Override duration if easing is a spring

  if (/^spring/.test(settings.easing)) {
    settings.duration = spring(settings.easing);
  }

  if (is.arr(prop)) {
    var l = prop.length;
    var isFromTo = l === 2 && !is.obj(prop[0]);

    if (!isFromTo) {
      // Duration divided by the number of tweens
      if (!is.fnc(tweenSettings.duration)) {
        settings.duration = tweenSettings.duration / l;
      }
    } else {
      // Transform [from, to] values shorthand to a valid tween value
      prop = {
        value: prop
      };
    }
  }

  var propArray = is.arr(prop) ? prop : [prop];
  return propArray.map(function (v, i) {
    var obj = is.obj(v) && !is.pth(v) ? v : {
      value: v
    }; // Default delay value should only be applied to the first tween

    if (is.und(obj.delay)) {
      obj.delay = !i ? tweenSettings.delay : 0;
    } // Default endDelay value should only be applied to the last tween


    if (is.und(obj.endDelay)) {
      obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0;
    }

    return obj;
  }).map(function (k) {
    return mergeObjects(k, settings);
  });
}

function flattenKeyframes(keyframes) {
  var propertyNames = filterArray(flattenArray(keyframes.map(function (key) {
    return Object.keys(key);
  })), function (p) {
    return is.key(p);
  }).reduce(function (a, b) {
    if (a.indexOf(b) < 0) {
      a.push(b);
    }

    return a;
  }, []);
  var properties = {};

  var loop = function (i) {
    var propName = propertyNames[i];
    properties[propName] = keyframes.map(function (key) {
      var newKey = {};

      for (var p in key) {
        if (is.key(p)) {
          if (p == propName) {
            newKey.value = key[p];
          }
        } else {
          newKey[p] = key[p];
        }
      }

      return newKey;
    });
  };

  for (var i = 0; i < propertyNames.length; i++) loop(i);

  return properties;
}

function getProperties(tweenSettings, params) {
  var properties = [];
  var keyframes = params.keyframes;

  if (keyframes) {
    params = mergeObjects(flattenKeyframes(keyframes), params);
  }

  for (var p in params) {
    if (is.key(p)) {
      properties.push({
        name: p,
        tweens: normalizePropertyTweens(params[p], tweenSettings)
      });
    }
  }

  return properties;
} // Tweens


function normalizeTweenValues(tween, animatable) {
  var t = {};

  for (var p in tween) {
    var value = getFunctionValue(tween[p], animatable);

    if (is.arr(value)) {
      value = value.map(function (v) {
        return getFunctionValue(v, animatable);
      });

      if (value.length === 1) {
        value = value[0];
      }
    }

    t[p] = value;
  }

  t.duration = parseFloat(t.duration);
  t.delay = parseFloat(t.delay);
  return t;
}

function normalizeTweens(prop, animatable) {
  var previousTween;
  return prop.tweens.map(function (t) {
    var tween = normalizeTweenValues(t, animatable);
    var tweenValue = tween.value;
    var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
    var toUnit = getUnit(to);
    var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
    var previousValue = previousTween ? previousTween.to.original : originalValue;
    var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
    var fromUnit = getUnit(from) || getUnit(originalValue);
    var unit = toUnit || fromUnit;

    if (is.und(to)) {
      to = previousValue;
    }

    tween.from = decomposeValue(from, unit);
    tween.to = decomposeValue(getRelativeValue(to, from), unit);
    tween.start = previousTween ? previousTween.end : 0;
    tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
    tween.easing = parseEasings(tween.easing, tween.duration);
    tween.isPath = is.pth(tweenValue);
    tween.isPathTargetInsideSVG = tween.isPath && is.svg(animatable.target);
    tween.isColor = is.col(tween.from.original);

    if (tween.isColor) {
      tween.round = 1;
    }

    previousTween = tween;
    return tween;
  });
} // Tween progress


var setProgressValue = {
  css: function (t, p, v) {
    return t.style[p] = v;
  },
  attribute: function (t, p, v) {
    return t.setAttribute(p, v);
  },
  object: function (t, p, v) {
    return t[p] = v;
  },
  transform: function (t, p, v, transforms, manual) {
    transforms.list.set(p, v);

    if (p === transforms.last || manual) {
      var str = '';
      transforms.list.forEach(function (value, prop) {
        str += prop + "(" + value + ") ";
      });
      t.style.transform = str;
    }
  }
}; // Set Value helper

function setTargetsValue(targets, properties) {
  var animatables = getAnimatables(targets);
  animatables.forEach(function (animatable) {
    for (var property in properties) {
      var value = getFunctionValue(properties[property], animatable);
      var target = animatable.target;
      var valueUnit = getUnit(value);
      var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
      var unit = valueUnit || getUnit(originalValue);
      var to = getRelativeValue(validateValue(value, unit), originalValue);
      var animType = getAnimationType(target, property);
      setProgressValue[animType](target, property, to, animatable.transforms, true);
    }
  });
} // Animations


function createAnimation(animatable, prop) {
  var animType = getAnimationType(animatable.target, prop.name);

  if (animType) {
    var tweens = normalizeTweens(prop, animatable);
    var lastTween = tweens[tweens.length - 1];
    return {
      type: animType,
      property: prop.name,
      animatable: animatable,
      tweens: tweens,
      duration: lastTween.end,
      delay: tweens[0].delay,
      endDelay: lastTween.endDelay
    };
  }
}

function getAnimations(animatables, properties) {
  return filterArray(flattenArray(animatables.map(function (animatable) {
    return properties.map(function (prop) {
      return createAnimation(animatable, prop);
    });
  })), function (a) {
    return !is.und(a);
  });
} // Create Instance


function getInstanceTimings(animations, tweenSettings) {
  var animLength = animations.length;

  var getTlOffset = function (anim) {
    return anim.timelineOffset ? anim.timelineOffset : 0;
  };

  var timings = {};
  timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) {
    return getTlOffset(anim) + anim.duration;
  })) : tweenSettings.duration;
  timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) {
    return getTlOffset(anim) + anim.delay;
  })) : tweenSettings.delay;
  timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) {
    return getTlOffset(anim) + anim.duration - anim.endDelay;
  })) : tweenSettings.endDelay;
  return timings;
}

var instanceID = 0;

function createNewInstance(params) {
  var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
  var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
  var properties = getProperties(tweenSettings, params);
  var animatables = getAnimatables(params.targets);
  var animations = getAnimations(animatables, properties);
  var timings = getInstanceTimings(animations, tweenSettings);
  var id = instanceID;
  instanceID++;
  return mergeObjects(instanceSettings, {
    id: id,
    children: [],
    animatables: animatables,
    animations: animations,
    duration: timings.duration,
    delay: timings.delay,
    endDelay: timings.endDelay
  });
} // Core


var activeInstances = [];

var engine = function () {
  var raf;

  function play() {
    if (!raf && (!isDocumentHidden() || !anime.suspendWhenDocumentHidden) && activeInstances.length > 0) {
      raf = requestAnimationFrame(step);
    }
  }

  function step(t) {
    // memo on algorithm issue:
    // dangerous iteration over mutable `activeInstances`
    // (that collection may be updated from within callbacks of `tick`-ed animation instances)
    var activeInstancesLength = activeInstances.length;
    var i = 0;

    while (i < activeInstancesLength) {
      var activeInstance = activeInstances[i];

      if (!activeInstance.paused) {
        activeInstance.tick(t);
        i++;
      } else {
        activeInstances.splice(i, 1);
        activeInstancesLength--;
      }
    }

    raf = i > 0 ? requestAnimationFrame(step) : undefined;
  }

  function handleVisibilityChange() {
    if (!anime.suspendWhenDocumentHidden) {
      return;
    }

    if (isDocumentHidden()) {
      // suspend ticks
      raf = cancelAnimationFrame(raf);
    } else {
      // is back to active tab
      // first adjust animations to consider the time that ticks were suspended
      activeInstances.forEach(function (instance) {
        return instance._onDocumentVisibility();
      });
      engine();
    }
  }

  if (typeof document !== 'undefined') {
    document.addEventListener('visibilitychange', handleVisibilityChange);
  }

  return play;
}();

function isDocumentHidden() {
  return !!document && document.hidden;
} // Public Instance


function anime(params) {
  if (params === void 0) params = {};
  var startTime = 0,
      lastTime = 0,
      now = 0;
  var children,
      childrenLength = 0;
  var resolve = null;

  function makePromise(instance) {
    var promise = window.Promise && new Promise(function (_resolve) {
      return resolve = _resolve;
    });
    instance.finished = promise;
    return promise;
  }

  var instance = createNewInstance(params);
  var promise = makePromise(instance);

  function toggleInstanceDirection() {
    var direction = instance.direction;

    if (direction !== 'alternate') {
      instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
    }

    instance.reversed = !instance.reversed;
    children.forEach(function (child) {
      return child.reversed = instance.reversed;
    });
  }

  function adjustTime(time) {
    return instance.reversed ? instance.duration - time : time;
  }

  function resetTime() {
    startTime = 0;
    lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
  }

  function seekChild(time, child) {
    if (child) {
      child.seek(time - child.timelineOffset);
    }
  }

  function syncInstanceChildren(time) {
    if (!instance.reversePlayback) {
      for (var i = 0; i < childrenLength; i++) {
        seekChild(time, children[i]);
      }
    } else {
      for (var i$1 = childrenLength; i$1--;) {
        seekChild(time, children[i$1]);
      }
    }
  }

  function setAnimationsProgress(insTime) {
    var i = 0;
    var animations = instance.animations;
    var animationsLength = animations.length;

    while (i < animationsLength) {
      var anim = animations[i];
      var animatable = anim.animatable;
      var tweens = anim.tweens;
      var tweenLength = tweens.length - 1;
      var tween = tweens[tweenLength]; // Only check for keyframes if there is more than one tween

      if (tweenLength) {
        tween = filterArray(tweens, function (t) {
          return insTime < t.end;
        })[0] || tween;
      }

      var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
      var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
      var strings = tween.to.strings;
      var round = tween.round;
      var numbers = [];
      var toNumbersLength = tween.to.numbers.length;
      var progress = void 0;

      for (var n = 0; n < toNumbersLength; n++) {
        var value = void 0;
        var toNumber = tween.to.numbers[n];
        var fromNumber = tween.from.numbers[n] || 0;

        if (!tween.isPath) {
          value = fromNumber + eased * (toNumber - fromNumber);
        } else {
          value = getPathProgress(tween.value, eased * toNumber, tween.isPathTargetInsideSVG);
        }

        if (round) {
          if (!(tween.isColor && n > 2)) {
            value = Math.round(value * round) / round;
          }
        }

        numbers.push(value);
      } // Manual Array.reduce for better performances


      var stringsLength = strings.length;

      if (!stringsLength) {
        progress = numbers[0];
      } else {
        progress = strings[0];

        for (var s = 0; s < stringsLength; s++) {
          var a = strings[s];
          var b = strings[s + 1];
          var n$1 = numbers[s];

          if (!isNaN(n$1)) {
            if (!b) {
              progress += n$1 + ' ';
            } else {
              progress += n$1 + b;
            }
          }
        }
      }

      setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
      anim.currentValue = progress;
      i++;
    }
  }

  function setCallback(cb) {
    if (instance[cb] && !instance.passThrough) {
      instance[cb](instance);
    }
  }

  function countIteration() {
    if (instance.remaining && instance.remaining !== true) {
      instance.remaining--;
    }
  }

  function setInstanceProgress(engineTime) {
    var insDuration = instance.duration;
    var insDelay = instance.delay;
    var insEndDelay = insDuration - instance.endDelay;
    var insTime = adjustTime(engineTime);
    instance.progress = minMax(insTime / insDuration * 100, 0, 100);
    instance.reversePlayback = insTime < instance.currentTime;

    if (children) {
      syncInstanceChildren(insTime);
    }

    if (!instance.began && instance.currentTime > 0) {
      instance.began = true;
      setCallback('begin');
    }

    if (!instance.loopBegan && instance.currentTime > 0) {
      instance.loopBegan = true;
      setCallback('loopBegin');
    }

    if (insTime <= insDelay && instance.currentTime !== 0) {
      setAnimationsProgress(0);
    }

    if (insTime >= insEndDelay && instance.currentTime !== insDuration || !insDuration) {
      setAnimationsProgress(insDuration);
    }

    if (insTime > insDelay && insTime < insEndDelay) {
      if (!instance.changeBegan) {
        instance.changeBegan = true;
        instance.changeCompleted = false;
        setCallback('changeBegin');
      }

      setCallback('change');
      setAnimationsProgress(insTime);
    } else {
      if (instance.changeBegan) {
        instance.changeCompleted = true;
        instance.changeBegan = false;
        setCallback('changeComplete');
      }
    }

    instance.currentTime = minMax(insTime, 0, insDuration);

    if (instance.began) {
      setCallback('update');
    }

    if (engineTime >= insDuration) {
      lastTime = 0;
      countIteration();

      if (!instance.remaining) {
        instance.paused = true;

        if (!instance.completed) {
          instance.completed = true;
          setCallback('loopComplete');
          setCallback('complete');

          if (!instance.passThrough && 'Promise' in window) {
            resolve();
            promise = makePromise(instance);
          }
        }
      } else {
        startTime = now;
        setCallback('loopComplete');
        instance.loopBegan = false;

        if (instance.direction === 'alternate') {
          toggleInstanceDirection();
        }
      }
    }
  }

  instance.reset = function () {
    var direction = instance.direction;
    instance.passThrough = false;
    instance.currentTime = 0;
    instance.progress = 0;
    instance.paused = true;
    instance.began = false;
    instance.loopBegan = false;
    instance.changeBegan = false;
    instance.completed = false;
    instance.changeCompleted = false;
    instance.reversePlayback = false;
    instance.reversed = direction === 'reverse';
    instance.remaining = instance.loop;
    children = instance.children;
    childrenLength = children.length;

    for (var i = childrenLength; i--;) {
      instance.children[i].reset();
    }

    if (instance.reversed && instance.loop !== true || direction === 'alternate' && instance.loop === 1) {
      instance.remaining++;
    }

    setAnimationsProgress(instance.reversed ? instance.duration : 0);
  }; // internal method (for engine) to adjust animation timings before restoring engine ticks (rAF)


  instance._onDocumentVisibility = resetTime; // Set Value helper

  instance.set = function (targets, properties) {
    setTargetsValue(targets, properties);
    return instance;
  };

  instance.tick = function (t) {
    now = t;

    if (!startTime) {
      startTime = now;
    }

    setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
  };

  instance.seek = function (time) {
    setInstanceProgress(adjustTime(time));
  };

  instance.pause = function () {
    instance.paused = true;
    resetTime();
  };

  instance.play = function () {
    if (!instance.paused) {
      return;
    }

    if (instance.completed) {
      instance.reset();
    }

    instance.paused = false;
    activeInstances.push(instance);
    resetTime();
    engine();
  };

  instance.reverse = function () {
    toggleInstanceDirection();
    instance.completed = instance.reversed ? false : true;
    resetTime();
  };

  instance.restart = function () {
    instance.reset();
    instance.play();
  };

  instance.remove = function (targets) {
    var targetsArray = parseTargets(targets);
    removeTargetsFromInstance(targetsArray, instance);
  };

  instance.reset();

  if (instance.autoplay) {
    instance.play();
  }

  return instance;
} // Remove targets from animation


function removeTargetsFromAnimations(targetsArray, animations) {
  for (var a = animations.length; a--;) {
    if (arrayContains(targetsArray, animations[a].animatable.target)) {
      animations.splice(a, 1);
    }
  }
}

function removeTargetsFromInstance(targetsArray, instance) {
  var animations = instance.animations;
  var children = instance.children;
  removeTargetsFromAnimations(targetsArray, animations);

  for (var c = children.length; c--;) {
    var child = children[c];
    var childAnimations = child.animations;
    removeTargetsFromAnimations(targetsArray, childAnimations);

    if (!childAnimations.length && !child.children.length) {
      children.splice(c, 1);
    }
  }

  if (!animations.length && !children.length) {
    instance.pause();
  }
}

function removeTargetsFromActiveInstances(targets) {
  var targetsArray = parseTargets(targets);

  for (var i = activeInstances.length; i--;) {
    var instance = activeInstances[i];
    removeTargetsFromInstance(targetsArray, instance);
  }
} // Stagger helpers


function stagger(val, params) {
  if (params === void 0) params = {};
  var direction = params.direction || 'normal';
  var easing = params.easing ? parseEasings(params.easing) : null;
  var grid = params.grid;
  var axis = params.axis;
  var fromIndex = params.from || 0;
  var fromFirst = fromIndex === 'first';
  var fromCenter = fromIndex === 'center';
  var fromLast = fromIndex === 'last';
  var isRange = is.arr(val);
  var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
  var val2 = isRange ? parseFloat(val[1]) : 0;
  var unit = getUnit(isRange ? val[1] : val) || 0;
  var start = params.start || 0 + (isRange ? val1 : 0);
  var values = [];
  var maxValue = 0;
  return function (el, i, t) {
    if (fromFirst) {
      fromIndex = 0;
    }

    if (fromCenter) {
      fromIndex = (t - 1) / 2;
    }

    if (fromLast) {
      fromIndex = t - 1;
    }

    if (!values.length) {
      for (var index = 0; index < t; index++) {
        if (!grid) {
          values.push(Math.abs(fromIndex - index));
        } else {
          var fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;
          var fromY = !fromCenter ? Math.floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;
          var toX = index % grid[0];
          var toY = Math.floor(index / grid[0]);
          var distanceX = fromX - toX;
          var distanceY = fromY - toY;
          var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

          if (axis === 'x') {
            value = -distanceX;
          }

          if (axis === 'y') {
            value = -distanceY;
          }

          values.push(value);
        }

        maxValue = Math.max.apply(Math, values);
      }

      if (easing) {
        values = values.map(function (val) {
          return easing(val / maxValue) * maxValue;
        });
      }

      if (direction === 'reverse') {
        values = values.map(function (val) {
          return axis ? val < 0 ? val * -1 : -val : Math.abs(maxValue - val);
        });
      }
    }

    var spacing = isRange ? (val2 - val1) / maxValue : val1;
    return start + spacing * (Math.round(values[i] * 100) / 100) + unit;
  };
} // Timeline


function timeline(params) {
  if (params === void 0) params = {};
  var tl = anime(params);
  tl.duration = 0;

  tl.add = function (instanceParams, timelineOffset) {
    var tlIndex = activeInstances.indexOf(tl);
    var children = tl.children;

    if (tlIndex > -1) {
      activeInstances.splice(tlIndex, 1);
    }

    function passThrough(ins) {
      ins.passThrough = true;
    }

    for (var i = 0; i < children.length; i++) {
      passThrough(children[i]);
    }

    var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
    insParams.targets = insParams.targets || params.targets;
    var tlDuration = tl.duration;
    insParams.autoplay = false;
    insParams.direction = tl.direction;
    insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
    passThrough(tl);
    tl.seek(insParams.timelineOffset);
    var ins = anime(insParams);
    passThrough(ins);
    children.push(ins);
    var timings = getInstanceTimings(children, params);
    tl.delay = timings.delay;
    tl.endDelay = timings.endDelay;
    tl.duration = timings.duration;
    tl.seek(0);
    tl.reset();

    if (tl.autoplay) {
      tl.play();
    }

    return tl;
  };

  return tl;
}

anime.version = '3.2.1';
anime.speed = 1; // TODO:#review: naming, documentation

anime.suspendWhenDocumentHidden = true;
anime.running = activeInstances;
anime.remove = removeTargetsFromActiveInstances;
anime.get = getOriginalTargetValue;
anime.set = setTargetsValue;
anime.convertPx = convertPxToUnit;
anime.path = getPath;
anime.setDashoffset = setDashoffset;
anime.stagger = stagger;
anime.timeline = timeline;
anime.easing = parseEasings;
anime.penner = penner;

anime.random = function (min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

var _default = anime;
exports.default = _default;
},{}],"src/assets/textures/coins.jpg":[function(require,module,exports) {
module.exports = "/coins.f10ae3fc.jpg";
},{}],"src/systems/OutroSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = OutroSystem;

var _simplexNoise = _interopRequireDefault(require("simplex-noise"));

var _animejs = _interopRequireDefault(require("animejs"));

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _resetPlayerPos = _interopRequireDefault(require("../util/resetPlayerPos"));

var _AnimationSystem = require("./AnimationSystem");

var _Line3D = _interopRequireDefault(require("./writing/Line3D"));

var _locale = require("../util/locale");

var _Assets = _interopRequireDefault(require("../util/Assets"));

var _queryString = _interopRequireDefault(require("../util/query-string"));

var _coins = _interopRequireDefault(require("../assets/textures/coins.jpg"));

var _coin = _interopRequireDefault(require("../assets/gltf/coin.gltf"));

var _GLTFLoader = require("../util/GLTFLoader");

var ShaderManager = _interopRequireWildcard(require("../util/ShaderManager"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _math = require("canvas-sketch-util/math");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const NOOP = () => {};

const texLoader = new THREE.TextureLoader();
const geom = new THREE.PlaneBufferGeometry(2, 2);
const random = (0, _Random.default)();
const noise = new _simplexNoise.default(random.value);
const coinMaterial = ShaderManager.create({
  name: "coinShader",
  uniforms: {
    uTime: {
      value: 0
    },
    tMap: {
      value: new THREE.Texture()
    },
    uOffset: {
      value: new THREE.Vector2()
    },
    uGlowIntensity: {
      value: 1
    }
  },
  vertexShader:
  /*glsl*/
  `
    attribute vec2 aOffset;
    attribute float aGlowDelay;

    uniform float uTime;
    
    varying vec2 vUv;
    varying vec2 vOffset;
    varying float vGlowDelay;
    
    void main() {
      
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      
      vUv = uv;
      vOffset = aOffset;
      vGlowDelay = aGlowDelay;
    }
  `,
  fragmentShader:
  /*glsl*/
  `
    uniform sampler2D tMap;
    uniform float uGlowIntensity;
    varying float vGlowDelay;

    varying vec2 vUv;
    varying vec2 vOffset;

    void main() {

      vec2 uv = vec2(vUv.x, 1. - vUv.y);
      uv *= .5;

      uv += vOffset;
      float glow = uGlowIntensity - vGlowDelay;
      glow = clamp(glow, 1., 3.);
      vec3 color = texture2D(tMap, uv).rgb * glow;

      gl_FragColor = vec4(color, 1.);
    }
  `
});
const fsQuadMaterial = ShaderManager.create({
  name: "coinShader",
  uniforms: {
    uOpacity: {
      value: 0
    }
  },
  transparent: true,
  depthTest: false,
  depthWrite: false,
  vertexShader:
  /*glsl*/
  `
    void main() {
      gl_Position = vec4( position, 1.0 );
    }
  `,
  fragmentShader:
  /*glsl*/
  `
    uniform float uOpacity;
    void main() {
      gl_FragColor = vec4(1., 1.0, 1.0, uOpacity);
    }
  `
});

function loadTexture(url) {
  return new Promise((resolve, reject) => {
    texLoader.load(url, // ok
    texture => {
      resolve(texture);
    }, // progress
    NOOP, // ko
    evt => {
      reject(evt);
    });
  });
}

const anim = {
  yOffset: 0,
  magicalEffect: 0,
  capeSpeed: 0.2,
  glowIntensity: 1,
  glowIntensity2: 1,
  coinScl: 0.001,
  coinGlow: 1,
  shakeSpeed: 0.5,
  flash: 0,
  coinSpinSpeed: 1,
  coinAngularSpeed: 0.1,
  camDistance: 15,
  camShake: 0,
  camShakeSpeed: 1
};

function OutroSystem(world) {
  let isLoaded = false;
  let time = 0;
  let outroElapsed = 0;
  let outroStarted = false;
  let hasPlayedSound = false;
  let hasStartedSecondPart = false;
  const container = new THREE.Group();
  container.name = "coins";
  world.entity().add(Tags.Object3D, container);
  let coinGeom = null;
  const user = world.findTag(Tags.UserCharacter);
  const userZoom = world.findTag(Tags.UserZoom);
  const userFollow = world.findTag(Tags.UserFollow);
  const animateOutEvents = world.listen(Tags.FinalBiomeResolution);
  let treePos = new THREE.Vector3(); // load

  const manager = new THREE.LoadingManager();
  const gltfLoader = new _GLTFLoader.GLTFLoader(manager);
  const coins = [];
  let fsquad = null;
  gltfLoader.load(_coin.default, function (_gltf) {
    coinGeom = _gltf.scene.children[0].geometry;
    makeCoins();
    makeFSQuad();
    isLoaded = true;
  });
  return dt => {
    if (!isLoaded) return;
    time += dt;

    if (outroStarted) {
      outroElapsed += dt;
    }

    const user = world.findTag(Tags.UserCharacter);
    coins.forEach((coin, idx) => {
      coin.rotateX(0.015 * anim.coinSpinSpeed);
      coin.rotateY(0.015 * anim.coinSpinSpeed);
      coin.rotateZ(0.015 * anim.coinSpinSpeed);
      let scl = anim.coinScl - coin.scaleDelay;
      scl = (0, _math.clamp)(scl, 0.001, 0.5);
      coin.scale.setScalar(scl);
      coin.time += dt * 2;
      const yoffsetAmpl = (0, _math.mapRange)(anim.coinAngularSpeed, 1, 20, 0.7, 0.1);
      coin.position.y = 3 + idx * 1.5 + Math.cos(coin.time) * yoffsetAmpl;
      coin.angularPos += dt * coin.angularSpeed * anim.coinAngularSpeed;
      coin.position.x = treePos.x + Math.cos(coin.angularPos) * (coin.radius - (0, _math.mapRange)(anim.coinAngularSpeed, 1, 20, 0, 1));
      coin.position.z = treePos.z - 0.5 + Math.sin(coin.angularPos) * (coin.radius - (0, _math.mapRange)(anim.coinAngularSpeed, 1, 20, 0, 1)); // shake
      // const ampl = .2
      // coin.position.x += noise.noise3D(coin.time * anim.shakeSpeed, coin.position.y, coin.position.z) * ampl;
      // coin.position.y += noise.noise3D(coin.position.x, coin.time * anim.shakeSpeed, coin.position.z) * ampl;
      // coin.position.z += noise.noise3D(coin.position.x, coin.position.y, coin.time * anim.shakeSpeed) * ampl;

      coin.material.uniforms.uGlowIntensity.value = anim.coinGlow;
    });
    fsquad.material.uniforms.uOpacity.value = anim.flash;
    fsquad.material.uniforms.uOpacity.value = anim.flash; // flash sound at 9.7sec

    if (outroElapsed > 9.7 && !hasPlayedSound) {
      hasPlayedSound = true;
      world.entity().add(Tags.FlashSound, "flash-build-up");
    } // notify second part of outro


    if (outroElapsed > 12.4 && !hasStartedSecondPart) {
      hasStartedSecondPart = true;
      world.entity().add(Tags.FinalBiomeResolutionLines);
    }

    animateOutEvents.added.forEach(e => {
      outroStarted = true;
      const originTrees = world.view([Tags.SpriteAnimation, Tags.SpriteAnimationOriginTreeTag]);
      treePos = originTrees[0].get(Tags.Object3D).position; // load texture

      loadTexture(_coins.default).then(texture => {
        coins.forEach((coin, idx) => {
          coin.material.uniforms.tMap.value = texture;
        });
      });
      start();
    });
  };

  function start() {
    // animate capespeed and magicaleffect
    (0, _animejs.default)({
      targets: anim,
      magicalEffect: 10,
      capeSpeed: 2,
      duration: 1000,
      delay: 0,
      easing: "easeInQuart",
      update: function () {
        user.magicalEffect = anim.magicalEffect;
        user.capeSpeed = anim.capeSpeed;
      }
    }); // glow

    (0, _animejs.default)({
      targets: anim,
      glowIntensity: 20,
      duration: 6000,
      delay: 0,
      easing: "easeInOutSine",
      update: function () {
        user.glowIntensity = anim.glowIntensity;
      }
    }); // elevates

    (0, _animejs.default)({
      targets: anim,
      yOffset: 3,
      duration: 5000,
      delay: 3000,
      easing: "easeInOutSine",
      update: function () {
        user.yOffset = anim.yOffset;
      }
    }); // coins scale

    (0, _animejs.default)({
      targets: anim,
      coinScl: 1.5,
      duration: 1300,
      delay: 7000,
      easing: "easeOutSine"
    }); // coins glow

    (0, _animejs.default)({
      targets: anim,
      coinGlow: 80,
      duration: 6000,
      delay: 9500,
      easing: "easeInSine",
      complete: () => {}
    }); // coin spin speed

    (0, _animejs.default)({
      targets: anim,
      coinSpinSpeed: 10,
      duration: 4500,
      delay: 8000,
      easing: "easeInSine"
    }); // coin angular speed

    (0, _animejs.default)({
      targets: anim,
      coinAngularSpeed: 20,
      duration: 4000,
      delay: 9000,
      easing: "easeInQuart"
    }); // cape glow 2

    (0, _animejs.default)({
      targets: anim,
      glowIntensity2: 2,
      duration: 2000,
      delay: 12000,
      easing: "easeInSine",
      update: function () {
        user.glowIntensity2 = anim.glowIntensity2;
      },
      complete: () => {
        anim.glowIntensity2 = 1;
        user.glowIntensity2 = anim.glowIntensity2;
        userFollow.shake = 0;
        userFollow.shakeSpeed = 1;
      }
    }); //  // shake speed
    //  anime({
    //   targets: anim, 'shakeSpeed': 1,
    //   duration: 5000, delay: 9000,
    //   easing: 'easeInSine',
    // })
    // flash in

    (0, _animejs.default)({
      targets: anim,
      flash: 1,
      duration: 500,
      delay: 12800,
      easing: "easeOutSine",
      update: () => {
        user.glowIntensity -= anim.flash * 1.5;
        user.magicalEffect -= anim.flash * 0.5;
      },
      complete: () => {
        // flash out
        hideCharacterAndCoins();
        camDistanceAnim.pause();
        shakeAnim.pause();
        shakeSpeedAnim.pause();
        anim.capeSpeed = 0.2;
        anim.glowIntensity2 = 1;
        user.glowIntensity2 = anim.glowIntensity2;
        userFollow.shake = 0;
        userFollow.shakeSpeed = 0;
        userZoom.distance = 15;
        (0, _animejs.default)({
          targets: anim,
          flash: 0,
          duration: 3000,
          delay: 1500,
          easing: "easeOutSine"
        });
      }
    }); // cam distance

    const camDistanceAnim = (0, _animejs.default)({
      targets: anim,
      camDistance: 12,
      duration: 9000,
      delay: 5000,
      easing: "easeInOutSine",
      update: function () {
        userZoom.distance = anim.camDistance;
      }
    }); // cam shake

    const shakeAnim = (0, _animejs.default)({
      targets: anim,
      camShake: 2,
      duration: 3000,
      delay: 12000,
      easing: "easeInOutSine",
      update: function () {
        userFollow.shake = anim.camShake;
        userFollow.shakeSpeed = anim.camShakeSpeed;
      }
    }); // cam shake speed

    const shakeSpeedAnim = (0, _animejs.default)({
      targets: anim,
      camShakeSpeed: 5,
      duration: 2000,
      delay: 11000,
      easing: "easeInOutSine",
      update: function () {
        userFollow.shakeSpeed = anim.camShakeSpeed;
      }
    });
  }

  function hideCharacterAndCoins() {
    coins.forEach(coin => {
      coin.visible = false;
    });
  }

  function makeFSQuad() {
    fsquad = new THREE.Mesh(geom, fsQuadMaterial);
    fsquad.frustumCulled = false;
    fsquad.renderOrder = 1e10;
    container.add(fsquad);
  }

  function makeCoins() {
    const anglBetween = Math.PI * 2 / 3;
    let angle = 0;
    const radius = 2;

    for (let i = 0; i < 3; i++) {
      const ox = i % 2;
      const oy = 1 - Math.floor(i / 2);
      const geom = coinGeom.clone();
      const offsets = new Float32Array(geom.attributes.position.count * 2);
      const glowDelays = new Float32Array(geom.attributes.position.count);

      for (let j = 0; j < offsets.length; j += 2) {
        offsets[j] = ox * 0.5;
        offsets[j + 1] = oy * 0.5;
      }

      for (let k = 0; k < glowDelays.length; k++) {
        glowDelays[k] = i * 2;
      }

      geom.setAttribute("aOffset", new THREE.BufferAttribute(offsets, 2));
      geom.setAttribute("aGlowDelay", new THREE.BufferAttribute(glowDelays, 1));
      const coin = new THREE.Mesh(geom, coinMaterial);
      coin.scale.setScalar(0.5);
      angle += anglBetween;
      coin.position.x = Math.cos(angle) * radius;
      coin.position.z = Math.sin(angle) * radius;
      container.add(coin);
      coin.rotateX(Math.PI * 2 * random.range(0, 1));
      coin.rotateY(Math.PI * 2 * random.range(0, 1));
      coin.rotateZ(Math.PI * 2 * random.range(0, 1)); // very bad, assigning props on the fly

      coin.time = random.range(0, 3);
      coin.scaleDelay = i * 0.5;
      coin.angularPos = angle;
      coin.angularSpeed = 1; //random.range(1, 1.5)

      coin.radius = random.range(5, 6);
      coins.push(coin);
    }
  }
}
},{"simplex-noise":"node_modules/simplex-noise/simplex-noise.js","animejs":"node_modules/animejs/lib/anime.es.js","../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/resetPlayerPos":"src/util/resetPlayerPos.js","./AnimationSystem":"src/systems/AnimationSystem.js","./writing/Line3D":"src/systems/writing/Line3D.js","../util/locale":"src/util/locale.js","../util/Assets":"src/util/Assets.js","../util/query-string":"src/util/query-string.js","../assets/textures/coins.jpg":"src/assets/textures/coins.jpg","../assets/gltf/coin.gltf":"src/assets/gltf/coin.gltf","../util/GLTFLoader":"src/util/GLTFLoader.js","../util/ShaderManager":"src/util/ShaderManager.js","../util/Random":"src/util/Random.js","canvas-sketch-util/math":"node_modules/canvas-sketch-util/math.js"}],"src/overlays/NotSupportedOverlay.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

/* overlays/NotSupportedOverlay.svelte generated by Svelte v3.31.0 */
function create_fragment(ctx) {
  let main;
  return {
    c() {
      main = (0, _internal.element)("main");
      main.innerHTML = `<div class="svelte-1wrnee7"><p>Your browser does not support WebGL, or it has been disabled.</p> 

    <p>Try viewing this experience in latest Chrome, Safari or FireFox. You may
      need to go into the browser settings and enable WebGL and hardware
      acceleration in order to play.</p></div>`;
      (0, _internal.attr)(main, "class", "svelte-1wrnee7");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, main, anchor);
    },

    p: _internal.noop,
    i: _internal.noop,
    o: _internal.noop,

    d(detaching) {
      if (detaching) (0, _internal.detach)(main);
    }

  };
}

class NotSupportedOverlay extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, null, create_fragment, _internal.safe_not_equal, {});
  }

}

var _default = NotSupportedOverlay;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs"}],"src/systems/SpriteSheetAnimationSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SpriteSheetAnimationSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var _SpriteManager = _interopRequireDefault(require("../util/SpriteManager"));

var _load = require("../util/load");

var _threeUtil = require("../util/three-util");

var _Assets = _interopRequireDefault(require("../util/Assets"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const sheetIds = {
  forest: "spritesheets/tree-anim-a",
  grasslands: "spritesheets/tree-anim-b",
  tundra: "spritesheets/tree-anim-b"
}; // Assets.prepare(sheets.forest);

async function SpriteSheetAnimationSystem(world) {
  const renderer = world.findTag(Tags.Renderer); // TODO: remove this await ...
  // const sheet = await SpriteManager("spritesheets/tree-anim-a", renderer);

  let sheet;

  let setSheet = s => {
    sheet = s;
  };

  const animationView = world.view([Tags.Object3D, Tags.SpriteAnimation]);
  const lazyLoaders = world.view([Tags.SpriteAnimation, Tags.SpriteAnimationLazyLoadSheet]);
  const spriteCache = {};
  const fps = 12;
  const frameInterval = 1 / fps;
  let currentBiome = null; // SpriteManager(id, renderer).then((sheet) => setSheet(sheet));

  return function SpriteSheetAnimationSystem(dt) {
    lazyLoaders.forEach(e => {
      const s = e.get(Tags.SpriteAnimationLazyLoadSheet);
      const d = e.get(Tags.SpriteAnimation);
      const id = s.id;

      if (id in spriteCache) {
        // see if sprite has loaded
        const asset = spriteCache[id];

        if (asset && asset.loaded) {
          d.sheet = asset.sheet;
          if (s.playOnLoad && !d.playing) d.start(); // console.log("LAZY LOAD DONE", d.sheet, asset.sheet, id);

          e.remove(Tags.SpriteAnimationLazyLoadSheet);
        }
      } else {
        // console.log("LAZY LOAD START", id);
        spriteCache[id] = {
          sheet: null,
          loaded: false,
          promise: (0, _SpriteManager.default)(id, renderer).then(sheet => {
            spriteCache[id].loaded = true;
            spriteCache[id].sheet = sheet;
          })
        };
      }
    });
    animationView.forEach(e => {
      const d = e.get(Tags.SpriteAnimation);
      const sheet = d.sheet;
      const object = e.get(Tags.Object3D);

      if (d.lastFrame == null && sheet) {
        const frame = sheet.frames[0];
        setFrame(object, frame, d.fixSpriteAspect);
        d.lastFrame = frame;
        d.frame = 0;
        d.dirty = false;
      }

      object.material.visible = Boolean(sheet);

      if (d.playing && sheet) {
        const totalFrames = sheet.frames.length;
        d.elapsed += dt * d.speed;

        if (d.elapsed >= d.delay && d.elapsed - d.delay >= frameInterval) {
          d.elapsed = d.delay;
          d.frame++;
          const endFrame = d.looping && d.loopEnd != null ? d.loopEnd : totalFrames;

          if (d.frame >= endFrame) {
            if (d.looping) {
              if (d.loopStart != null) {
                d.frame = d.loopStart;
              } else {
                d.frame = 0;
              }

              d.currentLoop++;
            } else {
              d.frame = totalFrames - 1;
              d.playing = false;
              d.finished = true;
            }

            if (d.onLoopEnd) d.onLoopEnd(e);
          }

          d.dirty = true;
        }
      }

      if (d.dirty && sheet) {
        d.dirty = false;
        const frame = sheet.frames[d.frame];
        setFrame(object, frame, d.fixSpriteAspect);
        d.lastFrame = frame;
      }
    });
  };

  function setFrame(object, frame, fixAspect) {
    const material = object.material;
    const tex = material.uniforms.map.value;
    (0, _threeUtil.shareAtlasTexture)(renderer, frame.atlas, tex); // console.log("set frame", object.name, frame);

    material.uniforms.repeat.value.copy(frame.repeat);
    material.uniforms.offset.value.copy(frame.offset);

    if (fixAspect) {
      const aspect = frame.width / frame.height;
      object.scale.x = object.scale.y * aspect;
    }
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/math":"src/util/math.js","../util/SpriteManager":"src/util/SpriteManager.js","../util/load":"src/util/load.js","../util/three-util":"src/util/three-util.js","../util/Assets":"src/util/Assets.js"}],"src/components/CardHint.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _hintCardLeft = _interopRequireDefault(require("../assets/image/ui/hint-card-left.png"));

var _hintCardMiddle = _interopRequireDefault(require("../assets/image/ui/hint-card-middle.png"));

var _hintCardRight = _interopRequireDefault(require("../assets/image/ui/hint-card-right.png"));

var _svelte = require("svelte");

var _locale = require("../util/locale");

var _tokens = require("../util/tokens");

var _Random = _interopRequireDefault(require("../util/Random"));

var _touchInv = _interopRequireDefault(require("../assets/image/ui/touch-inv.png"));

var _treeInv = _interopRequireDefault(require("../assets/image/ui/tree-inv.png"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* components/CardHint.svelte generated by Svelte v3.31.0 */
function create_if_block_2(ctx) {
  let div;
  let img;
  let img_src_value;
  return {
    c() {
      div = (0, _internal.element)("div");
      img = (0, _internal.element)("img");
      if (img.src !== (img_src_value =
      /*icon*/
      ctx[2])) (0, _internal.attr)(img, "src", img_src_value);
      (0, _internal.attr)(img, "alt", "");
      (0, _internal.attr)(img, "class", "token-image svelte-1c19bb0");
      (0, _internal.attr)(div, "class", "icon-container svelte-1c19bb0");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      (0, _internal.append)(div, img);
    },

    p(ctx, dirty) {
      if (dirty &
      /*icon*/
      4 && img.src !== (img_src_value =
      /*icon*/
      ctx[2])) {
        (0, _internal.attr)(img, "src", img_src_value);
      }
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
    }

  };
} // (93:37) 


function create_if_block_1(ctx) {
  let t_value =
  /*text*/
  ctx[0][_locale.language.get()] + "";
  let t;
  return {
    c() {
      t = (0, _internal.text)(t_value);
    },

    m(target, anchor) {
      (0, _internal.insert)(target, t, anchor);
    },

    p(ctx, dirty) {
      if (dirty &
      /*text*/
      1 && t_value !== (t_value =
      /*text*/
      ctx[0][_locale.language.get()] + "")) (0, _internal.set_data)(t, t_value);
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(t);
    }

  };
} // (91:6) {#if text && typeof text === "string"}


function create_if_block(ctx) {
  let t;
  return {
    c() {
      t = (0, _internal.text)(
      /*text*/
      ctx[0]);
    },

    m(target, anchor) {
      (0, _internal.insert)(target, t, anchor);
    },

    p(ctx, dirty) {
      if (dirty &
      /*text*/
      1) (0, _internal.set_data)(t,
      /*text*/
      ctx[0]);
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(t);
    }

  };
}

function create_fragment(ctx) {
  let div4;
  let div1;
  let img0;
  let img0_src_value;
  let t0;
  let div0;
  let t1;
  let img1;
  let img1_src_value;
  let t2;
  let div3;
  let t3;
  let div2;
  let mounted;
  let dispose;
  let if_block0 =
  /*icon*/
  ctx[2] && create_if_block_2(ctx);

  function select_block_type(ctx, dirty) {
    if (
    /*text*/
    ctx[0] && typeof
    /*text*/
    ctx[0] === "string") return create_if_block;
    if (
    /*text*/
    ctx[0] && "en" in
    /*text*/
    ctx[0]) return create_if_block_1;
  }

  let current_block_type = select_block_type(ctx, -1);
  let if_block1 = current_block_type && current_block_type(ctx);
  return {
    c() {
      div4 = (0, _internal.element)("div");
      div1 = (0, _internal.element)("div");
      img0 = (0, _internal.element)("img");
      t0 = (0, _internal.space)();
      div0 = (0, _internal.element)("div");
      t1 = (0, _internal.space)();
      img1 = (0, _internal.element)("img");
      t2 = (0, _internal.space)();
      div3 = (0, _internal.element)("div");
      if (if_block0) if_block0.c();
      t3 = (0, _internal.space)();
      div2 = (0, _internal.element)("div");
      if (if_block1) if_block1.c();
      (0, _internal.attr)(img0, "class", "card-hint-image slice-0 svelte-1c19bb0");
      (0, _internal.attr)(img0, "alt", "");
      if (img0.src !== (img0_src_value = _hintCardLeft.default)) (0, _internal.attr)(img0, "src", img0_src_value);
      (0, _internal.attr)(div0, "class", "card-hint-image slice-1 svelte-1c19bb0");
      (0, _internal.set_style)(div0, "background-image", "url('" + _hintCardMiddle.default + "')");
      (0, _internal.attr)(img1, "class", "card-hint-image slice-2 svelte-1c19bb0");
      (0, _internal.attr)(img1, "alt", "");
      if (img1.src !== (img1_src_value = _hintCardRight.default)) (0, _internal.attr)(img1, "src", img1_src_value);
      (0, _internal.attr)(div1, "class", "card-box svelte-1c19bb0");
      (0, _internal.set_style)(div1, "width",
      /*boxWidth*/
      ctx[3] + "px");
      (0, _internal.attr)(div2, "class", "card-text svelte-1c19bb0");
      (0, _internal.attr)(div3, "class", "card-content svelte-1c19bb0");
      (0, _internal.attr)(div4, "class", "card-hint-container svelte-1c19bb0");
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div4, anchor);
      (0, _internal.append)(div4, div1);
      (0, _internal.append)(div1, img0);
      (0, _internal.append)(div1, t0);
      (0, _internal.append)(div1, div0);
      (0, _internal.append)(div1, t1);
      (0, _internal.append)(div1, img1);
      (0, _internal.append)(div4, t2);
      (0, _internal.append)(div4, div3);
      if (if_block0) if_block0.m(div3, null);
      (0, _internal.append)(div3, t3);
      (0, _internal.append)(div3, div2);
      if (if_block1) if_block1.m(div2, null);
      /*div2_binding*/

      ctx[9](div2);

      if (!mounted) {
        dispose = [(0, _internal.listen)(window, "resize",
        /*resize*/
        ctx[4], {
          passive: true
        }), (0, _internal.listen)(div4, "click",
        /*clicked*/
        ctx[5])];
        mounted = true;
      }
    },

    p(ctx, [dirty]) {
      if (dirty &
      /*boxWidth*/
      8) {
        (0, _internal.set_style)(div1, "width",
        /*boxWidth*/
        ctx[3] + "px");
      }

      if (
      /*icon*/
      ctx[2]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_2(ctx);
          if_block0.c();
          if_block0.m(div3, t3);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }

      if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block1) {
        if_block1.p(ctx, dirty);
      } else {
        if (if_block1) if_block1.d(1);
        if_block1 = current_block_type && current_block_type(ctx);

        if (if_block1) {
          if_block1.c();
          if_block1.m(div2, null);
        }
      }
    },

    i: _internal.noop,
    o: _internal.noop,

    d(detaching) {
      if (detaching) (0, _internal.detach)(div4);
      if (if_block0) if_block0.d();

      if (if_block1) {
        if_block1.d();
      }
      /*div2_binding*/


      ctx[9](null);
      mounted = false;
      (0, _internal.run_all)(dispose);
    }

  };
}

function updateSize(textEl, text) {
  const r = textEl.getBoundingClientRect();
  return Math.max(270, r.width + 10 + 24 + 40);
}

function instance($$self, $$props, $$invalidate) {
  const dispatch = (0, _svelte.createEventDispatcher)();
  let {
    text = ""
  } = $$props;
  let {
    iconMode = null
  } = $$props;
  let {
    token = ""
  } = $$props;
  let icon;
  let textEl;
  let boxWidth;
  const random = (0, _Random.default)();
  let currentToken;

  const nextToken = () => {
    $$invalidate(8, currentToken = _tokens.InvertedTokenURLs[random.pick(_tokens.AllTokens)]);
    if (iconMode === "token-random") $$invalidate(2, icon = currentToken);
  };

  nextToken();
  (0, _svelte.onMount)(() => {
    resize();
    let interval;
    let timeout = setTimeout(() => {
      interval = setInterval(nextToken, 1000);
    }, 1000);
    return () => {
      clearTimeout(timeout);
      clearInterval(interval);
    };
  });

  function resize() {
    $$invalidate(3, boxWidth = updateSize(textEl, text));
  }

  function clicked() {
    dispatch("close");
  }

  function div2_binding($$value) {
    _internal.binding_callbacks[$$value ? "unshift" : "push"](() => {
      textEl = $$value;
      $$invalidate(1, textEl);
    });
  }

  $$self.$$set = $$props => {
    if ("text" in $$props) $$invalidate(0, text = $$props.text);
    if ("iconMode" in $$props) $$invalidate(6, iconMode = $$props.iconMode);
    if ("token" in $$props) $$invalidate(7, token = $$props.token);
  };

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*textEl, text*/
    3) {
      $: {
        if (textEl && text) {
          $$invalidate(3, boxWidth = updateSize(textEl, text));
        }
      }
    }

    if ($$self.$$.dirty &
    /*iconMode, currentToken, token*/
    448) {
      $: {
        if (iconMode === "token-random") {
          $$invalidate(2, icon = currentToken);
        } else if (iconMode === "finger") {
          $$invalidate(2, icon = _touchInv.default);
        } else if (iconMode === "tree") {
          $$invalidate(2, icon = _treeInv.default);
        } else if (iconMode === "token") {
          $$invalidate(2, icon = _tokens.InvertedTokenURLs[token]);
        }
      }
    }
  };

  return [text, textEl, icon, boxWidth, resize, clicked, iconMode, token, currentToken, div2_binding];
}

class CardHint extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      text: 0,
      iconMode: 6,
      token: 7
    });
  }

}

var _default = CardHint;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","../assets/image/ui/hint-card-left.png":"src/assets/image/ui/hint-card-left.png","../assets/image/ui/hint-card-middle.png":"src/assets/image/ui/hint-card-middle.png","../assets/image/ui/hint-card-right.png":"src/assets/image/ui/hint-card-right.png","svelte":"node_modules/svelte/index.mjs","../util/locale":"src/util/locale.js","../util/tokens":"src/util/tokens.js","../util/Random":"src/util/Random.js","../assets/image/ui/touch-inv.png":"src/assets/image/ui/touch-inv.png","../assets/image/ui/tree-inv.png":"src/assets/image/ui/tree-inv.png"}],"src/overlays/TutorialMessage.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _transition = require("svelte/transition");

var _svelte = require("svelte");

var _alecSvelte = require("../alec-svelte");

var Tags = _interopRequireWildcard(require("../tags"));

var _config = _interopRequireDefault(require("../config"));

var _AnimatedTextSpan = _interopRequireDefault(require("../components/AnimatedTextSpan.svelte"));

var _transitions = require("../animations/transitions");

var _tokens = require("../util/tokens");

var _Image = _interopRequireDefault(require("../components/Image.svelte"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _CardHint = _interopRequireDefault(require("../components/CardHint.svelte"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* overlays/TutorialMessage.svelte generated by Svelte v3.31.0 */
// import GameProgress from "../components/GameProgress.svelte";
function create_if_block(ctx) {
  let cardhint;
  let current;
  cardhint = new _CardHint.default({
    props: {
      token:
      /*token*/
      ctx[3],
      iconMode:
      /*iconMode*/
      ctx[2],
      text:
      /*text*/
      ctx[1]
    }
  });
  cardhint.$on("close",
  /*close_handler*/
  ctx[6]);
  return {
    c() {
      (0, _internal.create_component)(cardhint.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(cardhint, target, anchor);
      current = true;
    },

    p(ctx, dirty) {
      const cardhint_changes = {};
      if (dirty &
      /*token*/
      8) cardhint_changes.token =
      /*token*/
      ctx[3];
      if (dirty &
      /*iconMode*/
      4) cardhint_changes.iconMode =
      /*iconMode*/
      ctx[2];
      if (dirty &
      /*text*/
      2) cardhint_changes.text =
      /*text*/
      ctx[1];
      cardhint.$set(cardhint_changes);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(cardhint.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(cardhint.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(cardhint, detaching);
    }

  };
}

function create_fragment(ctx) {
  let div;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  let if_block =
  /*$canShow*/
  ctx[4] && create_if_block(ctx);
  return {
    c() {
      div = (0, _internal.element)("div");
      if (if_block) if_block.c();
      (0, _internal.attr)(div, "class", "container svelte-1lvhwzd");
      (0, _internal.toggle_class)(div, "ignorePointer", ignorePointer);
    },

    m(target, anchor) {
      (0, _internal.insert)(target, div, anchor);
      if (if_block) if_block.m(div, null);
      current = true;

      if (!mounted) {
        dispose = (0, _internal.listen)(div, "introin", introin_handler);
        mounted = true;
      }
    },

    p(ctx, [dirty]) {
      if (
      /*$canShow*/
      ctx[4]) {
        if (if_block) {
          if_block.p(ctx, dirty);

          if (dirty &
          /*$canShow*/
          16) {
            (0, _internal.transition_in)(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          (0, _internal.transition_in)(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        (0, _internal.group_outros)();
        (0, _internal.transition_out)(if_block, 1, 1, () => {
          if_block = null;
        });
        (0, _internal.check_outros)();
      }

      if (dirty &
      /*ignorePointer*/
      0) {
        (0, _internal.toggle_class)(div, "ignorePointer", ignorePointer);
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(if_block);
      (0, _internal.add_render_callback)(() => {
        if (div_outro) div_outro.end(1);
        if (!div_intro) div_intro = (0, _internal.create_in_transition)(div, _transitions.fadeInTransition, {
          // y: 20,
          delay: 0,
          duration: 1000
        });
        div_intro.start();
      });
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(if_block);
      if (div_intro) div_intro.invalidate();
      div_outro = (0, _internal.create_out_transition)(div, _transitions.fadeInTransition, {
        // y: 0,
        delay: 0,
        duration: 1000
      });
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(div);
      if (if_block) if_block.d();
      if (detaching && div_outro) div_outro.end();
      mounted = false;
      dispose();
    }

  };
}

let ignorePointer = true;

const introin_handler = () => {}; // ignorePointer = false;


function instance($$self, $$props, $$invalidate) {
  let $canShow,
      $$unsubscribe_canShow = _internal.noop,
      $$subscribe_canShow = () => ($$unsubscribe_canShow(), $$unsubscribe_canShow = (0, _internal.subscribe)(canShow, $$value => $$invalidate(4, $canShow = $$value)), canShow);

  $$self.$$.on_destroy.push(() => $$unsubscribe_canShow());
  const {
    entity
  } = (0, _alecSvelte.context)();
  const ref = entity.ref();
  let {
    canShow
  } = $$props;
  $$subscribe_canShow();
  let {
    text = ""
  } = $$props;
  let {
    iconMode = false
  } = $$props;
  let {
    token = ""
  } = $$props;
  (0, _svelte.onMount)(() => {
    // ignorePointer = false;
    return () => {};
  });

  const close_handler = () => {
    // ignorePointer = true;
    ref.kill();
  };

  $$self.$$set = $$props => {
    if ("canShow" in $$props) $$subscribe_canShow($$invalidate(0, canShow = $$props.canShow));
    if ("text" in $$props) $$invalidate(1, text = $$props.text);
    if ("iconMode" in $$props) $$invalidate(2, iconMode = $$props.iconMode);
    if ("token" in $$props) $$invalidate(3, token = $$props.token);
  };

  return [canShow, text, iconMode, token, $canShow, ref, close_handler];
}

class TutorialMessage extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      canShow: 0,
      text: 1,
      iconMode: 2,
      token: 3
    });
  }

}

var _default = TutorialMessage;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","svelte/transition":"node_modules/svelte/transition/index.mjs","svelte":"node_modules/svelte/index.mjs","../alec-svelte":"src/alec-svelte/index.js","../tags":"src/tags/index.js","../config":"src/config.js","../components/AnimatedTextSpan.svelte":"src/components/AnimatedTextSpan.svelte.js","../animations/transitions":"src/animations/transitions.js","../util/tokens":"src/util/tokens.js","../components/Image.svelte":"src/components/Image.svelte.js","../util/Random":"src/util/Random.js","../components/CardHint.svelte":"src/components/CardHint.svelte.js"}],"src/systems/TutorialMessageSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = TutorialMessageSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _TutorialMessage = _interopRequireDefault(require("../overlays/TutorialMessage.svelte"));

var _store = require("svelte/store");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function TutorialMessageSystem(world) {
  const messages = world.view(Tags.TutorialMessage);
  let canShow = !Boolean(world.findTag(Tags.IsGameUIActive));
  const canShowStore = (0, _store.writable)(canShow);
  canShowStore.subscribe(v => {
    canShow = v;
  });
  return function TutorialMessageSystemDT(dt) {
    const newCanShow = !Boolean(world.findTag(Tags.IsGameUIActive));

    if (newCanShow !== canShow) {
      canShow = newCanShow;
      canShowStore.update(d => canShow);
    }

    if (canShow) {
      messages.forEach(e => {
        const k = e.get(Tags.TutorialMessage);
        k.time += dt;

        if (k.time >= k.delay && !e.has(Tags.ViewLayer)) {
          e.add(Tags.ViewLayer, {
            component: _TutorialMessage.default,
            id: k.id,
            props: {
              canShow: canShowStore,
              token: k.token,
              iconMode: k.iconMode,
              text: k.message
            }
          });
        }

        const curTime = Math.max(0, k.time - k.delay);

        if (curTime >= k.duration) {
          e.kill();
        }
      });
    }
  };
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../overlays/TutorialMessage.svelte":"src/overlays/TutorialMessage.svelte.js","svelte/store":"node_modules/svelte/store/index.mjs"}],"src/systems/FloatingEndLines.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = FloatingEndLines;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _Random = _interopRequireDefault(require("../util/Random"));

var _Line3D = _interopRequireDefault(require("./writing/Line3D"));

var _AnimationSystem = require("./AnimationSystem");

var _easeAnimate = _interopRequireDefault(require("../util/ease-animate"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function FloatingEndLines(world) {
  const random = (0, _Random.default)();
  const event = world.listen(Tags.FinalBiomeResolutionLines);
  const lines = world.view(Tags.FloatingEndLine);
  return function FloatingEndLinesSys(dt) {
    if (event.added.length > 0) {
      start();
    }

    lines.forEach(e => {
      const d = e.get(Tags.FloatingEndLine);
      d.time += dt;
      const curTime = Math.max(0, d.time - d.delay);
      const anim = (0, _easeAnimate.default)(d.time, d.duration, d.delay, d.animateDuration, d.ease);
      const mesh = e.get(Tags.Object3D);
      mesh.material.uniforms.thickness.value = mesh.userData._lineThickness * anim;
      mesh.material.uniforms.opacity.value = anim;
      mesh.position.y += dt * d.speed; // mesh.material.uniforms.opacity.value = anim;

      if (curTime >= d.duration) {
        // kill
        e.kill();
      }
    });
  };

  function start() {
    const lines = Array(50).fill().map(() => {
      const thickness = 1;
      const mesh = new _Line3D.default(world, {
        thickness
      });
      const [x, z] = random.onCircle(random.range(2.5, 15));
      mesh.userData._lineThickness = thickness;
      mesh.position.x = x;
      mesh.position.y = random.range(2, 10);
      mesh.position.z = z; // mesh.material.uniforms.drawing.value = true;
      // mesh.material.uniforms.draw.value = 0;

      mesh.updatePath([[0, -1, 0], [0, 0, 0], [0, 1, 0]], false, false);
      mesh.userData._entity = world.entity().add(Tags.Object3D, mesh).add(Tags.FloatingEndLine);

      const d = mesh.userData._entity.get(Tags.FloatingEndLine);

      d.duration = random.range(2, 3.5);
      d.delay = 2 + random.range(0, 2);
      d.animateDuration = 0.5;
      d.speed = random.range(0.5, 2); // const group = new THREE.Mesh(
      //   new THREE.BoxGeometry(1, 1, 1),
      //   new THREE.MeshBasicMaterial({ color: "red" })
      // );
      // group.position.copy(mesh.position);
      // mesh.userData._entity = world.entity().add(Tags.Object3D, group);

      return mesh;
    });
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/Random":"src/util/Random.js","./writing/Line3D":"src/systems/writing/Line3D.js","./AnimationSystem":"src/systems/AnimationSystem.js","../util/ease-animate":"src/util/ease-animate.js"}],"src/systems/TokenPlacementSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = TokenPlacementSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var THREE = _interopRequireWildcard(require("three"));

var _AnimationSystem = require("./AnimationSystem");

var _Line3D = _interopRequireDefault(require("./writing/Line3D"));

var _tweenTicker = _interopRequireDefault(require("../util/tween-ticker"));

var _tokens = require("../util/tokens");

var _load = require("../util/load");

var _nfb = require("../nfb");

var _geometry = require("../util/geometry");

var _haikugen = _interopRequireDefault(require("../util/haikugen"));

var ShaderManager = _interopRequireWildcard(require("../util/ShaderManager"));

var _materials = require("../util/materials");

var _Assets = _interopRequireDefault(require("../util/Assets"));

var _ObjectPool = _interopRequireDefault(require("../util/ObjectPool"));

var _locale = require("../util/locale");

var _Random = _interopRequireDefault(require("../util/Random"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const Y_LINE_POSITION = 1.25;

function TokenPlacementSystem(world) {
  const bloom = 0.666;
  const renderLayers = world.findTag(Tags.RenderLayers);
  const renderer = world.findTag(Tags.Renderer);
  const white = new THREE.Color(1, 1, 1);
  const whiteWithBloom = new THREE.Color(1 + bloom, 1 + bloom, 1 + bloom);
  const shadowAlpha = 0.1;
  const shadowColor = new THREE.Color("#000"); // const shadowColor = new THREE.Color("#280422").lerp(white, 1 - shadowAlpha);

  const haiku = (0, _haikugen.default)();
  const timeline = (0, _tweenTicker.default)();

  const [blobShadowMap] = _Assets.default.createGPUTextureTask(renderer, "image/data/soft-circle");

  const tokenSpritePool = new _ObjectPool.default({
    initialCapacity: 10,

    create() {
      return createTokenSprite();
    },

    renew(m) {},

    release(m) {}

  });
  const availableTypes = Object.keys(_tokens.TokenURLs); // const tokenMap = entries.reduce((dict, t) => {
  //   dict[t.key] = t.texture;
  //   return dict;
  // }, {});

  const tokenViewWithObject = world.view([Tags.GroundAsset, Tags.GroundAssetToken, Tags.Object3D]);
  const tokenViewWaitingForCollection = world.view(Tags.TokenIsCollecting);
  const tokenViewTriggers = world.view(Tags.TriggerTokenLine);
  const tokenEvents = world.listen(Tags.GroundAssetToken);
  const hakiCardSavedEvents = world.listen(Tags.HaikuCardSaved);
  const finishedPoemView = world.view(Tags.FinishedPoem);
  const collectedTokenView = world.view(Tags.CollectedToken);
  const collectedTokenEvents = world.listen(Tags.CollectedToken);
  const messages = world.view(Tags.TutorialMessage);
  const writtenLineView = world.view([Tags.WrittenStanzaLine]);
  const tmpUserPos2D = [0, 0];
  const tmpTokenPos2D = [0, 0];
  const tokensDiscovered = world.tag(Tags.TokensDiscoveredSet, new Set());
  const activeEnvEvents = world.listen(Tags.ActiveEnvironmentState);
  const userChar = world.findTag(Tags.UserCharacter);
  const orbGeom = new THREE.SphereBufferGeometry(1, 16, 16);
  let isFinalizingPoem = false;
  let finalPoemTime = 0;
  let finalPoemDelay = 1;
  const random = (0, _Random.default)();
  return function TokenPlacementSystemDT(dt) {
    timeline.tick(dt);
    const userPos3D = userChar.position;
    tmpUserPos2D[0] = userPos3D.x;
    tmpUserPos2D[1] = userPos3D.z;

    if (activeEnvEvents.changed) {
      tokensDiscovered.clear();
      collectedTokenView.forEach(c => c.kill());
      tokenViewWaitingForCollection.forEach(e => e.tagOff(Tags.TokenIsCollecting));
      tokenViewTriggers.forEach(e => e.tagOff(Tags.TriggerTokenLine));
    } // add tokens to world


    tokenEvents.added.forEach(e => {
      const asset = e.get(Tags.GroundAsset);
      const tokenData = e.get(Tags.GroundAssetToken);
      const spriteGroup = tokenSpritePool.next();
      const object = spriteGroup.userData.sprite;
      (0, _materials.setSpriteToken)(renderer, object, tokenData.type, 1.25);
      const floorGap = 1;
      object.userData.startY = floorGap;
      object.userData.endY = object.userData.startY + 1;
      object.position.x = asset.x;
      object.position.z = asset.z;
      object.position.y = object.userData.startY;
      object.userData.show = null;
      const shadow = spriteGroup.userData.shadow;
      shadow.position.copy(object.position);
      shadow.position.y = 0;
      spriteGroup.visible = false;
      e.add(Tags.Object3D, spriteGroup);
      e.add(Tags.ShaderUniformTime);
      const shader = e.get(Tags.ShaderUniformTime);
      shader.uniform = object.material.uniforms.time;
    });
    tokenEvents.removing.forEach(e => {
      // console.log("removing", e.get(Tags.GroundAssetToken).type);
      if (e.has(Tags.Object3D)) {
        const spriteGroup = e.get(Tags.Object3D);
        tokenSpritePool.release(spriteGroup);
      }
    });
    const isDirectingToOrigin = Boolean(world.findTag(Tags.DirectUserToOrigin));
    const introSeq = Boolean(world.findTag(Tags.OriginTreeIntroSequence));
    const ignoreTokens = Boolean(world.findTag(Tags.BlockTokenCollection));
    const canCollect = !introSeq && collectedTokenView.length < 3 && !isDirectingToOrigin && !ignoreTokens;
    const isCollectingOne = tokenViewWaitingForCollection.length > 0;
    const isTriggeringOne = tokenViewTriggers.length > 0;
    const isCollecting = isCollectingOne || isTriggeringOne;
    tokenViewWithObject.forEach(e => {
      const asset = e.get(Tags.GroundAsset);
      const t = e.get(Tags.GroundAssetToken);
      const spriteGroup = e.get(Tags.Object3D);
      const object = spriteGroup.userData.sprite;
      const shadow = spriteGroup.userData.shadow; // see if user can collect this type (they don't have it already)

      const isShowing = object.userData.show;
      const canCollectType = !tokensDiscovered.has(t.type);
      const map = object.material.uniforms.map.value;
      const mapReady = Boolean(map);
      const shouldShow = canCollect && canCollectType && mapReady && !isCollecting; // object.material.uniforms.effect.value =
      // shouldShow && !hasCollectionFeature ? 1 : 0;

      if (shouldShow !== isShowing) {
        if (mapReady) {// const aspect = map.image.width / map.image.height;
          // const height = 1.25;
          // const width = height * aspect;
          // object.scale.set(width, height, 1);
        }

        object.userData.show = shouldShow;

        if (!isShowing && shouldShow) {// spriteGroup.visible = true;
        }

        timeline.to(object.position, {
          y: shouldShow ? object.userData.startY : object.userData.endY,
          ease: "sineOut",
          duration: 1
        });
        timeline.to(object.userData, {
          alpha: shouldShow ? 1 : 0,
          ease: "sineOut",
          duration: 1
        }).on("update", ev => {
          const t = object.userData.alpha;
          object.material.uniforms.opacity.value = t;
          const l = MathUtil.lerp(1, 1 + bloom, t);
          object.material.uniforms.color.value.setRGB(l, l, l);
          object.material.visible = t >= 1e-5;
          shadow.material.opacity = t * shadowAlpha;
        }).on("complete", ev => {
          if (!ev.cancelling) {
            if (!shouldShow) {
              spriteGroup.visible = false;
            }
          }
        });
      }

      tmpTokenPos2D[0] = asset.x;
      tmpTokenPos2D[1] = asset.z;
      const tokenRadius = 2;
      const userRadius = 1;

      if (canCollectType && shouldShow && (0, _geometry.circlesIntersect)(tmpTokenPos2D, tokenRadius, tmpUserPos2D, userRadius)) {
        e.tagOn(Tags.TriggerTokenLine);
        messages.forEach(e => e.kill());
      }
    });

    if (collectedTokenEvents.added.length > 0) {
      const tokensCollected = collectedTokenEvents.query.entities;
      const lastEntity = collectedTokenEvents.added[collectedTokenEvents.added.length - 1]; // sendAnalytics({
      //   event: "token_collect",
      //   eventLabel: "token_collect",
      // });
      // lastEntity.add(Tags.CapeMagicalEffect);
      // lastEntity.add(Tags.AutoRemoveCapeMagicalEffect);

      if (tokensCollected.length < 3) {
        const hint = world.entity().add(Tags.TutorialMessage);
        const last = lastEntity.get(Tags.CollectedToken);
        const msg = hint.get(Tags.TutorialMessage);
        msg.iconMode = "token";
        msg.token = last.type;
        msg.message = last.stanza;
        msg.id = last.type;
        msg.delay = 0.5;
        msg.duration = 6;
      }

      if (!isFinalizingPoem && tokensCollected.length >= 3) {
        isFinalizingPoem = true;
        finalPoemTime = 0;
      }
    }

    if (isFinalizingPoem) {
      finalPoemTime += dt;

      if (finalPoemTime >= finalPoemDelay) {
        isFinalizingPoem = false; // add final poem

        const poemEntity = world.entity().add(Tags.FinishedPoem);
        const fp = poemEntity.get(Tags.FinishedPoem);
        const curTokens = collectedTokenEvents.query.entities;

        for (let i = 0; i < 3; i++) {
          const c = curTokens[i].get(Tags.CollectedToken);
          fp.lines[i] = c.stanza;
          fp.tokens[i] = c.type;
        }

        collectedTokenView.forEach(e => e.kill()); // sendAnalytics({
        //   event: "poem_collect",
        //   eventLabel: "poem_collect",
        // });
      }
    }
  };

  function createText(text, position) {
    const startY = 1.75;
    const endY = 2.25;
    const g = new THREE.Group();
    g.position.copy(position);
    g.position.y = startY;
    const textEntity = world.entity().add(Tags.TextSprite3D).add(Tags.Object3D, g);
    const textData = textEntity.get(Tags.TextSprite3D);
    textData.text = text;
    textData.depth = false;
    textData.parent = g;
    textData.fontSize = 16;
    textData.opacity = 0;
    (0, _AnimationSystem.tweenTo)(world, g.position, "y", endY, 2, "expoOut");
    (0, _AnimationSystem.tweenTo)(world, textData, "opacity", 1, 1, "sineOut");
    return textEntity;
  }

  function createTokenSprite() {
    const sprite = new THREE.Mesh((0, _materials.getSpriteGeometry)(), (0, _materials.createTokenMaterial)(bloom, false));
    sprite.renderOrder = 10;
    sprite.userData.alpha = 1;
    sprite.name = "token";
    const shadow = new THREE.Sprite(new THREE.SpriteMaterial({
      map: blobShadowMap,
      depthTest: false,
      depthWrite: false,
      // blending: THREE.MultiplyBlending,
      color: shadowColor,
      opacity: shadowAlpha,
      transparent: true
    }));
    shadow.scale.set(2, 0.66, 1).multiplyScalar(0.75);
    shadow.layers.disableAll();
    shadow.layers.enable(renderLayers.shadow);
    const spriteGroup = new THREE.Group();
    spriteGroup.add(sprite);
    spriteGroup.add(shadow);
    spriteGroup.userData.sprite = sprite;
    spriteGroup.userData.shadow = shadow;
    return spriteGroup;
  }
}
},{"../tags":"src/tags/index.js","../util/math":"src/util/math.js","three":"src/vendor/three.module.js","./AnimationSystem":"src/systems/AnimationSystem.js","./writing/Line3D":"src/systems/writing/Line3D.js","../util/tween-ticker":"src/util/tween-ticker.js","../util/tokens":"src/util/tokens.js","../util/load":"src/util/load.js","../nfb":"src/nfb.js","../util/geometry":"src/util/geometry.js","../util/haikugen":"src/util/haikugen.js","../util/ShaderManager":"src/util/ShaderManager.js","../util/materials":"src/util/materials.js","../util/Assets":"src/util/Assets.js","../util/ObjectPool":"src/util/ObjectPool.js","../util/locale":"src/util/locale.js","../util/Random":"src/util/Random.js"}],"src/systems/TokenConstellationSystem.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = TokenConstellationSystem;

var Tags = _interopRequireWildcard(require("../tags"));

var MathUtil = _interopRequireWildcard(require("../util/math"));

var THREE = _interopRequireWildcard(require("three"));

var Helpers = _interopRequireWildcard(require("../util/helpers"));

var _AnimationSystem = require("./AnimationSystem");

var _Line3D = _interopRequireDefault(require("./writing/Line3D"));

var _tweenTicker = _interopRequireDefault(require("../util/tween-ticker"));

var _tokens = require("../util/tokens");

var _load = require("../util/load");

var _geometry = require("../util/geometry");

var _haikugen = _interopRequireDefault(require("../util/haikugen"));

var ShaderManager = _interopRequireWildcard(require("../util/ShaderManager"));

var _materials = require("../util/materials");

var _Assets = _interopRequireDefault(require("../util/Assets"));

var _ObjectPool = _interopRequireDefault(require("../util/ObjectPool"));

var _locale = require("../util/locale");

var _Random = _interopRequireDefault(require("../util/Random"));

var _threeUtil = require("../util/three-util");

var _queryString = _interopRequireDefault(require("../util/query-string"));

var _nfb = require("../nfb");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const Y_LINE_POSITION = 1.25;
const userHitRadius = 2.5;
const userHitRadiusSq = userHitRadius * userHitRadius;

function splitPhrase(phrase) {
  const words = phrase.split(" ");
  const result = [];
  words.forEach(w => {
    const chunks = w.split("-");
    chunks.forEach((c, i, list) => {
      let str = c;

      if (i < list.length - 1) {
        str += "-";
      }

      if (str) result.push(str);
    });
  });
  return result;
}

function TokenConstellationSystem(world) {
  const bloom = 0.666;
  const renderLayers = world.findTag(Tags.RenderLayers);
  const renderer = world.findTag(Tags.Renderer);
  const white = new THREE.Color(1, 1, 1);
  const whiteWithBloom = new THREE.Color(1 + bloom, 1 + bloom, 1 + bloom);
  const shadowAlpha = 0.1;
  const shadowColor = new THREE.Color("#280422").lerp(white, 1 - shadowAlpha);
  const haiku = (0, _haikugen.default)();
  const timeline = (0, _tweenTicker.default)();
  const startY = 1.75;
  const endY = 2.25;
  const planeGeo = new THREE.PlaneBufferGeometry(1, 1, 1, 1);
  const tokenCollectingEvents = world.listen([Tags.GroundAsset, Tags.GroundAssetToken, Tags.Object3D, Tags.TriggerTokenLine]); // const availableTypes = Object.keys(TokenURLs);
  // // const tokenMap = entries.reduce((dict, t) => {
  // //   dict[t.key] = t.texture;
  // //   return dict;
  // // }, {});
  // const tokenViewWithObject = world.view([
  //   Tags.GroundAsset,
  //   Tags.GroundAssetToken,
  //   Tags.Object3D,
  // ]);
  // const tokenViewWaitingForCollection = world.view([
  // Tags.GroundAsset,
  // Tags.GroundAssetToken,
  // Tags.Object3D,
  // Tags.TokenIsCollecting,
  // ]);
  // const tokenEvents = world.listen(Tags.GroundAssetToken);

  const finishedPoemView = world.view(Tags.FinishedPoem);
  const collectedTokenView = world.view(Tags.CollectedToken);
  const collectedTokenEvents = world.listen(Tags.CollectedToken);
  const collectedHaikuView = world.view(Tags.HaikuInInventory);
  const discoveredSet = world.findTag(Tags.TokensDiscoveredSet);
  const tmpUserPos2D = [0, 0];
  const tmpTokenPos2D = [0, 0]; // const tokensDiscovered = world.tag(Tags.TokensDiscoveredSet, new Set());

  const activeEnvEvents = world.listen(Tags.ActiveEnvironmentState);
  const userChar = world.findTag(Tags.UserCharacter); // const orbGeom = new THREE.SphereBufferGeometry(1, 16, 16);

  const random = (0, _Random.default)();
  const tokenChildrenView = world.view(Tags.TokenChildren);

  const [dotMap] = _Assets.default.createGPUTextureTask(renderer, `image/data/compass-dot`);

  const orbPool = new _ObjectPool.default({
    initialCapacity: 12,
    name: "orbs",

    create() {
      const m = new THREE.Mesh(planeGeo, (0, _materials.createTokenMaterial)(1, false) // new THREE.MeshBasicMaterial({
      //   depthTest: false,
      //   depthWrite: false,
      //   transparent: true,
      //   color: whiteWithBloom,
      // })
      );
      m.material.uniforms.map.value = dotMap;
      m.renderOrder = 10;
      m.position.y = Y_LINE_POSITION;
      m.userData.smallScale = 0.0;
      m.userData.bigScale = 0.45;
      m.userData.alpha = 1;
      m.userData.visibility = 0;
      m.userData.finalScale = 1;
      m.userData._entity = null;
      updateSphereScale(m);
      return m;
    },

    renew(m) {
      m.userData._pool = this;
    },

    release(m) {
      m.userData._pool = null;

      if (m.userData._entity) {
        m.userData._entity.kill();

        m.userData._entity = null;
      }
    }

  });
  const directToOrigin = world.view(Tags.DirectUserToOrigin);
  const directToOriginEvent = world.listen(Tags.DirectUserToOrigin);
  const musicalOrbs = world.view([Tags.Object3D, Tags.MusicalOrb]);
  let orbSpawnTime = 0;
  let orbSpawnDelay = 1;
  const tmpVecA = new THREE.Vector3();
  const tmpVecB = new THREE.Vector3();
  const tmp2D = [0, 0];
  let orbLine = null;

  const spawnMusicalOrb = position => {
    // const radius = 10;
    // direction to center
    // tmpVecA.copy(userPos).normalize().negate();
    // tmpVecB.copy(userPos).addScaledVector(tmpVecA, radius);
    // random.insideCircle(radius / 2, tmp2D);
    // tmpVecB.x += tmp2D[0];
    // tmpVecB.z += tmp2D[1];
    const orb = orbPool.next();
    if (orb.userData._entity) console.error("already has entity");
    orb.userData._entity = world.entity();
    orb.position.copy(position);
    orb.position.y = Y_LINE_POSITION;
    const e = orb.userData._entity;
    e.add(Tags.Object3D, orb);
    e.add(Tags.MusicalOrb);
    orb.userData.alpha = 1;
    orb.userData.visibility = 0;
    orb.userData.finalScale = 1;
    updateSphereScale(orb);
    timeline.to(orb.userData, {
      visibility: 1,
      duration: 1,
      ease: "expoOut"
    }).on("update", () => {
      updateSphereScale(orb);
    });
  };

  const animOutOrb = (orb, shouldKill = false) => {
    if (orb) {
      if (orb.userData._pool) {
        orbPool.release(orb);
      }

      if (shouldKill && orb.userData._entity) {
        orb.userData._entity.kill();

        orb.userData._entity = null;
      }

      (0, _threeUtil.detachObject)(orb);
    }

    timeline.to(orb.userData, {
      alpha: 0,
      duration: 1,
      ease: "expoOut"
    }).on("update", () => {
      updateSphereScale(orb);
    }).on("complete", () => {
      if (orb) {
        if (orb.userData._pool) {
          orbPool.release(orb);
        }

        if (shouldKill && orb.userData._entity) {
          orb.userData._entity.kill();

          orb.userData._entity = null;
        }

        (0, _threeUtil.detachObject)(orb);
      }
    });
  };

  return function TokenConstellationSystem(dt) {
    timeline.tick(dt);
    const userPos3D = userChar.position;
    tmpUserPos2D[0] = userPos3D.x;
    tmpUserPos2D[1] = userPos3D.z; // if (directToOriginEvent.added.length > 0 && !orbLine) {
    //   const a = userPos3D;
    //   const b = new THREE.Vector3(0, 0, 0);
    //   const steps = 10;
    //   const points = [];
    //   for (let i = 0; i < steps; i++) {
    //     const t = i / steps;
    //     const p = a.clone().lerp(b, t);
    //     random.insideCircle(5, tmp2D);
    //     p.x += tmp2D[0];
    //     p.z += tmp2D[1];
    //     p.y = Y_LINE_POSITION;
    //     const dstSq = p.x * p.x + p.z * p.z;
    //     const thresh = 25;
    //     const threshSq = thresh * thresh;
    //     if (dstSq >= threshSq) {
    //       points.push(p);
    //     }
    //   }
    //   const curve = new THREE.CatmullRomCurve3(points);
    //   orbLine = curve.getSpacedPoints(20).map((p) => {
    //     spawnMusicalOrb(p);
    //   });
    // }
    // if (directToOrigin.length > 0 && musicalOrbs.length < 10) {
    //   orbSpawnTime += dt;
    //   if (orbSpawnTime >= orbSpawnDelay) {
    //     orbSpawnTime %= orbSpawnDelay;
    //     spawnMusicalOrb(userPos3D);
    //   }
    // }

    musicalOrbs.forEach(e => {
      const d = e.get(Tags.MusicalOrb);
      const orb = e.get(Tags.Object3D);
      if (d.killing) return; // d.elapsed += dt;
      // if (d.elapsed >= d.duration) {
      //   d.killing = true;
      //   // animOutOrb(orb, true);
      // }

      if (!d.killing && !d.hit) {
        const dx = orb.position.x - tmpUserPos2D[0];
        const dz = orb.position.z - tmpUserPos2D[1];
        const dstSq = dx * dx + dz * dz;

        if (dstSq <= userHitRadiusSq) {
          d.hit = true;
          e.tagOff(Tags.CollectTokenOrb);
          e.tagOn(Tags.CollectTokenOrb);
          e.add(Tags.ParticleEmit);
          const particle = e.get(Tags.ParticleEmit);
          particle.position.copy(orb.position);
          d.killing = true;
          animOutOrb(orb, true);
        }
      }
    });
    tokenCollectingEvents.added.forEach(e => {
      const asset = e.get(Tags.GroundAsset);
      const t = e.get(Tags.GroundAssetToken);
      const spriteGroup = e.get(Tags.Object3D);
      e.tagOff(Tags.TriggerTokenLine);
      showLine(t.type, asset);
    });
    tokenChildrenView.forEach(e => {
      const c = e.get(Tags.TokenChildren);
      if (c.complete || c.killing) return;
      const userInside = (0, _geometry.circlesIntersect)(tmpUserPos2D, 5, c.center, c.radius); // if not completed and we are too far away

      if (!c.removing && !userInside) {
        console.log("token out of range");
        c.removeTime = 0;
        c.removing = true; // should remove
        // animateOutChildren(e, c);
      } else if (c.removing && userInside) {
        c.removing = false;
        console.log("token back in range");
      }

      if (c.removing) {
        c.removeTime += dt;

        if (c.removeTime >= c.removeDelay) {
          c.killing = true;
          c.removing = true;
          animateOutChildren(e, c);
        }
      }

      if (!c.complete && !c.killing && !c.removing) {
        checkMarkerHits(e, c);
      }
    });

    if (activeEnvEvents.changed) {
      tokenChildrenView.forEach(e => {
        killChildrenImmediate(e);
      });
    }
  };

  function updateSphereScale(sphere) {
    const scl = MathUtil.lerp(sphere.userData.smallScale, sphere.userData.bigScale, sphere.userData.alpha) * sphere.userData.visibility * sphere.userData.finalScale;
    sphere.visible = scl > 1e-14;
    sphere.scale.setScalar(Math.max(scl, 1e-14));
  }

  function checkMarkerHits(e, c) {
    for (let i = 0; i < c.markers.length; i++) {
      const m = c.markers[i]; // if this marker isn't hit

      if (!m.hit) {
        // if the marker has a previous non-hit marker, ignore rest
        const prev = i > 0 && c.markers.length > 1 ? c.markers[i - 1] : null;
        if (prev && !prev.hit) break;
        const dx = m.position.x - tmpUserPos2D[0];
        const dz = m.position.z - tmpUserPos2D[1];
        const dstSq = dx * dx + dz * dz;

        if (dstSq <= userHitRadiusSq) {
          m.hit = true;
          e.tagOff(Tags.CollectTokenOrb);
          e.tagOn(Tags.CollectTokenOrb);
          e.add(Tags.ParticleEmit);
          const particle = e.get(Tags.ParticleEmit);
          particle.position.copy(m.position);

          if (m.word) {
            m.text = createText(m.word, m.sphere.position);
          }

          const newFill = c.markers.length <= 1 ? 0.5 : i / (c.markers.length - 1);
          timeline.to(m.sphere.userData, {
            alpha: 0,
            duration: 1,
            ease: "expoOut"
          }).on("update", () => {
            updateSphereScale(m.sphere);
          }).on("complete", () => {
            if (m.sphere) {
              if (m.sphere.userData._pool) {
                orbPool.release(m.sphere);
              }

              (0, _threeUtil.detachObject)(m.sphere);
            }
          });
          const next = i < c.markers.length - 1 ? c.markers[i + 1] : null;

          if (next) {
            timeline.to(next.sphere.userData, {
              visibility: 1,
              duration: 1,
              ease: "expoOut"
            }).on("update", () => {
              updateSphereScale(next.sphere);
            });
          } // c.line.material.uniforms.filling.value = true;
          // timeline.to(c.line.material.uniforms.draw, {
          //   value: newFill2,
          //   duration: 1,
          //   ease: "expoOut",
          // });


          if (i === c.markers.length - 1) {
            c.complete = true;
            discoveredSet.add(c.type);
            e.tagOff(Tags.TokenIsCollecting);
            const collected = world.entity().add(Tags.CollectedToken);
            const collectedData = collected.get(Tags.CollectedToken);
            collected.add(Tags.CapeMagicalEffect);
            collected.add(Tags.AutoRemoveCapeMagicalEffect);
            collectedData.x = c.x;
            collectedData.z = c.z;
            collectedData.type = c.type;
            collectedData.stanza = c.stanza;
            collectedData.stanzaIndex = c.stanzaIndex;
            timeline.to(c.line.material.uniforms.dottedFill, {
              value: 1,
              duration: 1,
              ease: "quadInOut"
            });
          } else {}
        }
      }
    }
  }

  function animateOutChildren(e, c) {
    removeChildren(e);
  }

  function killChildrenImmediate(e) {
    if (!e.has(Tags.TokenChildren)) return;
    const c = e.get(Tags.TokenChildren);
    c.markers.forEach(m => {
      if (m.text) {
        killText(m.text);
      }

      if (m.sphere) {
        if (m.sphere.userData._pool) {
          orbPool.release(m.sphere);
        }

        (0, _threeUtil.detachObject)(m.sphere);
      }
    }); // c.parentEntity.tagOff(Tags.TokenIsCollecting);

    c.line.geometry.dispose();
    c.shadow.geometry.dispose();
    (0, _threeUtil.detachObject)(c.line);
    (0, _threeUtil.detachObject)(c.shadow);
    (0, _threeUtil.detachObject)(c.group);
    e.kill();
  }

  function removeChildren(e) {
    if (!e.has(Tags.TokenChildren)) return;
    const c = e.get(Tags.TokenChildren);
    c.markers.forEach(m => {
      if (m.text) {
        removeText(m.text);
      }

      const sphere = m.sphere;
      timeline.to(m.sphere.userData, {
        finalScale: 0,
        duration: 1,
        ease: "sineOut"
      }).on("update", () => updateSphereScale(m.sphere)).on("complete", () => {
        if (sphere.userData._pool) {
          orbPool.release(sphere);
        }

        (0, _threeUtil.detachObject)(sphere);
      });
    }); // c.parentEntity.tagOff(Tags.TokenIsCollecting);
    // detachObject(c.group);

    timeline.to(c.line.material.uniforms.thickness, {
      value: 0,
      duration: 1,
      ease: "sineOut"
    });
    timeline.to(c.shadow.material.uniforms.thickness, {
      value: 0,
      duration: 1,
      ease: "sineOut"
    }).on("complete", () => {
      console.log("dispose");
      c.line.geometry.dispose();
      c.shadow.geometry.dispose();
      (0, _threeUtil.detachObject)(c.line);
      (0, _threeUtil.detachObject)(c.shadow);
      (0, _threeUtil.detachObject)(c.group);
      e.kill();
    }); // const tweenEntity = tweenTo(
    //   world,
    //   c.line.material.uniforms.thickness,
    //   "value",
    //   0,
    //   1,
    //   "sineOut"
    // );
    // const tween = tweenEntity.get(Tags.TargetKeyTween);
    // tween.callbackOnFinish = () => {
    //   console.log("dispose");
    // };
    // e.kill();
  }

  function showLine(type, asset) {
    // tokensDiscovered.add(type);
    const userAngle = Math.atan2(userChar.direction.z, userChar.direction.x);
    const children = world.entity().add(Tags.TokenChildren);
    children.add(Tags.TokenIsCollecting);
    const c = children.get(Tags.TokenChildren);
    const group = new THREE.Group();
    c.group = group;
    const angle = userAngle; //MathUtil.degToRad(0);

    const u = Math.cos(angle);
    const v = Math.sin(angle);
    const initialOff = 4;
    const posA = new THREE.Vector3(asset.x, 0, asset.z).addScaledVector(new THREE.Vector3(u, 0, v), initialOff);
    const allPreviousPoems = finishedPoemView.map(e => e.get(Tags.FinishedPoem).lines);
    const previousState = collectedTokenView.slice(0, 2).map(e => e.get(Tags.CollectedToken).stanza);
    const stanzaIndex = collectedTokenView.length;
    const stanza = haiku.generateStanza({
      stanza: stanzaIndex,
      token: type,
      ignore: allPreviousPoems,
      state: previousState
    });
    c.x = asset.x;
    c.z = asset.z;
    c.type = type;
    c.stanzaIndex = stanzaIndex;
    c.stanza = stanza; // children.add(Tags.CollectedToken);
    // const collectedData = children.get(Tags.CollectedToken);
    // collectedData.x = asset.x;
    // collectedData.z = asset.z;
    // collectedData.type = type;
    // collectedData.stanza = stanza;
    // collectedData.stanzaIndex = stanzaIndex;

    const phrase = stanza[_locale.language.get()];

    const words = splitPhrase(phrase);
    const markerWords = []; // CollectedToken

    const substeps = collectedTokenView.length;

    for (let i = 0; i < words.length; i++) {
      markerWords.push(words[i]);

      for (let c = 0; c < substeps; c++) {
        if (i < words.length - 1) {
          markerWords.push(null);
        }
      }
    }

    const wordCount = words.length;
    const off = wordCount * 5;
    const dir = random.sign();
    const posB = posA.clone().addScaledVector(new THREE.Vector3(u, 0, v), off);
    const midA = posA.clone().lerp(posB, 0.25);
    const midB = posA.clone().lerp(posB, 0.75);
    const norm = new THREE.Vector2(posA.x, posA.z).sub(new THREE.Vector2(posB.x, posB.z)).normalize();
    const perp = new THREE.Vector2(-norm.y, norm.x);
    let curve;
    const perp3 = new THREE.Vector3(perp.x, 0, perp.y);

    if (wordCount > 3) {
      midA.addScaledVector(perp3, -off / 2 * dir);
      midB.addScaledVector(perp3, off / 2 * dir);
      curve = new THREE.CubicBezierCurve3(posA, midA, midB, posB);
    } else {
      midA.addScaledVector(perp3, off / 2 * dir);
      curve = new THREE.QuadraticBezierCurve3(posA, midA, posB);
    }

    const drawAmount = 1; //wordCount <= 2 ? 1 : 1 / (wordCount - 1);

    const line = new _Line3D.default(world, {
      taper: true,
      thickness: 0.35,
      dotted: true,
      filling: false,
      draw: drawAmount,
      depthWrite: false,
      depthTest: false
    });
    const shadow = new _Line3D.default(world, {
      bloom: 0,
      thickness: 0.75,
      blending: THREE.MultiplyBlending,
      // depthTest: false,
      // depthWrite: false,
      color: shadowColor,
      geometry: line.geometry
    });
    shadow.layers.set(renderLayers.shadow);
    shadow.userData.thickness = shadow.material.uniforms.thickness.value;
    const curvePoints = words.map((word, i, list) => {
      const t = list.length <= 1 ? 0.5 : i / (list.length - 1);
      const pos = new THREE.Vector3();
      curve.getPointAt(t, pos);
      return pos;
    });
    const lineCurve = new THREE.CatmullRomCurve3(curvePoints, false, "catmullrom", 0.5);
    const drawCurve = lineCurve;
    c.markers.length = 0;
    const wordOrbs = markerWords;

    for (let i = 0; i < wordOrbs.length; i++) {
      const word = wordOrbs[i];
      const t = wordOrbs.length <= 1 ? 0.5 : i / (wordOrbs.length - 1);
      const m = orbPool.next();
      console.log(orbPool.log());
      drawCurve.getPointAt(t, m.position);
      m.position.y = Y_LINE_POSITION;
      m.userData.alpha = 1;
      m.userData.visibility = 0;
      m.userData.finalScale = 1;
      group.add(m);
      updateSphereScale(m);

      if (i === 0) {
        // first sphere is always visible
        timeline.to(m.userData, {
          visibility: 1,
          duration: 1,
          ease: "expoOut"
        }).on("update", () => updateSphereScale(m));
      }

      c.markers.push({
        hit: false,
        word,
        sphere: m,
        position: m.position
      });
    }

    const points = c.markers.map(p => {
      const pos = p.position;
      return pos;
    });
    const circle = (0, _geometry.getBoundingCircle)(points.map(p => [p.x, p.z]));
    c.center = circle.center;
    c.radius = circle.radius; // const circleGeom = Helpers.circleHelper2D(circle.center, circle.radius);
    // world.entity().add(Tags.Object3D, circleGeom);
    // const curved = true;
    // if (curved) {
    //   const lineCurve = new THREE.CatmullRomCurve3(
    //     points,
    //     false,
    //     "catmullrom",
    //     0.5
    //   );
    //   line.updatePath(curve.getSpacedPoints(40), false, true);
    // } else {
    //   line.updatePath(points, false, true);
    // }

    line.updatePath(drawCurve.getSpacedPoints(30), false, true);
    const toThick = line.material.uniforms.thickness.value;
    (0, _AnimationSystem.tweenFromTo)(world, line.material.uniforms.thickness, "value", 0, toThick, 1, "sineOut");
    line.material.uniforms.filling.value = true;
    shadow.material.uniforms.filling.value = true;
    (0, _AnimationSystem.tweenFromTo)(world, line.material.uniforms.draw, "value", 0, 1, 1, "sineOut");
    (0, _AnimationSystem.tweenFromTo)(world, shadow.material.uniforms.draw, "value", 0, 1, 1, "sineOut");
    group.add(line);
    group.add(shadow);
    line.position.y = Y_LINE_POSITION;
    c.line = line;
    c.shadow = shadow;
    children.add(Tags.Object3D, group);
  }

  function removeText(entity) {
    if (entity.has(Tags.Object3D)) {
      const obj = entity.get(Tags.Object3D);

      if (obj && obj.userData.tweenA) {
        obj.userData.tweenA.kill();
        obj.userData.tweenB.kill();
      } // entity.kill();


      const textData = entity.get(Tags.TextSprite3D);
      const t0 = (0, _AnimationSystem.tweenTo)(world, obj.position, "y", startY, 1, "expoOut");
      (0, _AnimationSystem.setEntityTweenFromTo)(entity, textData, "opacity", 1, 0, 1, "sineOut");
      const t1 = entity.get(Tags.TargetKeyTween);
      t1.killEntityOnFinish = true;
      t1.assignFromOnStart = true;
    }
  }

  function killText(entity) {
    if (entity.has(Tags.Object3D)) {
      const obj = entity.get(Tags.Object3D);

      if (obj && obj.userData.tweenA) {
        obj.userData.tweenA.kill();
        obj.userData.tweenB.kill();
      }
    }

    entity.kill();
  }

  function createText(text, position) {
    const g = new THREE.Group();
    g.position.copy(position);
    g.position.y = startY;
    const textEntity = world.entity().add(Tags.TextSprite3D).add(Tags.Object3D, g);
    const textData = textEntity.get(Tags.TextSprite3D);
    textData.text = text;
    textData.depth = false;
    textData.parent = g;
    textData.fontSize = 16;
    textData.opacity = 0;
    const tweenA = (0, _AnimationSystem.tweenTo)(world, g.position, "y", endY, 2, "expoOut");
    const tweenB = (0, _AnimationSystem.tweenTo)(world, textData, "opacity", 1, 1, "sineOut");
    g.userData.tweenA = tweenA.ref();
    g.userData.tweenB = tweenB.ref();
    return textEntity;
  }
}
},{"../tags":"src/tags/index.js","../util/math":"src/util/math.js","three":"src/vendor/three.module.js","../util/helpers":"src/util/helpers.js","./AnimationSystem":"src/systems/AnimationSystem.js","./writing/Line3D":"src/systems/writing/Line3D.js","../util/tween-ticker":"src/util/tween-ticker.js","../util/tokens":"src/util/tokens.js","../util/load":"src/util/load.js","../util/geometry":"src/util/geometry.js","../util/haikugen":"src/util/haikugen.js","../util/ShaderManager":"src/util/ShaderManager.js","../util/materials":"src/util/materials.js","../util/Assets":"src/util/Assets.js","../util/ObjectPool":"src/util/ObjectPool.js","../util/locale":"src/util/locale.js","../util/Random":"src/util/Random.js","../util/three-util":"src/util/three-util.js","../util/query-string":"src/util/query-string.js","../nfb":"src/nfb.js"}],"src/systems/initialize.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = initializeWorld;

var Tags = _interopRequireWildcard(require("../tags"));

var THREE = _interopRequireWildcard(require("three"));

var _queryString = _interopRequireDefault(require("../util/query-string"));

var _SnowAtmosphereSystem = _interopRequireDefault(require("./SnowAtmosphereSystem"));

var _DOMTextSystem = _interopRequireDefault(require("./DOMTextSystem"));

var _GameUISystem = _interopRequireDefault(require("./GameUISystem"));

var _CanvasSystem = _interopRequireDefault(require("./CanvasSystem"));

var _TokenPaperFollowSystem = _interopRequireDefault(require("./TokenPaperFollowSystem"));

var _SceneSystem = _interopRequireDefault(require("./SceneSystem"));

var _InputSystem = _interopRequireDefault(require("./InputSystem"));

var _CompassSystem = _interopRequireDefault(require("./CompassSystem"));

var _ScreenCompassSystem = _interopRequireDefault(require("./ScreenCompassSystem"));

var _UserMoveSystem = _interopRequireDefault(require("./UserMoveSystem"));

var _WindAtmosphereSystem = _interopRequireDefault(require("./WindAtmosphereSystem"));

var _RainAtmosphereSystem = _interopRequireDefault(require("./RainAtmosphereSystem"));

var _CharacterSystem = _interopRequireDefault(require("./CharacterSystem"));

var _HatWindLineSystem = _interopRequireDefault(require("./HatWindLineSystem"));

var _AtmosphericsSystem = _interopRequireDefault(require("./AtmosphericsSystem"));

var _TallGrassSystem = _interopRequireDefault(require("./TallGrassSystem"));

var _HaikuFloraSystem = _interopRequireDefault(require("./HaikuFloraSystem"));

var _UserZoomSystem = _interopRequireDefault(require("./UserZoomSystem"));

var _RenderDebugTargetsSystem = _interopRequireDefault(require("./RenderDebugTargetsSystem"));

var _UserFollowSystem = _interopRequireDefault(require("./UserFollowSystem"));

var _ShaderUniformSystem = _interopRequireDefault(require("./ShaderUniformSystem"));

var _LoadJSONSystem = _interopRequireDefault(require("./LoadJSONSystem"));

var _TreeSpriteAnimationSystem = _interopRequireDefault(require("./TreeSpriteAnimationSystem"));

var _TextSpriteSystem = _interopRequireDefault(require("./TextSpriteSystem"));

var _EnvironmentGrassSystem = _interopRequireDefault(require("./EnvironmentGrassSystem"));

var _EnvironmentGroundRenderTextureSystem = _interopRequireDefault(require("./EnvironmentGroundRenderTextureSystem"));

var _SubmitFrameSystem = _interopRequireDefault(require("./SubmitFrameSystem"));

var _AnimationSystem = _interopRequireDefault(require("./AnimationSystem"));

var _ProceduralSpawningLeaves = _interopRequireDefault(require("./ProceduralSpawningLeaves"));

var _ProceduralSpawningDots = _interopRequireDefault(require("./ProceduralSpawningDots"));

var _EnvironmentGroundDataTextureSystem = _interopRequireDefault(require("./EnvironmentGroundDataTextureSystem"));

var _AudioSystem = _interopRequireDefault(require("./AudioSystem"));

var _SimpleEnvironmentSystem = _interopRequireDefault(require("./SimpleEnvironmentSystem"));

var _SimpleEnvironmentCellSystem = _interopRequireDefault(require("./SimpleEnvironmentCellSystem"));

var _SimpleEnvironmentAssetsSystem = _interopRequireDefault(require("./SimpleEnvironmentAssetsSystem"));

var _ShadowMapSystem = _interopRequireDefault(require("./ShadowMapSystem"));

var _LoadRefGLTFSystem = _interopRequireDefault(require("./LoadRefGLTFSystem"));

var _PoemCollectionSystem = _interopRequireDefault(require("./PoemCollectionSystem"));

var _HaikuCollectionSystem = _interopRequireDefault(require("./HaikuCollectionSystem"));

var _StanzaLineSpawningGrowthSystem = _interopRequireDefault(require("./StanzaLineSpawningGrowthSystem"));

var _WaterCollectionSystem = _interopRequireDefault(require("./WaterCollectionSystem"));

var _DevTutorialSystem = _interopRequireDefault(require("./DevTutorialSystem"));

var _BirdFlyingSystem = _interopRequireDefault(require("./BirdFlyingSystem"));

var _GroundBirdsSystem = _interopRequireDefault(require("./GroundBirdsSystem"));

var _ButterflySystem = _interopRequireDefault(require("./animals/ButterflySystem"));

var _RabbitSystem = _interopRequireDefault(require("./animals/RabbitSystem"));

var _SealSystem = _interopRequireDefault(require("./animals/SealSystem"));

var _OwlSystem = _interopRequireDefault(require("./animals/OwlSystem"));

var _FoxSystem = _interopRequireDefault(require("./animals/FoxSystem"));

var _FishSystem = _interopRequireDefault(require("./animals/FishSystem"));

var _JumpingRabbitSystem = _interopRequireDefault(require("./animals/JumpingRabbitSystem"));

var _OriginTreeSystem = _interopRequireDefault(require("./OriginTreeSystem"));

var _OriginTreeIntroSystem = _interopRequireDefault(require("./OriginTreeIntroSystem"));

var _IntroTutorialSystem = _interopRequireDefault(require("./IntroTutorialSystem"));

var _LetterboxBarsSystem = _interopRequireDefault(require("./LetterboxBarsSystem"));

var _AnimalSpawnSystem = _interopRequireDefault(require("./AnimalSpawnSystem"));

var _OutroSystem = _interopRequireDefault(require("./OutroSystem"));

var _globalIntroVideo = require("../util/globalIntroVideo");

var _config = _interopRequireWildcard(require("../config"));

var _resetPlayerPos = _interopRequireWildcard(require("../util/resetPlayerPos"));

var _Assets = _interopRequireDefault(require("../util/Assets"));

var _NotSupportedOverlay = _interopRequireDefault(require("../overlays/NotSupportedOverlay.svelte"));

var _SpriteSheetAnimationSystem = _interopRequireDefault(require("./SpriteSheetAnimationSystem"));

var _TutorialMessageSystem = _interopRequireDefault(require("./TutorialMessageSystem"));

var _nfb = require("../nfb");

var _FloatingEndLines = _interopRequireDefault(require("./FloatingEndLines"));

var _TokenPlacementSystem = _interopRequireDefault(require("./TokenPlacementSystem"));

var _TokenConstellationSystem = _interopRequireDefault(require("./TokenConstellationSystem"));

var _tokens = require("../util/tokens");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// import TokenWritingSystem from "./TokenWritingSystem";
// import TextLogSystem from "./TextLogSystem";
// import GIFRecordSystem from "./GIFRecordSystem";
// import TokenSystem from "./TokenSystem";
// import EnvironmentGroundFogTextureSystem from "./EnvironmentGroundFogTextureSystem";
// import AssetLoaderSystem from "./AssetLoaderSystem";
// import TutorialSystem from "./TutorialSystem";
// import Haiku from "../util/haikugen";
// const haiku = Haiku();
// const list = [];
// for (let i = 0; i < 150; i++) {
//   const gen = haiku.generate();
//   list.push(gen.map((e) => e.fr).join(" / "));
// }
// window.text = list.join("\n");
async function initializeWorld(world) {
  const config = (0, _config.default)();
  window.world = world;
  window.Tags = Tags;
  let finalResolve;
  const finalPromise = new Promise(resolve => {
    finalResolve = resolve;
  }); // Make sure we add any asset IDs that *need*
  // to be prepared initially, mostly just intro UI bits

  await preloadRequiredAssets(); // Now we run UI systems, this will trigger intro

  world.addSystem(_CanvasSystem.default, {
    context: config.context
  }); // don't submit rendering yet as it will slow down other initializations

  const appState = world.findTag(Tags.AppState);
  appState.rendering = false; // Bit of an odd thing here, we have to process
  // a single tick to ensure the Canvas.svelte is mounted
  // as many other systems will depend on its width/height state etc...

  world.root.process(1 / 60); // Show canvas

  const canvasSystem = world.getSystem(_CanvasSystem.default).instance; // Start the rendering now

  canvasSystem.running = true; // Actually show the DOM canvas to the screen

  canvasSystem.show(); // Run a single tick, this will trigger a frame render

  canvasSystem.step();
  const showUI = true;
  let gamePromise = Promise.resolve();
  world.addSystem(_DOMTextSystem.default); // world.addSystem(TextLogSystem);

  world.addSystem(_GameUISystem.default, {
    readyToInitialize,
    readyToShowEngine
  });
  (0, _config.hideLoader)(); // this entity will have some flags that turns the game and input 'on'

  const initEntity = world.entity();
  initEntity.add(Tags.CameraStopUserMovement);
  initEntity.add(Tags.HideHUD);
  initEntity.add(Tags.MoveUserToOrigin);

  _Assets.default.prepare(["image/ui/close-button", "image/ui/ico_resume", "image/ui/btn_start", "image/ui/btn_about", "image/ui/hint-card-left", "image/ui/hint-card-middle", "image/ui/hint-card-right", "image/ui/ico_paperJournal1-rotated"]);

  if (!_queryString.default.nolanding) {
    console.log("[video] Loading video");
    (0, _globalIntroVideo.getVideo)().load();
  } // Now the intro is on its way to showing
  // and in the background we can load things while that's happening


  const renderer = world.findTag(Tags.Renderer);
  await Promise.all([_Assets.default.loadQueued(), (0, _tokens.loadTokenSprites)(renderer)]);
  return finalPromise;

  function readyToInitialize() {
    console.log("[init] Initialize Game Systems");

    _Assets.default.prepare(["spritesheets/temp_grass_sprites"]);

    gamePromise = initializeGame(world); // start loading any more queued

    const p = _Assets.default.loadQueued();
  }

  async function readyToShowEngine() {
    await gamePromise;
    (0, _nfb.sendAnalytics)({
      event: "finished_loading",
      label: "FinishedLoading"
    });
    console.log("[init] Start Rendering Engine"); // start rendering and submit a single frame

    appState.rendering = true;
    world.root.process(1 / 60); // // Show canvas
    // const canvasSystem = world.getSystem(CanvasSystem).instance;
    // // Start the rendering now
    // canvasSystem.running = true;
    // // Actually show the DOM canvas to the screen
    // canvasSystem.show();
    // // Run a single tick, this will trigger a frame render
    // canvasSystem.step();
    // let a whole new tick go through before we actually show the canvas
    // to avoid any first-frame issues ...

    requestAnimationFrame(() => {
      initEntity.remove(Tags.HideHUD);
      world.entity().add(Tags.ScreenFade, {
        duration: 3,
        from: 1,
        to: 0
      });
      initEntity.remove(Tags.MoveUserToOrigin);
      initEntity.remove(Tags.CameraStopUserMovement);
      finalResolve();
    });
  }
}

function preloadRequiredAssets() {
  return Promise.all(["image/svg/nfblogo"].map(id => _Assets.default.load(id)));
}

async function initializeGame(world, initEntity) {
  const config = (0, _config.default)(); // global state for render layers

  world.entity().add(Tags.RenderLayers);
  world.addSystem(_SceneSystem.default);
  world.addSystem(_InputSystem.default); // world.addSystem(AssetLoaderSystem);

  world.addSystem(_ShaderUniformSystem.default);
  world.addSystem(_UserMoveSystem.default);
  world.addSystem(_CharacterSystem.default);
  world.addSystem(_HatWindLineSystem.default);
  world.addSystem(_UserZoomSystem.default, {
    allowMouseZoom: "development" === "development",
    maxDistance: 400
  });
  world.addSystem(_UserFollowSystem.default);
  world.addSystem(_AnimationSystem.default);
  world.addSystem(_EnvironmentGroundDataTextureSystem.default); // world.addSystem(EnvironmentGroundFogTextureSystem);

  world.addSystem(_EnvironmentGroundRenderTextureSystem.default);
  world.addSystem(_ShadowMapSystem.default);
  if (!config.embed) await world.addSystem(_LoadRefGLTFSystem.default);
  world.addSystem(_SimpleEnvironmentSystem.default);
  await world.addSystem(_EnvironmentGrassSystem.default);
  world.addSystem(_SimpleEnvironmentCellSystem.default);
  await world.addSystem(_SimpleEnvironmentAssetsSystem.default); // await world.addSystem(SpriteVideoSystem);

  world.addSystem(_SpriteSheetAnimationSystem.default);
  world.addSystem(_TreeSpriteAnimationSystem.default);
  if (config.embed) await world.addSystem(_LoadJSONSystem.default);
  await world.addSystem(_ProceduralSpawningLeaves.default);
  world.addSystem(_ProceduralSpawningDots.default);
  if (!config.embed) world.addSystem(_OriginTreeSystem.default);
  if (!config.embed) world.addSystem(_OriginTreeIntroSystem.default);
  world.addSystem(_TutorialMessageSystem.default);
  if (!config.embed && !_queryString.default.notutorial) world.addSystem(_IntroTutorialSystem.default); // world.addSystem(TokenSystem);
  // world.addSystem(TokenWritingSystem);

  world.addSystem(_TokenPlacementSystem.default);
  world.addSystem(_TokenConstellationSystem.default);
  world.addSystem(_TokenPaperFollowSystem.default);
  world.addSystem(_WaterCollectionSystem.default); // world.addSystem(StanzaLineSpawningGrowthSystem);

  world.addSystem(_RainAtmosphereSystem.default);
  world.addSystem(_WindAtmosphereSystem.default);
  world.addSystem(_SnowAtmosphereSystem.default);
  world.addSystem(_AnimalSpawnSystem.default);
  world.addSystem(_HaikuFloraSystem.default); // world.addSystem(ScreenCompassSystem);

  world.addSystem(_CompassSystem.default); // await world.addSystem(DevTutorialSystem);

  world.addSystem(_BirdFlyingSystem.default);
  world.addSystem(_GroundBirdsSystem.default);
  world.addSystem(_ButterflySystem.default); // world.addSystem(RabbitSystem);
  // world.addSystem(SealSystem);
  // world.addSystem(OwlSystem);

  world.addSystem(_FoxSystem.default);
  world.addSystem(_FishSystem.default);
  world.addSystem(_JumpingRabbitSystem.default);
  world.addSystem(_FloatingEndLines.default); // world.addSystem(TutorialSystem);

  world.addSystem(_OutroSystem.default); // await world.addSystem(DevTutorialUISystem);

  if (!config.embed) world.addSystem(_LetterboxBarsSystem.default);
  if (!config.embed) world.addSystem(_HaikuCollectionSystem.default); // world.addSystem(AtmosphericsSystem);

  if (!config.embed) world.addSystem(_AudioSystem.default);
  await world.addSystem(_SubmitFrameSystem.default, {
    fade: config.embed ? 0 : 1
  }); // world.addSystem(GIFRecordSystem);
  // world.addSystem(RenderDebugTargetsSystem);
  // TODO: figure out how to initialize the world a bit better
  // if (world.hasSystem(SimpleEnvironmentSystem)) {
  // const system = world.getSystem(SimpleEnvironmentSystem);
  // system.instance.createInitialEnvironment();
  // }

  if (_queryString.default.nointroseq) {
    (0, _resetPlayerPos.default)(world);
  }

  if (config.embed) {
    (0, _resetPlayerPos.setPlayerPos)(world, new THREE.Vector3(-20.625336223781655, 0, -7.556151890652441));
  } // debug code


  if (_queryString.default.resolve) {
    (0, _resetPlayerPos.setPlayerPos)(world, new THREE.Vector3(25, 0, -25));

    for (let i = 0; i < 3; i++) {
      window.addPoem();
    }
  } // if (query.testwater) {
  //   const waterStart = new THREE.Vector3(
  //     34.19839943737152,
  //     0,
  //     -18.377668713353398
  //   );
  //   setPlayerPos(world, waterStart);
  // }


  if (_queryString.default.testtoken) {
    const tokenStart = new THREE.Vector3(-71.4775163757554, 0, -34.91576302604653);
    (0, _resetPlayerPos.setPlayerPos)(world, tokenStart);
  }
}
},{"../tags":"src/tags/index.js","three":"src/vendor/three.module.js","../util/query-string":"src/util/query-string.js","./SnowAtmosphereSystem":"src/systems/SnowAtmosphereSystem.js","./DOMTextSystem":"src/systems/DOMTextSystem.js","./GameUISystem":"src/systems/GameUISystem.js","./CanvasSystem":"src/systems/CanvasSystem.js","./TokenPaperFollowSystem":"src/systems/TokenPaperFollowSystem.js","./SceneSystem":"src/systems/SceneSystem.js","./InputSystem":"src/systems/InputSystem.js","./CompassSystem":"src/systems/CompassSystem.js","./ScreenCompassSystem":"src/systems/ScreenCompassSystem.js","./UserMoveSystem":"src/systems/UserMoveSystem.js","./WindAtmosphereSystem":"src/systems/WindAtmosphereSystem.js","./RainAtmosphereSystem":"src/systems/RainAtmosphereSystem.js","./CharacterSystem":"src/systems/CharacterSystem.js","./HatWindLineSystem":"src/systems/HatWindLineSystem.js","./AtmosphericsSystem":"src/systems/AtmosphericsSystem.js","./TallGrassSystem":"src/systems/TallGrassSystem.js","./HaikuFloraSystem":"src/systems/HaikuFloraSystem.js","./UserZoomSystem":"src/systems/UserZoomSystem.js","./RenderDebugTargetsSystem":"src/systems/RenderDebugTargetsSystem.js","./UserFollowSystem":"src/systems/UserFollowSystem.js","./ShaderUniformSystem":"src/systems/ShaderUniformSystem.js","./LoadJSONSystem":"src/systems/LoadJSONSystem.js","./TreeSpriteAnimationSystem":"src/systems/TreeSpriteAnimationSystem.js","./TextSpriteSystem":"src/systems/TextSpriteSystem.js","./EnvironmentGrassSystem":"src/systems/EnvironmentGrassSystem.js","./EnvironmentGroundRenderTextureSystem":"src/systems/EnvironmentGroundRenderTextureSystem.js","./SubmitFrameSystem":"src/systems/SubmitFrameSystem.js","./AnimationSystem":"src/systems/AnimationSystem.js","./ProceduralSpawningLeaves":"src/systems/ProceduralSpawningLeaves.js","./ProceduralSpawningDots":"src/systems/ProceduralSpawningDots.js","./EnvironmentGroundDataTextureSystem":"src/systems/EnvironmentGroundDataTextureSystem.js","./AudioSystem":"src/systems/AudioSystem.js","./SimpleEnvironmentSystem":"src/systems/SimpleEnvironmentSystem.js","./SimpleEnvironmentCellSystem":"src/systems/SimpleEnvironmentCellSystem.js","./SimpleEnvironmentAssetsSystem":"src/systems/SimpleEnvironmentAssetsSystem.js","./ShadowMapSystem":"src/systems/ShadowMapSystem.js","./LoadRefGLTFSystem":"src/systems/LoadRefGLTFSystem.js","./PoemCollectionSystem":"src/systems/PoemCollectionSystem.js","./HaikuCollectionSystem":"src/systems/HaikuCollectionSystem.js","./StanzaLineSpawningGrowthSystem":"src/systems/StanzaLineSpawningGrowthSystem.js","./WaterCollectionSystem":"src/systems/WaterCollectionSystem.js","./DevTutorialSystem":"src/systems/DevTutorialSystem.js","./BirdFlyingSystem":"src/systems/BirdFlyingSystem.js","./GroundBirdsSystem":"src/systems/GroundBirdsSystem.js","./animals/ButterflySystem":"src/systems/animals/ButterflySystem.js","./animals/RabbitSystem":"src/systems/animals/RabbitSystem.js","./animals/SealSystem":"src/systems/animals/SealSystem.js","./animals/OwlSystem":"src/systems/animals/OwlSystem.js","./animals/FoxSystem":"src/systems/animals/FoxSystem.js","./animals/FishSystem":"src/systems/animals/FishSystem.js","./animals/JumpingRabbitSystem":"src/systems/animals/JumpingRabbitSystem.js","./OriginTreeSystem":"src/systems/OriginTreeSystem.js","./OriginTreeIntroSystem":"src/systems/OriginTreeIntroSystem.js","./IntroTutorialSystem":"src/systems/IntroTutorialSystem.js","./LetterboxBarsSystem":"src/systems/LetterboxBarsSystem.js","./AnimalSpawnSystem":"src/systems/AnimalSpawnSystem.js","./OutroSystem":"src/systems/OutroSystem.js","../util/globalIntroVideo":"src/util/globalIntroVideo.js","../config":"src/config.js","../util/resetPlayerPos":"src/util/resetPlayerPos.js","../util/Assets":"src/util/Assets.js","../overlays/NotSupportedOverlay.svelte":"src/overlays/NotSupportedOverlay.svelte.js","./SpriteSheetAnimationSystem":"src/systems/SpriteSheetAnimationSystem.js","./TutorialMessageSystem":"src/systems/TutorialMessageSystem.js","../nfb":"src/nfb.js","./FloatingEndLines":"src/systems/FloatingEndLines.js","./TokenPlacementSystem":"src/systems/TokenPlacementSystem.js","./TokenConstellationSystem":"src/systems/TokenConstellationSystem.js","../util/tokens":"src/util/tokens.js"}],"src/vendor/fastclick.js":[function(require,module,exports) {
var define;
(function () {
  "use strict";
  /**
   * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
   *
   * @codingstandard ftlabs-jsv2
   * @copyright The Financial Times Limited [All Rights Reserved]
   * @license MIT License (see LICENSE.txt)
   */

  /*jslint browser:true, node:true*/

  /*global define, Event, Node*/

  /**
   * Instantiate fast-clicking listeners on the specified layer.
   *
   * @constructor
   * @param {Element} layer The layer to listen on
   * @param {Object} [options={}] The options to override the defaults
   */

  function FastClick(layer, options) {
    var oldOnClick;
    options = options || {};
    /**
     * Whether a click is currently being tracked.
     *
     * @type boolean
     */

    this.trackingClick = false;
    /**
     * Timestamp for when click tracking started.
     *
     * @type number
     */

    this.trackingClickStart = 0;
    /**
     * The element being tracked for a click.
     *
     * @type EventTarget
     */

    this.targetElement = null;
    /**
     * X-coordinate of touch start event.
     *
     * @type number
     */

    this.touchStartX = 0;
    /**
     * Y-coordinate of touch start event.
     *
     * @type number
     */

    this.touchStartY = 0;
    /**
     * ID of the last touch, retrieved from Touch.identifier.
     *
     * @type number
     */

    this.lastTouchIdentifier = 0;
    /**
     * Touchmove boundary, beyond which a click will be cancelled.
     *
     * @type number
     */

    this.touchBoundary = options.touchBoundary || 10;
    /**
     * The FastClick layer.
     *
     * @type Element
     */

    this.layer = layer;
    /**
     * The minimum time between tap(touchstart and touchend) events
     *
     * @type number
     */

    this.tapDelay = options.tapDelay || 200;
    /**
     * The maximum time for a tap
     *
     * @type number
     */

    this.tapTimeout = options.tapTimeout || 700;

    if (FastClick.notNeeded(layer)) {
      return;
    } // Some old versions of Android don't have Function.prototype.bind


    function bind(method, context) {
      return function () {
        return method.apply(context, arguments);
      };
    }

    var methods = ["onMouse", "onClick", "onTouchStart", "onTouchMove", "onTouchEnd", "onTouchCancel"];
    var context = this;

    for (var i = 0, l = methods.length; i < l; i++) {
      context[methods[i]] = bind(context[methods[i]], context);
    } // Set up event handlers as required


    if (deviceIsAndroid) {
      layer.addEventListener("mouseover", this.onMouse, {
        passive: true
      });
      layer.addEventListener("mousedown", this.onMouse, {
        passive: true
      });
      layer.addEventListener("mouseup", this.onMouse, {
        passive: true
      });
    }

    layer.addEventListener("click", this.onClick, {
      passive: true
    });
    layer.addEventListener("touchstart", this.onTouchStart, {
      passive: false
    });
    layer.addEventListener("touchmove", this.onTouchMove, {
      passive: false
    });
    layer.addEventListener("touchend", this.onTouchEnd, {
      passive: false
    });
    layer.addEventListener("touchcancel", this.onTouchCancel, {
      passive: false
    }); // Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
    // which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
    // layer when they are cancelled.

    if (!Event.prototype.stopImmediatePropagation) {
      layer.removeEventListener = function (type, callback, capture) {
        var rmv = Node.prototype.removeEventListener;

        if (type === "click") {
          rmv.call(layer, type, callback.hijacked || callback, capture);
        } else {
          rmv.call(layer, type, callback, capture);
        }
      };

      layer.addEventListener = function (type, callback, capture) {
        var adv = Node.prototype.addEventListener;

        if (type === "click") {
          adv.call(layer, type, callback.hijacked || (callback.hijacked = function (event) {
            if (!event.propagationStopped) {
              callback(event);
            }
          }), capture);
        } else {
          adv.call(layer, type, callback, capture);
        }
      };
    } // If a handler is already declared in the element's onclick attribute, it will be fired before
    // FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
    // adding it as listener.


    if (typeof layer.onclick === "function") {
      // Android browser on at least 3.2 requires a new reference to the function in layer.onclick
      // - the old one won't work if passed to addEventListener directly.
      oldOnClick = layer.onclick;
      layer.addEventListener("click", function (event) {
        oldOnClick(event);
      }, false);
      layer.onclick = null;
    }
  }
  /**
   * Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
   *
   * @type boolean
   */


  var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;
  /**
   * Android requires exceptions.
   *
   * @type boolean
   */

  var deviceIsAndroid = navigator.userAgent.indexOf("Android") > 0 && !deviceIsWindowsPhone;
  /**
   * iOS requires exceptions.
   *
   * @type boolean
   */

  var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;
  /**
   * iOS 4 requires an exception for select elements.
   *
   * @type boolean
   */

  var deviceIsIOS4 = deviceIsIOS && /OS 4_\d(_\d)?/.test(navigator.userAgent);
  /**
   * iOS 6.0-7.* requires the target element to be manually derived
   *
   * @type boolean
   */

  var deviceIsIOSWithBadTarget = deviceIsIOS && /OS [6-7]_\d/.test(navigator.userAgent);
  /**
   * BlackBerry requires exceptions.
   *
   * @type boolean
   */

  var deviceIsBlackBerry10 = navigator.userAgent.indexOf("BB10") > 0;
  /**
   * Determine whether a given element requires a native click.
   *
   * @param {EventTarget|Element} target Target DOM element
   * @returns {boolean} Returns true if the element needs a native click
   */

  FastClick.prototype.needsClick = function (target) {
    switch (target.nodeName.toLowerCase()) {
      // Don't send a synthetic click to disabled inputs (issue #62)
      case "button":
      case "select":
      case "textarea":
        if (target.disabled) {
          return true;
        }

        break;

      case "input":
        // File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
        if (deviceIsIOS && target.type === "file" || target.disabled) {
          return true;
        }

        break;

      case "label":
      case "iframe": // iOS8 homescreen apps can prevent events bubbling into frames

      case "video":
        return true;
    }

    return /\bneedsclick\b/.test(target.className);
  };
  /**
   * Determine whether a given element requires a call to focus to simulate click into element.
   *
   * @param {EventTarget|Element} target Target DOM element
   * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
   */


  FastClick.prototype.needsFocus = function (target) {
    switch (target.nodeName.toLowerCase()) {
      case "textarea":
        return true;

      case "select":
        return !deviceIsAndroid;

      case "input":
        switch (target.type) {
          case "button":
          case "checkbox":
          case "file":
          case "image":
          case "radio":
          case "submit":
            return false;
        } // No point in attempting to focus disabled inputs


        return !target.disabled && !target.readOnly;

      default:
        return /\bneedsfocus\b/.test(target.className);
    }
  };
  /**
   * Send a click event to the specified element.
   *
   * @param {EventTarget|Element} targetElement
   * @param {Event} event
   */


  FastClick.prototype.sendClick = function (targetElement, event) {
    var clickEvent, touch; // On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)

    if (document.activeElement && document.activeElement !== targetElement) {
      document.activeElement.blur();
    }

    touch = event.changedTouches[0]; // Synthesise a click event, with an extra attribute so it can be tracked

    clickEvent = document.createEvent("MouseEvents");
    clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
    clickEvent.forwardedTouchEvent = true;
    targetElement.dispatchEvent(clickEvent);
  };

  FastClick.prototype.determineEventType = function (targetElement) {
    //Issue #159: Android Chrome Select Box does not open with a synthetic click event
    if (deviceIsAndroid && targetElement.tagName.toLowerCase() === "select") {
      return "mousedown";
    }

    return "click";
  };
  /**
   * @param {EventTarget|Element} targetElement
   */


  FastClick.prototype.focus = function (targetElement) {
    var length; // Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.

    if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf("date") !== 0 && targetElement.type !== "time" && targetElement.type !== "month") {
      length = targetElement.value.length;
      targetElement.setSelectionRange(length, length);
    } else {
      targetElement.focus();
    }
  };
  /**
   * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
   *
   * @param {EventTarget|Element} targetElement
   */


  FastClick.prototype.updateScrollParent = function (targetElement) {
    var scrollParent, parentElement;
    scrollParent = targetElement.fastClickScrollParent; // Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
    // target element was moved to another parent.

    if (!scrollParent || !scrollParent.contains(targetElement)) {
      parentElement = targetElement;

      do {
        if (parentElement.scrollHeight > parentElement.offsetHeight) {
          scrollParent = parentElement;
          targetElement.fastClickScrollParent = parentElement;
          break;
        }

        parentElement = parentElement.parentElement;
      } while (parentElement);
    } // Always update the scroll top tracker if possible.


    if (scrollParent) {
      scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
    }
  };
  /**
   * @param {EventTarget} targetElement
   * @returns {Element|EventTarget}
   */


  FastClick.prototype.getTargetElementFromEventTarget = function (eventTarget) {
    // On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
    if (eventTarget.nodeType === Node.TEXT_NODE) {
      return eventTarget.parentNode;
    }

    return eventTarget;
  };
  /**
   * On touch start, record the position and scroll offset.
   *
   * @param {Event} event
   * @returns {boolean}
   */


  FastClick.prototype.onTouchStart = function (event) {
    var targetElement, touch, selection; // Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).

    if (event.targetTouches.length > 1) {
      return true;
    }

    targetElement = this.getTargetElementFromEventTarget(event.target);
    touch = event.targetTouches[0];

    if (deviceIsIOS) {
      // Only trusted events will deselect text on iOS (issue #49)
      selection = window.getSelection();

      if (selection.rangeCount && !selection.isCollapsed) {
        return true;
      }

      if (!deviceIsIOS4) {
        // Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
        // when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
        // with the same identifier as the touch event that previously triggered the click that triggered the alert.
        // Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
        // immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
        // Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
        // which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
        // random integers, it's safe to to continue if the identifier is 0 here.
        if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
          event.preventDefault();
          return false;
        }

        this.lastTouchIdentifier = touch.identifier; // If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
        // 1) the user does a fling scroll on the scrollable layer
        // 2) the user stops the fling scroll with another tap
        // then the event.target of the last 'touchend' event will be the element that was under the user's finger
        // when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
        // is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).

        this.updateScrollParent(targetElement);
      }
    }

    this.trackingClick = true;
    this.trackingClickStart = event.timeStamp;
    this.targetElement = targetElement;
    this.touchStartX = touch.pageX;
    this.touchStartY = touch.pageY; // Prevent phantom clicks on fast double-tap (issue #36)

    if (event.timeStamp - this.lastClickTime < this.tapDelay) {
      event.preventDefault();
    }

    return true;
  };
  /**
   * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
   *
   * @param {Event} event
   * @returns {boolean}
   */


  FastClick.prototype.touchHasMoved = function (event) {
    var touch = event.changedTouches[0],
        boundary = this.touchBoundary;

    if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
      return true;
    }

    return false;
  };
  /**
   * Update the last position.
   *
   * @param {Event} event
   * @returns {boolean}
   */


  FastClick.prototype.onTouchMove = function (event) {
    if (!this.trackingClick) {
      return true;
    } // If the touch has moved, cancel the click tracking


    if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
      this.trackingClick = false;
      this.targetElement = null;
    }

    return true;
  };
  /**
   * Attempt to find the labelled control for the given label element.
   *
   * @param {EventTarget|HTMLLabelElement} labelElement
   * @returns {Element|null}
   */


  FastClick.prototype.findControl = function (labelElement) {
    // Fast path for newer browsers supporting the HTML5 control attribute
    if (labelElement.control !== undefined) {
      return labelElement.control;
    } // All browsers under test that support touch events also support the HTML5 htmlFor attribute


    if (labelElement.htmlFor) {
      return document.getElementById(labelElement.htmlFor);
    } // If no for attribute exists, attempt to retrieve the first labellable descendant element
    // the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label


    return labelElement.querySelector("button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea");
  };
  /**
   * On touch end, determine whether to send a click event at once.
   *
   * @param {Event} event
   * @returns {boolean}
   */


  FastClick.prototype.onTouchEnd = function (event) {
    var forElement,
        trackingClickStart,
        targetTagName,
        scrollParent,
        touch,
        targetElement = this.targetElement;

    if (!this.trackingClick) {
      return true;
    } // Prevent phantom clicks on fast double-tap (issue #36)


    if (event.timeStamp - this.lastClickTime < this.tapDelay) {
      this.cancelNextClick = true;
      return true;
    }

    if (event.timeStamp - this.trackingClickStart > this.tapTimeout) {
      return true;
    } // Reset to prevent wrong click cancel on input (issue #156).


    this.cancelNextClick = false;
    this.lastClickTime = event.timeStamp;
    trackingClickStart = this.trackingClickStart;
    this.trackingClick = false;
    this.trackingClickStart = 0; // On some iOS devices, the targetElement supplied with the event is invalid if the layer
    // is performing a transition or scroll, and has to be re-detected manually. Note that
    // for this to function correctly, it must be called *after* the event target is checked!
    // See issue #57; also filed as rdar://13048589 .

    if (deviceIsIOSWithBadTarget) {
      touch = event.changedTouches[0]; // In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null

      targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
      targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
    }

    targetTagName = targetElement.tagName.toLowerCase();

    if (targetTagName === "label") {
      forElement = this.findControl(targetElement);

      if (forElement) {
        this.focus(targetElement);

        if (deviceIsAndroid) {
          return false;
        }

        targetElement = forElement;
      }
    } else if (this.needsFocus(targetElement)) {
      // Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
      // Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
      if (event.timeStamp - trackingClickStart > 100 || deviceIsIOS && window.top !== window && targetTagName === "input") {
        this.targetElement = null;
        return false;
      }

      this.focus(targetElement);
      this.sendClick(targetElement, event); // Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
      // Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)

      if (!deviceIsIOS || targetTagName !== "select") {
        this.targetElement = null;
        event.preventDefault();
      }

      return false;
    }

    if (deviceIsIOS && !deviceIsIOS4) {
      // Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
      // and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
      scrollParent = targetElement.fastClickScrollParent;

      if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
        return true;
      }
    } // Prevent the actual click from going though - unless the target node is marked as requiring
    // real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.


    if (!this.needsClick(targetElement)) {
      event.preventDefault();
      this.sendClick(targetElement, event);
    }

    return false;
  };
  /**
   * On touch cancel, stop tracking the click.
   *
   * @returns {void}
   */


  FastClick.prototype.onTouchCancel = function () {
    this.trackingClick = false;
    this.targetElement = null;
  };
  /**
   * Determine mouse events which should be permitted.
   *
   * @param {Event} event
   * @returns {boolean}
   */


  FastClick.prototype.onMouse = function (event) {
    // If a target element was never set (because a touch event was never fired) allow the event
    if (!this.targetElement) {
      return true;
    }

    if (event.forwardedTouchEvent) {
      return true;
    } // Programmatically generated events targeting a specific element should be permitted


    if (!event.cancelable) {
      return true;
    } // Derive and check the target element to see whether the mouse event needs to be permitted;
    // unless explicitly enabled, prevent non-touch click events from triggering actions,
    // to prevent ghost/doubleclicks.


    if (!this.needsClick(this.targetElement) || this.cancelNextClick) {
      // Prevent any user-added listeners declared on FastClick element from being fired.
      if (event.stopImmediatePropagation) {
        event.stopImmediatePropagation();
      } else {
        // Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
        event.propagationStopped = true;
      } // Cancel the event


      event.stopPropagation();
      event.preventDefault();
      return false;
    } // If the mouse event is permitted, return true for the action to go through.


    return true;
  };
  /**
   * On actual clicks, determine whether this is a touch-generated click, a click action occurring
   * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
   * an actual click which should be permitted.
   *
   * @param {Event} event
   * @returns {boolean}
   */


  FastClick.prototype.onClick = function (event) {
    var permitted; // It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.

    if (this.trackingClick) {
      this.targetElement = null;
      this.trackingClick = false;
      return true;
    } // Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.


    if (event.target.type === "submit" && event.detail === 0) {
      return true;
    }

    permitted = this.onMouse(event); // Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.

    if (!permitted) {
      this.targetElement = null;
    } // If clicks are permitted, return true for the action to go through.


    return permitted;
  };
  /**
   * Remove all FastClick's event listeners.
   *
   * @returns {void}
   */


  FastClick.prototype.destroy = function () {
    var layer = this.layer;

    if (deviceIsAndroid) {
      layer.removeEventListener("mouseover", this.onMouse, true);
      layer.removeEventListener("mousedown", this.onMouse, true);
      layer.removeEventListener("mouseup", this.onMouse, true);
    }

    layer.removeEventListener("click", this.onClick, true);
    layer.removeEventListener("touchstart", this.onTouchStart, false);
    layer.removeEventListener("touchmove", this.onTouchMove, false);
    layer.removeEventListener("touchend", this.onTouchEnd, false);
    layer.removeEventListener("touchcancel", this.onTouchCancel, false);
  };
  /**
   * Check whether FastClick is needed.
   *
   * @param {Element} layer The layer to listen on
   */


  FastClick.notNeeded = function (layer) {
    var metaViewport;
    var chromeVersion;
    var blackberryVersion;
    var firefoxVersion; // Devices that don't support touch don't need FastClick

    if (typeof window.ontouchstart === "undefined") {
      return true;
    } // Chrome version - zero for other browsers


    chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];

    if (chromeVersion) {
      if (deviceIsAndroid) {
        metaViewport = document.querySelector("meta[name=viewport]");

        if (metaViewport) {
          // Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
          if (metaViewport.content.indexOf("user-scalable=no") !== -1) {
            return true;
          } // Chrome 32 and above with width=device-width or less don't need FastClick


          if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
            return true;
          }
        } // Chrome desktop doesn't need FastClick (issue #15)

      } else {
        return true;
      }
    }

    if (deviceIsBlackBerry10) {
      blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/); // BlackBerry 10.3+ does not require Fastclick library.
      // https://github.com/ftlabs/fastclick/issues/251

      if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
        metaViewport = document.querySelector("meta[name=viewport]");

        if (metaViewport) {
          // user-scalable=no eliminates click delay.
          if (metaViewport.content.indexOf("user-scalable=no") !== -1) {
            return true;
          } // width=device-width (or less than device-width) eliminates click delay.


          if (document.documentElement.scrollWidth <= window.outerWidth) {
            return true;
          }
        }
      }
    } // IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)


    if (layer.style.msTouchAction === "none" || layer.style.touchAction === "manipulation") {
      return true;
    } // Firefox version - zero for other browsers


    firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];

    if (firefoxVersion >= 27) {
      // Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896
      metaViewport = document.querySelector("meta[name=viewport]");

      if (metaViewport && (metaViewport.content.indexOf("user-scalable=no") !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
        return true;
      }
    } // IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
    // http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx


    if (layer.style.touchAction === "none" || layer.style.touchAction === "manipulation") {
      return true;
    }

    return false;
  };
  /**
   * Factory method for creating a FastClick object
   *
   * @param {Element} layer The layer to listen on
   * @param {Object} [options={}] The options to override the defaults
   */


  FastClick.attach = function (layer, options) {
    return new FastClick(layer, options);
  };

  if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
    // AMD. Register as an anonymous module.
    define(function () {
      return FastClick;
    });
  } else if (typeof module !== "undefined" && module.exports) {
    module.exports = FastClick.attach;
    module.exports.FastClick = FastClick;
  } else {
    window.FastClick = FastClick;
  }
})();
},{}],"src/alec-svelte/LayeredViewComponent.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _ = require("./");

var _svelte = require("svelte");

/* alec-svelte/LayeredViewComponent.svelte generated by Svelte v3.31.0 */
function create_fragment(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
  /*props*/
  ctx[0]];
  var switch_value =
  /*component*/
  ctx[1];

  function switch_props(ctx) {
    let switch_instance_props = {};

    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = (0, _internal.assign)(switch_instance_props, switch_instance_spread_levels[i]);
    }

    return {
      props: switch_instance_props
    };
  }

  if (switch_value) {
    switch_instance = new switch_value(switch_props(ctx));
  }

  return {
    c() {
      if (switch_instance) (0, _internal.create_component)(switch_instance.$$.fragment);
      switch_instance_anchor = (0, _internal.empty)();
    },

    m(target, anchor) {
      if (switch_instance) {
        (0, _internal.mount_component)(switch_instance, target, anchor);
      }

      (0, _internal.insert)(target, switch_instance_anchor, anchor);
      current = true;
    },

    p(ctx, [dirty]) {
      const switch_instance_changes = dirty &
      /*props*/
      1 ? (0, _internal.get_spread_update)(switch_instance_spread_levels, [(0, _internal.get_spread_object)(
      /*props*/
      ctx[0])]) : {};

      if (switch_value !== (switch_value =
      /*component*/
      ctx[1])) {
        if (switch_instance) {
          (0, _internal.group_outros)();
          const old_component = switch_instance;
          (0, _internal.transition_out)(old_component.$$.fragment, 1, 0, () => {
            (0, _internal.destroy_component)(old_component, 1);
          });
          (0, _internal.check_outros)();
        }

        if (switch_value) {
          switch_instance = new switch_value(switch_props(ctx));
          (0, _internal.create_component)(switch_instance.$$.fragment);
          (0, _internal.transition_in)(switch_instance.$$.fragment, 1);
          (0, _internal.mount_component)(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },

    i(local) {
      if (current) return;
      if (switch_instance) (0, _internal.transition_in)(switch_instance.$$.fragment, local);
      current = true;
    },

    o(local) {
      if (switch_instance) (0, _internal.transition_out)(switch_instance.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(switch_instance_anchor);
      if (switch_instance) (0, _internal.destroy_component)(switch_instance, detaching);
    }

  };
}

function instance($$self, $$props, $$invalidate) {
  let {
    entity
  } = $$props;
  let {
    props
  } = $$props;
  let {
    component
  } = $$props;
  const base = (0, _svelte.getContext)(_.CONTEXT_KEY_NODE);
  (0, _svelte.setContext)(_.CONTEXT_KEY_NODE, { ...base,
    entity
  });

  $$self.$$set = $$props => {
    if ("entity" in $$props) $$invalidate(2, entity = $$props.entity);
    if ("props" in $$props) $$invalidate(0, props = $$props.props);
    if ("component" in $$props) $$invalidate(1, component = $$props.component);
  };

  return [props, component, entity];
}

class LayeredViewComponent extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      entity: 2,
      props: 0,
      component: 1
    });
  }

}

var _default = LayeredViewComponent;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","./":"src/alec-svelte/index.js","svelte":"node_modules/svelte/index.mjs"}],"src/alec-svelte/LayeredView.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _LayeredViewComponent = _interopRequireDefault(require("./LayeredViewComponent.svelte"));

var _ = require("./");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* alec-svelte/LayeredView.svelte generated by Svelte v3.31.0 */
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i];
  return child_ctx;
} // (23:0) {#each layers as layer (layer.get(ViewLayer).id)}


function create_each_block(key_1, ctx) {
  let first;
  let layeredviewcomponent;
  let current;
  layeredviewcomponent = new _LayeredViewComponent.default({
    props: {
      props:
      /*layer*/
      ctx[1].get(_.ViewLayer).props,
      component:
      /*layer*/
      ctx[1].get(_.ViewLayer).component,
      entity:
      /*layer*/
      ctx[1]
    }
  });
  return {
    key: key_1,
    first: null,

    c() {
      first = (0, _internal.empty)();
      (0, _internal.create_component)(layeredviewcomponent.$$.fragment);
      this.first = first;
    },

    m(target, anchor) {
      (0, _internal.insert)(target, first, anchor);
      (0, _internal.mount_component)(layeredviewcomponent, target, anchor);
      current = true;
    },

    p(ctx, dirty) {
      const layeredviewcomponent_changes = {};
      if (dirty &
      /*layers*/
      1) layeredviewcomponent_changes.props =
      /*layer*/
      ctx[1].get(_.ViewLayer).props;
      if (dirty &
      /*layers*/
      1) layeredviewcomponent_changes.component =
      /*layer*/
      ctx[1].get(_.ViewLayer).component;
      if (dirty &
      /*layers*/
      1) layeredviewcomponent_changes.entity =
      /*layer*/
      ctx[1];
      layeredviewcomponent.$set(layeredviewcomponent_changes);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(layeredviewcomponent.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(layeredviewcomponent.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      if (detaching) (0, _internal.detach)(first);
      (0, _internal.destroy_component)(layeredviewcomponent, detaching);
    }

  };
}

function create_fragment(ctx) {
  let each_blocks = [];
  let each_1_lookup = new Map();
  let each_1_anchor;
  let current;
  let each_value =
  /*layers*/
  ctx[0];

  const get_key = ctx =>
  /*layer*/
  ctx[1].get(_.ViewLayer).id;

  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }

  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }

      each_1_anchor = (0, _internal.empty)();
    },

    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }

      (0, _internal.insert)(target, each_1_anchor, anchor);
      current = true;
    },

    p(ctx, [dirty]) {
      if (dirty &
      /*layers, ViewLayer*/
      1) {
        const each_value =
        /*layers*/
        ctx[0];
        (0, _internal.group_outros)();
        each_blocks = (0, _internal.update_keyed_each)(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, _internal.outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
        (0, _internal.check_outros)();
      }
    },

    i(local) {
      if (current) return;

      for (let i = 0; i < each_value.length; i += 1) {
        (0, _internal.transition_in)(each_blocks[i]);
      }

      current = true;
    },

    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        (0, _internal.transition_out)(each_blocks[i]);
      }

      current = false;
    },

    d(detaching) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }

      if (detaching) (0, _internal.detach)(each_1_anchor);
    }

  };
}

function instance($$self, $$props, $$invalidate) {
  let {
    layers = []
  } = $$props;

  $$self.$$set = $$props => {
    if ("layers" in $$props) $$invalidate(0, layers = $$props.layers);
  };

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*layers*/
    1) {
      $: {
        const set = new Set();
        layers.forEach(e => {
          const id = e.get(_.ViewLayer).id;
          if (!id) throw new Error(`Must specify an ID for ViewLayer ${e.name} ${e.get(_.ViewLayer).component.name}`);
          if (set.has(id)) throw new Error(`You already added the view layer with ID ${id}`);
          set.add(id);
        });
      }
    }
  };

  return [layers];
}

class LayeredView extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      layers: 0
    });
  }

}

var _default = LayeredView;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs","./LayeredViewComponent.svelte":"src/alec-svelte/LayeredViewComponent.svelte.js","./":"src/alec-svelte/index.js"}],"src/alec-svelte/GameApp.svelte.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _internal = require("svelte/internal");

var _ = require(".");

var _svelte = require("svelte");

var _LayeredView = _interopRequireDefault(require("./LayeredView.svelte"));

var _config = _interopRequireWildcard(require("../config"));

var _NotSupportedOverlay = _interopRequireDefault(require("../overlays/NotSupportedOverlay.svelte"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* alec-svelte/GameApp.svelte generated by Svelte v3.31.0 */
function create_if_block_1(ctx) {
  let layeredview;
  let current;
  layeredview = new _LayeredView.default({
    props: {
      layers:
      /*layers*/
      ctx[2]
    }
  });
  return {
    c() {
      (0, _internal.create_component)(layeredview.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(layeredview, target, anchor);
      current = true;
    },

    p(ctx, dirty) {
      const layeredview_changes = {};
      if (dirty &
      /*layers*/
      4) layeredview_changes.layers =
      /*layers*/
      ctx[2];
      layeredview.$set(layeredview_changes);
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(layeredview.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(layeredview.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(layeredview, detaching);
    }

  };
} // (40:0) {#if !supported}


function create_if_block(ctx) {
  let notsupportedoverlay;
  let current;
  notsupportedoverlay = new _NotSupportedOverlay.default({});
  return {
    c() {
      (0, _internal.create_component)(notsupportedoverlay.$$.fragment);
    },

    m(target, anchor) {
      (0, _internal.mount_component)(notsupportedoverlay, target, anchor);
      current = true;
    },

    p: _internal.noop,

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(notsupportedoverlay.$$.fragment, local);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(notsupportedoverlay.$$.fragment, local);
      current = false;
    },

    d(detaching) {
      (0, _internal.destroy_component)(notsupportedoverlay, detaching);
    }

  };
}

function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block, create_if_block_1];
  const if_blocks = [];

  function select_block_type(ctx, dirty) {
    if (!
    /*supported*/
    ctx[0]) return 0;
    if (
    /*ready*/
    ctx[1]) return 1;
    return -1;
  }

  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }

  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = (0, _internal.empty)();
    },

    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }

      (0, _internal.insert)(target, if_block_anchor, anchor);
      current = true;

      if (!mounted) {
        dispose = (0, _internal.listen)(window, "contextmenu", contextmenu_handler);
        mounted = true;
      }
    },

    p(ctx, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);

      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        }
      } else {
        if (if_block) {
          (0, _internal.group_outros)();
          (0, _internal.transition_out)(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          (0, _internal.check_outros)();
        }

        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];

          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block.c();
          } else {
            if_block.p(ctx, dirty);
          }

          (0, _internal.transition_in)(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },

    i(local) {
      if (current) return;
      (0, _internal.transition_in)(if_block);
      current = true;
    },

    o(local) {
      (0, _internal.transition_out)(if_block);
      current = false;
    },

    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }

      if (detaching) (0, _internal.detach)(if_block_anchor);
      mounted = false;
      dispose();
    }

  };
}

const contextmenu_handler = e => e.preventDefault();

function instance($$self, $$props, $$invalidate) {
  let {
    onCreate = () => {}
  } = $$props;
  const {
    world,
    viewLayerStore
  } = (0, _.createRootWorld)();
  const config = (0, _config.default)();
  const ctx = {
    world
  };
  (0, _svelte.setContext)(_.CONTEXT_KEY_NODE, ctx);
  let supported = true;
  let ready = false;
  (0, _svelte.onMount)(() => {
    start();
  });
  let layers;
  viewLayerStore.subscribe(v => {
    $$invalidate(2, layers = v);
  });

  async function start() {
    $$invalidate(1, ready = true);

    if (!config.context) {
      $$invalidate(0, supported = false);
      (0, _config.hideLoader)();
    } else {
      onCreate(world);
    }
  }

  $$self.$$set = $$props => {
    if ("onCreate" in $$props) $$invalidate(3, onCreate = $$props.onCreate);
  };

  return [supported, ready, layers, onCreate];
}

class GameApp extends _internal.SvelteComponent {
  constructor(options) {
    super();
    (0, _internal.init)(this, options, instance, create_fragment, _internal.safe_not_equal, {
      onCreate: 3
    });
  }

}

var _default = GameApp;
exports.default = _default;
},{"svelte/internal":"node_modules/svelte/internal/index.mjs",".":"src/alec-svelte/index.js","svelte":"node_modules/svelte/index.mjs","./LayeredView.svelte":"src/alec-svelte/LayeredView.svelte.js","../config":"src/config.js","../overlays/NotSupportedOverlay.svelte":"src/overlays/NotSupportedOverlay.svelte.js"}],"src/index.js":[function(require,module,exports) {
"use strict";

require("./polyfills");

var _initialize = _interopRequireDefault(require("./systems/initialize"));

var _queryString = _interopRequireDefault(require("./util/query-string"));

var Tags = _interopRequireWildcard(require("./tags"));

var _Assets = _interopRequireDefault(require("./util/Assets"));

var _nfb = _interopRequireDefault(require("./nfb.js"));

var _fastclick = _interopRequireDefault(require("./vendor/fastclick"));

var _GameApp = _interopRequireDefault(require("./alec-svelte/GameApp.svelte"));

var _config = _interopRequireDefault(require("./config"));

var _CanvasSystem = _interopRequireDefault(require("./systems/CanvasSystem"));

var _LoadJSONSystem = _interopRequireDefault(require("./systems/LoadJSONSystem"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _fastclick.default)(document.body); // import { Plugins } from "@capacitor/core";
// const { SplashScreen } = Plugins;
// SplashScreen.hide();
// import "./alec/test-alec";
// let ProdApp = require("./alec-svelte/GameApp.svelte").default;
// let App = ProdApp;

const config = (0, _config.default)();
let initPromise;

function init() {
  if (initPromise) return initPromise;
  initPromise = new Promise(resolve => {
    const container = config.container || document.querySelector("main.content");
    new _GameApp.default({
      target: container,
      props: {
        onCreate: setup
      }
    });

    async function setup(world) {
      await (0, _initialize.default)(world);
      const sys = world.hasSystem(_CanvasSystem.default) ? world.getSystem(_CanvasSystem.default).instance : null;
      let jsonLoader;

      if (world.hasSystem(_LoadJSONSystem.default)) {
        jsonLoader = world.getSystem(_LoadJSONSystem.default).instance;
      }

      config.stop = () => {
        if (sys) sys.running = false;
      };

      config.start = () => {
        if (sys) sys.running = true;
      };

      config.load = json => {
        if (jsonLoader) jsonLoader.load(json);
      };

      config.world = world;
      config.Tags = Tags;
      resolve();
    }
  });
  return initPromise;
}

config.init = init;

if (config.autoInit !== false) {
  window.requestAnimationFrame(() => {
    config.init();
  });
}
},{"./polyfills":"src/polyfills.js","./systems/initialize":"src/systems/initialize.js","./util/query-string":"src/util/query-string.js","./tags":"src/tags/index.js","./util/Assets":"src/util/Assets.js","./nfb.js":"src/nfb.js","./vendor/fastclick":"src/vendor/fastclick.js","./alec-svelte/GameApp.svelte":"src/alec-svelte/GameApp.svelte.js","./config":"src/config.js","./systems/CanvasSystem":"src/systems/CanvasSystem.js","./systems/LoadJSONSystem":"src/systems/LoadJSONSystem.js"}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "55891" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js","src/index.js"], null)
//# sourceMappingURL=/src.a2b27638.js.map